#*************************************************************************n
# Copyright (C) 2018, 19, 20, 21, 22, 23 Edinah K. Gnang kgnang@gmail.com #
#                          Ori Parzanchevski,                             #
#                          Yuval Filmus,                                  #
#                          Doron Zeilberger,                              #
#                          Fan Tian,                                      #
#                          Ricky Cheng,                                   #
#                          Jonathan Earl,                                 #
#                          Harry Crane,                                   #
#                                                                         #
#  Distributed under the terms of the GNU General Public License (GPL)    #
#                                                                         #
#    This code is distributed in the hope that it will be useful,         #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of       #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU     #
#    General Public License for more details.                             #
#                                                                         #
#  The full text of the GPL is available at:                              #
#                                                                         #
#                  http://www.gnu.org/licenses/                           #
#*************************************************************************#

# Imports
import itertools

# Definition of the hypermatrix class HM.
class HM:
    """
    Describes the Hypermatrix constructors
    
    INPUT:

    -  ``nrows`` - int, the number of rows
    -  ``ncols`` - int, the number of columns
    -  ``ndpts`` - int, the number of depths
    -  ``a`` - char, the symbolic entry prefix

    EXAMPLES::
    
        sage: HM(2,2,2,'a') # Initialization of a third order hypermatrix
        [[[a000, a001], [a010, a011]], [[a100, a101], [a110, a111]]]
        sage: od=2; sz=2; HM(od,sz,'kronecker') # Creating a Kronecker delta or identity matrix
        [[1, 0], [0, 1]]
        sage: od=Integer(2); HM(od,[1,0,2],'perm')
        [[0, 1, 0], [1, 0, 0], [0, 0, 1]]
        sage: od=Integer(3); HM(od,[1,0,2],'perm')
        [[[0, 1, 0], [1, 0, 0], [0, 0, 1]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]]]
        sage: od=2; sz=2; HM(od,sz,'a','sym') # Creating a symmetric matrix
        [[a00, a10], [a10, a11]]
        sage: od=2; sz=2; HM(od,sz,'a','skewsym') # Creating a skewsymmetric matrix
        [[0, a01], [-a01, 0]]
        sage: sz=2; HM(sz,sz,sz,'a','shift') # Creating a hypermatrix where the index are shifted by one
        [[[a111, a112], [a121, a122]], [[a211, a212], [a221, a222]]]
        sage: HM(2,2,'one') # creating a 2 x 2 matrix whose entries are all equal to one
        [[1, 1], [1, 1]]
        sage: HM(2,2,'zero') # creating a 2 x 2 matrix whose entries are all equal to one
        [[0, 0], [0, 0]]
        sage: HM(HM(2,2,'a').matrix()) # Creating a scaling hypermatrix
        [[[a00, 0], [0, a01]], [[a10, 0], [0, a11]]]
        sage: HM(3,'x').list() # creatling a list of variables
        [x0, x1, x2]
        sage: sz=3; var_list('x',sz) # alternative approach to creatling a list of variables
        [x0, x1, x2]
        sage: od=2; sz=2; HM(od,var_list('a',sz),'diag') # diagonal matrix
        [[a0, 0], [0, a1]]
        sage: La=HM(2, 2, 2, 'a').list(); Lb=HM(2, 2, 2, 'b').list(); Lc=HM(2, 2, 2, 'c').list() # Initialization of the variables
        sage: F = FreeAlgebra(QQ, 24, La + Lb + Lc)
        sage: F.<a000,a100,a010,a110,a001,a101,a011,a111,b000,b100,b010,b110,b001,b101,b011,b111,c000,c100,c010,c110,c001,c101,c011,c111> = FreeAlgebra(QQ,24)
        sage: Ha=HM(2, 2, 2, [a000,a100,a010,a110,a001,a101,a011,a111])
        sage: Hb=HM(2, 2, 2, [b000,b100,b010,b110,b001,b101,b011,b111])
        sage: Hc=HM(2, 2, 2, [c000,c100,c010,c110,c001,c101,c011,c111])
        sage: Prod(Ha,Hb,Hc)[0,0,0]
        a000*b000*c000 + a010*b001*c100
        sage: Prod(Hb,Ha,Hc)[0,0,0]
        b000*a000*c000 + b010*a001*c100
        sage: od=2; sz=3; DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
        sage: DltL[0].printHM()
        [:, :]=
        [1 0 0]
        [0 0 0]
        [0 0 0]
        sage: DltL[1].printHM()
        [:, :]=
        [0 0 0]
        [0 1 0]
        [0 0 0]
        sage: DltL[2].printHM()
        [:, :]=
        [0 0 0]
        [0 0 0]
        [0 0 1]
        sage: Ha=HM(2,1,2,'a');Hb=HM(2,1,2,'b');Hc=HM(2,2,1,'c');Hd=HM(2,2,1,'d');Hf=HM(1,2,2,'f');Hg=HM(1,2,2,'g')
        sage: A=HM(1,2,1,[Ha,Hb]); B=HM(1,1,2,[Hc,Hd]); C=HM(2,1,1,[Hf,Hg])
        sage: BlockProd(A, B, C)[0,0,0].printHM() # Computing the block product
        [:, :, 0]=
        [a000*c000*f000 + b000*d000*g000 a000*c010*f010 + b000*d010*g010]
        [a100*c100*f000 + b100*d100*g000 a100*c110*f010 + b100*d110*g010]
        <BLANKLINE>
        [:, :, 1]=
        [a001*c000*f001 + b001*d000*g001 a001*c010*f011 + b001*d010*g011]
        [a101*c100*f001 + b101*d100*g001 a101*c110*f011 + b101*d110*g011]
        sage: HM(3,3,3,'a').slice([2], 'dpt').printHM() # Illustrating the slicing
        [:, :, 0]=
        [a002 a012 a022]
        [a102 a112 a122]
        [a202 a212 a222] 
        <BLANKLINE>
        sage: sz=2; [A,B]=GeneralUncorrelatedHypermatrixTuple([HM(sz,sz,'u'),HM(sz,sz,'v')]); Prod(A,B).simplify_full()
        [[1, 0], [0, 1]]
        sage: sz=2; od=3; J0=Prod(HM(sz,sz,sz,'one'), HM(sz,sz,sz,'one'), HM(od,sz,'kronecker')); J1=Prod(HM(od,sz,'kronecker'), HM(sz,sz,sz,'one'), HM(sz,sz,sz,'one'))
        sage: Prod(J0,HM(sz,sz,sz,'a'),J1)-HM(sz,sz,sz,'a')
        [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]
        sage: od=Integer(2); sz=Integer(4); A=HM(sz,sz,'a'); X=var_list('x', sz); F=expand(((A*HM(od,X,'diag'))^4).trace()) # Setup for listing walks of lenght 4
        sage: X0=HM([[0, X[0]], [0, 0]]); X1=HM([[0, X[1]], [0, 0]]); X2=HM([[0, X[2]], [0, 0]]) # Initialization of 2x2 matrices to be substituted into F to list directed 4-cycles
        sage: F_x0=(X0.substituteHMinto(F, X[0]).expand())[0,1]; F_x0_x1=(X1.substituteHMinto(F_x0,X[1]).expand())[0,1]; F_x0_x1_x2=(X2.substituteHMinto(F_x0_x1,X[2]).expand())[0,1]; F_x0_x1_x2
        4*a02*a13*a21*a30*x0*x1*x2*x3 + 4*a01*a12*a23*a30*x0*x1*x2*x3 + 4*a03*a12*a20*a31*x0*x1*x2*x3 + 4*a02*a10*a23*a31*x0*x1*x2*x3 + 4*a01*a13*a20*a32*x0*x1*x2*x3 + 4*a03*a10*a21*a32*x0*x1*x2*x3
        sage: sz=2; od=2; X=HM(sz,sz,var_list('x',sz^2)); f=X.det(); H=Form2TotallySymmetricHypermatrix(f, 2, X.list()); H.printHM()
        [:, :]=
        [   0    0    0  1/2]
        [   0    0 -1/2    0]
        [   0 -1/2    0    0]
        [ 1/2    0    0    0]
        sage: sz=Integer(2); Li=List_of_Integers([2 for i in rg(sz)]); Li
        [[0, 0], [1, 0], [0, 1], [1, 1]]
        sage: P = 4*x^3 + 3*x^2 + 2*x + 1 # Initialization of the "dividend"
        sage: D = 5*x^2 + 3*x + 7 # Initialization of the "divisor"
        sage: [Lq, Rem] = CompositionalDivision(P, D, x) # Performing the compositional division
        sage: (GProd([D*HM(1,len(Lq),'one'),HM(len(Lq),1,Lq)], sum, [x])[0,0]+Rem).canonicalize_radical()
        4*x^3 + 3*x^2 + 2*x + 1
        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GProd([Ha,Hb,Hc], sum, [x,y]); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); GProd([Ha, Hb], sum, [x])
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); GProd([Ha, Hb], prod, [x])
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb)-HM(sz,1,[c0, c1, c2])*HM(1,l,[QQ(1/2) for i in rg(l)])
        sage: GProd([Hr, Hx], sum, [z]).printHM()
        [:, :]=
        [-c0 + a00*x0*b00 + a01*x1*b01]
        [-c1 + a10*x0*b10 + a11*x1*b11]
        [-c2 + a20*x0*b20 + a21*x1*b21]
        sage : sz=Integer(3); A=HM(sz,sz,'a') # Initializing a lower triangular matrix
        sage : for i in rg(sz-1):
        .... :     for j in rg(i+1,sz):
        .... :         A[i,j]=0
        sage : A.p()
        [:, :]=
        [a00   0   0]
        [a10 a11   0]
        [a20 a21 a22] 
    """
    def __init__(self,*args,func=None):
        if len(args) == 1:
            inp = args[0]
            if type(inp)==type(Matrix(SR,2,1,[var('xxi'),var('yyj')])) or type(inp)==type(Matrix(RR,2,1,[1,2])) or type(inp)==type(Matrix(CC,2,1,[1,1])):
                self.hm=DiagonalHypermatrix(inp)
            elif type(inp) == list:
                self.hm = inp
            # Case associated with the initialization of a picture
            # the inlustration of how images are turned into a hypermatrix
            # A=HM("I.png")
            elif type(inp) == type("abcd"):
                # Importing the numerical library
                import pylab, numpy
                from scipy import misc
                # Defining the input Pictures
                X  = pylab.imread(inp)
                sz = max(len(X),len(X[0]),len(X[0][0]))
                args = (len(X), len(X[0]), len(X[0][0]))
                #T = apply(HypermatrixGenerateAllZero, args)
                AtmpL=args
                T = HypermatrixGenerateAllZero(*AtmpL)
                # Filling up the image Hypermatrix
                for i in range(len(X)):
                    for j in range(len(X[0])):
                        for k in range(len(X[0][0])):
                            T[i][j][k] = X[i,j,k]
                self.hm = T
            else:
                raise ValueError("Expected list as input when generating diagonal hypermatrix")
            return
        # Obtaining the last argument
        s = args[-1]
        # Initializing the dimension parameters
        dims = args[:-1]
        if s == 'one':
            AtmpL=dims
            self.hm = HypermatrixGenerateAllOne(*AtmpL)
        elif s == 'zero':
            AtmpL=dims
            self.hm = HypermatrixGenerateAllZero(*AtmpL)
        elif s == 'shift':
            AtmpL=dims
            self.hm = HypermatrixGenerateII(*AtmpL)
        elif s == 'perm':
            if dims[0]==2:
                # Initialization of the size parameter
                sz=len(dims[1])
                Id=HM(2,sz,'kronecker')
                # The permutation acts on columns
                self.hm=sum(HM(sz,1,[Id[i,dims[1][k]] for i in range(sz)])*HM(1,sz,[Id[k,j] for j in range(sz)]) for k in range(sz)).transpose().listHM()
            elif dims[0]==3:
                # Initialization of the size parameter
                sz=len(dims[1])
                self.hm=HypermatrixPermutation(dims[1])
            else:
                raise ValueError("not supported for order %d hypermatrices" % dims[0])
        elif s == 'kronecker':
            AtmpL=args[:-1]
            self.hm=GeneralHypermatrixKroneckerDelta(*AtmpL).listHM()
        elif s == 'kron':
            AtmpL=args[:-1]
            self.hm=GeneralHypermatrixKroneckerDelta(*AtmpL).listHM()
        elif s == 'diag':
            AtmpL=args[:-1]
            self.hm=GeneralHypermatrixMainDiag(*AtmpL).listHM()
        elif s == 'sym':
            if (len(dims) == 3) and (dims[0]==2):
                self.hm=SymMatrixGenerate(dims[1],dims[2])
            elif (len(dims) == 3) and (dims[0]==3):
                self.hm=SymHypermatrixGenerate(dims[1],dims[2])
            else:
                raise ValueError("SymHypermatrixGenerate not supported for order %d hypermatrices" % dims[0])
        elif s == 'skewsym':
            if (len(dims) == 3) and (dims[0]==2):
                self.hm=SkewSymMatrixGenerate(dims[1],dims[2])
            elif (len(dims) == 3) and (dims[0]==3):
                self.hm=SkewSymHypermatrixGenerate(dims[1],dims[2])
            else:
                raise ValueError("SkewSymHypermatrixGenerate not supported for order %d hypermatrices" % dims[0])
        elif type(s) == list:
            self.hm=(List2Hypermatrix(*args)).listHM()
        elif func is not None:
            self.hm=HypermatrixGenerateFunc(*args[:-1], symbol=args[-1], digits=len(str(max(args[:-1])-1)), func=func)
        else:
            self.hm=HypermatrixGenerate(*args)
    def __repr__(self):
        return self.hm.__repr__()
    def __pow__(self, other):
        """
        This method returns the exponentiation
        operation. I uses the convention I have
        introduced for exponentiation which work
        for coformable block partition and relates
        multiplicative constraints. The functions
        should not be confused with exp(B*ln(A))


        EXAMPLES:

        ::

            sage: A=HM(2,2,'a'); B=HM(2,2,'b')
            sage: (A^B).printHM()
            [:, :]=
            [a00^b00*a10^b01 a01^b00*a11^b01]
            [a00^b10*a10^b11 a01^b10*a11^b11]


        AUTHORS:

        - Edinah K. Gnang
        """
        if self.order()==2 and other.order()==2 and self.n(0)==other.n(1):
            #return mprod(other, self)
            return GProdIII([other,self],prod,BaseExp)
        elif self.order()==2 and self.is_hypercolumn() and prod(self.dimensions())>1:
            return vec_exp(self, other)
        elif self.order()==2 and other==-1 and self.is_cubical():
            return self.inverse()
        elif self.order()==2 and other==0 and self.is_cubical():
            return HM(self.order(), self.n(0), 'kronecker')
        elif self.order()==2 and type(other)==type(5) and self.is_cubical():
            if other > 0:
                return self*(self^(other-1))
            elif other < 0:
                return self.inverse()^(-other)
        elif self.dimensions()==other.dimensions():
            return GeneralHypermatrixHadamardExponent(self,other)
        else:
            raise ValueError("Operation is not supported !")
    def __add__(self, other):
        return GeneralHypermatrixAdd(self,other)
    def __truediv__(other,self):
        """
        This method returns the product self
        with the inverse of the input other.
        It only works for second order hypermatrices.


        EXAMPLES:

        ::

            sage: A=HM(2,2,'a'); B=HM(2,var_list('b',2),'diag')
            sage: (A/B).printHM()
            [:, :]=
            [a00/b0 a01/b1]
            [a10/b0 a11/b1]


        AUTHORS:

        - Edinah K. Gnang
        """
        if self.order()==2:
            return other*self.inverse()
    def __radd__(self, other):
        return GeneralHypermatrixAdd(self,other)
    def __neg__(self):
        return GeneralHypermatrixScale(self,-1)
    def __sub__(self, other):
        return GeneralHypermatrixAdd(self, GeneralHypermatrixScale(other,-1))
    def __mul__(self, other):
        """
        This method returns the BM product, it
        is a short cuc of sort which avoid having
        to write Prod all the time.


        EXAMPLES:

        ::

            sage: A=HM(2,2,'a'); B=HM(2,2,'b') # The matrix setting
            sage: (A*B).printHM()
            [:, :]=
            [a00*b00 + a01*b10 a00*b01 + a01*b11]
            [a10*b00 + a11*b10 a10*b01 + a11*b11]
            sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'a'); C=HM(2,2,2,'c')
            sage: D=A*(B,C); D.printHM()
            [:, :, 0]=
            [   a000^2*c000 + a001*a010*c100 a000*a010*c010 + a010*a011*c110]
            [   a100^2*c000 + a101*a110*c100 a100*a110*c010 + a110*a111*c110]
            <BLANKLINE>
            [:, :, 1]=
            [a000*a001*c001 + a001*a011*c101    a001*a010*c011 + a011^2*c111]
            [a100*a101*c001 + a101*a111*c101    a101*a110*c011 + a111^2*c111]
            <BLANKLINE>


        AUTHORS:

        - Edinah K. Gnang
        """
        if other.__class__.__name__=='HM':
            return Prod(self,other)
        elif other.__class__.__name__=='tuple':
            l=other
            return Prod(self,*l)
        else: 
            return GeneralHypermatrixScaleRight(self,other)
    def __rmul__(self, a):
        return GeneralHypermatrixScale(self,a)
    def __getitem__(self,i):
        if i.__class__.__name__=='tuple':
            tmp = self.hm
            for j in i:
                tmp = tmp[j]
            return tmp
    def __setitem__(self, i, v):
        if   i.__class__.__name__=='tuple':
            tmp = self.hm
            while len(i)>1:
                tmp = tmp[i[0]]
                i = i[1:]
            tmp[i[0]] = v
    def __call__(self, *inpts):
        """
        This method uses the call functionality
        to return the general BM product inspired
        the notation the self is the background
        hypermatrix while inpts refers to the 
        conformable hypermatrices to be multiplied.


        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b'); C=HM(2,2,2,'c'); D=HM(2,2,2,'d')
            sage: D(A,B,C)-ProdB(A,B,C,D)
            [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        AtmpL=[inp for inp in inpts]+[self]
        return ProdB(*AtmpL)
    def __eq__(self, other):
        return (isinstance(other, self.__class__) and self.list() == other.list())
    def __ne__(self, other):
        return not self.__eq__(other)

    def elementwise_product(self, B):
        """
        Returns the elementwise product of two 
        hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b')
            sage: A.elementwise_product(B)
            [[[a000*b000, a001*b001], [a010*b010, a011*b011]], [[a100*b100, a101*b101], [a110*b110, a111*b111]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixHadamardProduct(self, B)

    def hadamard_product(self, B):
        """
        Returns the elementwise product of two 
        hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b')
            sage: A.hadamard_product(B)
            [[[a000*b000, a001*b001], [a010*b010, a011*b011]], [[a100*b100, a101*b101], [a110*b110, a111*b111]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixHadamardProduct(self, B)

    def elementwise_exponent(self,s):
        """
        Returns the elementwise exponent of the entries
        ``self`` and ``B`` are both hypermatrices, with
        identical sizes. It is "unsafe" in the sense that
        these conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a')
            sage: A.elementwise_exponent(3)
            [[[a000^3, a001^3], [a010^3, a011^3]], [[a100^3, a101^3], [a110^3, a111^3]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixExponent(self, s)

    def hadamard_exponent(self, B):
        """
        Returns the elementwise of two hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b')
            sage: A.hadamard_exponent(B)
            [[[a000^b000, a001^b001], [a010^b010, a011^b011]], [[a100^b100, a101^b101], [a110^b110, a111^b111]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixHadamardExponent(self, B)

    def elementwise_base_exponent(self, s):
        """
        Returns a hypermatrix whose entries are all
        raised by s.
        This routine assumes that we are not dividing
        by zero. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,2,'a')
            sage: A.elementwise_base_exponent(3)
            [[[3^a000, 3^a001], [3^a010, 3^a011]], [[3^a100, 3^a101], [3^a110, 3^a111]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixBaseExponent(self, s)

    def elementwise_base_exponentN(self, s, dgts=50):
        """
        Returns a hypermatrix whose entries are all
        raised by s.
        This routine assumes that we are not dividing
        by zero. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: A=HM(2,2,[1,2,3,4]); A.elementwise_base_exponentN(3)
            [[3.0000000000000, 27.000000000000], [9.0000000000000, 81.000000000000]]
            


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixBaseExponentN(self, s, dgts)

    def elementwise_base_logarithm(self, s):
        """
        Outputs a list of lists associated with the general
        whose entries are logarithms to the base s of the 
        original hypermatrix.
        The code only handles the Hypermatrix HM class objects.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,'a')
            sage: Ha.elementwise_base_logarithm(3)
            [[[log(a000)/log(3), log(a001)/log(3)], [log(a010)/log(3), log(a011)/log(3)]], [[log(a100)/log(3), log(a101)/log(3)], [log(a110)/log(3), log(a111)/log(3)]]]


        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixLogarithm(self, s)

    def elementwise_base_logarithmN(self, s, dgts=50):
        """
        Outputs a list of lists associated with the general
        whose entries are numerical logarithms to the base s of the 
        original hypermatrix.
        The code only handles the Hypermatrix HM class objects.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,[1,2,3,4]); Ha.elementwise_base_logarithmN(3)
            [[0.00000000000000, 1.0000000000000], [0.63092975357146, 1.2618595071429]]


        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixLogarithmN(self, s, dgts)

    def elementwise_transpose(self, k=1):
        """
        Outputs the hypermatrix of the same dimension
        where each entry is applied the transpose k times.

        EXAMPLES:

        ::

            sage: Ha=HM(1,1,[HM(2,2,'a')]); Ha.elementwise_transpose()[0,0]
            [[a00, a10], [a01, a11]]


        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixEntryTranspose(self, k)


    def apply_map(self, phi):
        """
        Apply the given map phi (an arbitrary Python function or callable
        object) to this hypermatrix.
        
         
        EXAMPLES::

        ::

            sage: A = HM(2,2,'a')
            sage: phi = lambda x: sin(x)
            sage: A.apply_map(phi).printHM()
            [:, :]=
            [sin(a00) sin(a01)]
            [sin(a10) sin(a11)]

        """
        return GeneralHypermatrixApplyMap(self, phi)

    def map(self, phi):
        """
        Apply the given map phi (an arbitrary Python function or callable
        object) to this hypermatrix.
        
         
        EXAMPLES::

        ::

            sage: A = HM(2,2,'a')
            sage: phi = lambda x: sin(x)
            sage: A.map(phi).printHM()
            [:, :]=
            [sin(a00) sin(a01)]
            [sin(a10) sin(a11)]

        """
        return GeneralHypermatrixApplyMap(self, phi)

    def tensor_product(self, V):
        """
        Computes the  Kronecker product of arbitrary hypermatrices A, B of the same order.

        EXAMPLES:

        ::

            sage: A=HM(2,2,'a'); B=HM(2,2,'b')
            sage: A.tensor_product(B)
            [[a00*b00, a00*b01, a01*b00, a01*b01], [a00*b10, a00*b11, a01*b10, a01*b11], [a10*b00, a10*b01, a11*b00, a11*b01], [a10*b10, a10*b11, a11*b10, a11*b11]]
        

        AUTHORS:
        - Edinah K. Gnang
        """
        if  self.order()==2:
            return SecondOrderSliceKroneckerProduct(self, V)
        elif self.order()==3:
            return ThirdOrderSliceKroneckerProduct(self, V)
        elif self.order()==4:
            return FourthOrderSliceKroneckerProduct(self, V)
        elif self.order()==5:
            return FifthOrderSliceKroneckerProduct(self, V)
        elif self.order()==6:
            return SixthOrderSliceKroneckerProduct(self, V)
        elif self.order()==7:
            return SeventhOrderSliceKroneckerProduct(self, V)
        elif self.order()>7:
            return GeneralHypermatrixKroneckerProduct(self, V)
        else :
            raise ValueError("not supported for order %d hypermatrices" % self.order())

    def tensor_power(self, m):
        """
        Computes the Kronecker product with itself of arbitrary hypermatrices
        m times.

        EXAMPLES:

        ::

            sage: A=HM(2,2,'a')
            sage: A.tensor_power(2)
            [[a00^2, a00*a01, a00*a01, a01^2], [a00*a10, a00*a11, a01*a10, a01*a11], [a00*a10, a01*a10, a00*a11, a01*a11], [a10^2, a10*a11, a10*a11, a11^2]]
        

        AUTHORS:
        - Edinah K. Gnang
        """
        if m==0:
            return HM(*([1 for i in rg(self.order())]+['one']))
        elif m == 1:
            return self.copy()
        elif m in ZZ and m > 1 :
            Tmp=self.copy()
            for i in range(m-1):
                Tmp=Tmp.tensor_product(self)  
            return Tmp
        else:
            raise ValueError("Expected a positive integer as argument")

    def block_sum(self, V):
        """
        Returns the block sum of two hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: HM(2,2,'a').block_sum(HM(2,2,'b'))
            [[a00, a01, 0, 0], [a10, a11, 0, 0], [0, 0, b00, b01], [0, 0, b10, b11]]

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixKroneckerSum(self, V)

    def direct_sum(self, V):
        """
        Returns the block sum of two hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised. Same as the previous 
        implementation

        EXAMPLES:

        ::

            sage: HM(2,2,'a').direct_sum(HM(2,2,'b'))
            [[a00, a01, 0, 0], [a10, a11, 0, 0], [0, 0, b00, b01], [0, 0, b10, b11]]

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixKroneckerSum(self, V)

    def block_sum_list(self, L):
        """
        Returns the block sum of a list of hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: HM(2,2,'a').block_sum_list([HM(2,2,'b'), HM(2,2,'c')])
            [[a00, a01, 0, 0, 0, 0], [a10, a11, 0, 0, 0, 0], [0, 0, b00, b01, 0, 0], [0, 0, b10, b11, 0, 0], [0, 0, 0, 0, c00, c01], [0, 0, 0, 0, c10, c11]]

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixKroneckerSumList([self]+L)

    def direct_sum_list(self, L):
        """
        Returns the block sum of a list of hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: HM(2,2,'a').direct_sum_list([HM(2,2,'b'), HM(2,2,'c')])
            [[a00, a01, 0, 0, 0, 0], [a10, a11, 0, 0, 0, 0], [0, 0, b00, b01, 0, 0], [0, 0, b10, b11, 0, 0], [0, 0, 0, 0, c00, c01], [0, 0, 0, 0, c10, c11]]

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixKroneckerSumList([self]+L)

    def pseudo_block_sum(self, V):
        """
        Returns the pseudo block sum of two hypermatrices.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: HM(2,2,'a').pseudo_block_sum(HM(2,2,'b'))
            [[a00, a01, 0], [a10, a11, b01], [0, b10, b11]]


        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixPseudoKroneckerSum(self, V)

    def repeated_pseudo_block_sum(self, nb):
        """
        Returns the pseudo block sum nb times with self.
        This routine assumes that ``self`` and ``B``
        are both hypermatrices, with identical
        sizes. It is "unsafe" in the sense that these
        conditions are not checked and no sensible 
        errors are raised.

        EXAMPLES:

        ::

            sage: HM(2,2,'a').repeated_pseudo_block_sum(3)
            [[a00, a01, 0, 0, 0], [a10, a11, a01, 0, 0], [0, a10, a11, a01, 0], [0, 0, a10, a11, a01], [0, 0, 0, a10, a11]]


        AUTHORS:
        - Edinah K. Gnang
        """
        if nb>=2:
            # Initialization of the temporary hypermatrices
            V=self.copy()
            Tmp=GeneralHypermatrixPseudoKroneckerSum(self, V)
            for i in rg(nb-2):
                Tmp=GeneralHypermatrixPseudoKroneckerSum(Tmp, V)
            return Tmp
        else:
            raise ValueError("Expected number of repeats to be >1")

    def expand(self):
        """
        Outputs a list of lists associated with the general
        hypermatrix with expressions in the entries in their
        expanded form.
        The code only handles the Hypermatrix HM class objects.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,[(var('x')+var('y'))^(i+j+k) for i in range(2) for j in range(2) for k in range(2)])
            sage: Ha.expand()
            [[[1, x + y], [x + y, x^2 + 2*x*y + y^2]], [[x + y, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^3 + 3*x^2*y + 3*x*y^2 + y^3]]]
        

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixExpand(self)

    def factor(self):
        """
        Outputs a list of lists associated with the general
        hypermatrix with expressions in the entries in their
        factored form.
        The code only handles the Hypermatrix HM class objects.

        EXAMPLES:

        ::

            sage: sz=2; vx=HM(sz,'x').list(); vy=HM(sz,'y').list(); vz=HM(sz,'z').list()
            sage: X=HM(sz, 1, sz, [vx[u] for v in range(sz) for t in range(1) for u in range(sz)])
            sage: Y=HM(sz, 1, sz, [vy[u] for v in range(sz) for t in range(1) for u in range(sz)])
            sage: Z=HM(sz, 1, sz, [vz[u] for v in range(sz) for t in range(1) for u in range(sz)])
            sage: A=Prod(X, Y.transpose(2), Z.transpose())
            sage: Prod(A,A,A).factor()
            [[[(x0*y0*z0 + x1*y1*z1)*x0^2*y0^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x0^2*y0^2*z1^2], [(x0*y0*z0 + x1*y1*z1)*x0^2*y1^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x0^2*y1^2*z1^2]], [[(x0*y0*z0 + x1*y1*z1)*x1^2*y0^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x1^2*y0^2*z1^2], [(x0*y0*z0 + x1*y1*z1)*x1^2*y1^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x1^2*y1^2*z1^2]]]

        AUTHORS:
        - Edinah K. Gnang
        """
        return GeneralHypermatrixFactor(self)

    def simplify(self):
        """
        Performs the symbolic simplification of the expressions
        associated with the hypermatrix entries. 

        EXAMPLES:

        ::

            sage: x,y=var('x,y'); ((x+y)^2*HM(2,2,2,'one')).simplify()
            [[[(x + y)^2, (x + y)^2], [(x + y)^2, (x + y)^2]], [[(x + y)^2, (x + y)^2], [(x + y)^2, (x + y)^2]]]
 

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixSimplify(self)

    def simplify_full(self):
        """
        Performs the symbolic simplification of the expressions
        associated with the hypermatrix entries. 

        EXAMPLES:

        ::

            sage: x,y=var('x,y'); ((x+y)^2*HM(2,2,2,'one')).simplify_full()
            [[[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]], [[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]]]
 

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixSimplifyFull(self)

    def canonicalize_radical(self):
        """
        Performs the symbolic simplification of the expressions
        associated with the hypermatrix entries. 

        EXAMPLES:

        ::

            sage: x,y = var('x,y') 
            sage: ((x^2+2*x*y+y^2)*HM(2,2,2,'one')).canonicalize_radical() 
            [[[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]], [[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]]]

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixCanonicalizeRadical(self)

    def numerical(self, dgts=15):
        """
        Returns numerical value associated with the expressions
        in the hypermatrix entries. 

        EXAMPLES:

        ::

            sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
            sage: Ha.numerical()
            [[1.00000000000000, 1.00000000000000, 1.00000000000000], [1.00000000000000, -0.500000000000000 + 0.866025403784439*I, -0.500000000000000 - 0.866025403784439*I], [1.00000000000000, -0.500000000000000 - 0.866025403784439*I, -0.500000000000000 + 0.866025403784439*I]] 
         

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixNumerical(self, dgts)

    def N(self, dgts=15):
        """
        Returns numerical value associated with the expressions
        in the hypermatrix entries. 

        EXAMPLES:

        ::

            sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
            sage: Ha.numerical()
            [[1.00000000000000, 1.00000000000000, 1.00000000000000], [1.00000000000000, -0.500000000000000 + 0.866025403784439*I, -0.500000000000000 - 0.866025403784439*I], [1.00000000000000, -0.500000000000000 - 0.866025403784439*I, -0.500000000000000 + 0.866025403784439*I]] 
         

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixNumerical(self, dgts)



    def real(self):
        """
        Returns the real part of the self.

        EXAMPLES:

        ::

            sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
            sage: Ha.real()
            [[1, 1, 1], [1, -1/2, -1/2], [1, -1/2, -1/2]] 
         

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixReal(self)

    def imag(self):
        """
        Returns the imaginary part of the self.

        EXAMPLES:

        ::

            sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
            sage: Ha.imag()
            [[0, 0, 0], [0, 1/2*sqrt(3), -1/2*sqrt(3)], [0, -1/2*sqrt(3), 1/2*sqrt(3)]] 
         

        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixImag(self)


    def subs(self, *args, **kwds):
        """
        Substitute values to the variables in the hypermatrix.
        All the arguments are transmitted unchanged to the method ``subs`` of
        the coefficients.

        EXAMPLES:

        ::

            sage: var('a,b,d,e')
            (a, b, d, e)
            sage: m=HM([[a,b], [d,e]])
            sage: m.subs(a=1).printHM()
            [:, :]=
            [1 b]
            [d e]
            sage: m.subs(a=b, b=d).printHM()
            [:, :]=
            [b d]
            [d e]
            sage: m.subs({a: 3, b:2, d:1, e:-1}).printHM()
            [:, :]=
            [ 3  2]
            [ 1 -1]
            sage: m.subs([a==3, b==2, d==1, e==-1]).printHM()
            [:, :]=
            [ 3  2]
            [ 1 -1]
        """
        return GeneralHypermatrixSubstituteII(self, *args, **kwds)

    def subsn(self,Dct):
        """
        Procedure for computes the substitution in the Hypermatrix entries
        the inputs are the corresponding Hypermatric and a dictionary 
        datastructure.

        EXAMPLES:

        ::

            sage: HM(3,2,'a','sym').subsn(dict([(var('a011'),1),(var('a001'),2),(var('a000'),3),(var('a111'),4)]))
            [[[3.00000000000000, 2.00000000000000], [2.00000000000000, 1.00000000000000]], [[2.00000000000000, 1.00000000000000], [1.00000000000000, 4.00000000000000]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixSubstituteN(self, Dct)

    def substituteHMinto(self, poly, vrbl):
        """
        Procedure for computing substitution of the Hypermatrix into
        the input polynomial

        EXAMPLES:

        ::

            sage: x = var('x'); A=HM(2,2,'a')
            sage: p=x^2 - A.trace()*x + A.det()
            sage: A.substituteHMinto(p, x).expand()
            [[0, 0], [0, 0]]

        AUTHORS:

        - Edinah K. Gnang
        """
        return substituteHM(poly, vrbl, self)

    def substituteInHM(self, vrbl, M):
        """
        Procedure for computing substitution into the Hypermatrix 
        polynomial entries of a given input matrix for the input
        variable.


        EXAMPLES:

        ::

            sage: x = var('x'); Ha=HM(2,1,[x+1,x^2+1])
            sage: Y=var_list('y',2); rM=Ha.substituteInHM(x,HM(2,2,[Y[0],0,0,Y[1]])); rM
            [[[[y0 + 1, 0], [0, y1 + 1]]], [[[y0^2 + 1, 0], [0, y1^2 + 1]]]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return GeneralHypermatrixSubstituteInMatrix(self,vrbl,M)

    def transpose(self, i=1):
        """
        Outputs a list of lists associated with the general
        transpose as defined by the cyclic permutation of indices.
        The code only handles the Hypermatrix HM class objects.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,'a')
            sage: Ha.transpose()
            [[[a000, a100], [a001, a101]], [[a010, a110], [a011, a111]]]

        AUTHORS:
        - Edinah K. Gnang
        """
        t = Integer(mod(i, self.order()))
        A = self 
        for i in range(t):
            A = GeneralHypermatrixCyclicPermute(A)
        return A

    def t(self, i=1):
        """
        Outputs a list of lists associated with the general
        transpose as defined by the cyclic permutation of indices.
        The code only handles the Hypermatrix HM class objects.
        Short spelling for the transpose.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,'a')
            sage: Ha.t()
            [[[a000, a100], [a001, a101]], [[a010, a110], [a011, a111]]]

        AUTHORS:
        - Edinah K. Gnang
        """
        t = Integer(mod(i, self.order()))
        A = self 
        for i in range(t):
            A = GeneralHypermatrixCyclicPermute(A)
        return A


    def conjugate(self):
        """
        Outputs the conjugate of the hypermatrix. 

        EXAMPLES:

        ::

            sage: Ha=HM(2,1,[1+3*I, I])
            sage: Ha.conjugate()
            [[-3*I + 1], [-I]]


        AUTHORS:

        - Edinah K. Gnang
        """ 
        A = self 
        return GeneralHypermatrixConjugate(A)

    def conjugate_transpose(self, i=1):
        """
        Outputs the conjugate transpose of the hypermatrix. 

        EXAMPLES:

        ::

            sage: Ha=HM(2,1,[1+3*I, I])
            sage: Ha.conjugate_transpose()
            [[-3*I + 1, -I]]

        AUTHORS:

        - Edinah K. Gnang
        """ 
        t = Integer(mod(i, self.order()))
        A = self 
        for i in range(1,t+1):
            A = GeneralHypermatrixCyclicPermute(A)
        if Integer(mod(i,2))==0:
            return A
        else:
            return GeneralHypermatrixConjugate(A)

    def tumble(self, i=1):
        """
        Outputs a list of lists associated with the tumble
        transpose. 
        The code only handles second order HM class objects.

        EXAMPLES:

        ::

            sage: sz=5; (HM(sz,sz,'a') - HM(sz,sz,'a').tumble()).printHM()
            [:, :]=
            [ a00 - a40  a01 - a30  a02 - a20  a03 - a10 -a00 + a04]
            [ a10 - a41  a11 - a31  a12 - a21 -a11 + a13 -a01 + a14]
            [ a20 - a42  a21 - a32          0 -a12 + a23 -a02 + a24]
            [ a30 - a43  a31 - a33 -a23 + a32 -a13 + a33 -a03 + a34]
            [ a40 - a44 -a34 + a41 -a24 + a42 -a14 + a43 -a04 + a44]


        AUTHORS:
        - Edinah K. Gnang
        """
        if self.order()==2 and self.is_cubical():
            t = Integer(mod(i,4))
            tA = self.copy() 
            for itr in range(t):
                B=HM(tA.n(0),tA.n(1),'zero')
                for i in rg(tA.n(0)):
                    for j in rg(tA.n(1)):
                        B[i,j]=tA[tA.n(0)-1-j,i]
                tA=B.copy()
            return tA
        else:
            raise ValueError("Expected a cubical second order hypermatrix")

    def index_rotation(self, T):
        """
        Outputs the index rotation by angle T of self.
        The method is only implemented to second and third
        order hypermatrices. The rotation is performed
        clockwise by multiples of 2*pi/4 for second order hypermatrices as follows
        [i,j] -> [(i-floor(sz/2))*cos(T)+(-j+floor(sz/2))*sin(T)+floor(sz/2), (i-floor(sz/2))*sin(T)-(-j+floor(sz/2))*cos(T)+floor(sz/2)] if sz is odd
        [i,j] -> [(i-(sz-1)/2)*cos(T)+(-j+(sz-1)/2)*sin(T)+(sz-1)/2, (i-(sz-1)/2)*sin(T)-(-j+(sz-1)/2)*cos(T)+(sz-1)/2] if sz is even


        EXAMPLES:

        ::

            sage: sz=Integer(5); (HM(sz,sz,'a') - HM(sz,sz,'a').index_rotation(pi/2)).printHM()
            [:, :]=
            [ a00 - a40  a01 - a30  a02 - a20  a03 - a10 -a00 + a04]
            [ a10 - a41  a11 - a31  a12 - a21 -a11 + a13 -a01 + a14]
            [ a20 - a42  a21 - a32          0 -a12 + a23 -a02 + a24]
            [ a30 - a43  a31 - a33 -a23 + a32 -a13 + a33 -a03 + a34]
            [ a40 - a44 -a34 + a41 -a24 + a42 -a14 + a43 -a04 + a44]
            sage: sz=2; A=HM(sz, sz, sz, 'a')
            sage: A.index_rotation([2*pi/4, 0, 0]).p()
            [:, :, 0]=
            [a100 a110]
            [a101 a111]
            <BLANKLINE>
            [:, :, 1]=
            [a000 a010]
            [a001 a011]
            <BLANKLINE>


        AUTHORS:
        - Edinah K. Gnang and Fan Tian
        """
        if self.order()==2:
            return SecondOrderIndexRotation(self, T)
        elif self.order()==3:
            return ThirdOrderIndexRotation(self, T)
        else :
            raise ValueError("not supported for order %d hypermatrices" % self.order())

    def select_index_rotation(self, T, EntryList):
        """
        Outputs a list of lists associated with the tumble
        transpose. 
        The code only handles second order HM class objects.

        EXAMPLES:

        ::

            sage: sz=5; (HM(sz,sz,'a') - HM(sz,sz,'a').select_index_rotation(pi/2, rg(sz))).printHM()
            [:, :]=
            [ a00 - a40  a01 - a30  a02 - a20  a03 - a10 -a00 + a04]
            [ a10 - a41  a11 - a31  a12 - a21 -a11 + a13 -a01 + a14]
            [ a20 - a42  a21 - a32          0 -a12 + a23 -a02 + a24]
            [ a30 - a43  a31 - a33 -a23 + a32 -a13 + a33 -a03 + a34]
            [ a40 - a44 -a34 + a41 -a24 + a42 -a14 + a43 -a04 + a44]
            sage: sz=5; (HM(sz,sz,'a') - HM(sz,sz,'a').select_index_rotation(pi/2, [1,3])).printHM()
            [:, :]=
            [         0          0          0          0          0]
            [         0  a11 - a31          0 -a11 + a13          0]
            [         0          0          0          0          0]
            [         0  a31 - a33          0 -a13 + a33          0]
            [         0          0          0          0          0]
            sage: sz=2; A=HM(sz, sz, sz, 'a')
            sage: A.select_index_rotation([2*pi/4, 0, 0], rg(sz)).printHM()
            [:, :, 0]=
            [a100 a110]
            [a101 a111]
            <BLANKLINE>
            [:, :, 1]=
            [a000 a010]
            [a001 a011]
            <BLANKLINE>


        AUTHORS:

        - Edinah K. Gnang and Fan Tian 
        - To Do: Implement the arbitrary order version
        """
        if self.order()==2:
            return SelectSecondOrderIndexRotation(self, T, EntryList)
        elif self.order()==3:
            return SelectThirdOrderIndexRotation(self, T, EntryList)
        else :
            raise ValueError("not supported for order %d hypermatrices" % self.order())

    def slice_index_rotation(self, T, Lslice):
        """
        Outputs a hypermatrix which perform index
        rotations only on the designated slice.
        This function was inspired by looking at TCO
        play with his 3 x 3 x 3 rubik's cube.
        In this context we represent a 3 x 3 x 3 rubik's cube
        as a 3 x 3 x 3 hypermatrix whose entries are 2 x 2 x 2
        rank one symbolic hypermatrices


        EXAMPLES:

        ::

            sage: sz=2; HM(sz,sz,sz,'a').slice_index_rotation([0,0,2*pi/4], [1]).printHM()
            [:, :, 0]=
            [a000 a010]
            [a100 a110]
            <BLANKLINE>
            [:, :, 1]=
            [a101 a001]
            [a111 a011]
            <BLANKLINE>
            sage: AlphaB = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
            sage: Ha = HM(2,2,2,[HM(2,2,2,AlphaB[i]) for i in rg(2^3)])
            sage: Hb = Ha.slice_index_rotation([0,0,2*pi/4], [0])
            sage: Hb[0,1,0].printHM()
            [:, :, 0]=
            [a100 a000]
            [a110 a010]
            <BLANKLINE>
            [:, :, 1]=
            [a101 a001]
            [a111 a011]
            <BLANKLINE>


        AUTHORS:

        - Edinah K. Gnang
        - To Do: Implement the arbitrary order version
        """
        if self.order()==3:
            if type(self[0,0,0]) == type(HM(2,2,2,'a')):
                # Performing the outside transformation
                Tmp=ThirdOrderSliceIndexRotation(self, T, Lslice); sz=Tmp.n(0)
                # Performing the inside transformation
                return HM(sz, sz, sz, [Tmp[i,j,k].index_rotation(T) for k in rg(sz) for j in rg(sz) for i in rg(sz)])
            else: 
                return ThirdOrderSliceIndexRotation(self, T, Lslice)
        else :
            raise ValueError("not supported for order %d hypermatrices" % self.order())

    def nrows(self):
        return len(self.hm)

    def ncols(self):
        return len(self.hm[0])

    def ndpts(self):
        return len(self.hm[0][0])

    def inverse(self):
        """
        Returns the matrix inverse. 

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,'a')
            sage: Ha.inverse().printHM()
            [:, :]=
            [1/a00 - a01*a10/(a00^2*(a01*a10/a00 - a11))               a01/(a00*(a01*a10/a00 - a11))]
            [              a10/(a00*(a01*a10/a00 - a11))                      -1/(a01*a10/a00 - a11)]

        AUTHORS:

        - Edinah K. Gnang
        """
        if self.order()==2 and self.is_cubical():
            return HM(self.n(0), self.n(1), Matrix(SR, self.listHM()).inverse().transpose().list()) 
        else:
            raise ValueError("not supported for order %d hypermatrices" %self.order())

    def printHM(self, dim1=0, dim2=1, dpths=None):
        """
        Conveniently displays matrices and higher order hypermatrices
        one depth slice at a time. For order 4 or greater
        hypermatrices, you may choose 2 dimensions along which a
        slice is taken, and specify specific depths to take the slices

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,'a')
            sage: Ha.printHM()
            [:, :, 0]=
            [a000 a010]
            [a100 a110]
            <BLANKLINE>
            [:, :, 1]=
            [a001 a011]
            [a101 a111]
            <BLANKLINE>
            
            sage: Hb=HM(1,2,3,2,'b')
            sage: Hb.printHM(1,2)
            [0, :, :, 0]=
            [b0000 b0010 b0020]
            [b0100 b0110 b0120]
            <BLANKLINE>
            [0, :, :, 1]=
            [b0001 b0011 b0021]
            [b0101 b0111 b0121]
            <BLANKLINE>
            sage: Hb.printHM(2,1)
            [0, :, :, 0]=
            [b0000 b0100]
            [b0010 b0110]
            [b0020 b0120]
            <BLANKLINE>
            [0, :, :, 1]=
            [b0001 b0101]
            [b0011 b0111]
            [b0021 b0121]
            <BLANKLINE>
            sage: Hb.printHM(2,0,dpths=[(0,1),(1,1),(1,0)])
            [:, 0, :, 1]=
            [b0001]
            [b0011]
            [b0021]
            <BLANKLINE>
            [:, 1, :, 1]=
            [b0101]
            [b0111]
            [b0121]
            <BLANKLINE>
            [:, 1, :, 0]=
            [b0100]
            [b0110]
            [b0120]


        AUTHORS:

        - Edinah K. Gnang and Ricky Cheng
        """
        if self.order()==2:
            L=self.listHM()
            print('[:, :]=\n'+Matrix(SR,L).str())
        elif self.order()==3:
            L=self.listHM()
            for dpth in range(self.n(2)):
                print('[:, :, '+str(dpth)+']=\n'+Matrix(SR,self.n(0),self.n(1),[L[i][j][dpth] for i in range(self.n(0)) for j in range(self.n(1))]).str()+'\n')
        elif dim1 != dim2:
            getFullTuple = (lambda tuple, i, j: tuple[:dim1] + (i,) + tuple[dim1:dim2-1] + (j,) + tuple[dim2-1:]) \
                       if   dim1 < dim2 \
                       else lambda tuple, i, j: tuple[:dim2] + (j,) + tuple[dim2:dim1-1] + (i,) + tuple[dim1-1:]
            def getEntry(list, tuple, i, j):
                tuple = getFullTuple(tuple, i, j)
                for i in tuple:
                    list = list[i]
                return list
        
            L=self.listHM()
            if dpths is None:
               dpths = itertools.product(*(range(self.n(i)) for i in range(self.order()) if i != dim1 and i != dim2))
            for dpth in dpths:
                # print(dpth)
                depth_to_print = ', '.join(str(s) for s in getFullTuple(dpth,':',':'))
                slice_to_print = [getEntry(L, dpth, i, j) for i in range(self.n(dim1)) for j in range(self.n(dim2))]
                
                print('['+depth_to_print+']=\n'+Matrix(SR, self.n(dim1),self.n(dim2),slice_to_print).str()+'\n')
        else:
            # raise ValueError("not supported for order %d hypermatrices" %self.order())
            raise ValueError("invalid slice dimensions; dim1 and dim2 must be distinct")

    def p(self, dim1=0, dim2=1, dpths=None):
        """
        Conveniently displays matrices and higher order hypermatrices
        one depth slice at a time. For order 4 or greater
        hypermatrices, you may choose 2 dimensions along which a
        slice is taken, and specify specific depths to take the slices
        Short spelling for printHM above.

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,2,'a')
            sage: Ha.p()
            [:, :, 0]=
            [a000 a010]
            [a100 a110]
            <BLANKLINE>
            [:, :, 1]=
            [a001 a011]
            [a101 a111]
            <BLANKLINE>
            
            sage: Hb=HM(1,2,3,2,'b')
            sage: Hb.p(1,2)
            [0, :, :, 0]=
            [b0000 b0010 b0020]
            [b0100 b0110 b0120]
            <BLANKLINE>
            [0, :, :, 1]=
            [b0001 b0011 b0021]
            [b0101 b0111 b0121]
            <BLANKLINE>
            sage: Hb.p(2,1)
            [0, :, :, 0]=
            [b0000 b0100]
            [b0010 b0110]
            [b0020 b0120]
            <BLANKLINE>
            [0, :, :, 1]=
            [b0001 b0101]
            [b0011 b0111]
            [b0021 b0121]
            <BLANKLINE>
            sage: Hb.p(2,0,dpths=[(0,1),(1,1),(1,0)])
            [:, 0, :, 1]=
            [b0001]
            [b0011]
            [b0021]
            <BLANKLINE>
            [:, 1, :, 1]=
            [b0101]
            [b0111]
            [b0121]
            <BLANKLINE>
            [:, 1, :, 0]=
            [b0100]
            [b0110]
            [b0120]

        AUTHORS:

        - Edinah K. Gnang and Ricky Cheng
        """
        if self.order()==2:
            L=self.listHM()
            print('[:, :]=\n'+Matrix(SR,L).str())
        elif self.order()==3:
            L=self.listHM()
            for dpth in range(self.n(2)):
                print('[:, :, '+str(dpth)+']=\n'+Matrix(SR,self.n(0),self.n(1),[L[i][j][dpth] for i in range(self.n(0)) for j in range(self.n(1))]).str()+'\n')
        elif dim1 != dim2:
            getFullTuple = (lambda tuple, i, j: tuple[:dim1] + (i,) + tuple[dim1:dim2-1] + (j,) + tuple[dim2-1:]) \
                       if   dim1 < dim2 \
                       else lambda tuple, i, j: tuple[:dim2] + (j,) + tuple[dim2:dim1-1] + (i,) + tuple[dim1-1:]
            def getEntry(list, tuple, i, j):
                tuple = getFullTuple(tuple, i, j)
                for i in tuple:
                    list = list[i]
                return list
        
            L=self.listHM()
            if dpths is None:
               dpths = itertools.product(*(range(self.n(i)) for i in range(self.order()) if i != dim1 and i != dim2))
            for dpth in dpths:
                # print(dpth)
                depth_to_print = ', '.join(str(s) for s in getFullTuple(dpth,':',':'))
                slice_to_print = [getEntry(L, dpth, i, j) for i in range(self.n(dim1)) for j in range(self.n(dim2))]
                
                print('['+depth_to_print+']=\n'+Matrix(SR, self.n(dim1),self.n(dim2),slice_to_print).str()+'\n')
        else:
            # raise ValueError("not supported for order %d hypermatrices" %self.order())
            raise ValueError("invalid slice dimensions; dim1 and dim2 must be distinct")

    def latexHM(self):
        """
        Returns the latex string. 

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,'a')
            sage: len(Ha.latexHM())
            86


        AUTHORS:

        - Edinah K. Gnang
        """
        # Initialization of the string to
        strng=""
        if self.order()==2:
            L=self.listHM()
            strng=strng+'[:, :]=\n'+latex(Matrix(SR,L))
            return strng
        elif self.order()==3:
            L=self.listHM()
            for dpth in range(self.n(2)):
                strng=strng+'[:, :, '+str(dpth)+']=\n'+latex(Matrix(SR,self.n(0),self.n(1),[L[i][j][dpth] for i in range(self.n(0)) for j in range(self.n(1))]))+'\n'
            return strng
        else:
            raise ValueError("not supported for order %d hypermatrices" %self.order())

    def l(self):
        """
        Returns the latex string. 

        EXAMPLES:

        ::

            sage: Ha=HM(2,2,'a')
            sage: len(Ha.l())
            86


        AUTHORS:

        - Edinah K. Gnang
        """
        # Initialization of the string to
        strng=""
        if self.order()==2:
            L=self.listHM()
            strng=strng+'[:, :]=\n'+latex(Matrix(SR,L))
            return strng
        elif self.order()==3:
            L=self.listHM()
            for dpth in range(self.n(2)):
                strng=strng+'[:, :, '+str(dpth)+']=\n'+latex(Matrix(SR,self.n(0),self.n(1),[L[i][j][dpth] for i in range(self.n(0)) for j in range(self.n(1))]))+'\n'
            return strng
        else:
            raise ValueError("not supported for order %d hypermatrices" %self.order())

    def n(self,i):
        """
        Returns the i-th side length

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,2,'a')
            sage: Ha.n(1)
            3


        AUTHORS:

        - Edinah K. Gnang
        """
        if i==0:
            return self.nrows()
        elif i==1:
            return self.ncols()
        elif i==2:
            return self.ndpts()
        else:
            tmp=self.listHM()
            for j in range(i):
                tmp=tmp[0]
            return len(tmp)

    def list(self):
        """
        Returns the hypermatrix as a list going down by columns.

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.list()
            [a00, a10, a01, a11, a02, a12]


        AUTHORS:

        - Edinah K. Gnang
        """
        lst = []
        l = [self.n(i) for i in range(self.order())]
        # Main loop canonicaly listing the elements
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            # Appending to the list
            lst.append(self[tuple(entry)])
        return lst

    def set(self):
        """
        Returns the hypermatrix as a set going down by columns.

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.set().list()
            [a10, a11, a12, a01, a00, a02]


        AUTHORS:

        - Edinah K. Gnang
        """
        return Set(self.list())

    def listHM(self):
        """
        Returns the hypermatrix as a list of list

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.listHM()
            [[a00, a01, a02], [a10, a11, a12]]


        AUTHORS:

        - Edinah K. Gnang
        """
        return self.hm

    def matrix(self):
        """
        Returns the sage matrix class conversion of a
        the second order hypermatrix associated with self

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.matrix()
            [a00 a01 a02]
            [a10 a11 a12]


        AUTHORS:

        - Edinah K. Gnang
        """
        if self.order()<=2:
            return Matrix(SR,self.listHM())
        else:
            raise ValueError("not supported for order %d hypermatrices" %self.order())

    def order(self):
        """
        Returns the hypermatrix order.

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.order()
            2


        AUTHORS:

        - Edinah K. Gnang
        """
        cnt = 0
        H = self.listHM()
        while type(H) == type([]):
            H = H[0]
            cnt = cnt+1
        return cnt

    def dimensions(self):
        """
        Returns the list of hypermatrix side lengths.

        EXAMPLES:

        ::

            sage: Ha=HM(2,3,'a'); Ha.dimensions()
            [2, 3]


        AUTHORS:

        - Edinah K. Gnang
        """
        return [self.n(i) for i in range(self.order())]

    def zero_pad(self, dimLst):
        """
        return the zero padding of the input hypermatrix the inputs dimLst
        is desired dimensions of the padding        

        EXAMPLES::
        
            sage: A = HM(2,3,'a'); B=A.zero_pad([4,4])
            sage: B.printHM()
            [:, :]=
            [a00 a01 a02   0]
            [a10 a11 a12   0]
            [  0   0   0   0]
            [  0   0   0   0]
            sage: U = HM(2,1,'u'); V=U.zero_pad([2,2,2])
            sage: V.printHM()
            [:, :, 0]=
            [u00   0]
            [u10   0]
            <BLANKLINE>
            [:, :, 1]=
            [0 0]
            [0 0] 
        """
        if len(dimLst) == self.order():
            l = self.dimensions()
            AtmpL=[max(dimLst[z],self.n(z)) for z in rg(self.order())]+['zero']
            Rh = HM(*AtmpL)
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                booldim = True
                for j in rg(self.order()):
                    if entry[j] >= self.n(j):
                        booldim = False
                        break
                if  booldim:
                    Rh[tuple(entry)]=self[tuple(entry)]
                else:
                    Rh[tuple(entry)]=0
            return Rh
        elif len(dimLst) > self.order():
            AtmpL=[max(dimLst[z],self.n(z)) for z in self.dimensions()]+[dimLst[z] for z in rg(self.order(),len(dimLst))]+['zero']
            Rh = HM(*AtmpL)
            l = Rh.dimensions()
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                booldim = True
                for j in rg(self.order()):
                    if entry[j] >= self.n(j):
                        booldim = False
                        break
                if entry[self.order():] == [0 for z in rg(self.order(),len(dimLst))] and booldim:
                    Rh[tuple(entry)]=self[tuple(entry[:self.order()])]
                else:
                    Rh[tuple(entry)]=0
            return Rh
        else:
            raise ValueError("The order must not be smaller the starting hypermatrix")

    def fill_with(self, T, stL):
        """
        returns a hypermatrix whose top left corner is replaced with the entries a same order
        but smaller size input hypermatrix T. This method generalizes slightly the zero padding
        method for hypermatrices of the same order. The input st which is set by default to 0
        is the shift parameter. It adds st to all the index and has the effec of translating the
        block along the main diagonal. 


        EXAMPLES::
        
            sage: A=HM(3,3,'a'); B=HM(2,2,'b') 
            sage: A.fill_with(B,[0,0]).printHM()
            [:, :]=
            [b00 b01 a02]
            [b10 b11 a12]
            [a20 a21 a22]
            sage: A=HM(3,3,'a'); B=HM(2,2,'b','shift') 
            sage: A.fill_with(B,[1,1]).printHM()
            [:, :]=
            [a00 a01 a02]
            [a10 b11 b12]
            [a20 b21 b22]
 
        """
        if len(stL) != self.order():
            raise ValueError("The shift list length does not match the order ")
        else:
            boolsize = True
            for d in rg(self.order()):
                if T.n(d)+stL[d] > self.n(d):
                    boolsize = False
                    raise ValueError("Expected the input hypermatrix to have larger dimensions in all directions")
            l = self.dimensions()
            Rh = self.copy()
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i, l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                booldim = True
                for j in rg(self.order()):
                    if entry[j] >= T.n(j):
                        booldim = False
                        break
                if booldim:
                    Rh[tuple([entry[z]+stL[z] for z in rg(len(entry))])]=T[tuple(entry)]
            return Rh

    def show(self):
        import pylab, numpy
        from scipy import misc
        # Obtaining the size of the image
        X = misc.toimage(pylab.array(self.listHM()))
        g = graphics_array([[matrix_plot(X)]])
        g.show()

    def save(self,filename):
        import pylab, numpy
        from scipy import misc
        # obtaining the image size
        X = misc.toimage(pylab.array(self.listHM()))
        X.save(filename)

    def copy(self):
        return GeneralHypermatrixCopy(self)

    def support(self):
        return GeneralHypermatrixSupport(self)

    def append_index(self,indx):
        return GeneralHypermatrixAppendIndex(self,indx)

    def norm(self,p=2):
        if p==Infinity:
            return max([abs(i) for i in self.list() if not i.is_zero()])
        elif p==0:
            return sum([1 for i in self.list() if not i.is_zero()])
        elif p==1:
            return sum([abs(i) for i in self.list() if not i.is_zero()])
        elif p>1:
            return sum([abs(i)^p for i in self.list()])^(1/p)
        else:
            raise ValueError("Expect a real number greater or equal to 0 or Infinity")

    def degree(self,vrbl):
        if type(vrbl)==type(var('x')):
            return max([i.degree(vrbl) for i in self.list() if not i.is_zero()])
        else:
            raise ValueError("Expect a real number greater or equal to 0 or Infinity")

    def trace(self):
        if self.order()==2:
            return sum(self[i,i] for i in range(min(self.n(0),self.n(1))))
        else:
            raise ValueError("Expects a second order hypermatrix")

    def reduce(self, VrbL, Rlts):
        return GeneralHypermatrixReduce(self, VrbL, Rlts)

    def fast_reduce(self, monom, subst):
        AtmpL=self.dimensions()+[[fast_reduce(self.list()[i], monom, subst) for i in rg(prod(self.dimensions()))]]
        return HM(*AtmpL)

    def reduce_modulo_binomial_ideal(self, monom, subst):
        AtmpL=self.dimensions()+[[reduce_modulo_binomial_ideal(self.list()[i], monom, subst) for i in rg(prod(self.dimensions()))]]
        return HM(*AtmpL)

    def diff(self, VrbL):
        AtmpL=self.dimensions()+[[diff(self.list()[i], VrbL) for i in rg(prod(self.dimensions()))]]
        return HM(*AtmpL)

    def operands(self):
        # Turning the hypermatrix into a list
        L=self.list()
        # Boolean variables checking that the operator is the same
        # for all entries.
        CommonOperator=True
        # max_len keeps track of the maximum number of operands.
        max_len=len(L[0].operands())
        for f in L[1:]:
            if f.operator() != L[0].operator():
                CommonOperator=False
                break
            else:
                if max_len < len(f.operands()):
                    max_len = len(f.operands())
        if CommonOperator==False:
            raise ValueError("Expects the same operator for all entries.")
        else:
            # Initilization of the list of operands
            Lst=[f.operands()+[0 for i in rg(max_len-len(f.operands()))] for f in L]
            # Initialization of the list which will store the hypermatrix operands
            LstOprds=[]
            # Looping over operands. The operands order is the default
            # sage lexicographic order
            for i in rg(max_len):
                AtmpL=self.dimensions()+[[l[i] for l in Lst]]
                LstOprds.append(HM(*AtmpL))  
            return LstOprds

    def mod(self, m):
        AtmpL=self.dimensions()+[[Integer(mod(self.list()[i], m)) for i in rg(prod(self.dimensions()))]]
        return HM(*AtmpL )

    def adjugate(self):
        if self.order()==2:
            return Matrix2HM((self.matrix()).adjugate())
        else:
            raise ValueError("Expects a second order hypermatrix")

    def per(self):
        if self.is_cubical():
            if self.n(0)==1:
                return self.list()[0]
            elif self.order()==2:
                return Per(self)
        else:
            raise ValueError("Expects a cubical second order hypermatrix")

    def det(self):
        if self.is_cubical():
            if self.n(0)==1:
                return self.list()[0]
            elif self.n(0)==2:
                return general_side_length_2_det(self)
            elif self.order()==2:
                return Deter(self)
            elif self.order()==3:
                return ThirdOrderDeter(self)
            elif self.order()==4:
                return FourthOrderHyperdeterminant(self)
            elif self.order()==5:
                return FifthOrderHyperdeterminant(self)
            elif self.order()==6:
                return SixthOrderHyperdeterminant(self)
            else:
                return GeneralHyperdeterminant(self) 
        else:
            raise ValueError("Expects a cubical hypermatrix")

    def is_empty(self):
        return self.hm==[]

    def is_zero(self):
        if Set([f.is_zero() for f in self.list()])==Set([True]):
            return True
        else:
            return False

    def is_unit(self):
        if self.n(0)==self.n(1) and self.n(0)==1 and self.list()==[1]:
            return True
        elif self.order()==2 and self.n(0)==self.n(1) and self==HM(self.order(),self.n(1),'kronecker'):
            return True
        else:
            return False

    def is_symmetric(self):
        return (self-self.transpose()).is_zero()

    def is_orthogonal(self):
        Blv=False
        for j in rg(self.order()):
            T=self.transpose(j)
            if Prod(*[T.transpose(T.order()-i) for i in rg(T.order())]).elementwise_product(HM(*(self.dimensions()+['one']))-HM(self.order(),self.n(0),'kronecker')).is_zero():
                Blv=True
                break
        return Blv

    def is_cubical(self):
        return len(Set(self.dimensions()).list())==1

    def is_hypercolumn(self):
        return Set(self.dimensions()[1:])==Set([1])

    def ref(self):
        if self.order()==2:
            return gaussian_eliminationHMIV(self)
        else:
            raise ValueError("Expected a second order hypermatrix")

    def refII(self):
        if self.order()==2:
            return gaussian_eliminationHMIII(self, HM(self.n(0),1,'zero'))[0]
        else:
            raise ValueError("Expected a second order hypermatrix")

    def rref(self):
        if self.order()==2:
            return gauss_jordan_eliminationHMII(self, HM(self.n(0),1,'zero'))[0]
        elif self.order()==3 and self.is_cubical():
            # Initializing the size parameter
            sz=self.n(0)
            # initializing the list second order slices
            TmpL=[HM(sz, sz, [self[i,j,k] for j in range(sz) for i in range(sz)]).rref() for k in range(sz)]
            # Initilizing the final second order hypermatrix
            M=HM(sz, sz, [TmpL[k][i,i] for i in range(sz) for k in range(sz)]).rref()
            # Initializing and filling up the resulting hypermatrix
            Rslt=HM(sz,sz,sz,'zero')
            for i in range(sz):
                for k in range(sz):
                    Rslt[i,i,k]=M[k,i]
            return Rslt
        else:
            raise ValueError("Expected a second order hypermatrix or a cubic third order hypermatrix")

    def rrefII(self):
        if self.order()==2:
            # Initiallization of the size parameter
            sz=max(self.dimensions())
            # Initialization of the identity matrix
            Id=HM(2,sz,'kronecker')
            # Initialization of the permutation matrix
            Hp=sum(HM(sz,1,[Id[i,sz-1-k] for i in range(sz)])*HM(1,sz,[Id[k,j] for j in range(sz)]) for k in range(sz))
            return (Hp.transpose()*((Hp.transpose()*ZeroPadding(self.refII())*Hp).refII())*Hp).refII()
        else:
            raise ValueError("Expected a second order hypermatrix")

    def rank(self):
        if self.order()==2:
            if self.is_zero():
                return 0
            else:
                cnt=0
                TmpHm=self.ref().copy()
                for i in range(min(TmpHm.dimensions())):
                    if not HM(1,self.n(1),[TmpHm[i,j] for j in range(self.n(1))]).is_zero():
                        cnt=cnt+1
                return cnt
        else:
            raise ValueError("Expected a second order hypermatrix")

    def matrix_from_rows_and_columns(self, rows, columns):
        """
        Return the matrix constructed from self from the given rows and
        columns.
    
        EXAMPLES::
    
            sage: A = HM(3,3,rg(3^2)); A.printHM()
            [:, :]=
            [0 3 6]
            [1 4 7]
            [2 5 8]
            sage: A.matrix_from_rows_and_columns([1], [0,2]).printHM()
            [:, :]=
            [1 7]
            sage: A.matrix_from_rows_and_columns([1,2], [1,2]).printHM()
            [:, :]=
            [4 7]
            [5 8]
    
        Note that row and column indices can be reordered or repeated::
    
            sage: A.matrix_from_rows_and_columns([2,1], [2,1]).printHM()
            [:, :]=
            [8 5]
            [7 4]
    
        For example here we take from row 1 columns 2 then 0 twice, and do
        this 3 times.
    
        ::
    
            sage: A.matrix_from_rows_and_columns([1,1,1],[2,0,0]).printHM()
            [:, :]=
            [7 1 1]
            [7 1 1]
            [7 1 1]

 
        AUTHORS:
    
        - Edinah K. Gnang
        """
        tMp=self.matrix().matrix_from_rows_and_columns(rows, columns)
        return HM(tMp.nrows(), tMp.ncols(), tMp.transpose().list())
 
    def third_order_hypermatrix_from_rows_columns_and_depths(self, rows, columns, depths):
        """
        Return the third order hypermatrix constructed from self from the given rows
        columns and depths.

        EXAMPLES::

            sage: A = HM(3,3,3,rg(3^3)); A.printHM()
            [:, :, 0]=
            [0 3 6]
            [1 4 7]
            [2 5 8]
            <BLANKLINE>
            [:, :, 1]=
            [ 9 12 15]
            [10 13 16]
            [11 14 17]
            <BLANKLINE>
            [:, :, 2]=
            [18 21 24]
            [19 22 25]
            [20 23 26]
            <BLANKLINE>
            sage: A.third_order_hypermatrix_from_rows_columns_and_depths([1], [0,2], [0,2]).printHM()
            [:, :, 0]=
            [1 7]
            <BLANKLINE>
            [:, :, 1]=
            [19 25]
            <BLANKLINE>
            sage: A.third_order_hypermatrix_from_rows_columns_and_depths([1,2], [1,2], [1,2]).printHM()
            [:, :, 0]=
            [13 16]
            [14 17]
            <BLANKLINE>
            [:, :, 1]=
            [22 25]
            [23 26]
            <BLANKLINE>

        Note that row and column indices can be reordered or repeated::

            sage: A.third_order_hypermatrix_from_rows_columns_and_depths([2,1], [2,1], [2,1]).printHM()
            [:, :, 0]=
            [26 23]
            [25 22]
            <BLANKLINE>
            [:, :, 1]=
            [17 14]
            [16 13]
            <BLANKLINE>

        For example here we take from row 1 columns 2 then 0 twice, and do
        this 3 times.

        ::

            sage: A.third_order_hypermatrix_from_rows_columns_and_depths([1,1,1],[2,0,0],[2,0,0]).printHM()
            [:, :, 0]=
            [25 19 19]
            [25 19 19]
            [25 19 19]
            <BLANKLINE>
            [:, :, 1]=
            [7 1 1]
            [7 1 1]
            [7 1 1]
            <BLANKLINE>
            [:, :, 2]=
            [7 1 1]
            [7 1 1]
            [7 1 1]
            <BLANKLINE>

        AUTHORS:

        - Edinah K. Gnang
        """
        if self.order()==3:
            if not type(rows)==list:
                raise TypeError("rows must be a list of integers")
            if not type(columns)==list:
                raise TypeError("columns must be a list of integers")
            if not type(depths)==list:
                raise TypeError("depths must be a list of integers")
            A = HM(len(rows), len(columns), len(depths), 'zero')
            r = 0 
            for i in rows:
                k = 0
                for j in columns:
                    t = 0
                    for l in depths:
                        A[r,k,t]=self.hm[i][j][l]
                        t += 1
                    k += 1
                r += 1
            return A
        else:
            raise ValueError("Expected a third order hypermatrix")

    def side_length_subhypermatrices(self, k):
        r"""
        Return the list of all side length hypermatrices.
        Only supported for second and third order hypermatrices. 
    
        In the case of matrix The returned list is sorted in lexicographical
        row major ordering, e.g., if A is a `3 \times 3` matrix then the minors
        returned are with these rows/columns: [ [0, 1]x[0, 1], [0, 1]x[0, 2], [0, 1]x[1, 2],
        [0, 2]x[0, 1], [0, 2]x[0, 2], [0, 2]x[1, 2], [1, 2]x[0, 1], [1, 2]x[0, 2], [1, 2]x[1, 2] ].
    
        INPUT:
    
        - ``k`` -- integer
    
        EXAMPLES::
    
            sage: A = HM(2,3,[1,2,3,4,5,6]); A.printHM()
            [:, :]=
            [1 3 5]
            [2 4 6]
            sage: [m.det() for m in A.side_length_subhypermatrices(2)]
            [-2, -4, -2]
            sage: [m.det() for m in A.side_length_subhypermatrices(1)]
            [1, 3, 5, 2, 4, 6]


        AUTHORS:

        - Edinah K. Gnang (2016-12-11)

        """
        if self.order() == 2:
            from sage.combinat.combination import Combinations
            all_rows = range(self.nrows())
            all_cols = range(self.ncols())
            m = []
            for rows in Combinations(all_rows,k):
                for cols in Combinations(all_cols,k):
                    m.append(self.matrix_from_rows_and_columns(rows,cols))
            return m
        elif self.order() == 3:
            from sage.combinat.combination import Combinations
            all_rows = range(self.nrows())
            all_cols = range(self.ncols())
            all_dpts = range(self.ndpts())
            m = []
            for rows in Combinations(all_rows,k):
                for cols in Combinations(all_cols,k):
                    for dpts in Combinations(all_dpts,k):
                        m.append(self.third_order_hypermatrix_from_rows_columns_and_depths(rows, cols, dpts))
            return m
        else :
            raise ValueError("Not supported for hypermatrices of this order")

    def matrix_minor(self,u,v):
        """
        Outputs a second order minor hypermatrix
        where the row u and column v is removed

        EXAMPLES:
 
        ::

            sage: HM(3,3,'a').matrix_minor(0,0).printHM()
            [:, :]=
            [a11 a12]
            [a21 a22]

        AUTHORS:
        - Edinah K. Gnang
        - To Do: 
        """
        if self.order()==2 and self.n(0)>1 and self.n(1)>1:
            return HM(self.n(0)-1,self.n(1)-1, [self[i,j] for j in rg(self.n(1)) for i in rg(self.n(0)) if j!=v and i!=u])
        else :
            raise ValueError("Not supported for hypermatrices of order > 2 and evry dimension must exceed 1")

    def slice(self,L,strg):
        """
        Outputs the result of the slicifing 


        EXAMPLES:
 
        ::

            sage: HM(3,3,'a').slice([0], 'row').printHM()
            [:, :]=
            [a00 a01 a02]
            <BLANKLINE>
            sage: HM(3,3,'a').slice([1], 'col').printHM()
            [:, :]=
            [a01]
            [a11]
            [a21]
            <BLANKLINE>
            sage: HM(3,3,3,'a').slice([2], 'dpt').printHM()
            [:, :, 0]=
            [a002 a012 a022]
            [a102 a112 a122]
            [a202 a212 a222] 
            <BLANKLINE>
  

        AUTHORS:
        - Edinah K. Gnang
        - To Do: 
        """
        return GeneralHypermatrixSlicer(self, L, strg)

    def flatten(self, dms, indx):
        """
        Outputs a lower order flattened hypermatrix computed from the higher order 
        input. The second input corresponds to the desired dimensions for the 
        flattened hypermatrix. The third input is the index of the most significant
        index. The default flatteing scheme is the column major order.


        EXAMPLES:
 
        ::


            sage: sz=3; A=HM(sz,sz,sz,'a')
            sage: A.flatten([sz, sz^2], 0).printHM() # Flattening scheme with the most significant index being 0
            [:, :]=
            [a000 a010 a020 a001 a011 a021 a002 a012 a022]
            [a100 a110 a120 a101 a111 a121 a102 a112 a122]
            [a200 a210 a220 a201 a211 a221 a202 a212 a222]
            sage: HM(sz,sz,sz, A.flatten([sz, sz^2], 0).list())-A # Checking the folding
            [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
            sage: A.flatten([sz, sz^2], 1).printHM()
            [:, :]=
            [a000 a001 a002 a100 a101 a102 a200 a201 a202]
            [a010 a011 a012 a110 a111 a112 a210 a211 a212]
            [a020 a021 a022 a120 a121 a122 a220 a221 a222]
            sage: HM(sz,sz,sz, A.flatten([sz, sz^2], 1).list())-A.transpose() # Checking the folding
            [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
            sage: A.flatten([sz, sz^2], 2).printHM()
            [:, :]=
            [a000 a100 a200 a010 a110 a210 a020 a120 a220]
            [a001 a101 a201 a011 a111 a211 a021 a121 a221]
            [a002 a102 a202 a012 a112 a212 a022 a122 a222] 
            sage: HM(sz,sz,sz, A.flatten([sz, sz^2], 2).list())-A.transpose(2) # Checking the folding
            [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
  

        AUTHORS:
        - Edinah K. Gnang and Fan Tian
        - To Do: 
        """
        return GeneralHypermatrixFlatten(self, dms, indx)

def MatrixGenerate(nr, nc, c):
    """
    Generates a list of lists associated with a symbolic nr x nc
    matrix by indexing the input character c by the indices.

    EXAMPLES:

    ::

        sage: M = MatrixGenerate(2, 2, 'm'); M
        [[m00, m01], [m10, m11]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = nr; n_q_cols = nc
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                # Filling up the matrix
                (q[i]).append(var(c+str(i)+str(j)))
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" and "+str(nc)+" must both be non-zero positive integers.")

def SymMatrixGenerate(nr, c):
    """
    Generates a list of lists associated with a symbolic nr x nr
    symmetric matrix by indexing the input character c by indices.

    EXAMPLES:

    ::

        sage: M = SymMatrixGenerate(2, 'm'); M
        [[m00, m10], [m10, m11]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = nr; n_q_cols = nr
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                # Filling up the matrix
                #(q[i]).append(var(c+str(min(i,j))+str(max(i,j))))
                (q[i]).append(var(c+str(max(i,j))+str(min(i,j))))
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" must be a non-zero positive integers.")

def SkewSymMatrixGenerate(nr, c):
    """
    Generates a list of lists associated with a symbolic nr x nr
    symmetric matrix by indexing the input character c by indices.

    EXAMPLES:

    ::

        sage: M = SkewSymMatrixGenerate(2, 'm'); M
        [[0, m01], [-m01, 0]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = nr; n_q_cols = nr
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                # Filling up the matrix
                if i==j:
                    (q[i]).append(0)
                elif i>j:
                    (q[i]).append(-var(c+str(min(i,j))+str(max(i,j))))
                else:
                    (q[i]).append(var(c+str(min(i,j))+str(max(i,j))))
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" must be a non-zero positive integers.")

def HypermatrixGenerate(*args):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character

    EXAMPLES:

    ::

        sage: M = HypermatrixGenerate(2, 2, 2, 'm'); M
        [[[m000, m001], [m010, m011]], [[m100, m101], [m110, m111]]]


    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    if len(args) == 1:
        return var(args[0])
    return [HypermatrixGenerate(*(args[1:-1]+(args[-1]+str(i),))) for i in range(args[0])]

def HypermatrixGenerateII(*args):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character. The difference
    between this function and the previous one is the fact that the index
    start from 1 as apposed to starting from zero. This was motivated by
    general determinant implementation.

    EXAMPLES:

    ::

        sage: M = HypermatrixGenerateII(2, 2, 2, 'm'); M
        [[[m111, m112], [m121, m122]], [[m211, m212], [m221, m222]]]


    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    if len(args) == 1:
        return var(args[0])
    return [HypermatrixGenerateII( *(args[1:-1]+(args[-1]+str(i),)) ) for i in range(1,1+args[0])]

def HypermatrixGenerateDigits(*args, symbol, digits=1):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character

    EXAMPLES:

    ::

        sage: N = HypermatrixGenerateDigits(12, 5, symbol='N', digits=2); N
        [[N0000, N0001, N0002, N0003, N0004],
         [N0100, N0101, N0102, N0103, N0104],
         [N0200, N0201, N0202, N0203, N0204],
         [N0300, N0301, N0302, N0303, N0304],
         [N0400, N0401, N0402, N0403, N0404],
         [N0500, N0501, N0502, N0503, N0504],
         [N0600, N0601, N0602, N0603, N0604],
         [N0700, N0701, N0702, N0703, N0704],
         [N0800, N0801, N0802, N0803, N0804],
         [N0900, N0901, N0902, N0903, N0904],
         [N1000, N1001, N1002, N1003, N1004],
         [N1100, N1101, N1102, N1103, N1104]]


    AUTHORS:
    - Edinah K. Gnang, Ricky Cheng
    """
    if len(args) == 0:
        return var(symbol)
    return [HypermatrixGenerateDigits(*(args[1:]), symbol=symbol+str(i).zfill(digits), digits=digits) for i in range(args[0])]

def HypermatrixGenerateFunc(*args, symbol, digits=1, func):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character


    EXAMPLES:

    ::

        sage: N = HypermatrixGenerateFunc


    AUTHORS:
    - Edinah K. Gnang, Ricky Cheng
    """
    if len(args) == 0:
        return var(symbol+func(digits))
    return [HypermatrixGenerateFunc(*(args[1:]), symbol=symbol+str(i).zfill(digits), digits=digits, func=func(i)) for i in range(args[0])]

def HypermatrixGenerateAllOne(*args):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character

    EXAMPLES:

    ::

        sage: M = HypermatrixGenerateAllOne(2, 2, 2); M
        [[[1, 1], [1, 1]], [[1, 1], [1, 1]]]


    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    if len(args) == 1:
        return [SR(1) for i in rg(args[0])]
    AtmpL=args[1:]
    return [HypermatrixGenerateAllOne(*AtmpL) for i in rg(args[0])]

def HypermatrixGenerateAllZero(*args):
    """
    Generates a list of lists associated with a symbolic arbitrary
    order hypematrix of size specified by the input using and the
    entries are determined by the last input character

    EXAMPLES:

    ::

        sage: M = HypermatrixGenerateAllZero(2, 2, 2); M
        [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    if len(args) == 1:
        return [SR(0) for i in range(args[0])]
    AtmpL=args[1:]
    return [HypermatrixGenerateAllZero(*AtmpL) for i in range(args[0])]

def SymHypermatrixGenerate(nr, c):
    """
    Generates a list of lists associated with a symbolic third order hypermatrix of size
    nr x nc x nd third order hypematrix using the input character c followed by indices.

    EXAMPLES:

    ::

        sage: M = SymHypermatrixGenerate(2, 'm'); M
        [[[m000, m001], [m001, m011]], [[m001, m011], [m011, m111]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = nr
    n_q_cols = nr
    n_q_dpts = nr
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_q_dpts):
                    if i==j or i==k or j==k:
                        (q[i][j]).append(var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                    else:
                        if i == min(i,j,k) and k == max(i,j,k):
                            (q[i][j]).append(var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                        elif k == min(i,j,k) and j == max(i,j,k):
                            (q[i][j]).append(var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                        elif i == max(i,j,k) and j == min(i,j,k):
                            (q[i][j]).append(var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                        else:
                            (q[i][j]).append(var(c+str(i+j+k-min(i,j,k)-max(i,j,k))+str(min(i,j,k))+str(max(i,j,k))))
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" must be a non-zero positive integer.")

def SkewSymHypermatrixGenerate(nr, c):
    """
    Generates a list of lists associated with a symbolic third order hypermatrix of size
    nr x nc x nd third order hypematrix using the input character c followed by indices.

    EXAMPLES:

    ::

        sage: M = SkewSymHypermatrixGenerate(3, 'm'); M
        [[[0, 0, 0], [0, 0, m012], [0, m021, 0]],
         [[0, 0, m021*w^2], [0, 0, 0], [m012*w, 0, 0]],
         [[0, m012*w^2, 0], [m021*w, 0, 0], [0, 0, 0]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the variable to be subsituted
    w=var('w')
    # Setting the dimensions parameters.
    n_q_rows = nr
    n_q_cols = nr
    n_q_dpts = nr
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_q_dpts):
                    if i==j or i==k or j==k:
                        (q[i][j]).append(0*var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                    else:
                        if i == min(i,j,k) and k == max(i,j,k):
                            (q[i][j]).append(w^0*var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                        elif k == min(i,j,k) and j == max(i,j,k):
                            (q[i][j]).append(w^1*var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                        elif i == max(i,j,k) and j == min(i,j,k):
                            (q[i][j]).append(w^2*var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))

                        elif i == min(i,j,k) and j == max(i,j,k):
                            (q[i][j]).append(w^0*var(c+str(min(i,j,k))+str(max(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))))
                        elif k == min(i,j,k) and i == max(i,j,k):
                            (q[i][j]).append(w^1*var(c+str(min(i,j,k))+str(max(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))))
                        elif k == max(i,j,k) and j == min(i,j,k):
                            (q[i][j]).append(w^2*var(c+str(min(i,j,k))+str(max(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))))
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" must be a non-zero positive integer.")

def HypermatrixVectorize(A):
    """
    Outputs our canonical vectorization list associated with
    the input third order hypermatrices A.

    EXAMPLES:

    ::

        sage: A = SymHypermatrixGenerate(2, 'a') 
        sage: Lst = HypermatrixVectorize(A); Lst
        [a000, a001, a001, a011, a001, a011, a011, a111]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A)
    n_q_cols = len(A[0])
    n_q_dpts = len(A[0][0])
    # Test for dimension match
    if n_q_rows>0 and n_q_cols>0 and n_q_dpts>0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            for j in range(n_q_cols):
                for k in range(n_q_dpts):
                    q.append(A[i][j][k])
        return q

    else :
        raise ValueError("The Dimensions non zero.")

def HypermatrixAdd(A, B):
    """
    Outputs a list of lists associated with the addtion of
    the two input third order hypermatrices A and B

    EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a'); B = HypermatrixGenerate(2,2,2,'b')
        sage: Rslt = HypermatrixAdd(A, B); Rslt
        [[[a000 + b000, a001 + b001], [a010 + b010, a011 + b011]], [[a100 + b100, a101 + b101], [a110 + b110, a111 + b111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(B)
    n_q_cols = len(B[0])
    n_q_dpts = len(B[0][0])
    # Test for dimension match
    if n_q_rows==len(A) and n_q_cols==len(A[0]) and n_q_dpts==len(A[0][0]):
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_q_dpts):
                    (q[i][j]).append(A[i][j][k]+B[i][j][k])
        return q
    else :
        raise ValueError("The Dimensions of the input hypermatrices must match.")

def HypermatrixHadamardProduct(A, B):
    """
    Outputs a list of lists associated with the Hadamard product of
    the two input third order hypermatrices A and B

    EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a'); B = HypermatrixGenerate(2,2,2,'b')
        sage: Rslt = HypermatrixHadamardProduct(A, B); Rslt
        [[[a000*b000, a001*b001], [a010*b010, a011*b011]],
         [[a100*b100, a101*b101], [a110*b110, a111*b111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A)
    n_q_cols = len(A[0])
    n_q_dpts = len(A[0][0])
    # Test for dimension match
    if n_q_rows==len(A) and n_q_cols==len(A[0]) and n_q_dpts==len(A[0][0]):
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_q_dpts):
                    (q[i][j]).append(A[i][j][k]*B[i][j][k])
        return q
    else :
        raise ValueError("The Dimensions of the input hypermatrices must match.")

def HypermatrixScale(A, s):
    """
    Outputs a list of lists associated with product of the
    scalar s with the third order hypermatrix A.

    EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a')
        sage: Rslt = HypermatrixScale(A, 3); Rslt
        [[[3*a000, 3*a001], [3*a010, 3*a011]], [[3*a100, 3*a101], [3*a110, 3*a111]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A)
    n_q_cols = len(A[0])
    n_q_dpts = len(A[0][0])
    # Initialization of the hypermatrix
    q = []
    for i in range(n_q_rows):
        q.append([])
    for i in range(len(q)):
        for j in range(n_q_cols):
            (q[i]).append([])
    for i in range(len(q)):
        for j in range(len(q[i])):
            for k in range(n_q_dpts):
                (q[i][j]).append(A[i][j][k]*s)
    return q

def HypermatrixEntryExponent(A, s):
    """
    Outputs a list of lists associated with raising every entry of the 
    third order input hypermatrix A by the scalar s.

    EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a')
        sage: Rslt = HypermatrixEntryExponent(A, 3); Rslt
        [[[a000^3, a001^3], [a010^3, a011^3]], [[a100^3, a101^3], [a110^3, a111^3]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A)
    n_q_cols = len(A[0])
    n_q_dpts = len(A[0][0])
    # Initialization of the hypermatrix
    q = []
    for i in range(n_q_rows):
        q.append([])
    for i in range(len(q)):
        for j in range(n_q_cols):
            (q[i]).append([])
    for i in range(len(q)):
        for j in range(len(q[i])):
            for k in range(n_q_dpts):
                (q[i][j]).append(A[i][j][k]^s)
    return q

def HypermatrixEntryExponentB(s, A):
    """
    Outputs a list of lists associated with the exponentiation by the
    scalar s of every entry of the third order input hypermatrix A.

    EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a')
        sage: Rslt = HypermatrixEntryExponentB(3,A); Rslt
        [[[3^a000, 3^a001], [3^a010, 3^a011]], [[3^a100, 3^a101], [3^a110, 3^a111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A)
    n_q_cols = len(A[0])
    n_q_dpts = len(A[0][0])
    # Initialization of the hypermatrix
    q = []
    for i in range(n_q_rows):
        q.append([])
    for i in range(len(q)):
        for j in range(n_q_cols):
            (q[i]).append([])
    for i in range(len(q)):
        for j in range(len(q[i])):
            for k in range(n_q_dpts):
                (q[i][j]).append(s^(A[i][j][k]))
    return q

def HypermatrixProduct(A, B, C):
    """
    Outputs a list of lists associated with the ternary
    Bhattacharya-Mesner product of the input third order 
    hypermatrices A, B and C.
    The code writen here handles both list of list data
    structures as well as the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: HypermatrixProduct(HM(2,2,2,'a'), HM(2,2,2,'b'), HM(2,2,2,'c'))
        [[[a000*b000*c000 + a010*b001*c100, a001*b000*c001 + a011*b001*c101], [a000*b010*c010 + a010*b011*c110, a001*b010*c011 + a011*b011*c111]], [[a100*b100*c000 + a110*b101*c100, a101*b100*c001 + a111*b101*c101], [a100*b110*c010 + a110*b111*c110, a101*b110*c011 + a111*b111*c111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    typ = 'list'
    if type(A) == type(HM(1,1,1,'one')) and type(B) == type(HM(1,1,1,'one')) and type(C)==type(HM(1,1,1,'one')):
        A = A.listHM(); B = B.listHM(); C = C.listHM()
        typ = 'HM'
    # Setting the dimensions parameters.
    n_a_rows = len(A)
    n_a_cols = len(A[0])
    n_a_dpts = len(A[0][0])
    n_b_rows = len(B)
    n_b_cols = len(B[0])
    n_b_dpts = len(B[0][0])
    n_c_rows = len(C)
    n_c_cols = len(C[0])
    n_c_dpts = len(C[0][0])
    # Test for dimension match
    if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and n_a_cols==n_b_dpts and n_b_dpts==n_c_rows:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_a_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_b_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_c_dpts):
                    (q[i][j]).append(sum([A[i][l][k]*B[i][j][l]*C[l][j][k] for l in range(n_a_cols)]))
        if typ=='list':
            return q
        else:
            return HM(q)

    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixProductII(A, B, C, support):
    """
    Outputs a list of lists associated with the ternary
    Bhattacharya-Mesner product of the input third order 
    hypermatrices A, B and C. But we restrict the sum in products
    to the support 
    The code writen here handles both list of list data
    structures as well as the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: M = HypermatrixProductII(HM(2,2,2,'a'), HM(2,2,2,'b'), HM(2,2,2,'c'), [0]); M
        [[[a000*b000*c000, a001*b000*c001], [a000*b010*c010, a001*b010*c011]], [[a100*b100*c000, a101*b100*c001], [a100*b110*c010, a101*b110*c011]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    typ = 'list'
    if type(A) == type(HM(1,1,1,'one')) and type(B) == type(HM(1,1,1,'one')) and type(C)==type(HM(1,1,1,'one')):
        A = A.listHM(); B = B.listHM(); C = C.listHM()
        typ = 'HM'
    # Setting the dimensions parameters.
    n_a_rows = len(A)
    n_a_cols = len(A[0])
    n_a_dpts = len(A[0][0])
    n_b_rows = len(B)
    n_b_cols = len(B[0])
    n_b_dpts = len(B[0][0])
    n_c_rows = len(C)
    n_c_cols = len(C[0])
    n_c_dpts = len(C[0][0])
    # Test for dimension match
    if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and n_a_cols==n_b_dpts and n_b_dpts==n_c_rows:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_a_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_b_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_c_dpts):
                    (q[i][j]).append(sum([A[i][l][k]*B[i][j][l]*C[l][j][k] for l in support]))
        if typ=='list':
            return q
        else:
            return HM(q)

    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixLogProduct(A,B,C):
    """
    Outputs a list of lists associated with the ternary
    product of the input hypermatrices A, B and C.

    EXAMPLES:

    ::

        sage: Ha=HM(2,1,2,'a'); Hb=HM(2,2,1,'b'); Hc=HM(1,2,2,'c'); HypermatrixLogProduct(Ha,Hb,Hc)
        [[[a000 + b000 + c000, a001 + b000 + c001], [a000 + b010 + c010, a001 + b010 + c011]], [[a100 + b100 + c000, a101 + b100 + c001], [a100 + b110 + c010, a101 + b110 + c011]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    typ = 'list'
    if type(A) == type(HM(1,1,1,'one')) and type(B) == type(HM(1,1,1,'one')) and type(C)==type(HM(1,1,1,'one')):
        A = A.listHM(); B = B.listHM(); C = C.listHM()
        typ = 'HM'
    # Setting the dimensions parameters.
    n_a_rows = len(A)
    n_a_cols = len(A[0])
    n_a_dpts = len(A[0][0])
    n_b_rows = len(B)
    n_b_cols = len(B[0])
    n_b_dpts = len(B[0][0])
    n_c_rows = len(C)
    n_c_cols = len(C[0])
    n_c_dpts = len(C[0][0])
    # Test for dimension match
    if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and n_a_cols==n_b_dpts and n_b_dpts==n_c_rows:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_a_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_b_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_c_dpts):
                    (q[i][j]).append(sum([A[i][l][k]+B[i][j][l]+C[l][j][k] for l in range(n_a_cols)]))
        if typ == 'list':
            return q
        else:
            return HM(q)
    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixKroneckerProduct(A, B, C):
    """
    Outputs a list of lists associated with the ternary
    analog of the Kronecker product for the inputh third
    order hypermatrices A, B and C.

    EXAMPLES:

    ::

        sage: X=HM(2, 1, 1, HM(2, 'x').list()); Y=HM(1, 2, 1, HM(2, 'y').list()); Z=HM(1, 1, 2, HM(2, 'z').list())
        sage: T=HypermatrixKroneckerProduct(X, Y, Z); T
        [[[x0*y0*z0, x0*y0*z1], [x0*y1*z0, x0*y1*z1]], [[x1*y0*z0, x1*y0*z1], [x1*y1*z0, x1*y1*z1]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    typ = 'list'
    if type(A) == type(HM(1,1,1,'one')) and type(B) == type(HM(1,1,1,'one')) and type(C)==type(HM(1,1,1,'one')):
        A = A.listHM(); B = B.listHM(); C = C.listHM()
        typ = 'HM'
    # Setting the dimensions parameters.
    n_a_rows = len(A)
    n_a_cols = len(A[0])
    n_a_dpts = len(A[0][0])
    n_b_rows = len(B)
    n_b_cols = len(B[0])
    n_b_dpts = len(B[0][0])
    n_c_rows = len(C)
    n_c_cols = len(C[0])
    n_c_dpts = len(C[0][0])
    # Test for zero dimension
    if n_a_rows*n_b_rows*n_c_rows>0 and n_a_cols*n_b_cols*n_c_cols>0 and n_a_dpts*n_b_dpts*n_c_dpts>0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_a_rows*n_b_rows*n_c_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_a_cols*n_b_cols*n_c_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_a_dpts*n_b_dpts*n_c_dpts):
                    (q[i][j]).append(0)
        for i0 in range(n_a_rows):
            for i1 in range(n_b_rows):
                for i2 in range(n_c_rows):
                    for j0 in range(n_a_cols):
                        for j1 in range(n_b_cols):
                            for j2 in range(n_c_cols):
                                for k0 in range(n_a_dpts):
                                    for k1 in range(n_b_dpts):
                                        for k2 in range(n_c_dpts):
                                            q[n_a_rows*n_b_rows*i2+n_a_rows*i1+i0][n_b_cols*n_c_cols*j0+n_b_cols*j2+j1][n_c_cols*n_a_dpts*k1+n_c_dpts*k0+k2]=A[i0][i1][i2]*B[j0][j1][j2]*C[k0][k1][k2]
        if typ=='list':
            return q
        else:
            return HM(q)
    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixProductB(A, B, C, D):
    """
    Outputs a list of lists associated with the ternary
    product the input hypermatrices A, B and C with
    background hypermatrix D.

    EXAMPLES:

    ::

        sage: Ha=HypermatrixGenerate(2,2,2,'a')
        sage: Hb=HypermatrixGenerate(2,2,2,'b')
        sage: Hc=HypermatrixGenerate(2,2,2,'c')
        sage: Hd=HypermatrixGenerate(2,2,2,'d')
        sage: Rslt=HypermatrixProductB(Ha,Hb,Hc,Hd); Rslt
        [[[a000*b000*c000*d000 + a000*b000*c100*d001 + a000*b001*c000*d010 + a000*b001*c100*d011 + a010*b000*c000*d100 + a010*b000*c100*d101 + a010*b001*c000*d110 + a010*b001*c100*d111, a001*b000*c001*d000 + a001*b000*c101*d001 + a001*b001*c001*d010 + a001*b001*c101*d011 + a011*b000*c001*d100 + a011*b000*c101*d101 + a011*b001*c001*d110 + a011*b001*c101*d111], [a000*b010*c010*d000 + a000*b010*c110*d001 + a000*b011*c010*d010 + a000*b011*c110*d011 + a010*b010*c010*d100 + a010*b010*c110*d101 + a010*b011*c010*d110 + a010*b011*c110*d111, a001*b010*c011*d000 + a001*b010*c111*d001 + a001*b011*c011*d010 + a001*b011*c111*d011 + a011*b010*c011*d100 + a011*b010*c111*d101 + a011*b011*c011*d110 + a011*b011*c111*d111]], [[a100*b100*c000*d000 + a100*b100*c100*d001 + a100*b101*c000*d010 + a100*b101*c100*d011 + a110*b100*c000*d100 + a110*b100*c100*d101 + a110*b101*c000*d110 + a110*b101*c100*d111, a101*b100*c001*d000 + a101*b100*c101*d001 + a101*b101*c001*d010 + a101*b101*c101*d011 + a111*b100*c001*d100 + a111*b100*c101*d101 + a111*b101*c001*d110 + a111*b101*c101*d111], [a100*b110*c010*d000 + a100*b110*c110*d001 + a100*b111*c010*d010 + a100*b111*c110*d011 + a110*b110*c010*d100 + a110*b110*c110*d101 + a110*b111*c010*d110 + a110*b111*c110*d111, a101*b110*c011*d000 + a101*b110*c111*d001 + a101*b111*c011*d010 + a101*b111*c111*d011 + a111*b110*c011*d100 + a111*b110*c111*d101 + a111*b111*c011*d110 + a111*b111*c111*d111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    typ = 'list'
    if type(A)==type(HM(1,1,1,'one')) and type(B)==type(HM(1,1,1,'one')) and type(C)==type(HM(1,1,1,'one')) and type(D)==type(HM(1,1,1,'one')):
        A = A.listHM(); B = B.listHM(); C = C.listHM(); D = D.listHM()
        typ = 'HM'
    # Setting the dimensions parameters.
    n_a_rows = len(A)
    n_a_cols = len(A[0])
    n_a_dpts = len(A[0][0])
    n_b_rows = len(B)
    n_b_cols = len(B[0])
    n_b_dpts = len(B[0][0])
    n_c_rows = len(C)
    n_c_cols = len(C[0])
    n_c_dpts = len(C[0][0])
    n_d_rows = len(D)
    n_d_cols = len(D[0])
    n_d_dpts = len(D[0][0])

    # Test for dimension match
    if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and n_a_cols==n_b_dpts and n_b_dpts==n_c_rows and n_a_cols==n_d_rows and n_a_cols==n_d_cols and n_a_cols==n_d_dpts:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_a_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_b_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_c_dpts):
                    (q[i][j]).append(sum([A[i][l0][k]*B[i][j][l1]*C[l2][j][k]*D[l0][l1][l2] for l0 in range(n_d_rows) for l1 in range(n_d_cols) for l2 in range(n_d_dpts)]))
        if typ=='list':
            return q
        else:
            return HM(q)
    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixDualProduct(A, B, C):
    """
    Outputs a list of lists associated with the ternary
    dual product the third order input hypermatrices A, B
    and C. Corresponds to the product introduced by Richard
    Kerner.


    EXAMPLES:

    ::

        sage: Ha=HM(2, 2, 2,'a'); Hb=HM(2, 2, 2,'b'); Hc=HM(2, 2, 2,'c')
        sage: Hr=HypermatrixDualProduct(Ha, Hb, Hc); Hr.p()
        [:, :, 0]=
        [a000*b000*c000 + a001*b001*c000 + a010*b000*c010 + a011*b001*c010 + a000*b100*c100 + a001*b101*c100 + a010*b100*c110 + a011*b101*c110 a000*b010*c000 + a001*b011*c000 + a010*b010*c010 + a011*b011*c010 + a000*b110*c100 + a001*b111*c100 + a010*b110*c110 + a011*b111*c110]
        [a100*b000*c000 + a101*b001*c000 + a110*b000*c010 + a111*b001*c010 + a100*b100*c100 + a101*b101*c100 + a110*b100*c110 + a111*b101*c110 a100*b010*c000 + a101*b011*c000 + a110*b010*c010 + a111*b011*c010 + a100*b110*c100 + a101*b111*c100 + a110*b110*c110 + a111*b111*c110]

        [:, :, 1]=
        [a000*b000*c001 + a001*b001*c001 + a010*b000*c011 + a011*b001*c011 + a000*b100*c101 + a001*b101*c101 + a010*b100*c111 + a011*b101*c111 a000*b010*c001 + a001*b011*c001 + a010*b010*c011 + a011*b011*c011 + a000*b110*c101 + a001*b111*c101 + a010*b110*c111 + a011*b111*c111]
        [a100*b000*c001 + a101*b001*c001 + a110*b000*c011 + a111*b001*c011 + a100*b100*c101 + a101*b101*c101 + a110*b100*c111 + a111*b101*c111 a100*b010*c001 + a101*b011*c001 + a110*b010*c011 + a111*b011*c011 + a100*b110*c101 + a101*b111*c101 + a110*b110*c111 + a111*b111*c111]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Test for dimension match
    if A.n(1)==C.n(1) and B.n(0)==C.n(0) and A.n(2)==B.n(2):
        # Initialization of the output
        Hr=HM(A.n(0), B.n(1), C.n(2),'zero')
        for i in rg(A.n(0)):
            for j in rg(B.n(1)):
                for k in rg(C.n(2)):
                    Hr[i,j,k]=sum([A[i,l1,l2]*B[l0,j,l2]*C[l0,l1,k] for l0 in rg(B.n(0)) for l1 in rg(C.n(1)) for l2 in rg(A.n(2))])
        return Hr
    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixDualProductB(A, B, C, D):
    """
    Outputs a list of lists associated with the ternary
    dual product the third order input hypermatrices A, B
    and C with background hypermatrix D which relates to 
    the product introduced by Richard Kerner.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c'); Hd=HM(2,2,2,'d')
        sage: Hr=HypermatrixDualProductB(Ha, Hb, Hc, Hd); Hr.p()
        [:, :, 0]=
        [a000*b000*c000*d000 + a001*b001*c000*d001 + a010*b000*c010*d010 + a011*b001*c010*d011 + a000*b100*c100*d100 + a001*b101*c100*d101 + a010*b100*c110*d110 + a011*b101*c110*d111 a000*b010*c000*d000 + a001*b011*c000*d001 + a010*b010*c010*d010 + a011*b011*c010*d011 + a000*b110*c100*d100 + a001*b111*c100*d101 + a010*b110*c110*d110 + a011*b111*c110*d111]
        [a100*b000*c000*d000 + a101*b001*c000*d001 + a110*b000*c010*d010 + a111*b001*c010*d011 + a100*b100*c100*d100 + a101*b101*c100*d101 + a110*b100*c110*d110 + a111*b101*c110*d111 a100*b010*c000*d000 + a101*b011*c000*d001 + a110*b010*c010*d010 + a111*b011*c010*d011 + a100*b110*c100*d100 + a101*b111*c100*d101 + a110*b110*c110*d110 + a111*b111*c110*d111]

        [:, :, 1]=
        [a000*b000*c001*d000 + a001*b001*c001*d001 + a010*b000*c011*d010 + a011*b001*c011*d011 + a000*b100*c101*d100 + a001*b101*c101*d101 + a010*b100*c111*d110 + a011*b101*c111*d111 a000*b010*c001*d000 + a001*b011*c001*d001 + a010*b010*c011*d010 + a011*b011*c011*d011 + a000*b110*c101*d100 + a001*b111*c101*d101 + a010*b110*c111*d110 + a011*b111*c111*d111]
        [a100*b000*c001*d000 + a101*b001*c001*d001 + a110*b000*c011*d010 + a111*b001*c011*d011 + a100*b100*c101*d100 + a101*b101*c101*d101 + a110*b100*c111*d110 + a111*b101*c111*d111 a100*b010*c001*d000 + a101*b011*c001*d001 + a110*b010*c011*d010 + a111*b011*c011*d011 + a100*b110*c101*d100 + a101*b111*c101*d101 + a110*b110*c111*d110 + a111*b111*c111*d111]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Test for dimension match
    if A.n(1)==C.n(1) and B.n(0)==C.n(0) and A.n(2)==B.n(2) and D.n(0)==C.n(0) and D.n(1)==A.n(1) and D.n(2)==A.n(2):
        # Initialization of the output
        Hr=HM(A.n(0), B.n(1), C.n(2),'zero')
        for i in rg(A.n(0)):
            for j in rg(B.n(1)):
                for k in rg(C.n(2)):
                    Hr[i,j,k]=sum([A[i,l1,l2]*B[l0,j,l2]*C[l0,l1,k]*D[l0,l1,l2] for l0 in rg(B.n(0)) for l1 in rg(C.n(1)) for l2 in rg(A.n(2))])
        return Hr
    else :
        raise ValueError("Hypermatrix dimension mismatch.")

def HypermatrixCyclicPermute(A):
    """
    Outputs a list of lists associated with the third order
    hypermatrix with entries index cyclicaly permuted.

    EXAMPLES:

    ::

        sage: Ha=HypermatrixGenerate(2,2,2,'a'); Ha
        [[[a000, a001], [a010, a011]], [[a100, a101], [a110, a111]]]
        sage: HypermatrixCyclicPermute(Ha)
        [[[a000, a100], [a001, a101]], [[a010, a110], [a011, a111]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = len(A[0])
    n_q_cols = len(A[0][0])
    n_q_dpts = len(A)
    # Initialization of the hypermatrix
    q = []
    for i in range(n_q_rows):
        q.append([])
    for i in range(len(q)):
        for j in range(n_q_cols):
            (q[i]).append([])
    for i in range(len(q)):
        for j in range(len(q[i])):
            for k in range(n_q_dpts):
                (q[i][j]).append(A[k][i][j])
    return q

def HypermatrixKroneckerDelta(nr):
    """
    Generates a list of lists associated with the third order
    nr x nr x nr Kronecker Delta hypermatrix.

    EXAMPLES:

    ::

        sage: Dlt = HypermatrixKroneckerDelta(2); Dlt
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Setting the dimensions parameters.
    n_q_rows = nr
    n_q_cols = nr
    n_q_dpts = nr
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
        # Initialization of the hypermatrix
        q = []
        for i in range(n_q_rows):
            q.append([])
        for i in range(len(q)):
            for j in range(n_q_cols):
                (q[i]).append([])
        for i in range(len(q)):
            for j in range(len(q[i])):
                for k in range(n_q_dpts):
                    if i==j and i==k:
                        (q[i][j]).append(1)
                    else:
                        (q[i][j]).append(0)
        return q
    else :
        raise ValueError("Input dimensions "+str(nr)+" must be a non-zero positive integer.")

def Vandermonde(l, shft=0):
    """
    Constructs a Vandermonde matrix from the input list
    assumed to be either numbers or symbolic variables
    nothing breaks however if one presents as input a list of
    hypermatrices.

    EXAMPLES:

    ::

        sage: Vandermonde(var_list('x',2))
        [[1, 1], [x0, x1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return HM(len(l),len(l),[l[j]^(i+shft) for j in rg(len(l)) for i in rg(len(l))])

def Circulant(l):
    """
    Constructs a circulant matrix from the input list
    assumed to be either numbers or symbolic variables
    nothing breaks however if one presents as input a list of
    hypermatrices.

    EXAMPLES:

    ::

        sage: Circulant(var_list('x',2)).p()
        [:, :]=
        [x0 x1]
        [x1 x0]


    AUTHORS:
    - Edinah K. Gnang
    """
    P=HM(Integer(2),rg(1,len(l))+[0],'perm')
    return HM([(P^i*HM(len(l),1,l)).list() for i in rg(len(l))])

def VandermondeHM(l, shft=0):
    """
    Constructs a Vandermonde matrix from the input list
    assumed to be either numbers or symbolic variables
    nothing breaks however if one presents as input a list of
    hypermatrices. Differs from the previous function in the 
    fact that the input is an object of type HM

    EXAMPLES:

    ::

        sage: VandermondeHM(HM(2,1,var_list('x',2)))
        [[1, 1], [x0, x1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return Vandermonde(l.list(), shft)

def inverse_vandermonde(X):
    """
    Constructs the symbolic inverse of the Vandermonde matrix
    associated with the vandermonde matrix from the input list X.
    Crucially the input is not of type HM just a list

    EXAMPLES:

    ::

        sage: inverse_vandermonde(var_list('x',2))
        [[-x1/(x0 - x1), 1/(x0 - x1)], [x0/(x0 - x1), -1/(x0 - x1)]]
        sage: (inverse_vandermonde(var_list('x',2))*Vandermonde(var_list('x',2))).canonicalize_radical().printHM()
        [:, :]=
        [1 0]
        [0 1] 


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the Vandermonde matrix
    sz=len(X); V=Vandermonde(X)
    # Initialization of the inverse
    iV=HM(sz, sz, 'zero')
    # Initialization of the set
    S=Set(rg(sz))
    # Filling up the inverse matrix
    for i in rg(sz):
        Dn_i=prod((X[k]-X[i]) for k in rg(sz) if k != i)
        for j in rg(sz):
            Nm_i=0
            for St in S.subsets(sz-1-j):
                if not i in St:
                    Nm_i=Nm_i+(-1)^j*prod(X[u] for u in St)
            # Updating the matrix entry
            iV[i,j]=Nm_i/Dn_i
    # Returning the result
    return iV

def var_list(c,sz,shft=0):
    """
    Returns a variable list of size sz indexing the input character c.
    the last input is the shift parameter of for the index.
   
 
    EXAMPLES:

    ::

        sage: var_list('x', 3)
        [x0, x1, x2]
        sage: var_list('x', 3, 1)
        [x1, x2, x3]


    AUTHORS:
    - Edinah K. Gnang
    """
    return HM(sz+shft,c).list()[shft:]

def Lagrange(X):
    """
    Constructs a Lagrange matrix from the input list
    assumed to be either numbers or symbolic variables
    nothing breaks however if one presents as input a 
    list of hypermatrices.

    EXAMPLES:

    ::

        sage: Lagrange(HM(3,'x').list())
        [[x0 - x2, x0 - x1], [x1 - x2, 1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    sz=len(X)-1; L=[]
    for i in range(sz):
        tmpl=range(sz,i,-1)
        L.append([X[i]-X[j] for j in tmpl]+[1 for k in range(sz-len(tmpl))]) 
    return HM(L) 

def HypermatrixPermutation(s):
    """
    Generates a list of lists associated with a transposition 
    hypermatrix deduced from sigma. Note that as a result of 
    the  non associativity, permutations must be performed as
    one transposition at a time. This is one way of implementing
    permutation hypermatrices in this setting only non overlaping
    cycles can be combined into a single permutation hypermatrix


    EXAMPLES:


    ::


        sage: P = HypermatrixPermutation([0,2,1]); P
        [[[1, 0, 0], [0, 0, 1], [0, 1, 0]], [[1, 0, 0], [0, 0, 1], [0, 1, 0]], [[1, 0, 0], [0, 0, 1], [0, 1, 0]]]
        sage: P = HM(HypermatrixPermutation([1,0])); A=HM(2,2,2,'a')
        sage: Prod(P,A,P.transpose(2)).printHM()
        [:, :, 0]=
        [a001 a011]
        [a101 a111]
        <BLANKLINE>
        [:, :, 1]=
        [a000 a010]
        [a100 a110]


    AUTHORS:

    - Edinah K. Gnang and Ori Parzanchevski
    """
    sz = len(s)
    # Setting the dimensions parameters.
    n_q_rows = sz; n_q_cols = sz; n_q_dpts = sz
    # Test for dimension match
    if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
        # Initialization of the hypermatrix
        q = []
        T = HypermatrixKroneckerDelta(sz)
        U = HypermatrixGenerateAllOne(sz,sz,sz)
        Id= HypermatrixProduct(U,U,T)
        Id= HypermatrixCyclicPermute(Id)
        for i in range(sz):
            q.append(Id[s[i]])
        return HypermatrixCyclicPermute(HypermatrixCyclicPermute(q))
    else :
        raise ValueError("Input dimensions "+str(sz)+" must be a non-zero positive integer.")

def DiagonalHypermatrix(Mtrx):
    """
    Outputs a diagonal third order hypermatrix
    constructed using the input square matrix.
    We enforce the symmetry constraint by only
    taking entries from the lower triangular
    part of the input matrix.

     EXAMPLES:

    ::

        sage: a00, a11, a01=var('a00, a11, a01'); Mtrx = Matrix(SR, [[a00, a01], [a01, a11]])
        sage: Dg = DiagonalHypermatrix(Mtrx); Dg
        [[[a00, 0], [0, a01]], [[a01, 0], [0, a11]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the dimensions
    sz = min(Mtrx.nrows(), Mtrx.ncols())
    n_d_rows = sz; n_d_cols = sz; n_d_dpts = sz
    # Initialization of the identity permutations hypermatrix
    D = HypermatrixPermutation(range(sz))
    # Filling up the entries of the hypermatrix.
    for i in range(n_d_rows):
        for j in range(n_d_cols):
            for k in range(n_d_dpts):
                if D[i][j][k] != 0:
                    D[i][j][k] = Mtrx[i,k]
    return D

def Orthogonal2x2Matrix(t):
    """
    Outputs a symbolic parametrization of third order orthogonal matrix
    of size 2x2. Yields a matrix representation of the field of complex
    numbers.

     EXAMPLES:

    ::

        sage: t=var('t'); Q=Orthogonal2x2Matrix(t); Q.p()
        [:, :]=
        [ cos(t) -sin(t)]
        [ sin(t)  cos(t)]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the trigonometric
    c=cos(t); s=sin(t)
    # Initialization of the 2x2x2 hypermatrix
    Q=HM(2, 2,'zero')
    Q[0,0]=c; Q[0,1]=-s; Q[1,0]=s; Q[1,1]=c
    return Q

def Orthogonal2x2x2Hypermatrix(t,x,y):
    """
    Outputs a symbolic parametrization of third order orthogonal hypermatrix
    of size 2x2x2.

     EXAMPLES:

    ::

        sage: t,x,y=var('t,x,y')
        sage: Orthogonal2x2x2Hypermatrix(t,x,y)
        [[[sin(t)^(2/3), -x*cos(t)^(2/3)], [cos(t)^(2/3), y*sin(t)^(2/3)]], [[1/x, sin(t)^(2/3)], [1/y, cos(t)^(2/3)]]]
        sage: U=Orthogonal2x2x2Hypermatrix(t,x,y); Prod(U,U.transpose(2),U.transpose())
        [[[cos(t)^2 + sin(t)^2, 0], [0, 0]], [[0, 0], [0, cos(t)^2 + sin(t)^2]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    return HM([[[sin(t)^(2/3), -x*cos(t)^(2/3)], [cos(t)^(2/3), y*sin(t)^(2/3)]], [[1/x, sin(t)^(2/3)], [1/y, cos(t)^(2/3)]]])

def Orthogonal2x2x2HypermatrixII(t,x,y):
    """
    Outputs a symbolic parametrization of third order orthogonal hypermatrix
    of size 2x2x2. The difference with the first implementation above is a
    permutation of the entries in the second row of the first slice and in the
    the first row of the second slice


     EXAMPLES:

    ::

        sage: t,x,y=var('t,x,y')
        sage: Orthogonal2x2x2HypermatrixII(t,x,y)
        [[[sin(t)^(2/3), y*cos(t)^(2/3)], [cos(t)^(2/3), -x*sin(t)^(2/3)]], [[1/y, sin(t)^(2/3)], [1/x, cos(t)^(2/3)]]]
        sage: U=Orthogonal2x2x2HypermatrixII(t,x,y); Prod(U,U.transpose(2),U.transpose())
        [[[cos(t)^2 + sin(t)^2, 0], [0, 0]], [[0, 0], [0, cos(t)^2 + sin(t)^2]]]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the Permutation hypermatrix
    P,Q=HypermatrixSn([1,0])
    return Prod(HM([[[cos(t)^(2/3), -x*sin(t)^(2/3)], [sin(t)^(2/3), y*cos(t)^(2/3)]], [[1/x, cos(t)^(2/3)], [1/y, sin(t)^(2/3)]]]), Q.transpose(), P.transpose())

def Orthogonal2x2x2HypermatrixIII(t,x,y):
    """
    Outputs a symbolic parametrization of third order orthogonal hypermatrix
    of size 2x2x2. The difference in the very first implementation is the sign
    change in the first row of the secodn slice.

     EXAMPLES:

    ::

        sage: t,x,y=var('t,x,y')
        sage: Orthogonal2x2x2HypermatrixIII(t,x,y)
        [[[sin(t)^(2/3), x*cos(t)^(2/3)], [cos(t)^(2/3), -y*sin(t)^(2/3)]], [[1/x, sin(t)^(2/3)], [1/y, cos(t)^(2/3)]]]
        sage: U=Orthogonal2x2x2HypermatrixIII(t,x,y); Prod(U,U.transpose(2),U.transpose())
        [[[cos(t)^2 + sin(t)^2, 0], [0, 0]], [[0, 0], [0, cos(t)^2 + sin(t)^2]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    return HM([[[sin(t)^(2/3), x*cos(t)^(2/3)], [cos(t)^(2/3), -y*sin(t)^(2/3)]], [[1/x, sin(t)^(2/3)], [1/y, cos(t)^(2/3)]]])

def Orthogonal2x2x2HypermatrixIV(t):
    """
    Outputs a symbolic parametrization of third order orthogonal hypermatrix
    of size 2x2x2. This implementation is a good candidate for the 3rd analog
    of the matrix representation of complex numbers.

     EXAMPLES:

    ::

        sage: t=var('t'); Q=Orthogonal2x2x2HypermatrixIV(t); Q.p()
        [:, :, 0]=
        [ cos(t)^(2/3) -sin(t)^(2/3)]
        [ sin(t)^(2/3)  cos(t)^(2/3)]
        
        [:, :, 1]=
        [ sin(t)^(2/3)  sin(t)^(2/3)]
        [ cos(t)^(2/3)  sin(t)^(2/3)]
        sage: Prod(Q.transpose(), Q, Q.transpose(2))
        [[[cos(t)^2 + sin(t)^2, 0], [0, 0]], [[0, 0], [0, cos(t)^2 + sin(t)^2]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the trigonometric
    c=(cos(t))^(2/3); s=(sin(t))^(2/3)
    # Initialization of the 2x2x2 hypermatrix
    Q=HM(2, 2, 2, 'zero')
    Q[0,0,0]=c; Q[1,0,0]=s; Q[0,1,0]=-s; Q[1,1,0]=c
    Q[0,0,1]=s; Q[1,0,1]=c; Q[0,1,1]= s; Q[1,1,1]=s
    return Q

def Orthogonal3x3x3Hypermatrix(t1,t2):
    """
    Outputs a symbolic parametrization of third order orthogonal hypermatrix
    of size 3x3x3.

     EXAMPLES:

    ::

        sage: t1, t2=var('t1, t2')
        sage: Orthogonal3x3x3Hypermatrix(t1,t2)
        [[[cos(t1)^(2/3), cos(t2)^(2/3)*sin(t1)^(2/3), 0],
          [cos(t2)^(2/3)*sin(t1)^(2/3), sin(t1)^(2/3)*sin(t2)^(2/3), 0],
          [sin(t1)^(2/3)*sin(t2)^(2/3), -1/2*(I*sqrt(3) + 1)*cos(t1)^(2/3), 0]],
         [[sin(t1)^(2/3)*sin(t2)^(2/3),
           cos(t1)^(2/3),
           -1/2*(I*sqrt(3) + 1)*cos(t2)^(2/3)*sin(t1)^(2/3)],
          [-1/2*(-I*sqrt(3) + 1)*cos(t1)^(2/3),
           cos(t2)^(2/3)*sin(t1)^(2/3),
           sin(t1)^(2/3)*sin(t2)^(2/3)],
          [cos(t2)^(2/3)*sin(t1)^(2/3), sin(t1)^(2/3)*sin(t2)^(2/3), cos(t1)^(2/3)]],
         [[0, sin(t1)^(2/3)*sin(t2)^(2/3), cos(t1)^(2/3)],
          [0, cos(t1)^(2/3), cos(t2)^(2/3)*sin(t1)^(2/3)],
          [0,
           -1/2*(-I*sqrt(3) + 1)*cos(t2)^(2/3)*sin(t1)^(2/3),
           sin(t1)^(2/3)*sin(t2)^(2/3)]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    c1=cos(t1)^(2/3)
    s1=sin(t1)^(2/3)
    c2=cos(t2)^(2/3)
    s2=sin(t2)^(2/3)
    return [[[c1,s1*c2,0],[s1*c2,s1*s2,0],[s1*s2,exp(-I*2*pi/3)*c1,0]], [[s1*s2,c1,exp(-I*2*pi/3)*s1*c2],[exp(I*2*pi/3)*c1,s1*c2,s1*s2], [s1*c2,s1*s2,c1]],[[0,s1*s2,c1],[0,c1,s1*c2],[0,exp(I*2*pi/3)*s1*c2,s1*s2]]]

def HypermatrixCayleyHamiltonStringList(n,c):
    """
    Outpts a list of strings describint hypermatrix powers of degree n. 

     EXAMPLES:

    ::

        sage: HypermatrixCayleyHamiltonStringList(5,'A')
        ['Prod(A, A, Prod(A, A, A))',
         'Prod(A, Prod(A, A, A), A)',
         'Prod(Prod(A, A, A), A, A)']

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if n == 1:
        return [c]
    else:
        gu = []
        for i in range(1,n,2):
            for j in range(1,n-i,2):
                gu = gu + ["Prod("+g1+", "+g2+", "+g3+")" for g1 in HypermatrixCayleyHamiltonStringList(i,c) for g2 in HypermatrixCayleyHamiltonStringList(j,c) for g3 in HypermatrixCayleyHamiltonStringList(n-(i+j),c)]
        return gu

def HypermatrixCayleyHamiltonList(A,n):
    """
    Outpts a list of hypermatrices (each of which is encapsulated as a single list) of all product composition of degree n.
    This function is most adapted for constructing matrices.

     EXAMPLES:

    ::

        sage: A=HM(2,2,2,'a'); HypermatrixCayleyHamiltonList(A,3)
        [[a000^3 + a001*a010*a100,
          a000*a100^2 + a100*a101*a110,
          a000*a010^2 + a010*a011*a110,
          a010*a100*a110 + a110^2*a111,
          a000*a001^2 + a001*a011*a101,
          a001*a100*a101 + a101^2*a111,
          a001*a010*a011 + a011^2*a111,
          a011*a101*a110 + a111^3]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if n == 1:
        return [A.list()]
    else:
        gu = []
        for i in range(1,n,2):
            for j in range(1,n-i,2):
                gu = gu + [HypermatrixProduct(HM(A.n(0),A.n(1),A.n(2),g1), HM(A.n(0),A.n(1),A.n(2),g2), HM(A.n(0),A.n(1),A.n(2),g3)).list() for g1 in HypermatrixCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonList(A,j) for g3 in HypermatrixCayleyHamiltonList(A,n-(i+j))]
        return gu

def HypermatrixCayleyHamiltonListII(A,n):
    """
    Outpts a list of third order hypermatrices of all product composition of degree n.

     EXAMPLES:

    ::

        sage: A = HypermatrixGenerate(2,2,2,'a')
        sage: Lst = HypermatrixCayleyHamiltonListII(A,3); Lst
        [[[[a000^3 + a001*a010*a100, a000*a001^2 + a001*a011*a101], [a000*a010^2 + a010*a011*a110, a001*a010*a011 + a011^2*a111]], [[a000*a100^2 + a100*a101*a110, a001*a100*a101 + a101^2*a111], [a010*a100*a110 + a110^2*a111, a011*a101*a110 + a111^3]]]]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if n == 1:
        return [A]
    else:
        gu = []
        for i in range(1,n,2):
            for j in range(1,n-i,2):
                gu = gu + [HypermatrixProduct(g1,g2,g3) for g1 in HypermatrixCayleyHamiltonListII(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,n-(i+j))]
        return gu

def HypermatrixCayleyHamiltonListIII(A,n):
    """
    Outputs a list of hypermatrices of all product
    composition of degree n for hypermatrices of 
    order up to 8 tends to be slow because it uses
    the general hypermatrix product and it takes HM
    object class as the input A

     EXAMPLES:

    ::

        sage: A = HM(2,2,2,'a')
        sage: L = HypermatrixCayleyHamiltonListIII(A,3)

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if A.order()==3:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    gu = gu + [GeneralHypermatrixProduct(g1,g2,g3) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,n-(i+j))]
            return gu
    # Case of order 4
    elif A.order()==4:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        gu = gu + [GeneralHypermatrixProduct(g1,g2,g3,g4) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,k) for g4 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k))]
            return gu
    # Case of order 5
    elif A.order()==5:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            gu = gu + [GeneralHypermatrixProduct(g1,g2,g3,g4,g5) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,k) for g4 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l))]
            return gu
    # Case of order 6
    elif A.order()==6:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                gu = gu + [GeneralHypermatrixProduct(g1,g2,g3,g4,g5,g6) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,k) for g4 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m))]
            return gu
    # Case of order 7
    elif A.order()==7:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                for o in range(1,n-i-j-k-l,2):
                                    gu = gu + [GeneralHypermatrixProduct(g1,g2,g3,g4,g5,g6,g7) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,k) for g4 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m)) for g7 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m+o))]
            return gu
    # Case of order 8
    elif A.order()==8:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                for o in range(1,n-i-j-k-l,2):
                                    for p in range(1,n-i-j-k-l-o,2):
                                        gu = gu + [GeneralHypermatrixProduct(g1,g2,g3,g4,g5,g6,g7) for g1 in HypermatrixCayleyHamiltonListIII(A,i) for g2 in HypermatrixCayleyHamiltonListIII(A,j) for g3 in HypermatrixCayleyHamiltonListIII(A,k) for g4 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m)) for g7 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m+o))  for g8 in HypermatrixCayleyHamiltonListIII(A,n-(i+j+k+l+m+o+p))]
            return gu
    else :
        raise ValueError("Not supported for order > 4 and for non cube hypermpatrix of order 3 ")
   
def HypermatrixSymCayleyHamiltonList(A,n):
    """
    Outpts a list of symmetric hypermatrices of all product
    composition of degree n.

     EXAMPLES:

    ::

        sage: A = HM(2,2,2,'a')
        sage: L = HypermatrixSymCayleyHamiltonList(A,3)

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if A.order()==3:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(2),g3.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,n-(i+j))]
            return gu
    # Case of order 4
    elif A.order()==4:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(3),g3.transpose(2),g4.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k))]
    # Case of order 5
    elif A.order()==5:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(4),g3.transpose(3),g4.transpose(2),g5.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l))]
    # Case of order 6
    elif A.order()==6:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(5),g3.transpose(4),g4.transpose(3),g5.transpose(2),g6.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m))]
    # Case of order 7
    elif A.order()==7:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                for o in range(1,n-i-j-k-l,2):
                                    gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(6),g3.transpose(5),g4.transpose(4),g5.transpose(3),g6.transpose(2),g7.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m)) for g7 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o))]
    # Case of order 8
    elif A.order()==8:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                for o in range(1,n-i-j-k-l,2):
                                    for p in range(1,n-i-j-k-l-o,2):
                                        gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(7),g3.transpose(6),g4.transpose(5),g5.transpose(4),g6.transpose(3),g7.transpose(2),g8.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m)) for g7 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o))  for g8 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o+p))]
    # Case of order 9
    elif A.order()==9:
        if n == 1:
            return [A]
        else:
            gu = []
            for i in range(1,n,2):
                for j in range(1,n-i,2):
                    for k in range(1,n-i-j,2):
                        for l in range(1,n-i-j-k,2):
                            for m in range(1,n-i-j-k-l,2):
                                for o in range(1,n-i-j-k-l,2):
                                    for p in range(1,n-i-j-k-l-o,2):
                                        for q in range(1,n-i-j-k-l-o-p,2):
                                            gu = gu + [GeneralHypermatrixProduct(g1,g2.transpose(8),g3.transpose(7),g4.transpose(6),g5.transpose(5),g6.transpose(4),g7.transpose(3),g8.transpose(2),g9.transpose()) for g1 in HypermatrixSymCayleyHamiltonList(A,i) for g2 in HypermatrixCayleyHamiltonListII(A,j) for g3 in HypermatrixCayleyHamiltonListII(A,k) for g4 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k)) for g5 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l)) for g6 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m)) for g7 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o))  for g8 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o+p)) for g9 in HypermatrixCayleyHamiltonListII(A,n-(i+j+k+l+m+o+p+q)) ]
    else :
        raise ValueError("Not supported for order > 4 and for non cube hypermpatrix of order 3 ")

def ConstraintFormator(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over CC for both A and b.

    EXAMPLES:

    ::

        sage: x, y = var('x, y')
        sage: CnstrLst = [x + y == 1, x - y == 2]
        sage: VrbLst = [x, y]
        sage: [A, b] = ConstraintFormator(CnstrLst, VrbLst)
        sage: A
        [ 1.00000000000000  1.00000000000000]
        [ 1.00000000000000 -1.00000000000000]
        sage: b
        [1.00000000000000]
        [2.00000000000000]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(CC,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    b=vector(CC, [eq.rhs() for eq in CnstrLst]).column()
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=(CnstrLst[r]).lhs().coefficient(VrbLst[c])
    return [A,b]

def ConstraintFormatorII(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.

    EXAMPLES:

    ::

        sage: x,y = var('x,y')
        sage: CnstrLst = [x+y==1, x-y==2]
        sage: VrbLst = [x, y]
        sage: [A,b] = ConstraintFormatorII(CnstrLst, VrbLst)
        sage: A
        [ 1  1]
        [ 1 -1]
        sage: b
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    b=vector(SR, [eq.rhs() for eq in CnstrLst]).column()
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=(CnstrLst[r]).lhs().coefficient(VrbLst[c])
    return [A,b]

def ConstraintFormatorHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs an HM 
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.

    EXAMPLES:

    ::

        sage: x,y = var('x,y')
        sage: CnstrLst = [x+y==1, x-y==2]
        sage: VrbLst = [x, y]
        sage: [A,b] = ConstraintFormatorHM(CnstrLst, VrbLst)
        sage: A.printHM()
        [:, :]=
        [ 1  1]
        [ 1 -1]
        sage: b.printHM()
        [:, :]=
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=HM(len(CnstrLst),len(VrbLst),'zero')
    b=HM(len(CnstrLst), 1, [eq.rhs() for eq in CnstrLst])
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=SR((CnstrLst[r]).lhs().coefficient(VrbLst[c]))
    return [A,b]

def multiplicativeConstraintFormator(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.

    EXAMPLES:

    ::

        sage: x, y = var('x, y')
        sage: CnstrLst = [x*y^2==1, x/y==2]
        sage: VrbLst = [x, y]
        sage: [A,b] = multiplicativeConstraintFormator(CnstrLst, VrbLst)
        sage: A
        [ 1  2]
        [ 1 -1]
        sage: b
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    b=vector(SR, [eq.rhs() for eq in CnstrLst]).column()
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=(CnstrLst[r]).lhs().degree(VrbLst[c])
    return [A,b]

def multiplicativeConstraintFormatorII(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.

    EXAMPLES:

    ::

        sage: x, y = var('x, y')
        sage: CnstrLst = [(1/7)*x*y^2, (1/2)*x/y]
        sage: VrbLst = [x, y]
        sage: [A,b] = multiplicativeConstraintFormatorII(CnstrLst, VrbLst)
        sage: A
        [ 1  2]
        [ 1 -1]
        sage: b
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the equations
    Eq=[f/f.subs([v==1 for v in VrbLst])==f.subs([v==1 for v in VrbLst])^(-1) for f in CnstrLst]
    return multiplicativeConstraintFormator(Eq, VrbLst)

def multiplicativeConstraintFormatorIII(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.

    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [x^A[0,0]*y^A[0,1]==7, x^A[1,0]*y^A[1,1]==2]
        sage: VrbLst = [x, y]
        sage: [A,b] = multiplicativeConstraintFormatorIII(CnstrLst, VrbLst)
        sage: A
        [a00 a01]
        [a10 a11]
        sage: b
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    b=vector(SR, [eq.rhs() for eq in CnstrLst]).column()
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            #A[r,c]=(CnstrLst[r]).lhs().degree(VrbLst[c])
            A[r,c]=((CnstrLst[r]).lhs().diff(VrbLst[c])/(CnstrLst[r]).lhs()).subs(VrbLst[c]==1)
    return [A,b]

def multiplicativeConstraintFormatorIV(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [(1/7)*x^A[0,0]*y^A[0,1], (1/2)*x^A[1,0]*y^A[1,1]]
        sage: VrbLst = [x, y]
        sage: [A,b] = multiplicativeConstraintFormatorIV(CnstrLst, VrbLst)
        sage: A
        [a00 a01]
        [a10 a11]
        sage: b
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the equations
    Eq=[f/f.subs([v==1 for v in VrbLst])==f.subs([v==1 for v in VrbLst])^(-1) for f in CnstrLst]
    return multiplicativeConstraintFormatorIII(Eq, VrbLst)

def multiplicativeConstraintFormatorHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs HM
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.


    EXAMPLES:

    ::

        sage: x, y = var('x, y')
        sage: CnstrLst = [x*y^2==1, x/y==2]
        sage: VrbLst = [x, y]
        sage: [Ha,hb] = multiplicativeConstraintFormatorHM(CnstrLst, VrbLst)
        sage: Ha.printHM()
        [:, :]=
        [ 1  2]
        [ 1 -1]
        sage: hb.printHM()
        [:, :]=
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=HM(len(CnstrLst),len(VrbLst),'zero')
    b=HM(len(CnstrLst), 1, [eq.rhs() for eq in CnstrLst])
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=SR((CnstrLst[r]).lhs().degree(VrbLst[c]))
    return [A,b]

def multiplicativeConstraintFormatorIIHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs HM
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.

    EXAMPLES:

    ::

        sage: x, y = var('x, y')
        sage: CnstrLst = [(1/7)*x*y^2, (1/2)*x/y]
        sage: VrbLst = [x, y]
        sage: [Ha,hb] = multiplicativeConstraintFormatorIIHM(CnstrLst, VrbLst)
        sage: Ha.printHM()
        [:, :]=
        [ 1  2]
        [ 1 -1]
        sage: hb.printHM()
        [:, :]=
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    Eq=[f/f.subs([v==1 for v in VrbLst])==f.subs([v==1 for v in VrbLst])^(-1) for f in CnstrLst]
    return multiplicativeConstraintFormatorHM(Eq, VrbLst)

def multiplicativeConstraintFormatorIIIHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs HM
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [x^A[0,0]*y^A[0,1]==7, x^A[1,0]*y^A[1,1]==2]
        sage: VrbLst = [x, y]
        sage: [Ha,hb] = multiplicativeConstraintFormatorIIIHM(CnstrLst, VrbLst)
        sage: Ha.p()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: hb.p()
        [:, :]=
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=HM(len(CnstrLst),len(VrbLst),'zero')
    b=HM(len(CnstrLst), 1, [eq.rhs() for eq in CnstrLst])
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            #A[r,c]=SR((CnstrLst[r]).lhs().degree(VrbLst[c]))
            A[r,c]=((CnstrLst[r]).lhs().diff(VrbLst[c])/(CnstrLst[r]).lhs()).subs(VrbLst[c]==1)
    return [A,b]

def multiplicativeConstraintFormatorIVHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [(1/7)*x^A[0,0]*y^A[0,1], (1/2)*x^A[1,0]*y^A[1,1]]
        sage: VrbLst = [x, y]
        sage: [A,b] = multiplicativeConstraintFormatorIVHM(CnstrLst, VrbLst)
        sage: A.printHM()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: b.printHM()
        [:, :]=
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the equations
    Eq=[f/f.subs([v==1 for v in VrbLst])==f.subs([v==1 for v in VrbLst])^(-1) for f in CnstrLst]
    return multiplicativeConstraintFormatorIIIHM(Eq, VrbLst)

def ConstraintFormatorIII(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over CC for A and SR for b

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); CnstrLst=[x+y==1, x-y==2]; VrbLst=[x,y]
        sage: [A,b] = ConstraintFormatorIII(CnstrLst, VrbLst)
        sage: A
        [ 1.00000000000000  1.00000000000000]
        [ 1.00000000000000 -1.00000000000000]
        sage: b
        [1.00000000000000]
        [2.00000000000000]

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(CC,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    b=vector(CC, [eq.rhs() for eq in CnstrLst]).column()
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=(CnstrLst[r]).lhs().coefficient(VrbLst[c])
    return [A,b]

def ConstraintFormatorIV(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    this implementation allows for the lefthand side
    not to be specified but input variables must not
    be monomials.

    EXAMPLES:

    ::

        sage: x,y = var('x,y')
        sage: CnstrLst = [x+y-1, x-y-2]
        sage: VrbLst = [x, y]
        sage: [A,b] = ConstraintFormatorIV(CnstrLst, VrbLst)
        sage: A
        [ 1  1]
        [ 1 -1]
        sage: b
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            Tmp=Set(VrbLst).difference(Set([VrbLst[c]])).list()
            A[r,c]=CnstrLst[r].subs([f==0 for f in Tmp]).coefficient(VrbLst[c])
    b=-Matrix(len(CnstrLst),1,CnstrLst).subs([f==0 for f in VrbLst])
    return [A,b]

def ConstraintFormatorIVHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    this implementation allows for the lefthand side
    not to be specified but input variables must not
    be monomials.

    EXAMPLES:

    ::

        sage: x,y = var('x,y')
        sage: CnstrLst = [x+y-1, x-y-2]
        sage: VrbLst = [x, y]
        sage: [A,b] = ConstraintFormatorIVHM(CnstrLst, VrbLst)
        sage: A.printHM()
        [:, :]=
        [ 1  1]
        [ 1 -1]
        sage: b.printHM()
        [:, :]=
        [1]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=HM(len(CnstrLst),len(VrbLst),'zero')
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            Tmp=Set(VrbLst).difference(Set([VrbLst[c]])).list()
            A[r,c]=CnstrLst[r].subs([f==0 for f in Tmp]).coefficient(VrbLst[c])
    b=-HM(len(CnstrLst),1,CnstrLst).subs([f==0 for f in VrbLst])
    return [A,b]

def MonomialConstraintFormator(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.


    EXAMPLES:

    ::


        sage: x1, x2 = var('x1, x2')
        sage: X = [x1, x2]
        sage: MnL=[x1*x2, x1, x2]
        sage: L = [-2*x1*x2 + 3*x2 - 2, -38*x1*x2 - 18*x1 + 11*x2 - 8, -506*x1*x2 + 112*x1 + 121*x2 - 8, -5852*x1*x2 + 202*x1 + 1099*x2 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormator(L, X, MnL, Y)
        sage: A
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b
        [2]
        [8]
        [8]
        [8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                if (o/Hy[0,j]).is_constant():
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorII(Eq, Y)

def MonomialConstraintFormatorII(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.
    The difference with the implementation above is that it not assume
    that the coefficients are constants they can be themselves polynomials.


    EXAMPLES:

    ::


        sage: x1, x2 = var('x1, x2')
        sage: X = [x1, x2]
        sage: MnL=[x1*x2, x1, x2]
        sage: L = [-2*x1*x2 + 3*x2 - 2, -38*x1*x2 - 18*x1 + 11*x2 - 8, -506*x1*x2 + 112*x1 + 121*x2 - 8, -5852*x1*x2 + 202*x1 + 1099*x2 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormatorII(L, X, MnL, Y)
        sage: A
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b
        [2]
        [8]
        [8]
        [8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                #if (o/Hy[0,j]).is_constant():
                if Set([(o/Hy[0,j]).degree(v) for v in X]).list()==[0]:
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorII(Eq, Y)

def MonomialConstraintFormatorIII(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::


        sage: x1, x2, y1, y2, y3, y4 = var('x1, x2, y1, y2, y3, y4')
        sage: X = [x1, x2]
        sage: MnL=[x1^y1*x2^y2, x1^y3, x2^y4]
        sage: L = [-2*x1^y1*x2^y2 + 3*x2^y4 - 2, -38*x1^y1*x2^y2 - 18*x1^y3 + 11*x2^y4 - 8, -506*x1^y1*x2^y2 + 112*x1^y3 + 121*x2^y4 - 8, -5852*x1^y1*x2^y2 + 202*x1^y3 + 1099*x2^y4 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormatorIII(L, X, MnL, Y)
        sage: A
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b
        [                 2*0^y1*0^y2 - 3*0^y4 + 2]
        [     38*0^y1*0^y2 + 18*0^y3 - 11*0^y4 + 8]
        [  506*0^y1*0^y2 - 112*0^y3 - 121*0^y4 + 8]
        [5852*0^y1*0^y2 - 202*0^y3 - 1099*0^y4 + 8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                #if (o/Hy[0,j]).is_constant():
                #if Set([(o/Hy[0,j]).degree(v) for v in X]).list()==[0]:
                if Set([(o/Hy[0,j]).diff(v)/((o/Hy[0,j]).subs(v==1)) for v in X]).list()==[0]:
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorII(Eq, Y)

def MonomialConstraintFormatorHM(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.


    EXAMPLES:

    ::


        sage: x1, x2 = var('x1, x2')
        sage: X = [x1, x2]
        sage: MnL=[x1*x2, x1, x2]
        sage: L = [-2*x1*x2 + 3*x2 - 2, -38*x1*x2 - 18*x1 + 11*x2 - 8, -506*x1*x2 + 112*x1 + 121*x2 - 8, -5852*x1*x2 + 202*x1 + 1099*x2 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormatorHM(L, X, MnL, Y)
        sage: A.printHM()
        [:, :]=
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b.printHM()
        [:, :]=
        [2]
        [8]
        [8]
        [8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                if (o/Hy[0,j]).is_constant():
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorHM(Eq, Y)

def MonomialConstraintFormatorHMII(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.
    The difference with the implementation above is that this
    function deals well with symbolic coefficient matrices

    EXAMPLES:

    ::


        sage: x1, x2 = var('x1, x2')
        sage: X = [x1, x2]
        sage: MnL=[x1*x2, x1, x2]
        sage: L = [-2*x1*x2 + 3*x2 - 2, -38*x1*x2 - 18*x1 + 11*x2 - 8, -506*x1*x2 + 112*x1 + 121*x2 - 8, -5852*x1*x2 + 202*x1 + 1099*x2 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormatorHMII(L, X, MnL, Y)
        sage: A.printHM()
        [:, :]=
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b.printHM()
        [:, :]=
        [2]
        [8]
        [8]
        [8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                #if (o/Hy[0,j]).is_constant():
                if Set([(o/Hy[0,j]).degree(v) for v in X]).list()==[0]:
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorHM(Eq, Y)

def MonomialConstraintFormatorHMIII(L, X, MnL, Y):
    """
    Takes as input a List of polynomials, a list of
    variables used in the polynomials,the monomial list 
    a list of alternative variables to replace the monomials.
    No right hand side is given. We are implicitly working over SR.
    The difference with the implementation above is that this
    function deals well with symbolic coefficient matrices

    EXAMPLES:

    ::


        sage: x1, x2, y1, y2, y3, y4 = var('x1, x2, y1, y2, y3, y4')
        sage: X = [x1, x2]
        sage: MnL=[x1^y1*x2^y2, x1^y3, x2^y4]
        sage: L = [-2*x1^y1*x2^y2 + 3*x2^y4 - 2, -38*x1^y1*x2^y2 - 18*x1^y3 + 11*x2^y4 - 8, -506*x1^y1*x2^y2 + 112*x1^y3 + 121*x2^y4 - 8, -5852*x1^y1*x2^y2 + 202*x1^y3 + 1099*x2^y4 - 8]
        sage: Y = HM(3,'y').list()
        sage: [A,b] = MonomialConstraintFormatorHMIII(L, X, MnL, Y)
        sage: A.printHM()
        [:, :]=
        [   -2     0     3]
        [  -38   -18    11]
        [ -506   112   121]
        [-5852   202  1099]
        sage: b.printHM()
        [:, :]=
        [                 2*0^y1*0^y2 - 3*0^y4 + 2]
        [     38*0^y1*0^y2 + 18*0^y3 - 11*0^y4 + 8]
        [  506*0^y1*0^y2 - 112*0^y3 - 121*0^y4 + 8]
        [5852*0^y1*0^y2 - 202*0^y3 - 1099*0^y4 + 8]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Obtaining the right hand side vector b
    tb=Matrix(SR,len(L),1,[-f.subs([v==0 for v in X]) for f in L])
    L2=copy(L)
    # Updating the list to remove the constant terms
    for i in range(len(L)):
        L2[i]=L2[i]+tb[i,0]
    # Performing the monomial substitution
    Eq=[]; Hy=HM([MnL,Y])
    cnt=0
    for g in L2:
        TmpL=[]
        for o in g.operands():
            for j in range(Hy.n(1)):
                #if (o/Hy[0,j]).is_constant():
                #if Set([(o/Hy[0,j]).degree(v) for v in X]).list()==[0]:
                if Set([(o/Hy[0,j]).diff(v)/((o/Hy[0,j]).subs(v==1)) for v in X]).list()==[0]:
                    TmpL.append((o/Hy[0,j])*Hy[1,j]);break
        Eq.append(sum(TmpL)==tb[cnt,0]); cnt=cnt+1 
    # Ready to use the generic Constraint formator
    return ConstraintFormatorHM(Eq, Y)

def exponentialConstraintFormatorHM(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs HM
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [(A[0,0]^x)*(A[0,1]^y) == 7, (A[1,0]^x)*(A[1,1])^y == 2]
        sage: VrbLst = [x, y]
        sage: [Ha,hb] = exponentialConstraintFormatorHM(CnstrLst, VrbLst)
        sage: Ha.printHM()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: hb.printHM()
        [:, :]=
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the Matrix
    A=HM(len(CnstrLst),len(VrbLst),'zero')
    b=HM(len(CnstrLst), 1, [eq.rhs() for eq in CnstrLst])
    for r in range(len(CnstrLst)):
        for c in range(len(VrbLst)):
            A[r,c]=((CnstrLst[r]).lhs().diff(VrbLst[c])/(CnstrLst[r]).lhs()).subs(VrbLst[c]==1)
    return [A.elementwise_base_exponent(e),b]

def exponentialConstraintFormatorHMII(CnstrLst, VrbLst):
    """
    Takes as input a List of linear constraints
    and a list of variables and outputs matrix
    and the right hand side vector associate
    with the matrix formulation of the constraints.
    working over SR for both A and b.
    The difference with the implementation above is
    that it handles symbolic exponents.


    EXAMPLES:

    ::

        sage: x, y = var('x, y'); A=HM(2,2,'a')
        sage: CnstrLst = [(1/7)*(A[0,0]^x)*(A[0,1]^y), (1/2)*(A[1,0]^x)*(A[1,1])^y]
        sage: VrbLst = [x, y]
        sage: [A,b] = exponentialConstraintFormatorHMII(CnstrLst, VrbLst)
        sage: A.printHM()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: b.printHM()
        [:, :]=
        [7]
        [2]


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the equations
    Eq=[f/f.subs([v==0 for v in VrbLst])==f.subs([v==0 for v in VrbLst])^(-1) for f in CnstrLst]
    return exponentialConstraintFormatorHM(Eq, VrbLst)

def Companion_matrix(p,vrbl):
    """
    Takes as input a polynomial and a variable
    and outputs the companion matrix associated
    with the polynomial in the specified variables.

    EXAMPLES:

    ::

        sage: x=var('x'); p=sum(HM(5,'a').list()[k]*x^(k) for k in range(5))
        sage: A=Companion_matrix(p,x); A.characteristic_polynomial()
        x^4 + a3/a4*x^3 + a2/a4*x^2 + a1/a4*x + a0/a4

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl):
        dg=Integer(p.degree(vrbl))
        if dg>1:
            # Initialization of the matrix
            A=HM(dg,dg,'zero').matrix()
            # Filling up the matrix
            A[0,dg-1]=-p.subs(dict([(vrbl,0)]))/(p.diff(vrbl, dg)/factorial(dg))
            for i in range(1,dg):
                #A[i,dg-1]=-p.coefficient(vrbl^(i))/p.coefficient(vrbl^dg)
                A[i,dg-1]=-(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))/(p.diff(vrbl,dg).subs(vrbl==0)/factorial(dg))
                A[i,i-1]=1
            return A
        elif dg==1:
            #return Matrix(SR,1,1,[p.subs(dict([(vrbl,0)]))/p.coefficient(vrbl)])
            return Matrix(SR,1,1,[p.subs(dict([(vrbl,0)]))/(diff(p,vrbl).subs(vrbl==0))])
        else:
            raise ValueError("Must be of degree at least 1.")
    else:
        raise ValueError("Must be a polynomial in the input variable.")

def CompanionHM(p,vrbl):
    """
    Takes as input a polynomial and a variable
    and outputs the companion second order hypermatrix
    associated with the polynomial in the specified variables.

    EXAMPLES:

    ::

        sage: sz=5; x=var('x'); Id=HM(2,sz-1,'kronecker')
        sage: A=CompanionHM(sum(HM(sz,'a').list()[k]*x^(k) for k in range(sz)),x); expand((x*Id-A).det())
        x^4 + a3*x^3/a4 + a2*x^2/a4 + a1*x/a4 + a0/a4

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl):
        dg=Integer(p.degree(vrbl))
        if dg>1:
            # Initialization of the matrix
            A=HM(dg,dg,'zero')
            # Filling up the matrix
            #A[0,dg-1]=-p.subs(dict([(vrbl,0)]))/p.coefficient(vrbl^dg)
            A[0,dg-1]=-p.subs(dict([(vrbl,0)]))/(p.diff(vrbl, dg)/factorial(dg))
            for i in range(1,dg):
                #A[i,dg-1]=-p.coefficient(vrbl^(i))/p.coefficient(vrbl^dg)
                A[i,dg-1]=-(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))/(p.diff(vrbl,dg).subs(vrbl==0)/factorial(dg))
                A[i,i-1]=1
            return A
        elif dg==1:
            #return HM(1,1,[p.subs(dict([(vrbl,0)]))/p.coefficient(vrbl)])
            return HM(1,1,[p.subs(dict([(vrbl,0)]))/(diff(p,vrbl).subs(vrbl==0))])
        else:
            raise ValueError("Must be of degree at least 1.")
    else:
        raise ValueError("Must be a polynomial in the input variable.")

def Sylvester_matrix(p,q,vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the Sylvester matrix associated
    with the polynomials in the specified variables.

    EXAMPLES:

    ::

        sage: x, a0, a1, b0, b1=var('x, a0, a1, b0, b1')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: Sylvester_matrix(p, q, x).det().factor()
        (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl) and q.is_polynomial(vrbl):
        dp=Integer(p.degree(vrbl)); dq=Integer(q.degree(vrbl))
        # Initialization of the matrix
        A=HM(dp+dq,dp+dq,'zero').matrix()
        # Filling up the matrix
        cp=0
        for i in range(dq):
            for j in range(dp):
                #A[i,cp+j]=p.coefficient(vrbl^(dp-j))
                A[i,cp+j]=p.diff(vrbl,Integer(dp-j)).subs(vrbl==0)/factorial(dp-j)
            A[i,cp+dp]=p.subs(dict([(vrbl,0)]))
            cp=cp+1
        cq=0
        for i in range(dp):
            for j in range(dq):
                #A[dq+i,cq+j]=q.coefficient(vrbl^(dq-j))
                A[dq+i,cq+j]=q.diff(vrbl,Integer(dq-j)).subs(vrbl==0)/factorial(dq-j)
            A[dq+i,cq+dq]=q.subs(dict([(vrbl,0)]))
            cq=cq+1
        return A
    else:
        raise ValueError("The inputs must both be polynomials in the input variable.")

def SylvesterHM(p,q,vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the Sylvester second order 
    hypermatrix associated with the polynomials
    in the specified variables.

    EXAMPLES:

    ::

        sage: x, a0, a1, b0, b1=var('x, a0, a1, b0, b1')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: SylvesterHM(p, q, x).ref()[3,3].factor()
        (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl) and q.is_polynomial(vrbl):
        dp=Integer(p.degree(vrbl)); dq=Integer(q.degree(vrbl))
        # Initialization of the second order hypermatrix
        A=HM(dp+dq,dp+dq,'zero')
        # Filling up the matrix
        cp=0
        for i in range(dq):
            for j in range(dp):
                #A[i,cp+j]=p.coefficient(vrbl^(dp-j))
                A[i,cp+j]=p.diff(vrbl,Integer(dp-j)).subs(vrbl==0)/factorial(dp-j)
            A[i,cp+dp]=p.subs(dict([(vrbl,0)]))
            cp=cp+1
        cq=0
        for i in range(dp):
            for j in range(dq):
                #A[dq+i,cq+j]=q.coefficient(vrbl^(dq-j))
                A[dq+i,cq+j]=q.diff(vrbl,Integer(dq-j)).subs(vrbl==0)/factorial(dq-j)
            A[dq+i,cq+dq]=q.subs(dict([(vrbl,0)]))
            cq=cq+1
        return A
    else:
        raise ValueError("The inputs must both be polynomials in the input variable.")

def Resultant(p, q, vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the corresponding resultant.

    EXAMPLES:

    ::

        sage: x, a0, a1, b0, b1=var('x, a0, a1, b0, b1')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: Resultant(p, q, x).factor()
        (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)

    AUTHORS:
    - Edinah K. Gnang
    """
    return SylvesterHM(p, q, vrbl).det()

def Gmatrix(p,q,vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the G matrix associated with the 
    polynomial in the specified variables.

    EXAMPLES:

    ::

        sage: x, a0, a1, b0, b1=var('x, a0, a1, b0, b1')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: Gmatrix(p,q,x).det().factor()
        (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl) and q.is_polynomial(vrbl):
        dp=Integer(p.degree(vrbl)); dq=Integer(q.degree(vrbl))
        if dp >= 1 and dq >= 1:
            return identity_matrix(dq).tensor_product(Companion_matrix(p,vrbl))-(Companion_matrix(q,vrbl)).tensor_product(identity_matrix(dp))
        else:
            raise ValueError("Both inputs must be of degree at least 2.")
    else:
        raise ValueError("Both inputs must be polynomials in the input variable.")

def GmatrixHM(p,q,vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the G matrix associated with the 
    polynomial in the specified variables.

    EXAMPLES:

    ::

        sage: x, a0, a1, b0, b1=var('x, a0, a1, b0, b1')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: GmatrixHM(p,q,x).ref()[3,3].factor()
        -(a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)

    AUTHORS:
    - Edinah K. Gnang
    """
    if p.is_polynomial(vrbl) and q.is_polynomial(vrbl):
        dp=Integer(p.degree(vrbl)); dq=Integer(q.degree(vrbl))
        if dp >= 1 and dq >= 1:
            return HM(2,dq,'kronecker').tensor_product(CompanionHM(p,vrbl))-(CompanionHM(q,vrbl)).tensor_product(HM(2,dp,'kronecker'))
        else:
            raise ValueError("Both inputs must be of degree at least 2.")
    else:
        raise ValueError("Both inputs must be polynomials in the input variable.")

def Convolution(Hp,Hq):
    """
    Takes as input two vectors stored as column vecots of type hypermatrices and computes
    their convolution via polynomial product in the variable x

    EXAMPLES:

    ::

        sage: sz=Integer(3); Lp=var_list('a',sz); Lq=var_list('b',sz)
        sage: Convolution(HM(sz,1,Lp), HM(sz,1,Lq)).p()
        [:, :]=
        [                a0*b0]
        [        a1*b0 + a0*b1]
        [a2*b0 + a1*b1 + a0*b2]
        [        a2*b1 + a1*b2]
        [                a2*b2]
        sage: sz0=Integer(4); sz1=Integer(2); Lp=var_list('a',sz0); Lq=var_list('b',sz1) 
        sage: Convolution(HM(sz0,1,Lp), HM(sz1,1,Lq)).p()
        [:, :]=
        [        a0*b0]
        [a1*b0 + a0*b1]
        [a2*b0 + a1*b1]
        [a3*b0 + a2*b1]
        [        a3*b1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list
    Lp=Hp.list(); Lq=Hq.list()
    # Initializing the sizes
    sz0=len(Lp); sz1=len(Lq)
    # Initialization of the polynomials
    P=sum(Lp[i]*x^i for i in rg(sz0)); Q=sum(Lq[i]*x^i for i in rg(sz1))
    # Initialization of the product of the two polynomials
    H=expand(P*Q)
    return HM(len(Lq)+len(Lp)-1,1,[diff(H,x,k).subs(x=0)/factorial(k) for k in rg(len(Lq)+len(Lp)-1)])

def ConvolutionL(L):
    """
    Takes as input a list of two vectors stored as column vecots of type hypermatrices and computes
    their convolution via polynomial product in the variable x

    EXAMPLES:

    ::

        sage: sz=Integer(3); Lp=var_list('a',sz); Lq=var_list('b',sz)
        sage: ConvolutionL([HM(sz,1,Lp),HM(sz,1,Lq)]).p()
        [:, :]=
        [                a0*b0]
        [        a1*b0 + a0*b1]
        [a2*b0 + a1*b1 + a0*b2]
        [        a2*b1 + a1*b2]
        [                a2*b2]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Obtaining the hypermatrices
    Hp=L[0]; Hq=L[1]
    # Initializing the sizes
    sz0=Hp.n(0); sz1=Hq.n(0)
    # Initialization of the list
    Lp=Hp.list(); Lq=Hq.list()
    # Initialization of the polynomials
    P=sum(Lp[i]*x^i for i in rg(sz0)); Q=sum(Lq[i]*x^i for i in rg(sz1))
    # Initialization of the product of the two polynomials
    H=expand(P*Q)
    return HM(len(Lq)+len(Lp)-1,1,[diff(H,x,k).subs(x=0)/factorial(k) for k in rg(len(Lq)+len(Lp)-1)])

def substitute_matrix(p, vrbl, A):
    """
    The functions takes as input a polynomial p,
    a variable vrbl, and a matrix A. The function
    outputs the polynomial in the variable.

    EXAMPLES:

    ::

        sage: x,y = var('x,y')
        sage: p=x^2+2*x*y+1
        sage: substitute_matrix(p,x,HM(2,2,'a').matrix())
        [a00^2 + a01*a10 + 2*a00*y + 1   a00*a01 + a01*a11 + 2*a01*y]
        [  a00*a10 + a10*a11 + 2*a10*y a01*a10 + a11^2 + 2*a11*y + 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.nrows() == A.ncols():
        T=p.subs(vrbl == 0)*identity_matrix(A.nrows())
        d=Integer(p.degree(vrbl))
        for i in rg(1,d+1):
            #T=T+(A^i)*p.coefficient(vrbl^i)
            #T=T+(A^Integer(i))*(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))
            T=T+(A^i)*(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))
        return T
    else:
        raise ValueError("Must be a polynomial in the input variable.")

def substituteHM(p, vrbl, A):
    """
    The functions takes as input a polynomial p,
    a variable vrbl, and a hypermatrix A of order 2.
    The function outputs the polynomial in the variable.


    EXAMPLES:

    ::

        sage: x = var('x'); A=HM(2,2,'a')
        sage: p=x^2 - A.trace()*x + A.det()
        sage: substituteHM(p,x,A).expand()
        [[0, 0], [0, 0]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.nrows()==A.ncols():
        d=Integer(p.degree(vrbl))
        T = p.subs(vrbl==0)*HM(2,A.nrows(),'kronecker')
        for i in rg(1,d+1):
            #T=T+(A^Integer(i))*(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))
            T=T+(A^i)*(p.diff(vrbl,i).subs(vrbl==0)/factorial(i))
        return T
    else:
        raise ValueError("Must be a polynomial in the input variable.")

def OuterHypermatrixInversePair(U,V):
    """
    Outputs the pseudo inverse pairs associated with the input pairs of hypermatrices
    The implementation does not assume that the input third order hypermatrices are
    cubic. In fact U must be m x p x p and V is p x n x p.


    EXAMPLES:

    ::

        sage: Hu=HM(3,2,2,'u'); Hv=HM(2,4,2,'v')
        sage: [Sln, Tx, Ty]=OuterHypermatrixInversePair(Hu, Hv)[0]
        sage: Hx=Tx.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1])) 
        sage: Hy=Ty.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Prod(Hx, Prod(Hu, HM(3,4,2,'a'), Hv), Hy).simplify_full().list()
        [a000,
         a100,
         a200,
         ((a010*u001*u010*u201*u210*v001*v011*v100 - a010*u001*u010*u200*u211*v000*v011*v101)*v110 - (a010*u000*u011*u201*u210*v001*v010*v100 - a010*u000*u011*u200*u211*v000*v010*v101)*v111)/((u001*u010*u201*u210*v001*v011*v100 - u000*u011*u201*u210*v000*v011*v101)*v110 - (u001*u010*u200*u211*v001*v010*v100 - u000*u011*u200*u211*v000*v010*v101)*v111),
         ((a110*u101*u110*u201*u210*v001*v011*v100 - a110*u101*u110*u200*u211*v000*v011*v101)*v110 - (a110*u100*u111*u201*u210*v001*v010*v100 - a110*u100*u111*u200*u211*v000*v010*v101)*v111)/((u101*u110*u201*u210*v001*v011*v100 - u100*u111*u201*u210*v000*v011*v101)*v110 - (u101*u110*u200*u211*v001*v010*v100 - u100*u111*u200*u211*v000*v010*v101)*v111),
         a210,
         ((a020*u001*u010*u201*u210*v001*v021*v100 - a020*u001*u010*u200*u211*v000*v021*v101)*v120 - (a020*u000*u011*u201*u210*v001*v020*v100 - a020*u000*u011*u200*u211*v000*v020*v101)*v121)/((u001*u010*u201*u210*v001*v021*v100 - u000*u011*u201*u210*v000*v021*v101)*v120 - (u001*u010*u200*u211*v001*v020*v100 - u000*u011*u200*u211*v000*v020*v101)*v121),
         ((a120*u101*u110*u201*u210*v001*v021*v100 - a120*u101*u110*u200*u211*v000*v021*v101)*v120 - (a120*u100*u111*u201*u210*v001*v020*v100 - a120*u100*u111*u200*u211*v000*v020*v101)*v121)/((u101*u110*u201*u210*v001*v021*v100 - u100*u111*u201*u210*v000*v021*v101)*v120 - (u101*u110*u200*u211*v001*v020*v100 - u100*u111*u200*u211*v000*v020*v101)*v121),
         a220,
         ((a030*u001*u010*u201*u210*v001*v031*v100 - a030*u001*u010*u200*u211*v000*v031*v101)*v130 - (a030*u000*u011*u201*u210*v001*v030*v100 - a030*u000*u011*u200*u211*v000*v030*v101)*v131)/((u001*u010*u201*u210*v001*v031*v100 - u000*u011*u201*u210*v000*v031*v101)*v130 - (u001*u010*u200*u211*v001*v030*v100 - u000*u011*u200*u211*v000*v030*v101)*v131),
         ((a130*u101*u110*u201*u210*v001*v031*v100 - a130*u101*u110*u200*u211*v000*v031*v101)*v130 - (a130*u100*u111*u201*u210*v001*v030*v100 - a130*u100*u111*u200*u211*v000*v030*v101)*v131)/((u101*u110*u201*u210*v001*v031*v100 - u100*u111*u201*u210*v000*v031*v101)*v130 - (u101*u110*u200*u211*v001*v030*v100 - u100*u111*u200*u211*v000*v030*v101)*v131),
         a230,
         a001,
         a101,
         a201,
         a011,
         ((a111*u001*u010*u101*u110*v001*v011*v100 - a111*u000*u011*u101*u110*v000*v011*v101)*v110 - (a111*u001*u010*u100*u111*v001*v010*v100 - a111*u000*u011*u100*u111*v000*v010*v101)*v111)/((u001*u010*u101*u110*v001*v011*v100 - u001*u010*u100*u111*v000*v011*v101)*v110 - (u000*u011*u101*u110*v001*v010*v100 - u000*u011*u100*u111*v000*v010*v101)*v111),
         ((a211*u001*u010*u201*u210*v001*v011*v100 - a211*u000*u011*u201*u210*v000*v011*v101)*v110 - (a211*u001*u010*u200*u211*v001*v010*v100 - a211*u000*u011*u200*u211*v000*v010*v101)*v111)/((u001*u010*u201*u210*v001*v011*v100 - u001*u010*u200*u211*v000*v011*v101)*v110 - (u000*u011*u201*u210*v001*v010*v100 - u000*u011*u200*u211*v000*v010*v101)*v111),
         a021,
         ((a121*u001*u010*u101*u110*v001*v021*v100 - a121*u000*u011*u101*u110*v000*v021*v101)*v120 - (a121*u001*u010*u100*u111*v001*v020*v100 - a121*u000*u011*u100*u111*v000*v020*v101)*v121)/((u001*u010*u101*u110*v001*v021*v100 - u001*u010*u100*u111*v000*v021*v101)*v120 - (u000*u011*u101*u110*v001*v020*v100 - u000*u011*u100*u111*v000*v020*v101)*v121),
         ((a221*u001*u010*u201*u210*v001*v021*v100 - a221*u000*u011*u201*u210*v000*v021*v101)*v120 - (a221*u001*u010*u200*u211*v001*v020*v100 - a221*u000*u011*u200*u211*v000*v020*v101)*v121)/((u001*u010*u201*u210*v001*v021*v100 - u001*u010*u200*u211*v000*v021*v101)*v120 - (u000*u011*u201*u210*v001*v020*v100 - u000*u011*u200*u211*v000*v020*v101)*v121),
         a031,
         ((a131*u001*u010*u101*u110*v001*v031*v100 - a131*u000*u011*u101*u110*v000*v031*v101)*v130 - (a131*u001*u010*u100*u111*v001*v030*v100 - a131*u000*u011*u100*u111*v000*v030*v101)*v131)/((u001*u010*u101*u110*v001*v031*v100 - u001*u010*u100*u111*v000*v031*v101)*v130 - (u000*u011*u101*u110*v001*v030*v100 - u000*u011*u100*u111*v000*v030*v101)*v131),
         ((a231*u001*u010*u201*u210*v001*v031*v100 - a231*u000*u011*u201*u210*v000*v031*v101)*v130 - (a231*u001*u010*u200*u211*v001*v030*v100 - a231*u000*u011*u200*u211*v000*v030*v101)*v131)/((u001*u010*u201*u210*v001*v031*v100 - u001*u010*u200*u211*v000*v031*v101)*v130 - (u000*u011*u201*u210*v001*v030*v100 - u000*u011*u200*u211*v000*v030*v101)*v131)]
        sage: sz=2; Mu=HM(sz,sz,'u'); Mv=HM(sz,sz,'v') # Initialization of the sizes and matrices which undelie the Vandermonde hypermatrix pairs
        sage: U=HM(sz,sz,sz, [(Mu[j,k])^(i+1) for k in rg(sz) for j in rg(sz) for i in rg(sz)]).subs(Mu[0,0] == Mu[0,1]*Mu[1,0]/Mu[1,1])
        sage: V=HM(sz,sz,sz, [(Mv[i,k])^(j+1) for k in rg(sz) for j in rg(sz) for i in rg(sz)]); A=HM(sz,sz,sz,'a')
        sage: [Sln,Tx,Ty]=OuterHypermatrixInversePair(U,V)[0] # Computing the inverse pairs
        sage: Hx=Tx.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1])) # Performing the subsitution
        sage: Hy=Ty.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1])) # performing the substiution
        sage: A==Prod(Hx,Prod(U,A,V),Hy).simplify_full()
        True

 
    AUTHORS:
    - Edinah K. Gnang
    """
    if U.n(1)==U.n(2) and V.n(0)==V.n(2) and U.n(1)==V.n(0) and U.order()==3 and V.order()==3:
        # Initialization of the size parameter
        sz0=U.n(0); sz1=V.n(1); sz2=U.n(2)
        # Initialization of the container matrix
        M = Matrix(SR,HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero').listHM())
        for i in range(sz0):
            for j in range(sz1):
                for k in range(sz2):
                    for t in range(sz2):
                        M[i*sz1*sz2+j*sz2+k, i*sz1*sz2+j*sz2+t]=U[i,t,k]*V[t,j,k]
        # Initialization of the coefficient HM
        Ha=HM(sz0*sz1, sz0*sz1, [HM(sz2,sz2,'zero') for ij in range((sz0*sz1)^2)])
        for ij in range(sz0*sz1):
            Ha[ij, ij]=HM(sz2, sz2, M[ij*sz2:ij*sz2+sz2, ij*sz2:ij*sz2+sz2].transpose().list())
        # Initialization of the RHS
        Hb=HM(sz0*sz1, 1, [HM(2,sz2,'kronecker') for ij in range(sz0*sz1)])
        # Computing the matrix pseudo inverse
        [A,b]=gauss_jordan_eliminationHM(Ha, Hb)
        # Filling up the solution with the result
        B=HM(M.nrows(), M.ncols(), 'zero').matrix()
        for ij in range(sz0*sz1):
            B[sz2*ij:sz2*ij+sz2, sz2*ij:sz2*ij+sz2]=b[ij,0].simplify_full().matrix()
        # Initializing the multiplicative constraints.
        X=HM(U.n(0), U.n(1), U.n(2), 'x'); Y=HM(V.n(0), V.n(1), V.n(2), 'y')
        Eq=[X[i,s,t]*Y[s,j,t]==B[i*sz1*sz2+j*sz2+t,i*sz1*sz2+j*sz2+s] for i in range(sz0) for j in range(sz1) for s in range(sz2) for t in range(sz2)]
        # Formating the constraints
        [A,b]=multiplicativeConstraintFormator(Eq, X.list()+Y.list())
        Mx=Matrix(SR, A.ncols(), 1, X.list()+Y.list())
        return [[multiplicative_linear_solver(A,b,Mx,Mx), X, Y], multiplicative_gauss_jordan_eliminationII(A,b)]
    else:
        raise ValueError("The input hypermatrices must be cubical third order hypermatrices of the same sizes.")

def OuterHypermatrixInversePairHM(U, V):
    """
    Outputs the pseudo inverse pairs associated with the input pairs of hypermatrices
    The implementation does not assume that the input third order hypermatrices are
    cubic. In fact U must be m x p x p and V is p x n x p.


    EXAMPLES:

    ::

        sage: Hu=HM(2,2,2,'u'); Hv=HM(2,2,2,'v')
        sage: [Sln, Tx, Ty]=OuterHypermatrixInversePairHM(Hu, Hv)[0]
        sage: Hx=Tx.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1])) 
        sage: Hy=Ty.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Prod(Hx, Prod(Hu, HM(2,2,2,'a'), Hv), Hy).simplify_full().list()
        [a000,
         a100,
         ((a010*u001*u010*u101*u110*v001*v011*v100 - a010*u001*u010*u100*u111*v000*v011*v101)*v110 - (a010*u000*u011*u101*u110*v001*v010*v100 - a010*u000*u011*u100*u111*v000*v010*v101)*v111)/((u001*u010*u101*u110*v001*v011*v100 - u000*u011*u101*u110*v000*v011*v101)*v110 - (u001*u010*u100*u111*v001*v010*v100 - u000*u011*u100*u111*v000*v010*v101)*v111),
         a110,
         a001,
         a101,
         a011,
         ((a111*u001*u010*u101*u110*v001*v011*v100 - a111*u000*u011*u101*u110*v000*v011*v101)*v110 - (a111*u001*u010*u100*u111*v001*v010*v100 - a111*u000*u011*u100*u111*v000*v010*v101)*v111)/((u001*u010*u101*u110*v001*v011*v100 - u001*u010*u100*u111*v000*v011*v101)*v110 - (u000*u011*u101*u110*v001*v010*v100 - u000*u011*u100*u111*v000*v010*v101)*v111)]

 
    AUTHORS:
    - Edinah K. Gnang
    """
    if U.n(1)==U.n(2) and V.n(0)==V.n(2) and U.n(1)==V.n(0) and U.order()==3 and V.order()==3:
        # Initialization of the size parameter
        sz0=U.n(0); sz1=V.n(1); sz2=U.n(2)
        # Initialization of the container matrix
        #M = Matrix(SR,HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero').listHM())
        M = HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero')
        for i in range(sz0):
            for j in range(sz1):
                for k in range(sz2):
                    for t in range(sz2):
                        M[i*sz1*sz2+j*sz2+k, i*sz1*sz2+j*sz2+t]=U[i,t,k]*V[t,j,k]
        # Initialization of the coefficient HM
        Ha=HM(sz0*sz1, sz0*sz1, [HM(sz2,sz2,'zero') for ij in range((sz0*sz1)^2)])
        for ij in range(sz0*sz1):
            #Ha[ij, ij]=HM(sz2, sz2, M[ij*sz2:ij*sz2+sz2, ij*sz2:ij*sz2+sz2].transpose().list())
            Ha[ij, ij]=M.slice(rg(ij*sz2,ij*sz2+sz2),0).slice(rg(ij*sz2,ij*sz2+sz2),1)
        # Initialization of the RHS
        Hb=HM(sz0*sz1, 1, [HM(2,sz2,'kronecker') for ij in range(sz0*sz1)])
        # Computing the matrix pseudo inverse
        [A,b]=gauss_jordan_eliminationHM(Ha, Hb)
        # Filling up the solution with the result
        #B=HM(M.nrows(), M.ncols(), 'zero').matrix()
        #for ij in range(sz0*sz1):
        #    B[sz2*ij:sz2*ij+sz2, sz2*ij:sz2*ij+sz2]=b[ij,0].simplify_full().matrix()
        B=HM(M.nrows(), M.ncols(), 'zero')
        for ij in range(sz0*sz1):
            for ii in rg(sz2*ij,sz2*ij+sz2):
                for jj in rg(sz2*ij,sz2*ij+sz2):
                    B[ii,jj]=(b[ij,0])[ii-sz2*ij,jj-sz2*ij].canonicalize_radical()
        # Initializing the multiplicative constraints.
        X=HM(U.n(0), U.n(1), U.n(2), 'x'); Y=HM(V.n(0), V.n(1), V.n(2), 'y')
        #Eq=[X[i,s,t]*Y[s,j,t]==B[i*sz1*sz2+j*sz2+t,i*sz1*sz2+j*sz2+s] for i in range(sz0) for j in range(sz1) for s in range(sz2) for t in range(sz2)]
        Eq=[X[i,s,t]*Y[s,j,t]==B[i*sz1*sz2+j*sz2+t,i*sz1*sz2+j*sz2+s] for i in rg(sz0) for j in rg(sz1) for s in rg(sz2) for t in rg(sz2)]
        # Formating the constraints
        #[A,b]=multiplicativeConstraintFormator(Eq, X.list()+Y.list())
        [A,b]=multiplicativeConstraintFormatorHM(Eq, X.list()+Y.list())
        #Mx=Matrix(SR, A.ncols(), 1, X.list()+Y.list())
        Mx=HM(A.ncols(), 1, X.list()+Y.list())
        #return [[multiplicative_linear_solver(A,b,Mx,Mx), X, Y], multiplicative_gauss_jordan_eliminationII(A,b)]
        return [[multiplicative_linear_solverHM(A,b,Mx,Mx), X, Y], multiplicative_gauss_jordan_eliminationHMII(A,b)]
    else:
        raise ValueError("The input hypermatrices must be cubical third order hypermatrices of the same sizes.")

def InnerHypermatrixInversePair(X, Y):
    """
    Outputs the pseudo inverse pairs associated with the input pairs of hypermatrices
    The implementation does not assume that the input third order hypermatrices are 
    cubic. In fact X is m x p x p and Y is p x n x p.


    EXAMPLES:

    ::

        sage: Hx=HM(2,2,2,'x'); Hy=HM(2,2,2,'y')
        sage: [Sln, Tu, Tv]=InnerHypermatrixInversePair(Hx, Hy)[0]
        sage: Hu=Tu.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs() !=1])) 
        sage: Hv=Tv.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs() !=1]))
        sage: Prod(Hx, Prod(Hu, HM(2,2,2,'a'), Hv), Hy).simplify_full().list()
        [a000,
         a100,
         ((a010*x001*x010*x101*x110*y001*y011*y100 - a010*x001*x010*x100*x111*y000*y011*y101)*y110 - (a010*x000*x011*x101*x110*y001*y010*y100 - a010*x000*x011*x100*x111*y000*y010*y101)*y111)/((x001*x010*x101*x110*y001*y011*y100 - x000*x011*x101*x110*y000*y011*y101)*y110 - (x001*x010*x100*x111*y001*y010*y100 - x000*x011*x100*x111*y000*y010*y101)*y111),
         a110,
         a001,
         a101,
         ((a011*x001*x010*x101*x110*y001*y011*y100 - a011*x001*x010*x100*x111*y000*y011*y101)*y110 - (a011*x000*x011*x101*x110*y001*y010*y100 - a011*x000*x011*x100*x111*y000*y010*y101)*y111)/((x001*x010*x101*x110*y001*y011*y100 - x000*x011*x101*x110*y000*y011*y101)*y110 - (x001*x010*x100*x111*y001*y010*y100 - x000*x011*x100*x111*y000*y010*y101)*y111),
         a111]


    AUTHORS:
    - Edinah K. Gnang
    """
    if X.n(1)==X.n(2) and Y.n(0)==Y.n(2) and X.n(1)==Y.n(0) and X.order()==3 and Y.order()==3:
        # Initialization of the size parameter
        sz0=X.n(0); sz1=Y.n(1); sz2=Y.n(2)
        # Initialization of the container matrix
        M = Matrix(SR,HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero').listHM())
        for i in range(sz0):
            for j in range(sz1):
                for s in range(sz2):
                    for t in range(sz2):
                        M[i*sz1*sz2+j*sz2+t,sz1*sz2*i+sz2*j+s]=X[i,s,t]*Y[s,j,t]
        # Initialization of the coefficient HM
        Ha=HM(sz0*sz1, sz0*sz1, [HM(sz2,sz2,'zero') for ij in range((sz0*sz1)^2)])
        for ij in range(sz0*sz1):
            Ha[ij, ij]=HM(sz2, sz2, M[ij*sz2:ij*sz2+sz2, ij*sz2:ij*sz2+sz2].transpose().list())
        # Initialization of the RHS
        Hb=HM(sz0*sz1, 1, [HM(2,sz2,'kronecker') for ij in range(sz0*sz1)])
        # Computing the matrix pseudo inverse
        [A,b]=gauss_jordan_eliminationHM(Ha, Hb)
        # Filling up the solution with the result
        B=HM(M.nrows(), M.ncols(), 'zero').matrix()
        for ij in range(sz0*sz1):
            B[sz2*ij:sz2*ij+sz2, sz2*ij:sz2*ij+sz2]=b[ij,0].simplify_full().matrix()
        # Initializing the multiplicative constraints.
        U=HM(X.n(0),X.n(1),X.n(2),'u'); V=HM(Y.n(0),Y.n(1),Y.n(2),'v')
        Eq=[U[i,t,k]*V[t,j,k]==B[i*sz1*sz2+j*sz2+k,i*sz1*sz2+j*sz2+t] for i in range(sz0) for j in range(sz1) for k in range(sz2) for t in range(sz2)]
        # Formating the constraints
        [A,b]=multiplicativeConstraintFormator(Eq, U.list()+V.list())
        Mx=Matrix(SR, A.ncols(), 1, U.list()+V.list())
        return [[multiplicative_linear_solver(A,b,Mx,Mx), U, V], multiplicative_gauss_jordan_eliminationII(A,b)]
    else:
        raise ValueError("The input hypermatrices must be cubical third order hypermatrices of the same sizes.")

def InnerHypermatrixInversePairHM(X, Y):
    """
    Outputs the pseudo inverse pairs associated with the input pairs of hypermatrices
    The implementation does not assume that the input third order hypermatrices are 
    cubic. In fact X is m x p x p and Y is p x n x p.


    EXAMPLES:

    ::

        sage: Hx=HM(2,2,2,'x'); Hy=HM(2,2,2,'y')
        sage: [Sln, Tu, Tv]=InnerHypermatrixInversePairHM(Hx, Hy)[0]
        sage: Hu=Tu.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs() !=1])) 
        sage: Hv=Tv.subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs() !=1]))
        sage: Prod(Hx, Prod(Hu, HM(2,2,2,'a'), Hv), Hy).simplify_full().list()
        [a000,
         a100,
         ((a010*x001*x010*x101*x110*y001*y011*y100 - a010*x001*x010*x100*x111*y000*y011*y101)*y110 - (a010*x000*x011*x101*x110*y001*y010*y100 - a010*x000*x011*x100*x111*y000*y010*y101)*y111)/((x001*x010*x101*x110*y001*y011*y100 - x000*x011*x101*x110*y000*y011*y101)*y110 - (x001*x010*x100*x111*y001*y010*y100 - x000*x011*x100*x111*y000*y010*y101)*y111),
         a110,
         a001,
         a101,
         ((a011*x001*x010*x101*x110*y001*y011*y100 - a011*x001*x010*x100*x111*y000*y011*y101)*y110 - (a011*x000*x011*x101*x110*y001*y010*y100 - a011*x000*x011*x100*x111*y000*y010*y101)*y111)/((x001*x010*x101*x110*y001*y011*y100 - x000*x011*x101*x110*y000*y011*y101)*y110 - (x001*x010*x100*x111*y001*y010*y100 - x000*x011*x100*x111*y000*y010*y101)*y111),
         a111] 


    AUTHORS:
    - Edinah K. Gnang
    """
    if X.n(1)==X.n(2) and Y.n(0)==Y.n(2) and X.n(1)==Y.n(0) and X.order()==3 and Y.order()==3:
        # Initialization of the size parameter
        sz0=X.n(0); sz1=Y.n(1); sz2=Y.n(2)
        # Initialization of the container matrix
        #M = Matrix(SR,HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero').listHM())
        M = HM(sz0*sz1*sz2, sz0*sz1*sz2, 'zero')
        for i in range(sz0):
            for j in range(sz1):
                for s in range(sz2):
                    for t in range(sz2):
                        M[i*sz1*sz2+j*sz2+t,sz1*sz2*i+sz2*j+s]=X[i,s,t]*Y[s,j,t]
        # Initialization of the coefficient HM
        Ha=HM(sz0*sz1, sz0*sz1, [HM(sz2,sz2,'zero') for ij in range((sz0*sz1)^2)])
        for ij in range(sz0*sz1):
            #Ha[ij, ij]=HM(sz2, sz2, M[ij*sz2:ij*sz2+sz2, ij*sz2:ij*sz2+sz2].transpose().list())
            Ha[ij, ij]=M.slice(rg(ij*sz2,ij*sz2+sz2),0).slice(rg(ij*sz2,ij*sz2+sz2),1)
        # Initialization of the RHS
        Hb=HM(sz0*sz1, 1, [HM(2,sz2,'kronecker') for ij in range(sz0*sz1)])
        # Computing the matrix pseudo inverse
        [A,b]=gauss_jordan_eliminationHM(Ha, Hb)
        # Filling up the solution with the result
        #B=HM(M.nrows(), M.ncols(), 'zero').matrix()
        #for ij in range(sz0*sz1):
        #    B[sz2*ij:sz2*ij+sz2, sz2*ij:sz2*ij+sz2]=b[ij,0].simplify_full().matrix()
        B=HM(M.nrows(), M.ncols(), 'zero')
        for ij in range(sz0*sz1):
            for ii in rg(sz2*ij,sz2*ij+sz2):
                for jj in rg(sz2*ij,sz2*ij+sz2):
                    B[ii,jj]=(b[ij,0])[ii-sz2*ij,jj-sz2*ij].canonicalize_radical()
        # Initializing the multiplicative constraints.
        U=HM(X.n(0),X.n(1),X.n(2),'u'); V=HM(Y.n(0),Y.n(1),Y.n(2),'v')
        #Eq=[U[i,t,k]*V[t,j,k]==B[i*sz1*sz2+j*sz2+k,i*sz1*sz2+j*sz2+t] for i in range(sz0) for j in range(sz1) for k in range(sz2) for t in range(sz2)]
        Eq=[U[i,t,k]*V[t,j,k]==B[i*sz1*sz2+j*sz2+k,i*sz1*sz2+j*sz2+t] for i in rg(sz0) for j in rg(sz1) for k in rg(sz2) for t in rg(sz2)]
        # Formating the constraints
        #[A,b]=multiplicativeConstraintFormator(Eq, U.list()+V.list())
        [A,b]=multiplicativeConstraintFormatorHM(Eq, U.list()+V.list())
        #Mx=Matrix(SR, A.ncols(), 1, U.list()+V.list())
        Mx=HM(A.ncols(), 1, U.list()+V.list())
        #return [[multiplicative_linear_solver(A,b,Mx,Mx), U, V], multiplicative_gauss_jordan_eliminationII(A,b)]
        return [[multiplicative_linear_solverHM(A,b,Mx,Mx), U, V], multiplicative_gauss_jordan_eliminationHMII(A,b)]
    else:
        raise ValueError("The input hypermatrices must be cubical third order hypermatrices of the same sizes.")

def HypermatrixPseudoInversePairs(A,B):
    """
     Outputs the pseudo inverse pairs associated with the input pairs of matrices

    EXAMPLES:

    ::

        sage: A1=[[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]] ,[[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]]
        sage: A2=[[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]] ,[[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]]
        sage: [B1,B2]=HypermatrixPseudoInversePairs(A1,A2)

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    sz = len(A)
    # Initializing the list of linear constraints
    CnstrLst = []
    # Initilizing the variable list
    Vrbls  = [var('ln_al'+str(i)+str(j)+str(k)) for i in range(sz) for j in range(sz) for k in range(sz)]+[var('ln_bt'+str(i)+str(j)+str(k)) for i in range(sz) for j in range(sz) for k in range(sz)]
    for m in range(sz):
        for p in range(sz):
            for n in range(sz):
                V=Matrix(CC, sz, sz, [(A[m][k1][k0])*(B[k0][k1][p]) for k0 in range(sz) for k1 in range(sz)]).inverse()
                CnstrLst=CnstrLst+[var('ln_al'+str(m)+str(n)+str(k1))+var('ln_bt'+str(k1)+str(n)+str(p))==ln(V[k1,n])  for k1 in range(sz)]
    [A,b]=ConstraintFormator(CnstrLst,Vrbls)
    # Importing the Numerical Python package
    # for computing the matrix pseudo inverse
    import numpy
    sln = matrix(numpy.linalg.pinv(A))*b
    R1 = HypermatrixGenerateAllZero(sz,sz,sz)
    for i in range(sz):
        for j in range(sz):
            for k in range(sz):
                R1[i][j][k] = exp(sln[i*sz^2+j*sz^1+k*sz^0,0])
    R2 = HypermatrixGenerateAllZero(sz, sz, sz)
    for i in range(sz):
        for j in range(sz):
            for k in range(sz):
                R2[i][j][k] = exp(sln[sz^3+i*sz^2+j*sz^1+k*sz^0,0])
    return [R1,R2]

def CountCompositions(n):
    """
    Counts the number of product composition involving the input
    hypermatrix n times.

    EXAMPLES:
    The input n must be greater than 0
    ::

        sage: CountCompositions(3)
        1

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    if n == 1 :
        return 1
    else :
        return sum([CountCompositions(i)*CountCompositions(j)*CountCompositions(n-i-j) for i in range(1,n,2) for j in range(1,n-i,2)])

def GeneralHypermatrixProduct(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GeneralHypermatrixProduct(Ha, Hb, Hc); Rslt
        [[[a000*b000*c000 + a010*b001*c100, a001*b000*c001 + a011*b001*c101], [a000*b010*c010 + a010*b011*c110, a001*b010*c011 + a011*b011*c111]], [[a100*b100*c000 + a110*b101*c100, a101*b100*c001 + a111*b101*c101], [a100*b110*c010 + a110*b111*c110, a101*b110*c011 + a111*b111*c111]]]
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); GeneralHypermatrixProduct(Ha, Hb)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)]=sum([prod([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+[args[len(args)-1][tuple([t]+entry[1:])]]) for t in range((args[0]).n(1))])
    return Rh

# Defining a shorter function call for the hypermatrix product implemented above.
def Prod(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=Prod(Ha, Hb, Hc); Rslt
        [[[a000*b000*c000 + a010*b001*c100, a001*b000*c001 + a011*b001*c101], [a000*b010*c010 + a010*b011*c110, a001*b010*c011 + a011*b011*c111]], [[a100*b100*c000 + a110*b101*c100, a101*b100*c001 + a111*b101*c101], [a100*b110*c010 + a110*b111*c110, a101*b110*c011 + a111*b111*c111]]]
        sage: Prod(HM(2,2,'a'),HM(2,2,'b'))
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProduct(*args)

# Defining a shorter function call for the hypermatrix product implemented above.
def BMP(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=BMP(Ha, Hb, Hc); Rslt
        [[[a000*b000*c000 + a010*b001*c100, a001*b000*c001 + a011*b001*c101], [a000*b010*c010 + a010*b011*c110, a001*b010*c011 + a011*b011*c111]], [[a100*b100*c000 + a110*b101*c100, a101*b100*c001 + a111*b101*c101], [a100*b110*c010 + a110*b111*c110, a101*b110*c011 + a111*b111*c111]]]
        sage: BMP(HM(2,2,'a'),HM(2,2,'b'))
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProduct(*args)

def GeneralHypermatrixProductB(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices
    with non-trivial background. The code only handles the 
    Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c'); Hd = HM(2,2,2,'d')
        sage: Rslt=GeneralHypermatrixProductB(Ha, Hb, Hc, Hd); Rslt
        [[[a000*b000*c000*d000 + a000*b000*c100*d001 + a000*b001*c000*d010 + a000*b001*c100*d011 + a010*b000*c000*d100 + a010*b000*c100*d101 + a010*b001*c000*d110 + a010*b001*c100*d111, a001*b000*c001*d000 + a001*b000*c101*d001 + a001*b001*c001*d010 + a001*b001*c101*d011 + a011*b000*c001*d100 + a011*b000*c101*d101 + a011*b001*c001*d110 + a011*b001*c101*d111], [a000*b010*c010*d000 + a000*b010*c110*d001 + a000*b011*c010*d010 + a000*b011*c110*d011 + a010*b010*c010*d100 + a010*b010*c110*d101 + a010*b011*c010*d110 + a010*b011*c110*d111, a001*b010*c011*d000 + a001*b010*c111*d001 + a001*b011*c011*d010 + a001*b011*c111*d011 + a011*b010*c011*d100 + a011*b010*c111*d101 + a011*b011*c011*d110 + a011*b011*c111*d111]], [[a100*b100*c000*d000 + a100*b100*c100*d001 + a100*b101*c000*d010 + a100*b101*c100*d011 + a110*b100*c000*d100 + a110*b100*c100*d101 + a110*b101*c000*d110 + a110*b101*c100*d111, a101*b100*c001*d000 + a101*b100*c101*d001 + a101*b101*c001*d010 + a101*b101*c101*d011 + a111*b100*c001*d100 + a111*b100*c101*d101 + a111*b101*c001*d110 + a111*b101*c101*d111], [a100*b110*c010*d000 + a100*b110*c110*d001 + a100*b111*c010*d010 + a100*b111*c110*d011 + a110*b110*c010*d100 + a110*b110*c110*d101 + a110*b111*c010*d110 + a110*b111*c110*d111, a101*b110*c011*d000 + a101*b110*c111*d001 + a101*b111*c011*d010 + a101*b111*c111*d011 + a111*b110*c011*d100 + a111*b110*c111*d101 + a111*b111*c011*d110 + a111*b111*c111*d111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args)-1)]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Initializing the background hypermatrix
    B = (args[len(args)-1]).transpose(args[len(args)-1].order()-1)
    args = tuple([args[id] for id in range(len(args)-1)])
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # Computing the Hypermatrix product
        if len(args) < 2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)] = 0
            l2 = [B.n(sz) for sz in range(B.order())]
            for j in range(prod(l2)):
                # Turning the index j into an hypermatrix array location using the decimal encoding trick
                entry2 = [Integer(mod(j,l2[0]))]
                sm2 = Integer(mod(j,l2[0]))
                for z in range(len(l2)-1):
                    entry2.append(Integer(mod(Integer((j-sm2)/prod(l2[0:z+1])),l2[z+1])))
                    sm2 = sm2+prod(l2[0:z+1])*entry2[len(entry2)-1]
                Rh[tuple(entry)] = Rh[tuple(entry)]+prod([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[entry2[ Integer(mod(s+1,len(args))) ]]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry[0:len(entry)-1]+[entry2[len(entry2)-1]])]]+[args[len(args)-1][tuple([entry2[0]]+entry[1:])]])*B[tuple(entry2)]
    return Rh

def ProdB(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices
    with non-trivial background. The code only handles the 
    Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c'); Hd = HM(2,2,2,'d')
        sage: Rslt=ProdB(Ha, Hb, Hc, Hd); Rslt
        [[[a000*b000*c000*d000 + a000*b000*c100*d001 + a000*b001*c000*d010 + a000*b001*c100*d011 + a010*b000*c000*d100 + a010*b000*c100*d101 + a010*b001*c000*d110 + a010*b001*c100*d111, a001*b000*c001*d000 + a001*b000*c101*d001 + a001*b001*c001*d010 + a001*b001*c101*d011 + a011*b000*c001*d100 + a011*b000*c101*d101 + a011*b001*c001*d110 + a011*b001*c101*d111], [a000*b010*c010*d000 + a000*b010*c110*d001 + a000*b011*c010*d010 + a000*b011*c110*d011 + a010*b010*c010*d100 + a010*b010*c110*d101 + a010*b011*c010*d110 + a010*b011*c110*d111, a001*b010*c011*d000 + a001*b010*c111*d001 + a001*b011*c011*d010 + a001*b011*c111*d011 + a011*b010*c011*d100 + a011*b010*c111*d101 + a011*b011*c011*d110 + a011*b011*c111*d111]], [[a100*b100*c000*d000 + a100*b100*c100*d001 + a100*b101*c000*d010 + a100*b101*c100*d011 + a110*b100*c000*d100 + a110*b100*c100*d101 + a110*b101*c000*d110 + a110*b101*c100*d111, a101*b100*c001*d000 + a101*b100*c101*d001 + a101*b101*c001*d010 + a101*b101*c101*d011 + a111*b100*c001*d100 + a111*b100*c101*d101 + a111*b101*c001*d110 + a111*b101*c101*d111], [a100*b110*c010*d000 + a100*b110*c110*d001 + a100*b111*c010*d010 + a100*b111*c110*d011 + a110*b110*c010*d100 + a110*b110*c110*d101 + a110*b111*c010*d110 + a110*b111*c110*d111, a101*b110*c011*d000 + a101*b110*c111*d001 + a101*b111*c011*d010 + a101*b111*c111*d011 + a111*b110*c011*d100 + a111*b110*c111*d101 + a111*b111*c011*d110 + a111*b111*c111*d111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductB(*args) 

def BMPb(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices
    with non-trivial background. The code only handles the 
    Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c'); Hd = HM(2,2,2,'d')
        sage: Rslt=BMPb(Ha, Hb, Hc, Hd); Rslt
        [[[a000*b000*c000*d000 + a000*b000*c100*d001 + a000*b001*c000*d010 + a000*b001*c100*d011 + a010*b000*c000*d100 + a010*b000*c100*d101 + a010*b001*c000*d110 + a010*b001*c100*d111, a001*b000*c001*d000 + a001*b000*c101*d001 + a001*b001*c001*d010 + a001*b001*c101*d011 + a011*b000*c001*d100 + a011*b000*c101*d101 + a011*b001*c001*d110 + a011*b001*c101*d111], [a000*b010*c010*d000 + a000*b010*c110*d001 + a000*b011*c010*d010 + a000*b011*c110*d011 + a010*b010*c010*d100 + a010*b010*c110*d101 + a010*b011*c010*d110 + a010*b011*c110*d111, a001*b010*c011*d000 + a001*b010*c111*d001 + a001*b011*c011*d010 + a001*b011*c111*d011 + a011*b010*c011*d100 + a011*b010*c111*d101 + a011*b011*c011*d110 + a011*b011*c111*d111]], [[a100*b100*c000*d000 + a100*b100*c100*d001 + a100*b101*c000*d010 + a100*b101*c100*d011 + a110*b100*c000*d100 + a110*b100*c100*d101 + a110*b101*c000*d110 + a110*b101*c100*d111, a101*b100*c001*d000 + a101*b100*c101*d001 + a101*b101*c001*d010 + a101*b101*c101*d011 + a111*b100*c001*d100 + a111*b100*c101*d101 + a111*b101*c001*d110 + a111*b101*c101*d111], [a100*b110*c010*d000 + a100*b110*c110*d001 + a100*b111*c010*d010 + a100*b111*c110*d011 + a110*b110*c010*d100 + a110*b110*c110*d101 + a110*b111*c010*d110 + a110*b111*c110*d111, a101*b110*c011*d000 + a101*b110*c111*d001 + a101*b111*c011*d010 + a101*b111*c111*d011 + a111*b110*c011*d100 + a111*b110*c111*d101 + a111*b111*c011*d110 + a111*b111*c111*d111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductB(*args) 

def GeneralHypermatrixLogProduct(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner Log-product of the input hypermatrices
    with non-trivial background. The code only handles the 
    Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,1,2,'a'); Hb=HM(2,2,1,'b'); Hc=HM(1,2,2,'c')
        sage: Rslt=GeneralHypermatrixLogProduct(Ha, Hb, Hc); Rslt
        [[[a000 + b000 + c000, a001 + b000 + c001], [a000 + b010 + c010, a001 + b010 + c011]], [[a100 + b100 + c000, a101 + b100 + c001], [a100 + b110 + c010, a101 + b110 + c011]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)]=sum([sum([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+[args[len(args)-1][tuple([t]+entry[1:])]]) for t in range((args[0]).n(1))])
    return Rh

def GeneralHypermatrixBlockProduct(*args):
    """  
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner block product of the input hypermatrices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::   

        sage: Ha=HM(2,2,2,'a');Hb=HM(2,2,2,'b');Hc=HM(2,2,2,'c');Hd=HM(2,2,2,'d');Hf=HM(2,2,2,'f');Hg=HM(2,2,2,'g')
        sage: A=HM(1,2,1,[Ha,Hb]); B=HM(1,1,2,[Hc,Hd]); C=HM(2,1,1,[Hf,Hg])
        sage: Rslt=GeneralHypermatrixBlockProduct(A, B, C); Rslt[0,0,0].printHM()
        [:, :, 0]=
        [a000*c000*f000 + a010*c001*f100 + b000*d000*g000 + b010*d001*g100 a000*c010*f010 + a010*c011*f110 + b000*d010*g010 + b010*d011*g110]
        [a100*c100*f000 + a110*c101*f100 + b100*d100*g000 + b110*d101*g100 a100*c110*f010 + a110*c111*f110 + b100*d110*g010 + b110*d111*g110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*c000*f001 + a011*c001*f101 + b001*d000*g001 + b011*d001*g101 a001*c010*f011 + a011*c011*f111 + b001*d010*g011 + b011*d011*g111]
        [a101*c100*f001 + a111*c101*f101 + b101*d100*g001 + b111*d101*g101 a101*c110*f011 + a111*c111*f111 + b101*d110*g011 + b111*d111*g111]


    AUTHORS:
    - Edinah K. Gnang
    """  
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)]=sum([Prod( *([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+[args[len(args)-1][tuple([t]+entry[1:])]]) ) for t in range((args[0]).n(1))])
    return Rh

def BlockProd(*args):
    """  
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner block product of the input hypermatrices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::   

        sage: Ha=HM(2,2,2,'a');Hb=HM(2,2,2,'b');Hc=HM(2,2,2,'c');Hd=HM(2,2,2,'d');Hf=HM(2,2,2,'f');Hg=HM(2,2,2,'g')
        sage: A=HM(1,2,1,[Ha,Hb]); B=HM(1,1,2,[Hc,Hd]); C=HM(2,1,1,[Hf,Hg])
        sage: Rslt=BlockProd(A, B, C); Rslt[0,0,0].printHM()
        [:, :, 0]=
        [a000*c000*f000 + a010*c001*f100 + b000*d000*g000 + b010*d001*g100 a000*c010*f010 + a010*c011*f110 + b000*d010*g010 + b010*d011*g110]
        [a100*c100*f000 + a110*c101*f100 + b100*d100*g000 + b110*d101*g100 a100*c110*f010 + a110*c111*f110 + b100*d110*g010 + b110*d111*g110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*c000*f001 + a011*c001*f101 + b001*d000*g001 + b011*d001*g101 a001*c010*f011 + a011*c011*f111 + b001*d010*g011 + b011*d011*g111]
        [a101*c100*f001 + a111*c101*f101 + b101*d100*g001 + b111*d101*g101 a101*c110*f011 + a111*c111*f111 + b101*d110*g011 + b111*d111*g111]
        sage: Ha=HM(2,1,2,'a');Hb=HM(2,1,2,'b');Hc=HM(2,2,1,'c');Hd=HM(2,2,1,'d');Hf=HM(1,2,2,'f');Hg=HM(1,2,2,'g')
        sage: A=HM(1,2,1,[Ha,Hb]); B=HM(1,1,2,[Hc,Hd]); C=HM(2,1,1,[Hf,Hg])
        sage: BlockProd(A, B, C)[0,0,0].printHM() # Computing the block product
        [:, :, 0]=
        [a000*c000*f000 + b000*d000*g000 a000*c010*f010 + b000*d010*g010]
        [a100*c100*f000 + b100*d100*g000 a100*c110*f010 + b100*d110*g010]
        <BLANKLINE>
        [:, :, 1]=
        [a001*c000*f001 + b001*d000*g001 a001*c010*f011 + b001*d010*g011]
        [a101*c100*f001 + b101*d100*g001 a101*c110*f011 + b101*d110*g011]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixBlockProduct(*args) 

def GeneralHypermatrixProductII(Lh, Op, F):
    """
    Outputs an HM which is a list of lists associated with the
    construct approach to the Bhattacharya-Mesner product of the input
    hypermatrices. Here Op is the combinator and F is the composer.
    This implementation in theory captures the full scope of
    the construct products subsequently implemented here but in 
    practice is hard for to specify arbitrary composers for F.
    The code only handles the Hypermatrix HM class objects.


    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GeneralHypermatrixProductII([Ha, Hb, Hc], prod, sum); Rslt.printHM()
        [:, :, 0]=
        [(a000 + b000 + c000)*(a010 + b001 + c100) (a000 + b010 + c010)*(a010 + b011 + c110)]
        [(a100 + b100 + c000)*(a110 + b101 + c100) (a100 + b110 + c010)*(a110 + b111 + c110)]
        <BLANKLINE>
        [:, :, 1]=
        [(a001 + b000 + c001)*(a011 + b001 + c101) (a001 + b010 + c011)*(a011 + b011 + c111)]
        [(a101 + b100 + c001)*(a111 + b101 + c101) (a101 + b110 + c011)*(a111 + b111 + c111)]        
        
        sage: Rslt=GeneralHypermatrixProductII([Ha, Hb, Hc], sum, prod); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]

        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); GeneralHypermatrixProductII([Ha, Hb], sum, prod)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: A=HM([[59, -3, 2], [-6, 1, 1], [1, -1, 1]]); B=HM([[-1, 1, 0], [-1, 1, 0], [0, -43, 1]])
        sage: GeneralHypermatrixProductII([A, B], sum, prod)-A*B # One way of recovering matrix multiplication
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        sage: GeneralHypermatrixProductII([A, B], min, sum) # Recovering the Min-plus matrix multiplication
        [[-4, -41, -3], [-7, -42, -6], [-2, -42, -1]]
        sage: MSta=HM([[Set([1,2]), Set([1,3,2])], [Set([1]), Set([2,3])]])
        sage: MStb=HM([[Set([1,2,3]), Set([2])], [Set([1,3]), Set([1,3])]])
        sage: GeneralHypermatrixProductII([MSta, MStb], SetIntersection, SetUnion) 
        [[{1, 2, 3}, {1, 2}], [{1, 2, 3}, {1, 2}]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(Lh[i]).n(i) for i in range(len(Lh))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(Lh)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(Lh) >= 2:
            #Rh[tuple(entry)]=apply(Op, [[apply(F, [[Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]]]) for t in range((Lh[0]).n(1))]])
            Rh[tuple(entry)]=Op(*[[F( *[[Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]]] ) for t in range((Lh[0]).n(1))]])
    return Rh

def GeneralHypermatrixProductIII(Lh, Op, Lv):
    """
    Outputs a list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the first of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for composition as our defacto product operation. Hoever it is
    theoretically less general then the previous one. Both these implementations
    are inspired by initial exposure to ideas from Category theory, the implementation
    also make painfully obvious some of the programming constraints imposed by Python.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GeneralHypermatrixProductIII([Ha,Hb,Hc], sum, [x,y]); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]

        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); GeneralHypermatrixProductIII([Ha, Hb], sum, [x])
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); GeneralHypermatrixProductIII([Ha, Hb], prod, [x])
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]



    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(Lh[i]).n(i) for i in range(len(Lh))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(Lh)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(Lh) >= 2:
            #Rh[tuple(entry)]=apply(Op, [ [([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[0].subs([Lv[z-1]==([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[z] for z in rg(1,len(Lh))]) for t in range((Lh[0]).n(1))] ])
            Rh[tuple(entry)]=Op( *[ [([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[0].subs([Lv[z-1]==([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[z] for z in rg(1,len(Lh))]) for t in range((Lh[0]).n(1))] ])
    return Rh

def GeneralHypermatrixProductIV(Lh, Op, Lv):
    """
    Outputs a list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the first of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for composition as our defacto product operation. Hoever it is
    theoretically less general then the previous one. Both these implementations
    are inspired by initial exposure to ideas from Category theory, the implementation
    also make painfully obvious some of the programming constraints imposed by Python.
    The code only handles the Hypermatrix HM class objects. This new variant is to
    accomodate substitution with free variables, it is mainly a work around a sage
    bug the substitute function behaves very differently for free field.
    This implmentation suggest that free variables which support inversions would
    be a great feature to have. I will keep this in mind as I get acquainted with
    sage developers.


    EXAMPLES:

    ::

        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+[z]),La+Lx+Lb+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, z>=FreeAlgebra(QQ,len(La+Lx+Lb+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb); GeneralHypermatrixProductIV([Hr, Hx], sum, [z]).printHM()
        [:, :]=
        [a00*x0*b00 + a01*x1*b01]
        [a10*x0*b10 + a11*x1*b11]
        [a20*x0*b20 + a21*x1*b21]
        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GeneralHypermatrixProductIV([Ha,Hb,Hc], sum, [x,y]); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Testing conformability by initiailizing the common dimension
    el=Lh[len(Lh)-1].n(0)
    # Loop running throug the dimentsion of the input
    for indx in rg(len(Lh)-1):
        if Lh[indx].n(indx+1) != el:
            print('WARNING !!! The input hypermatrices are not conformable. Truncating to allow the product.')
            break
    # Initialization of the list specifying the dimensions of the output
    l = [(Lh[i]).n(i) for i in range(len(Lh))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(Lh)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(Lh) >= 2:
            Ltmp=[]
            for t in range((Lh[0]).n(1)):
                Tmp=([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[0]
                #print 'Tmp before', Tmp
                #print 'Ltmp before', Ltmp
                for vz in rg(1,len(Lh)):
                    #print {Lv[vz-1]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]}
                    Tmp=Tmp.subs({Lv[vz-1]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]})
                    #print 'Tmp after', Tmp
                Ltmp.append(Tmp)
                #print 'Ltmp after', Ltmp
            #print apply(Op, [Ltmp])
            #Rh[tuple(entry)]=apply(Op, [Ltmp])
            Rh[tuple(entry)]=Op(*[Ltmp])
    return Rh

def GeneralHypermatrixProductV(Lh, Op, Lv, indx):
    """
    Outputs a list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the first of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for composition as our defacto product operation. Hoever it is
    theoretically less general then the previous one. Both these implementations
    are inspired by initial exposure to ideas from Category theory, the implementation
    also make painfully obvious some of the programming constraints imposed by Python.
    The code only handles the Hypermatrix HM class objects. This new variant is to
    accomodate substitution with free variables, it is mainly a work around a sage
    bug the substitute function behaves very differently for free field.
    This implmentation suggest that free variables which support inversions would
    be a great feature to have. I will keep this in mind as I get acquainted with
    sage developers. The difference with the previous function is that this support
    an indexing parameter for the hypermatrix input in which the substitions will be
    performed. This gives a tiny bit more flexibility with setting the composer.


    EXAMPLES:

    ::

        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+[z]),La+Lx+Lb+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, z>=FreeAlgebra(QQ,len(La+Lx+Lb+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb); GeneralHypermatrixProductV([Hr, Hx], sum, [z], 0).printHM()
        [:, :]=
        [a00*x0*b00 + a01*x1*b01]
        [a10*x0*b10 + a11*x1*b11]
        [a20*x0*b20 + a21*x1*b21]
        sage: x,y=var('x,y'); Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: GeneralHypermatrixProductV([x*y*Ha,Hb,Hc], sum, [x,y], 0).printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        sage: x,y=var('x,y'); Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: GeneralHypermatrixProductV([Ha,x*y*Hb,Hc], sum, [x,y], 1).printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        sage: GeneralHypermatrixProductV([x*y*Ha,Hb,Hc], sum, [x,y], 0).printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        sage: P = 4*x^3 + 3*x^2 + 2*x + 1 # Initialization of the "dividend"
        sage: D = 5*x^2 + 3*x + 7 # Initialization of the "divisor"
        sage: [Lq, Rem] = CompositionalDivision(P, D, x) # Performing the compositional division
        sage: (GProd([D*HM(1,len(Lq),'one'),HM(len(Lq),1,Lq)], sum, [x])[0,0]+Rem).canonicalize_radical()
        4*x^3 + 3*x^2 + 2*x + 1


    AUTHORS:
    - Edinah K. Gnang
    """
    if indx == 0:
        return GeneralHypermatrixProductIV(Lh, Op, Lv)
    else:
        # Initialization of the list specifying the dimensions of the output
        l = [(Lh[i]).n(i) for i in range(len(Lh))]
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the assignement
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            # computing the Hypermatrix product
            if len(Lh)<2:
                raise ValueError("The number of operands must be >= 2")
            elif len(Lh) >= 2:
                Ltmp=[]
                for t in range((Lh[0]).n(1)):
                    Tmp=([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[indx]
                    #print 'Tmp before', Tmp
                    #print 'Ltmp before', Ltmp
                    LindX1 = rg(indx)
                    #print 'indx=', indx
                    #print 'LindX1=', LindX1
                    for vz in LindX1:
                        #print {Lv[vz]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]}
                        Tmp=Tmp.subs({Lv[vz]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]})
                        #print 'Tmp after', Tmp
                    #print 'LindX2=', LindX2
                    LindX2 = rg(1+indx,1+len(Lh)-indx)
                    for vz in LindX2:
                        #print {Lv[vz-1]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]}
                        Tmp=Tmp.subs({Lv[vz-1]:([Lh[s][tuple(entry[0:Integer(mod(s+1,len(Lh)))]+[t]+entry[Integer(mod(s+2,len(Lh))):])] for s in range(len(Lh)-2)]+[Lh[len(Lh)-2][tuple(entry[0:len(Lh)-1]+[t])]]+[Lh[len(Lh)-1][tuple([t]+entry[1:])]])[vz]})
                        #print 'Tmp after', Tmp
                    Ltmp.append(Tmp)
                    #print 'Ltmp after', Ltmp
                #print apply(Op, [Ltmp])
                #Rh[tuple(entry)]=apply(Op, [Ltmp])
                Rh[tuple(entry)]=Op(*[Ltmp])
        return Rh

def GProd(Lh, Op, Lv):
    """
    Outputs a list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the first of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for composition as our defacto product operation. However it is
    theoretically less general then the previous one. Both these implementations
    are inspired by initial exposure to ideas from Category theory, the implementation
    also make painfully obvious some of the programming constraints imposed by Python.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GProd([Ha,Hb,Hc], sum, [x,y]); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); GProd([Ha, Hb], sum, [x])
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); GProd([Ha, Hb], prod, [x])
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb)-HM(sz,1,[c0, c1, c2])*HM(1,l,[QQ(1/2) for i in rg(l)])
        sage: GProd([Hr, Hx], sum, [z]).printHM()
        [:, :]=
        [-c0 + a00*x0*b00 + a01*x1*b01]
        [-c1 + a10*x0*b10 + a11*x1*b11]
        [-c2 + a20*x0*b20 + a21*x1*b21]
        sage: P = 4*x^3 + 3*x^2 + 2*x + 1 # Initialization of the "dividend"
        sage: D = 5*x^2 + 3*x + 7 # Initialization of the "divisor"
        sage: [Lq, Rem] = CompositionalDivision(P, D, x) # Performing the compositional division
        sage: (GProd([D*HM(1,len(Lq),'one'),HM(len(Lq),1,Lq)], sum, [x])[0,0]+Rem).canonicalize_radical()
        4*x^3 + 3*x^2 + 2*x + 1


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductIV(Lh, Op, Lv)

def GProdII(Lh, Op, Lv, indx):
    """
    Outputs an HM which is list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the indx-th of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for a particular composition operation. However both this
    and the previous implementation are special instances of ways to specify the composer.
    Both these implementations are inspired by initial exposure to ideas from Category theory,
    the implementation also make painfully obvious some of the programming constraints imposed by Python.
    This code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: GProdII([Ha,Hb,Hc], sum, [x,y], 0).printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); GProdII([Ha, Hb], sum, [x], 0)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); GProdII([Ha, Hb], prod, [x], 0)
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb)-HM(sz,1,[c0, c1, c2])*HM(1,l,[QQ(1/2) for i in rg(l)])
        sage: GProdII([Hr, Hx], sum, [z], 0).printHM()
        [:, :]=
        [-c0 + a00*x0*b00 + a01*x1*b01]
        [-c1 + a10*x0*b10 + a11*x1*b11]
        [-c2 + a20*x0*b20 + a21*x1*b21]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductV(Lh, Op, Lv, indx)

def GProdIII(Lh, Op, F):
    """
    Outputs an HM which is a list of lists associated with the
    construct approach to the Bhattacharya-Mesner product of the input
    hypermatrices. Here Op is the combinator and F is the composer.
    This implementation in theory captures the full scope of
    the construct products subsequently implemented here but in 
    practice is hard for to specify arbitrary composers for F.
    The code only handles the Hypermatrix HM class objects.
    This implementation comes in handy for combinatorial constructs
    such as shortest path problems and set valued constructs.


    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GProdIII([Ha, Hb, Hc], prod, sum); Rslt.printHM()
        [:, :, 0]=
        [(a000 + b000 + c000)*(a010 + b001 + c100) (a000 + b010 + c010)*(a010 + b011 + c110)]
        [(a100 + b100 + c000)*(a110 + b101 + c100) (a100 + b110 + c010)*(a110 + b111 + c110)]
        <BLANKLINE>
        [:, :, 1]=
        [(a001 + b000 + c001)*(a011 + b001 + c101) (a001 + b010 + c011)*(a011 + b011 + c111)]
        [(a101 + b100 + c001)*(a111 + b101 + c101) (a101 + b110 + c011)*(a111 + b111 + c111)]        
        <BLANKLINE>
        sage: Rslt=GProdIII([Ha, Hb, Hc], sum, prod); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); GProdIII([Ha, Hb], sum, prod)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); GProdIII([Ha, Hb], prod, Exp)
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); GProdIII([Ha, Hb], prod, BaseExp)
        [[b00^a00*b10^a01, b01^a00*b11^a01], [b00^a10*b10^a11, b01^a10*b11^a11]]
        sage: A=HM([[59, -3, 2], [-6, 1, 1], [1, -1, 1]]); B=HM([[-1, 1, 0], [-1, 1, 0], [0, -43, 1]])
        sage: GProdIII([A, B], sum, prod)-A*B # One way of recovering matrix multiplication
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        sage: GProdIII([A, B], min, sum) # Recovering the Min-plus matrix multiplication
        [[-4, -41, -3], [-7, -42, -6], [-2, -42, -1]]
        sage: MSta=HM([[Set([1,2]), Set([1,3,2])], [Set([1]), Set([2,3])]])
        sage: MStb=HM([[Set([1,2,3]), Set([2])], [Set([1,3]), Set([1,3])]])
        sage: GProdIII([MSta, MStb], SetIntersection, SetUnion) 
        [[{1, 2, 3}, {1, 2}], [{1, 2, 3}, {1, 2}]]
        sage: GProdIII([MSta, MStb], SetUnion, SetIntersection)
        [[{1, 2, 3}, {1, 2, 3}], [{1, 3}, {3}]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(1,l,sz,[a00, a10, a20, a01, a11, a21])
        sage: Hx=HM(1,1,l,[x0, x1]) 
        sage: Hb=HM(l,1,sz,[b00, b10, b20, b01, b11, b21])
        sage: GProdIII([Ha, Hx, Hb], sum, prod).printHM()
        [:, :, 0]=
        [a00*x0*b00 + a10*x1*b10]
        <BLANKLINE>
        [:, :, 1]=
        [a20*x0*b20 + a01*x1*b01]
        <BLANKLINE>
        [:, :, 2]=
        [a11*x0*b11 + a21*x1*b21]
        <BLANKLINE>
        sage: Ca=HM(2,2,[HM(1,1,[var('a00')]), HM(1,1,[var('a10')]), HM(1,1,[var('a01')]), HM(1,1,[var('a11')])])
        sage: Cb=HM(2,2,[HM(1,1,[var('b00')]), HM(1,1,[var('b10')]), HM(1,1,[var('b01')]), HM(1,1,[var('b11')])])
        sage: GProdIII([Ca, Cb], DirectSum, TensorProduct)[0,0].printHM()
        [:, :]=
        [a00*b00       0]
        [      0 a01*b10]
        sage: GProdIII([Ca, Cb], DirectSum, TensorProduct)[0,1].printHM()
        [:, :]=
        [a00*b01       0]
        [      0 a01*b11]
        sage: GProdIII([Ca, Cb], DirectSum, TensorProduct)[1,0].printHM()
        [:, :]=
        [a10*b00       0]
        [      0 a11*b10]
        sage: GProdIII([Ca, Cb], DirectSum, TensorProduct)[1,1].printHM()
        [:, :]=
        [a10*b01       0]
        [      0 a11*b11]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductII(Lh, Op, F)

def CProd(Lh, Op, F):
    """
    Outputs an HM which is a list of lists associated with the
    construct approach to the Bhattacharya-Mesner product of the input
    hypermatrices. Here Op is the combinator and F is the composer.
    This implementation in theory captures the full scope of
    the construct products subsequently implemented here but in 
    practice is hard for to specify arbitrary composers for F.
    The code only handles the Hypermatrix HM class objects.
    This implementation comes in handy for combinatorial constructs
    such as shortest path problems and set valued constructs.


    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=CProd([Ha, Hb, Hc], prod, sum); Rslt.printHM()
        [:, :, 0]=
        [(a000 + b000 + c000)*(a010 + b001 + c100) (a000 + b010 + c010)*(a010 + b011 + c110)]
        [(a100 + b100 + c000)*(a110 + b101 + c100) (a100 + b110 + c010)*(a110 + b111 + c110)]
        <BLANKLINE>
        [:, :, 1]=
        [(a001 + b000 + c001)*(a011 + b001 + c101) (a001 + b010 + c011)*(a011 + b011 + c111)]
        [(a101 + b100 + c001)*(a111 + b101 + c101) (a101 + b110 + c011)*(a111 + b111 + c111)]        
        <BLANKLINE>
        sage: Rslt=CProd([Ha, Hb, Hc], sum, prod); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); CProd([Ha, Hb], sum, prod)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); CProd([Ha, Hb], prod, Exp)
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); CProd([Ha, Hb], prod, BaseExp)
        [[b00^a00*b10^a01, b01^a00*b11^a01], [b00^a10*b10^a11, b01^a10*b11^a11]]
        sage: A=HM([[59, -3, 2], [-6, 1, 1], [1, -1, 1]]); B=HM([[-1, 1, 0], [-1, 1, 0], [0, -43, 1]])
        sage: CProd([A, B], sum, prod)-A*B # One way of recovering matrix multiplication
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        sage: CProd([A, B], min, sum) # Recovering the Min-plus matrix multiplication
        [[-4, -41, -3], [-7, -42, -6], [-2, -42, -1]]
        sage: MSta=HM([[Set([1,2]), Set([1,3,2])], [Set([1]), Set([2,3])]])
        sage: MStb=HM([[Set([1,2,3]), Set([2])], [Set([1,3]), Set([1,3])]])
        sage: CProd([MSta, MStb], SetIntersection, SetUnion) 
        [[{1, 2, 3}, {1, 2}], [{1, 2, 3}, {1, 2}]]
        sage: CProd([MSta, MStb], SetUnion, SetIntersection)
        [[{1, 2, 3}, {1, 2, 3}], [{1, 3}, {3}]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(1,l,sz,[a00, a10, a20, a01, a11, a21])
        sage: Hx=HM(1,1,l,[x0, x1]) 
        sage: Hb=HM(l,1,sz,[b00, b10, b20, b01, b11, b21])
        sage: CProd([Ha, Hx, Hb], sum, prod).printHM()
        [:, :, 0]=
        [a00*x0*b00 + a10*x1*b10]
        <BLANKLINE>
        [:, :, 1]=
        [a20*x0*b20 + a01*x1*b01]
        <BLANKLINE>
        [:, :, 2]=
        [a11*x0*b11 + a21*x1*b21]
        <BLANKLINE>
        sage: Ca=HM(2,2,[HM(1,1,[var('a00')]), HM(1,1,[var('a10')]), HM(1,1,[var('a01')]), HM(1,1,[var('a11')])])
        sage: Cb=HM(2,2,[HM(1,1,[var('b00')]), HM(1,1,[var('b10')]), HM(1,1,[var('b01')]), HM(1,1,[var('b11')])])
        sage: CProd([Ca, Cb], DirectSum, TensorProduct)[0,0].printHM()
        [:, :]=
        [a00*b00       0]
        [      0 a01*b10]
        sage: CProd([Ca, Cb], DirectSum, TensorProduct)[0,1].printHM()
        [:, :]=
        [a00*b01       0]
        [      0 a01*b11]
        sage: CProd([Ca, Cb], DirectSum, TensorProduct)[1,0].printHM()
        [:, :]=
        [a10*b00       0]
        [      0 a11*b10]
        sage: CProd([Ca, Cb], DirectSum, TensorProduct)[1,1].printHM()
        [:, :]=
        [a10*b01       0]
        [      0 a11*b11]
        sage: A=HM([[0, 1/2, 1], [1/2, 0, 1],[1, 1, 0]]) # Example of a disimilarity matrix
        sage: (CProd([A,A], max, max)-A).printHM() # Checking the strong triangle or ultrametric inequality for a finite Ultrametric space
        [:, :]=
        [  1 1/2   0]
        [1/2   1   0]
        [  0   0   1]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductII(Lh, Op, F)

def CProdII(Lh, Op, Lv):
    """
    Outputs a list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the first of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for composition as our defacto product operation. However it is
    theoretically less general then the previous one. Both these implementations
    are inspired by initial exposure to ideas from Category theory, the implementation
    also make painfully obvious some of the programming constraints imposed by Python.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=CProdII([Ha,Hb,Hc], sum, [x,y]); Rslt.printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); CProdII([Ha, Hb], sum, [x])
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); CProdII([Ha, Hb], prod, [x])
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb)-HM(sz,1,[c0, c1, c2])*HM(1,l,[QQ(1/2) for i in rg(l)])
        sage: CProdII([Hr, Hx], sum, [z]).printHM()
        [:, :]=
        [-c0 + a00*x0*b00 + a01*x1*b01]
        [-c1 + a10*x0*b10 + a11*x1*b11]
        [-c2 + a20*x0*b20 + a21*x1*b21]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductIV(Lh, Op, Lv)

def GProdII(Lh, Op, Lv, indx):
    """
    Outputs an HM which is list of lists associated with the composition
    based Bhattacharya-Mesner product of the input hypermatrices.
    The entries of the hypermatrices are taken to be functions
    so that while performing the product we compose with the entries
    of the indx-th of the list of inputs. This implementation is aesthetically
    more pleasing then the previous one because it explicitly articulate the
    preference for a particular composition operation. However both this
    and the previous implementation are special instances of ways to specify the composer.
    Both these implementations are inspired by initial exposure to ideas from Category theory,
    the implementation also make painfully obvious some of the programming constraints imposed by Python.
    This code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); Ha=x*y*HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: GProdII([Ha,Hb,Hc], sum, [x,y], 0).printHM()
        [:, :, 0]=
        [a000*b000*c000 + a010*b001*c100 a000*b010*c010 + a010*b011*c110]
        [a100*b100*c000 + a110*b101*c100 a100*b110*c010 + a110*b111*c110]
        <BLANKLINE>
        [:, :, 1]=
        [a001*b000*c001 + a011*b001*c101 a001*b010*c011 + a011*b011*c111]
        [a101*b100*c001 + a111*b101*c101 a101*b110*c011 + a111*b111*c111]
        <BLANKLINE>
        sage: x=var('x'); Ha=x*HM(2,2,'a'); Hb=HM(2,2,'b'); GProdII([Ha, Hb], sum, [x], 0)
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]
        sage: Ha=HM(2,2,'a').elementwise_exponent(x); Hb=HM(2,2,'b'); GProdII([Ha, Hb], prod, [x], 0)
        [[a00^b00*a01^b10, a00^b01*a01^b11], [a10^b00*a11^b10, a10^b01*a11^b11]]
        sage: sz=3; l=2; Lx=var_list('x',l); La=HM(sz,l,'a').list(); Lb=HM(sz,l,'b').list(); Lc=var_list('c',sz); z=var('z')
        sage: F=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]),La+Lx+Lb+Lc+[z])
        sage: F.<a00, a10, a20, a01, a11, a21, x0, x1, b00, b10, b20, b01, b11, b21, c0, c1, c2, z>=FreeAlgebra(QQ,len(La+Lx+Lb+Lc+[z]))
        sage: Ha=HM(sz,l,[a00, a10, a20, a01, a11, a21]); Hx=HM(l,1,[x0, x1])
        sage: Hb=HM(sz,l,[b00, b10, b20, b01, b11, b21])
        sage: Hr=Ha.elementwise_product(z*Hb)-HM(sz,1,[c0, c1, c2])*HM(1,l,[QQ(1/2) for i in rg(l)])
        sage: GProdII([Hr, Hx], sum, [z], 0).printHM()
        [:, :]=
        [-c0 + a00*x0*b00 + a01*x1*b01]
        [-c1 + a10*x0*b10 + a11*x1*b11]
        [-c2 + a20*x0*b20 + a21*x1*b21]


    AUTHORS:
    - Edinah K. Gnang
    """
    return GeneralHypermatrixProductV(Lh, Op, Lv, indx)


def GProdB(Lh, Op, F):
    """
    Outputs an HM whose entries are themselves hypermatrices
    providing a construct approach to the general Bhattacharya-Mesner
    product with non-trivial background hypermatrix. This code emphasizes
    the outer product picture. The function is currently implemented
    having the sum as the combinator input noted  Op  and the composer
    input noted F is the general BM product.
    Note that one must be careful here with the combinator because of
    the conformablity issue. The sum combinator is currently the safe
    bet.
    This implementation in theory captures the full scope of
    the construct products subsequently implemented here but in 
    practice is hard for to specify arbitrary composers for F.
    The code only handles the Hypermatrix HM class objects.


    EXAMPLES:

    ::

        sage: AlphaB=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        sage: sz=2; A=HM(sz,1,[HM(1,sz,var_list(AlphaB[i],sz)) for i in rg(sz)]); B=HM(1,sz,[HM(sz,1,var_list(AlphaB[sz+j],sz)) for j in rg(sz)])
        sage: C=HM(sz,sz,AlphaB[2*sz]) # Initialization of the Background hypermatrix
        sage: GProdB([A, B, C], sum, ProdB)
        [[[[a0*c0*e00 + a0*c1*e01 + a1*c0*e10 + a1*c1*e11]], [[a0*d0*e00 + a0*d1*e01 + a1*d0*e10 + a1*d1*e11]]], [[[b0*c0*e00 + b0*c1*e01 + b1*c0*e10 + b1*c1*e11]], [[b0*d0*e00 + b0*d1*e01 + b1*d0*e10 + b1*d1*e11]]]]
        sage: Hr=GProdB([A, B, C], sum, ProdB); D=HM(sz,sz,[Hr[i,j][0,0] for j in rg(sz) for i in rg(sz)]); D.printHM()
        [:, :]=
        [a0*c0*e00 + a0*c1*e01 + a1*c0*e10 + a1*c1*e11 a0*d0*e00 + a0*d1*e01 + a1*d0*e10 + a1*d1*e11]
        [b0*c0*e00 + b0*c1*e01 + b1*c0*e10 + b1*c1*e11 b0*d0*e00 + b0*d1*e01 + b1*d0*e10 + b1*d1*e11]
        sage: sz=2; A=HM(sz,1,[HM(1,sz,var_list(AlphaB[i],sz)) for i in rg(sz)]); B=HM(1,sz,[HM(sz,1,var_list(AlphaB[sz+j],sz)) for j in rg(sz)])
        sage: Hr=GProdB([A, B, HM(2,sz,'kronecker')], sum, ProdB); D=HM(sz,sz,[Hr[i,j][0,0] for j in rg(sz) for i in rg(sz)]); D.printHM()
        [:, :]=
        [a0*c0 + a1*c1 a0*d0 + a1*d1]
        [b0*c0 + b1*c1 b0*d0 + b1*d1]
        sage: sz=2 # Initialization of the size parameter
        sage: A=HM(sz,1,sz,[HM(1,sz,1,var_list(AlphaB[0*sz^2+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: B=HM(sz,sz,1,[HM(1,1,sz,var_list(AlphaB[1*sz^2+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: C=HM(1,sz,sz,[HM(sz,1,1,var_list(AlphaB[2*sz^3+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: D=HM(sz,sz,sz,'d') # Initialization of the background matrix
        sage: Ht=GProdB([A, B, C, D], sum, ProdB); E=HM(sz,sz,sz,[Ht[i,j,k][0,0,0] for k in rg(sz) for j in rg(sz) for i in rg(sz)]); E.printHM()
        [:, :, 0]=
        [a0*d000*e0*q0 + a1*d100*e0*q0 + a0*d010*e1*q0 + a1*d110*e1*q0 + a0*d001*e0*q1 + a1*d101*e0*q1 + a0*d011*e1*q1 + a1*d111*e1*q1 a0*d000*f0*s0 + a1*d100*f0*s0 + a0*d010*f1*s0 + a1*d110*f1*s0 + a0*d001*f0*s1 + a1*d101*f0*s1 + a0*d011*f1*s1 + a1*d111*f1*s1]
        [c0*d000*g0*q0 + c1*d100*g0*q0 + c0*d010*g1*q0 + c1*d110*g1*q0 + c0*d001*g0*q1 + c1*d101*g0*q1 + c0*d011*g1*q1 + c1*d111*g1*q1 c0*d000*h0*s0 + c1*d100*h0*s0 + c0*d010*h1*s0 + c1*d110*h1*s0 + c0*d001*h0*s1 + c1*d101*h0*s1 + c0*d011*h1*s1 + c1*d111*h1*s1]
        <BLANKLINE>
        [:, :, 1]=
        [b0*d000*e0*r0 + b1*d100*e0*r0 + b0*d010*e1*r0 + b1*d110*e1*r0 + b0*d001*e0*r1 + b1*d101*e0*r1 + b0*d011*e1*r1 + b1*d111*e1*r1 b0*d000*f0*t0 + b1*d100*f0*t0 + b0*d010*f1*t0 + b1*d110*f1*t0 + b0*d001*f0*t1 + b1*d101*f0*t1 + b0*d011*f1*t1 + b1*d111*f1*t1]
        [d0*d000*g0*r0 + d1*d100*g0*r0 + d0*d010*g1*r0 + d1*d110*g1*r0 + d0*d001*g0*r1 + d1*d101*g0*r1 + d0*d011*g1*r1 + d1*d111*g1*r1 d0*d000*h0*t0 + d1*d100*h0*t0 + d0*d010*h1*t0 + d1*d110*h1*t0 + d0*d001*h0*t1 + d1*d101*h0*t1 + d0*d011*h1*t1 + d1*d111*h1*t1]
        <BLANKLINE>
        sage: AlphaB=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        sage: sz=2 # Initialization of the size parameter
        sage: A=HM(sz,1,sz,[HM(1,sz,1,var_list(AlphaB[0*sz^2+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: B=HM(sz,sz,1,[HM(1,1,sz,var_list(AlphaB[1*sz^2+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: C=HM(1,sz,sz,[HM(sz,1,1,var_list(AlphaB[2*sz^3+sz*i+j],sz)) for j in rg(sz) for i in rg(sz)])
        sage: Ht=GProdB([A, B, C, HM(3, sz, 'kronecker')], sum, ProdB); E=HM(sz,sz,sz,[Ht[i,j,k][0,0,0] for k in rg(sz) for j in rg(sz) for i in rg(sz)]); E.printHM()
        [:, :, 0]=
        [a0*e0*q0 + a1*e1*q1 a0*f0*s0 + a1*f1*s1]
        [c0*g0*q0 + c1*g1*q1 c0*h0*s0 + c1*h1*s1]
        <BLANKLINE>
        [:, :, 1]=
        [b0*e0*r0 + b1*e1*r1 b0*f0*t0 + b1*f1*t1]
        [d0*g0*r0 + d1*g1*r1 d0*h0*t0 + d1*h1*t1]
        <BLANKLINE>


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(Lh[i]).n(i) for i in range(len(Lh)-1)]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(Lh)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(Lh) >= 2:
            t=0
            #Rh[tuple(entry)]=Op(*[[F(*[ [Lh[s][tuple(entry[0:Integer(mod(s+1,len(l)))]+[t]+entry[Integer(mod(s+2,len(l))):])] for s in range(len(l)-2)]+[Lh[len(l)-2][tuple(entry[0:len(l)-1]+[t])]]+[Lh[len(l)-1][tuple([t]+entry[1:])]]+[Lh[len(Lh)-1]] ] ) for t in range((Lh[0]).n(1))]])
            LsT=[[F( *([Lh[s][tuple(entry[0:Integer(mod(s+1,len(l)))]+[t]+entry[Integer(mod(s+2,len(l))):])] for s in range(len(l)-2)]+[Lh[len(l)-2][tuple(entry[0:len(l)-1]+[t])]]+[Lh[len(l)-1][tuple([t]+entry[1:])]]+[Lh[len(Lh)-1]]) ) for t in range((Lh[0]).n(1))]]
            Rh[tuple(entry)]=Op(*LsT)
    return Rh

def GeneralHypermatrixCyclicPermute(A):
    """
    Outputs a list of lists associated with the general
    transpose as defined by the cyclic permutation of indices.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a')
        sage: GeneralHypermatrixCyclicPermute(Ha)
        [[[a000, a100], [a001, a101]], [[a010, a110], [a011, a111]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    l = l[1:]+[l[0]]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # Performing the transpose
        Rh[tuple(entry)]=A[tuple([entry[len(entry)-1]]+entry[:len(entry)-1])]
    return Rh

def GeneralHypermatrixEntryTranspose(A,s):
    """
    Outputs a list of lists associated with the transpose of each entry
    without changing the dimention of the underlying hypermatrix.

    EXAMPLES:

    ::

        sage: Ha=HM(1,1,[HM(2,2,'a')]); GeneralHypermatrixEntryTranspose(Ha, 1)[0,0]
        [[a00, a10], [a01, a11]]
        sage: L=[HM(3,1,[1,2,2]), HM(3,1,[3,4,5])]; M=HM(1, len(L), L)
        sage: (M.elementwise_transpose())[0,0].dimensions()
        [1, 3]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=(A[tuple(entry)]).transpose(s)
    return Rh

def GeneralHypermatrixScale(A,s):
    """
    Outputs a list of lists associated with the scaling of a general hypermatrix.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a')
        sage: GeneralHypermatrixScale(Ha,3)
        [[[3*a000, 3*a001], [3*a010, 3*a011]], [[3*a100, 3*a101], [3*a110, 3*a111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=s*A[tuple(entry)]
    return Rh

def GeneralHypermatrixScaleRight(A,s):
    """
    Outputs a list of lists associated with the scaling of a general hypermatrix.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a')
        sage: GeneralHypermatrixScaleRight(Ha,3)
        [[[3*a000, 3*a001], [3*a010, 3*a011]], [[3*a100, 3*a101], [3*a110, 3*a111]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=A[tuple(entry)]*s
    return Rh

def GeneralHypermatrixExponent(A,s):
    """
    Outputs a list of lists associated with the general
    whose entries are all raised to the power s.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a')
        sage: GeneralHypermatrixExponent(Ha,3)
        [[[a000^3, a001^3], [a010^3, a011^3]], [[a100^3, a101^3], [a110^3, a111^3]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the computations of the entries
    for i in range(prod(l)):
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if A[tuple(entry)].is_zero():
            Rh[tuple(entry)] = 0
        else:
            Rh[tuple(entry)] = (A[tuple(entry)])^s
    return Rh

def GeneralHypermatrixBaseExponent(A,s):
    """
    Outputs a list of lists associated with the general
    whose entries are exponentiated using the input s as
    basis for the exponentiation.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a')
        sage: GeneralHypermatrixBaseExponent(Ha,3)
        [[[3^a000, 3^a001], [3^a010, 3^a011]], [[3^a100, 3^a101], [3^a110, 3^a111]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=s^(A[tuple(entry)])
    return Rh

def GeneralHypermatrixBaseExponentN(A,s, dgts=50):
    """
    Outputs a list of lists associated with the general
    whose entries are exponentiated using the input s as
    basis for the numerical exponentiation.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,[1,2,3,4]); GeneralHypermatrixBaseExponentN(Ha,3)
        [[3.0000000000000, 27.000000000000], [9.0000000000000, 81.000000000000]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=ComplexField(dgts)(s)^ComplexField(dgts)(A[tuple(entry)])
    return Rh

def GeneralHypermatrixLogarithm(A,s=e):
    """
    Outputs a list of lists associated with the general
    whose entries are logarithms to the base s of the 
    original hypermatrix.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); GeneralHypermatrixLogarithm(Ha,3)
        [[[log(a000)/log(3), log(a001)/log(3)], [log(a010)/log(3), log(a011)/log(3)]], [[log(a100)/log(3), log(a101)/log(3)], [log(a110)/log(3), log(a111)/log(3)]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=log(A[tuple(entry)],s).canonicalize_radical()
    return Rh

def GeneralHypermatrixLogarithmN(A,s=e, dgts=50):
    """
    Outputs a list of lists associated with the general
    whose entries are numerical logarithms to the base s of the 
    original hypermatrix.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,[1,2,3,4]); GeneralHypermatrixLogarithmN(Ha,3)
        [[0.00000000000000, 1.0000000000000], [0.63092975357146, 1.2618595071429]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=ComplexField(dgts)(log(A[tuple(entry)],s))
    return Rh

def GeneralHypermatrixApplyMap(A, phi):
    """
    Apply the given map phi (an arbitrary Python function or callable
    object) to this hypermatrix.
    

    INPUT:

    -  ``phi`` - arbitrary Python function or callable object


    OUTPUT: a symbolic hypermatrix

    EXAMPLES::

        sage: A = HM(2,2,'a')
        sage: phi = lambda x: sin(x)
        sage: GeneralHypermatrixApplyMap(A, phi).matrix()
        [sin(a00) sin(a01)]
        [sin(a10) sin(a11)]

    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the computations of the entries
    for i in range(prod(l)):
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if A[tuple(entry)].is_zero():
            Rh[tuple(entry)] = 0
        else:
            Rh[tuple(entry)] = phi(A[tuple(entry)])
    return Rh

def GeneralHypermatrixConjugate(A):
    """
    Outputs a list of lists associated with the general
    whose entries are complex conjugates of the original
    hypermatrix.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,[exp(I*2*pi*u*v*w/4) for u in range(2) for v in range(2) for w in range(2)])
        sage: GeneralHypermatrixConjugate(Ha)
        [[[1, 1], [1, 1]], [[1, 1], [1, -I]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=conjugate(A[tuple(entry)])
    return Rh

def GeneralHypermatrixExpand(A):
    """
    Outputs a list of lists associated with the general
    hypermatrix with expressions in the entries in their
    expanded form.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,[(var('x')+var('y'))^(i+j+k) for i in range(2) for j in range(2) for k in range(2)])
        sage: GeneralHypermatrixExpand(Ha)
        [[[1, x + y], [x + y, x^2 + 2*x*y + y^2]], [[x + y, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^3 + 3*x^2*y + 3*x*y^2 + y^3]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=(A[tuple(entry)]).expand()
    return Rh

def GeneralHypermatrixFactor(A):
    """
    Outputs a list of lists associated with the general
    hypermatrix with expressions in the entries in their
    factored form.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: sz=2; vx=HM(sz,'x').list(); vy=HM(sz,'y').list(); vz=HM(sz,'z').list()
        sage: X=HM(sz, 1, sz, [vx[u] for v in range(sz) for t in range(1) for u in range(sz)])
        sage: Y=HM(sz, 1, sz, [vy[u] for v in range(sz) for t in range(1) for u in range(sz)])
        sage: Z=HM(sz, 1, sz, [vz[u] for v in range(sz) for t in range(1) for u in range(sz)])
        sage: A=Prod(X, Y.transpose(2), Z.transpose())
        sage: GeneralHypermatrixFactor(Prod(A,A,A))
        [[[(x0*y0*z0 + x1*y1*z1)*x0^2*y0^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x0^2*y0^2*z1^2], [(x0*y0*z0 + x1*y1*z1)*x0^2*y1^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x0^2*y1^2*z1^2]], [[(x0*y0*z0 + x1*y1*z1)*x1^2*y0^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x1^2*y0^2*z1^2], [(x0*y0*z0 + x1*y1*z1)*x1^2*y1^2*z0^2, (x0*y0*z0 + x1*y1*z1)*x1^2*y1^2*z1^2]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=(A[tuple(entry)]).factor()
    return Rh

def GeneralHypermatrixSimplifyFull(A):
    """
    Performs the symbolic simplification of the expressions
    associated with the hypermatrix entries. 

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); ((x+y)^2*HM(2,2,2,'one')).simplify_full()
        [[[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]], [[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]]]
 

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if type(Integer(0)) != type(A[tuple(entry)]):
            Rh[tuple(entry)]=(A[tuple(entry)]).simplify_full()
        else:
            Rh[tuple(entry)]=A[tuple(entry)]
    return Rh

def GeneralHypermatrixSimplify(A):
    """
    Performs the symbolic simplification of the expressions
    associated with the hypermatrix entries. 

    EXAMPLES:

    ::

        sage: x,y=var('x,y'); GeneralHypermatrixSimplify((x+y)^2*HM(2,2,2,'one'))
        [[[(x + y)^2, (x + y)^2], [(x + y)^2, (x + y)^2]], [[(x + y)^2, (x + y)^2], [(x + y)^2, (x + y)^2]]]
 

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if type(Integer(0)) != type(A[tuple(entry)]):
            Rh[tuple(entry)]=(A[tuple(entry)]).simplify()
        else:
            Rh[tuple(entry)]=A[tuple(entry)]
    return Rh

def GeneralHypermatrixCanonicalizeRadical(A):
    """
    Performs the symbolic simplification of the expressions
    associated with the hypermatrix entries. 

    EXAMPLES:

    ::

        sage: x,y = var('x,y') 
        sage: GeneralHypermatrixCanonicalizeRadical((x+y)^2*HM(2,2,2,'one'))
        [[[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]], [[x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2], [x^2 + 2*x*y + y^2, x^2 + 2*x*y + y^2]]]

    AUTHORS:

    - Edinah K. Gnang
    """

    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if type(Integer(0)) != type(A[tuple(entry)]):
            Rh[tuple(entry)]=(A[tuple(entry)]).canonicalize_radical()
        else:
            Rh[tuple(entry)]=A[tuple(entry)]
    return Rh

def GeneralHypermatrixNumerical(A, dgts=15):
    """
    Performs the symbolic simplification of the expressions
    associated with the hypermatrix entries. 


    EXAMPLES:

    ::

        sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
        sage: GeneralHypermatrixNumerical(Ha)
        [[1.00000000000000, 1.00000000000000, 1.00000000000000], [1.00000000000000, -0.500000000000000 + 0.866025403784439*I, -0.500000000000000 - 0.866025403784439*I], [1.00000000000000, -0.500000000000000 - 0.866025403784439*I, -0.500000000000000 + 0.866025403784439*I]] 
         

    AUTHORS:

    - Edinah K. Gnang
    """

    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=N(A[tuple(entry)], digits=dgts)
    return Rh

def GeneralHypermatrixReal(A):
    """
    Returns the real part of the input 
    hypermatrix.


    EXAMPLES:

    ::

        sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
        sage: GeneralHypermatrixReal(Ha)
        [[1, 1, 1], [1, -1/2, -1/2], [1, -1/2, -1/2]] 
         

    AUTHORS:

    - Edinah K. Gnang
    """

    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=real(A[tuple(entry)])
    return Rh

def GeneralHypermatrixImag(A):
    """
    Returns the imaginary part of the input 
    hypermatrix.


    EXAMPLES:

    ::

        sage: Ha=HM(3,3,[exp(I*2*pi*u*v/3) for v in range(3) for u in range(3)]) 
        sage: GeneralHypermatrixImag(Ha)
        [[0, 0, 0], [0, 1/2*sqrt(3), -1/2*sqrt(3)], [0, -1/2*sqrt(3), 1/2*sqrt(3)]] 
         

    AUTHORS:

    - Edinah K. Gnang
    """

    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=imag(A[tuple(entry)])
    return Rh


def GeneralHypermatrixSubstitute(A, Dct):
    """
    Procedure for computes the substitution in the Hypermatrix entries
    the inputs are the corresponding Hypermatric and a dictionary 
    datastructure.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixSubstitute(HM(3,2,'a','sym'), dict([(var('a011'),var('x')),(var('a001'),var('y')),(var('a000'),var('z')),(var('a111'),var('t'))]))
        [[[z, y], [y, x]], [[y, x], [x, t]]]


    AUTHORS:

    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=(A[tuple(entry)]).subs(Dct)
    return Rh

def GeneralHypermatrixSubstituteN(A, Dct):
    """
    Procedure for computes the substitution in the Hypermatrix entries
    the inputs are the corresponding Hypermatric and a dictionary 
    datastructure.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixSubstituteN(HM(3,2,'a','sym'),dict([(var('a011'),1),(var('a001'),2),(var('a000'),3),(var('a111'),4)]))
        [[[3.00000000000000, 2.00000000000000], [2.00000000000000, 1.00000000000000]], [[2.00000000000000, 1.00000000000000], [1.00000000000000, 4.00000000000000]]]
        


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=N((A[tuple(entry)]).subs(Dct))
    return Rh

def GeneralHypermatrixSubstituteII(A, *args, **kwds):
    """
    Procedure for computes the substitution in the Hypermatrix entries
    the inputs are the corresponding Hypermatric and a dictionary 
    datastructure.

    EXAMPLES:

    ::

        sage: a,b,d,e=var('a,b,d,e'); M=HM([[a,b],[d,e]])
        sage: GeneralHypermatrixSubstituteII(M,a=1)
        [[1, b], [d, e]]
        sage: GeneralHypermatrixSubstituteII(M, a=b, b=d)
        [[b, d], [d, e]]
        sage: GeneralHypermatrixSubstituteII(M, {a: 3, b:2, d:1, e:-1})
        [[3, 2], [1, -1]]
        

    AUTHORS:

    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=(A[tuple(entry)]).subs(*args, **kwds)
    return Rh

def GeneralHypermatrixCopy(A):
    """
    Procedure for performing a Hypermatrix copy.

    EXAMPLES:

    ::

        sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b'); GeneralHypermatrixCopy(A+B)
        [[[a000 + b000, a001 + b001], [a010 + b010, a011 + b011]], [[a100 + b100, a101 + b101], [a110 + b110, a111 + b111]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=A[tuple(entry)]
    return Rh

def GeneralHypermatrixAppendIndex(A,indx):
    """
    Procedure for computing Hypermatrix Hadamard addition.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixAppendIndex(HM(2,2,'a','shift'),1)
        [[a111, a121], [a211, a221]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=var(str(A[tuple(entry)])+str(indx))
    return Rh

def List2Hypermatrix(*args):
    """
    Procedure for Initializing a Hypermatrix from a size specifications and a list

    EXAMPLES:

    ::

        sage: A = List2Hypermatrix(2,2,2,HM(2,2,2,'a').list()); A
        [[[a000, a001], [a010, a011]], [[a100, a101], [a110, a111]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = args[:-1]
    # Initialization of the list
    Lst =args[-1]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = [j for j in l]+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=Lst[i]
    return Rh

def GeneralHypermatrixAdd(A,B):
    """
    Procedure for computing Hypermatrix Hadamard addition.

    EXAMPLES:

    ::

        sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b'); GeneralHypermatrixAdd(A,B)
        [[[a000 + b000, a001 + b001], [a010 + b010, a011 + b011]], [[a100 + b100, a101 + b101], [a110 + b110, a111 + b111]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # The if statement bellow address the sum function
    if B == 0:
        tl = [A.n(i) for i in range(A.order())]+['zero']
        B = HM(*tl)
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    s = [B.n(i) for i in range(B.order())]
    # Testing the dimensions 
    x = var('x')
    if(sum([l[i]*x^i for i in range(len(l))])==sum([s[i]*x^i for i in range(len(s))])):
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=A[tuple(entry)]+B[tuple(entry)]
        return Rh
    else:
        raise ValueError("The Dimensions of the input hypermatrices must match.")
 
def GeneralHypermatrixHadamardProduct(A,B):
    """
    Procedure for computing Hypermatrix Hadamard products.

    EXAMPLES:

    ::

        sage: A=HM(2,2,2,'a'); B=HM(2,2,2,'b')
        sage: GeneralHypermatrixHadamardProduct(A,B)
        [[[a000*b000, a001*b001], [a010*b010, a011*b011]], [[a100*b100, a101*b101], [a110*b110, a111*b111]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    s = [B.n(i) for i in range(B.order())]
    # Testing the dimensions 
    x = var('x')
    if(sum([l[i]*x^i for i in range(len(l))])==sum([s[i]*x^i for i in range(len(s))])):
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=A[tuple(entry)]*B[tuple(entry)]
        return Rh
    else:
        raise ValueError("The Dimensions of the input hypermatrices must match.")

def GeneralHypermatrixHadamardExponent(A,B):
    """
    Procedure for computing Hypermatrix elementwise exponent of two input hypermatrices.

    EXAMPLES:

    ::

        sage: A = HM(2,2,2,'a');B = HM(2,2,2,'b')
        sage: GeneralHypermatrixHadamardExponent(A,B) 
        [[[a000^b000, a001^b001], [a010^b010, a011^b011]], [[a100^b100, a101^b101], [a110^b110, a111^b111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    s = [B.n(i) for i in range(B.order())]
    # Testing the dimensions 
    x = var('x')
    if(sum([l[i]*x^i for i in range(len(l))])==sum([s[i]*x^i for i in range(len(s))])):
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=A[tuple(entry)]^B[tuple(entry)]
        return Rh
    else:
        raise ValueError("The Dimensions of the input hypermatrices must match.")

def GeneralHypermatrixKroneckerDelta(od, sz):
    """
    Outputs a list of lists associated with the general
    Kronecter delta hypermatrix
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Dlt = GeneralHypermatrixKroneckerDelta(2,2); Dlt
        [[1, 0], [0, 1]] 
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [sz for i in range(od)] 
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if len(Set(entry)) == 1:
            Rh[tuple(entry)] = 1
    return Rh

def GeneralHypermatrixMainDiag(od, Lv):
    """
    Outputs a list of lists associated with the general
    Kronecter delta type hypermatrix using the entries of
    list Lv as elements to be placed on the main diagonal
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Dlt = GeneralHypermatrixMainDiag(2, HM(2,'x').list()); Dlt
        [[x0, 0], [0, x1]] 
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the size parameter
    sz=len(Lv)
    # Initialization of the list specifying the dimensions of the output
    l = [sz for i in range(od)] 
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Initializing the index
    Indx=0
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if len(Set(entry)) == 1:
            Rh[tuple(entry)] = Lv[Indx]
            Indx=Indx+1
    return Rh

def GeneralHypermatrixKroneckerDeltaL(od, sz):
    """
    Outputs a list of lists associated with the general
    Kronecter delta hypermatrix
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: L = GeneralHypermatrixKroneckerDeltaL(2,2); L
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    L=[]
    for t in range(sz):
        # Initialization of the list specifying the dimensions of the output
        l = [sz for i in range(od)] 
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            if Set(entry).list() == [t]:
                Rh[tuple(entry)] = 1
        L.append(Rh)
    return L

def GeneralUncorrelatedHypermatrixTupleU(od):
    """
    Generates a tuplet of hypermatrices of the appropriate order which are
    uncorrelated but I do not normalize them. Each one of the dimensions are equal to 2.

    EXAMPLES:

    ::

        sage: [A,B]=GeneralUncorrelatedHypermatrixTupleU(2)
        sage: A
        [[e^(I*pi + r1 - r2 + r6), e^r6], [e^(I*pi + r3 - r4 + r5), e^r5]]
        sage: B
        [[e^r4, e^r2], [e^r3, e^r1]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization the alphabet list
    AlphaB = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    # Initializing the hypermatrix
    LQ = [HM(*([2 for i in range(od)]+[AlphaB[j]])).elementwise_base_exponent(e) for j in range(od)]
    # Initilizing the list of variable
    VrbLst = []
    for Q in LQ:
        VrbLst = VrbLst + (Q.elementwise_base_logarithm(e)).list()
    # Computing the product
    Eq = GeneralHypermatrixProduct(*[Q for Q in LQ])
    # Writting up the constraints
    LeQ = (Eq.list())[1:2^od-1]
    # Filling up the linear constraints
    CnstrLst= [] 
    for f in LeQ:
        CnstrLst.append(ln((f.operands())[0]).canonicalize_radical()-I*pi-ln((f.operands())[1]).canonicalize_radical()==0)
    # Directly solving the constraints
    Sl = solve(CnstrLst, VrbLst)
    # Setting up the list for the dictionary
    Dct = [(eq.lhs(),exp(eq.rhs())) for eq in Sl[0]]
    # Returning the uncorrelated tuplets
    return [HM(*([2 for i in range(od)]+[AlphaB[j]])).subs(dict(Dct)) for j in range(od)]

def GeneralUncorrelatedHypermatrixTuple(L):
    """
    Generates a list of uncorealted hypermatrix tuples whose entries are rational functions
    in the entries of the three input hypermatrices. The input hypermatrices are assumed
    to be symbolic. The product of the output hypermatrices is a Kronecker delta.

    EXAMPLES:

    ::

        sage: sz=2; [A,B]=GeneralUncorrelatedHypermatrixTuple([HM(sz,sz,'u'),HM(sz,sz,'v')]); Prod(A,B).simplify_full()
        [[1, 0], [0, 1]]
        sage: sz=2; [A,B,C]=GeneralUncorrelatedHypermatrixTuple([HM(sz,sz,sz,'u'),HM(sz,sz,sz,'v'),HM(sz,sz,sz,'w')]); Prod(A,B,C).simplify_full()
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order parameter
    od=Integer(len(L)); sz=Integer(2)
    # Initialization of the Kronecker projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Initialization of the Kronecler delta
    Dlt=sum(DltL)
    # Initialization of the left and right hypermatrix
    Hl=(HM(*([sz for i in range(od)]+['one']))-Dlt).elementwise_product(ProdB(*(L+[DltL[Integer(0)]])))
    Hr=(HM(*([sz for i in range(od)]+['one']))-Dlt).elementwise_product(ProdB(*(L+[DltL[Integer(1)]]))).elementwise_exponent(-1)
    # Initialization of the list of variables
    VrbL=[]
    for i in rg(od):
        VrbL=VrbL+L[i].list()
    # Initialization of the list of constraints
    EqL=[]
    # Initialization of the list of integers
    iL=List_of_Integers([sz for i in rg(od)])[1:-1]
    # Looping through the non diagonal entries
    for l in iL:
        EqL.append(Hl.elementwise_product(Hr)[tuple(l)]==exp(sqrt(-1)*pi))
    # Formating the constraints
    [A,b]=multiplicativeConstraintFormatorHM(EqL, VrbL)
    # Solving the constraints
    Mv=HM(A.ncols(),1,VrbL)
    Sln=multiplicative_linear_solverHM(A,b,Mv,Mv)
    # Performing the substitutions
    sL=[L[i].subs(Sln) for i in rg(od)]
    # Initializing the product
    Pd=Prod(*sL)
    # Updating the third hypermatrix for normalization purposes
    for i in rg(sz):
        sL[od-1][tuple([i]+[0 for i in rg(od-1)])]=sL[od-1][tuple([i]+[0 for i in rg(od-1)])]/Pd[tuple([0 for i in rg(od)])]
        sL[od-1][tuple([i]+[1 for i in rg(od-1)])]=sL[od-1][tuple([i]+[1 for i in rg(od-1)])]/Pd[tuple([1 for i in rg(od)])]
    return sL

def GeneralOrthogonalHypermatrixU(od):
    """
    Generates an orthogonal hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized.

    EXAMPLES:

    ::

        sage: Q=GeneralOrthogonalHypermatrixU(3); Rs=Prod(Q,Q.transpose(2),Q.transpose())
        sage: [Rs[i,j,k] for k in range(2) for j in range(2) for i in range(2) if i!=j or j!=k or i!=k]
        [0, 0, 0, 0, 0, 0]


    AUTHORS:

    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    # Initializing the hypermatrix
    #Q=apply(HM,[2 for i in range(od)]+['q'])
    Q=HM(*[2 for i in range(od)]+['q'])
    # Initilizing the list of variable
    VrbLst=Q.list()
    # Reinitializing of Q by exponentiation 
    Q=Q.elementwise_base_exponent(e)
    # Computing the product
    Eq=GeneralHypermatrixProduct(*[Q.transpose(j) for j in range(od,0,-1)])
    # Writting up the constraints
    LeQ=(Set(Eq.list())).list()
    # Removing the normalization constraints
    LeQ.remove(e^(od*var('q'+''.join(['0' for i in range(od)])))+e^(od*var('q01'+''.join(['0' for i in range(od-2)]))))
    LeQ.remove( e^(od*var('q10'+''.join(['1' for i in range(od-2)])))+e^(od*var('q'+''.join(['1' for i in range(od)]))))
    # Filling up the linear constraints
    CnstrLst= [] 
    for f in LeQ:
        CnstrLst.append(ln((f.operands())[0]).canonicalize_radical()-I*pi-ln((f.operands())[1]).canonicalize_radical()==0)
    # Directly solving the constraints
    Sl = solve(CnstrLst,VrbLst)
    # Main loop performing the substitution of the entries
    Lr = [var('r'+str(i)) for i in range(1,2^od+1)]
    l = [Q.n(i) for i in range(Q.order())]
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Q[tuple(entry)]=Q[tuple(entry)].subs(dict(map(lambda eq: (eq.lhs(),eq.rhs()), Sl[0]))).canonicalize_radical()
    return Q

def GeneralOrthogonalHypermatrix(od):
    """
    Generates an orthogonal hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized.

    EXAMPLES:

    ::

        sage: Q=GeneralOrthogonalHypermatrix(3); Prod(Q,Q.transpose(2),Q.transpose()).simplify_full()
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]


    AUTHORS:

    - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
    """
    if od == 2:
        nrm = sqrt(exp(2*var('r1'))+exp(2*var('r2')))
        return HM([[exp(var('r1'))/nrm, exp(var('r2'))/nrm],[-exp(var('r2'))/nrm, exp(var('r1'))/nrm]])
    else :
        # Initializing the hypermatrix
        #Q = apply(HM,[2 for i in range(od)]+['q'])
        Q = HM(*[2 for i in range(od)]+['q'])
        # Initilizing the list of variable
        VrbLst = Q.list()
        # Reinitializing of Q by exponentiation 
        Q = Q.elementwise_base_exponent(e)
        # Computing the product
        Eq = GeneralHypermatrixProduct(*[Q.transpose(j) for j in range(od,0,-1)])
        # Writting up the constraints
        LeQ = (Set(Eq.list())).list()
        # Removing the normalization constraints
        LeQ.remove(e^(od*var('q'+''.join(['0' for i in range(od)])))+ e^(od*var('q01'+''.join(['0' for i in range(od-2)]))))
        LeQ.remove( e^(od*var('q10'+''.join(['1' for i in range(od-2)])))+ e^(od*var('q'+''.join(['1' for i in range(od)]))))
        # Filling up the linear constraints
        CnstrLst= [] 
        for f in LeQ:
            CnstrLst.append(ln((f.operands())[0]).canonicalize_radical()-I*pi-ln((f.operands())[1]).canonicalize_radical()==0)
        # Directly solving the constraints
        Sl = solve(CnstrLst,VrbLst)
        # Main loop performing the substitution of the entries
        Lr = [var('r'+str(i)) for i in range(1,2^od+1)]
        l = [Q.n(i) for i in range(Q.order())]
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Q[tuple(entry)]=Q[tuple(entry)].subs(dict(map(lambda eq: (eq.lhs(),eq.rhs()), Sl[0]))).canonicalize_radical()
        # Initialization of the output hypermatrix
        U = GeneralHypermatrixCopy(Q)
        # first row to normalize 
        entry = [0 for i in range(Q.order())]
        U[tuple(entry)]=Q[tuple(entry)]/sum([ Q[tuple([entry[0]]+[j]+entry[2:])]^Q.order() for j in range(2) ])^(1/Q.order())
        entry[1] = 1
        U[tuple(entry)]=Q[tuple(entry)]/sum([ Q[tuple([entry[0]]+[j]+entry[2:])]^Q.order() for j in range(2) ])^(1/Q.order())
        # last row to normalize 
        entry = [1 for i in range(Q.order())]
        U[tuple(entry)]=Q[tuple(entry)]/sum([ Q[tuple([entry[0]]+[j]+entry[2:])]^Q.order() for j in range(2) ])^(1/Q.order())
        entry[1] = 0
        U[tuple(entry)]=Q[tuple(entry)]/sum([ Q[tuple([entry[0]]+[j]+entry[2:])]^Q.order() for j in range(2) ])^(1/Q.order())
    return U

def GeneralUnitaryHypermatrixU(od):
    """
    Generates an unitary hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized. The order input od
    must be even for the function call to be meaningful.

    EXAMPLES:

    ::

        sage: [A, Ac]=GeneralUnitaryHypermatrixU(4); Rs=(Prod(A,Ac.transpose(3),A.transpose(2),Ac.transpose())).simplify()
        sage: [Rs[i,j,k,l] for l in range(2) for k in range(2) for j in range(2) for i in range(2) if i!=j or j!=k or k!=l or i!=k or i!=l or j!=k]
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the variable playing the role of sqrt(-1)
    z=var('z')
    # Initializing the real part and the imaginary part
    #X=apply(HM,[2 for i in range(od)]+['x']); Y=apply(HM,[2 for i in range(od)]+['y'])
    X=HM(*([2 for i in range(od)]+['x'])); Y=HM(*([2 for i in range(od)]+['y']))
    # Initialization of the list
    Lh = [(X+z*Y).elementwise_base_exponent(e), (X-z*Y).elementwise_base_exponent(e)]
    # Computation of the Product.
    #B = apply(Prod,[Lh[Integer(mod(i,2))].transpose(i) for i in range(od,0,-1)])
    B = Prod(*[Lh[Integer(mod(i,2))].transpose(i) for i in range(od,0,-1)])
    B[tuple([0 for i in range(od)])]=0; B[tuple([1 for i in range(od)])]=0
    # Initializing the list
    L=Set(B.list()).list()
    # Removing the normalization constraints
    L.remove(0)
    # Initialization of the variables.
    Vrbls =X.list()+Y.list() 
    # Initialization of the non homogeneous equations
    Eq =[(log((l.operands())[0])).simplify_log().subs(z=0) - (log((l.operands())[1])).simplify_log().subs(z=0) == 0 for l in L]+[(log((l.operands())[0])).simplify_log().coefficient(z) - (log((l.operands())[1])).simplify_log().coefficient(z)==pi for l in L]
    # Calling the constraint formator
    [A,b]=ConstraintFormatorII(Eq,Vrbls)
    # Setting the signs right
    V = A.kernel().basis()
    for i in range(Integer(len(V)/2),len(V)):
        # Initilization of the index locators
        c1=-1; c2=-1
        for j in range(len(V[i])):
            if V[i][j] == 1 and c1 == -1:
                c1=j
            elif V[i][j] == 1 and c1 != -1:
                c2=j
                break
        b[c2,0] = -b[c2,0]
    # Rewriting the system
    Eq = [(A*Matrix(SR,len(Vrbls),1,Vrbls))[i,0]==b[i,0] for i in range(A.nrows())]
    # Computing the Homogeneous solution
    Sln = solve(Eq,Vrbls)[0]
    X = X.subs(dict([(s.lhs(),s.rhs()) for s in Sln]))
    Y = Y.subs(dict([(s.lhs(),s.rhs()) for s in Sln]))
    # Final result
    return [(X+I*Y).elementwise_base_exponent(e), (X-I*Y).elementwise_base_exponent(e)]

def GeneralUnitaryHypermatrix(od):
    """
    Generates an unitary hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized.

    EXAMPLES:

    ::

        sage: [A, Ac]=GeneralUnitaryHypermatrix(4)
        sage: (Prod(A, Ac.transpose(3), A.transpose(2), Ac.transpose())).simplify_full()
        [[[[1, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 1]]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    Lh=GeneralUnitaryHypermatrixU(od)
    Tp=Prod(*[Lh[Integer(mod(i,2))].transpose(i) for i in range(od,0,-1)])
    Q =Lh[0].copy()
    Qc=Lh[1].copy()
    # first row to normalize 
    entry=[0 for i in range(Q.order())]
    Q[tuple(entry)]=Q[tuple(entry)]/(Tp[tuple([0 for i in range(Q.order())])])^(1/od)
    Qc[tuple(entry)]=Qc[tuple(entry)]/(Tp[tuple([0 for i in range(Q.order())])])^(1/od)
    entry[1]=1
    Q[tuple(entry)]=Q[tuple(entry)]/(Tp[tuple([0 for i in range(Q.order())])])^(1/od)
    Qc[tuple(entry)]=Qc[tuple(entry)]/(Tp[tuple([0 for i in range(Q.order())])])^(1/od)
    # last row to normalize 
    entry=[1 for i in range(Q.order())]
    Q[tuple(entry)]=Q[tuple(entry)]/(Tp[tuple([1 for i in range(Q.order())])])^(1/od)
    Qc[tuple(entry)]=Qc[tuple(entry)]/(Tp[tuple([1 for i in range(Q.order())])])^(1/od)
    entry[1]=0
    Q[tuple(entry)]=Q[tuple(entry)]/(Tp[tuple([1 for i in range(Q.order())])])^(1/od)
    Qc[tuple(entry)]=Qc[tuple(entry)]/(Tp[tuple([1 for i in range(Q.order())])])^(1/od)
    # Final result
    return [Q,Qc]

def GeneralHypermatrixReduce(A, VrbL, Rlts):
    """
    Outputs a list of lists associated with the general
    hypermatrix with expressions in the entries reduced 
    modulo the input relations in the list Rlts on the
    variables VrbL. The relation are assume to be monic.


    EXAMPLES:

    ::
        
        sage: VrbL=[var('x'), var('y')]
        sage: Ha=HM(2,2,2,[(VrbL[0]+VrbL[1])^(i+j+k) for i in range(2) for j in range(2) for k in range(2)])
        sage: GeneralHypermatrixReduce(Ha, VrbL, [VrbL[0]^2-5, VrbL[1]^3-7])
        [[[1, x + y], [x + y, 2*x*y + y^2 + 5]], [[x + y, 2*x*y + y^2 + 5], [2*x*y + y^2 + 5, 3*x*y^2 + 5*x + 15*y + 7]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # Initialization of the function
        f=(A[tuple(entry)]).expand()
        # performing the reduction
        for v in range(len(VrbL)):
            for d in range(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                f=expand(fast_reduce(f,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
        Rh[tuple(entry)]=f
    return Rh

def DFT_image_resizer(sz, dm):
    """
    Generates a third order hypermatrix of 3 slices
    for performing third reduction on the size in each color
    channel.

    EXAMPLES:

    ::

        sage: DFT_image_resizer(4,2)
        [[[[1, 1, 1], [0, 0, 0], [1, 1, 1], [0, 0, 0]], [[1, 1, 1], [0, 0, 0], [-1, -1, -1], [0, 0, 0]], [[0, 0, 0], [1, 1, 1], [0, 0, 0], [1, 1, 1]], [[0, 0, 0], [1, 1, 1], [0, 0, 0], [-1, -1, -1]]],
         [[[1, 1, 1], [1, 1, 1], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 1]], [[1, 1, 1], [-1, -1, -1], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [1, 1, 1], [-1, -1, -1]]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if Integer(mod(sz,dm)) == 0:
        # Initializing the identity matrix of the appropriate size
        Idm = identity_matrix(Integer(sz/dm))
        # Computing the Kronecker product with the hadamard 2x2 matrix
        Rs = Idm.tensor_product(Matrix(SR, dm, dm, [exp(I*2*pi*u*v/dm) for u in range(dm) for v in range(dm)]))
        # Permuting the colum of the matrix in order to put the resized
        # image in the top left corner of the image
        for i in range(1,Integer(sz/dm)):
            tmp = Rs[:,i]
            Rs[:,i] = Rs[:,dm*i]
            Rs[:,dm*i] = tmp
        return [HM([[(Rs[i,:]).list() for i in range(sz)] for j in range(3)]).transpose(), HM([[((Rs.transpose())[i,:]).list() for i in range(sz)] for j in range(3)]).transpose()]
    else:
        print('Dimension mismatch !!')

def channel_product(A,B):
    """
    Performs channel specific matrix multiplication

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,3,'a'); Hb=HM(2,2,3,'b')
        sage: channel_product(Ha,Hb)
        [[[a000*b000 + a010*b100, a001*b001 + a011*b101, a002*b002 + a012*b102], [a000*b010 + a010*b110, a001*b011 + a011*b111, a002*b012 + a012*b112]], [[a100*b000 + a110*b100, a101*b001 + a111*b101, a102*b002 + a112*b102], [a100*b010 + a110*b110, a101*b011 + a111*b111, a102*b012 + a112*b112]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    P0 = HM(A.n(0),A.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            P0[i,j]=A[i,j,0]
    P1 = HM(A.n(0),A.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            P1[i,j]=A[i,j,1]
    P2 = HM(A.n(0),A.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            P2[i,j]=A[i,j,2]
    Q0 = HM(B.n(0),B.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            Q0[i,j]=B[i,j,0]
    Q1 = HM(B.n(0),B.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            Q1[i,j]=B[i,j,1]
    Q2 = HM(B.n(0),B.n(1),'zero')
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            Q2[i,j]=B[i,j,2]
    R0 = Matrix(SR,P0.listHM())*Matrix(SR,Q0.listHM())
    R1 = Matrix(SR,P1.listHM())*Matrix(SR,Q1.listHM())
    R2 = Matrix(SR,P2.listHM())*Matrix(SR,Q2.listHM())
    return HM([[(R0[i,:]).list() for i in range(A.n(1))],[(R1[i,:]).list() for i in range(A.n(1))],[(R2[i,:]).list() for i in range(A.n(1))]]).transpose()

def Matrix2HM(A):
    """
    Converts a matrix to a hypermatrix.


    EXAMPLES:

    ::

        sage: Lv=var_list('a',5)
        sage: Matrix2HM(Matrix(SR,[Lv[1:3],Lv[3:]]))
        [[a1, a2], [a3, a4]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return HM(A.nrows(), A.ncols(), [SR(v) for v in A.transpose().list()])

def Deter(A):
    """
    Computes symbolically the determinant of a square matrix
    using the sum over permutation formula.

    EXAMPLES:

    ::

        sage: Deter(HM(2,2,'m'))
        -m01*m10 + m00*m11

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the permutations
    P = Permutations(range(A.nrows()))
    return sum([Permutation([p[i]+1 for i in range(len(p))]).signature()*prod([A[k,p[k]] for k in range(A.nrows())]) for p in P])

def DeterII(A):
    """
    Computes symbolically the determinant via canonical matrix representation 
    of Grassmanian vaiables


    EXAMPLES:

    ::

        sage: DeterII(HM(2,2,'m'))
        -m01*m10 + m00*m11

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order and size parameters
    od=2; sz=A.nrows()
    # Initialization of the identity matrix
    I2=HM(od,2,'kronecker')
    # Initialization of the Pauli matrix
    s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])
    # Initialization of the center rank one matrix
    c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])
    # Initialization of the list of matrices
    Lm=[s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]
    # Computing the matrix
    M=prod(sum(A[i,j]*Lm[j] for j in rg(sz)) for i in rg(sz))
    return M[2^(sz)-1,0]

def GPer(A, k, Dct={'x':x}):
    """
    Computes symbolically the partial expansion permanent via canonical matrix representation 
    of Grassmanian vaiables


    EXAMPLES:

    ::

        sage: sz=3; M=HM(sz, sz, 'm'); expand(GPer(M, 2, dict([(str(v), v) for v in M.list()])))
        m02*m11*m20 + m01*m12*m20 - m02*m10*m21 - m00*m12*m21 + m01*m10*m22 + m00*m11*m22


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order and size parameters
    od=2; sz=A.nrows()
    # Initialization of the variables
    X=var_list('x', sz); Y=var_list('y', sz); Lc=['y'+str(i) for i in rg(sz)]
    # Initialization of the identity matrix
    I2=HM(od,2,'kronecker')
    # Initialization of the Pauli matrix
    s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])
    # Initialization of the center rank one matrix
    c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])
    # Initialization of the list of matrices
    Lm=[s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]
    # Computing the matrix
    #f=expand(prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(sz)))
    f=expand(prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(k)))*prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(k,sz))
    # Updating the dictionary
    Dct.update(dict([(Lc[i], Lm[i]) for i in rg(sz)]))
    # Performing the matrix substitution
    M=fast_reduceII(f, X, Y, Dct)
    return M[2^(sz)-1, 0]

def PerIII(A, Dct={'x':x}):
    """
    Computes symbolically the permanent via canonical matrix representation 
    of Grassmanian vaiables


    EXAMPLES:

    ::

        sage: sz=2; M=HM(sz, sz, 'm'); PerIII(M, dict([(str(v), v) for v in M.list()])) 
        m01*m10 + m00*m11


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order and size parameters
    od=2; sz=A.nrows()
    # Initialization of the variables
    X=var_list('x', sz); Y=var_list('y', sz); Lc=['y'+str(i) for i in rg(sz)]
    # Initialization of the identity matrix
    I2=HM(od,2,'kronecker')
    # Initialization of the Pauli matrix
    s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])
    # Initialization of the center rank one matrix
    c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])
    # Initialization of the list of matrices
    Lm=[s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]
    # Computing the matrix
    f=expand(prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(sz)))
    # Updating the dictionary
    Dct.update(dict([(Lc[i], Lm[i]) for i in rg(sz)]))
    # Performing the matrix substitution
    M=fast_reduceII(f, X, Y, Dct)
    return M[2^(sz)-1, 0]

def DeterHadamard(A):
    """
    Computes symbolically the determinant of a square matrix
    using the sum over permutation formula.

    EXAMPLES:

    ::

        sage: DeterHadamard(HM(2,2,[HM(2,2,'a'),HM(2,2,'c'),HM(2,2,'b'),HM(2,2,'d')])).printHM()
        [:, :]=
        [-b00*c00 + a00*d00 -b01*c01 + a01*d01]
        [-b10*c10 + a10*d10 -b11*c11 + a11*d11]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the permutations
    P = Permutations(range(A.nrows()))
    return sum([Permutation([p[i]+1 for i in range(len(p))]).signature()*list_elementwise_product([A[k,p[k]] for k in range(A.nrows())]) for p in P])

def ThirdOrderDeter(H):
    """
    computes third order hypermatrix determinant using the recursive determinant construction.
    Where the base case is the matrix case. The third order hyperdeterminant are only defined
    for cubic third order hypermatrices.
    
    EXAMPLES:
 
    ::

        sage: ThirdOrderDeter(HM(2,2,2,'a'))
        a000*a011*a101*a110 - a001*a010*a100*a111
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: Implement a faster and more generic version.
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==3:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),H.n(0),[var('x'+str(i)+str(j)) for j in range(1,1+H.n(0)) for i in range(1,1+H.n(0))])
        # Computing the mnemonique polynomial
        P=Permutations(range(A.nrows()))
        L=expand(Deter(A)*prod([sum([sqrt(g^2).canonicalize_radical() for g in Deter(A.elementwise_exponent(j)).operands()]) for j in range(2,1+A.n(0))])).operands()
        # Computing the polynomial
        f=sum([l for l in L if len((l^2).operands())==(H.n(0))^2])
        # Loop performing the umbral expression
        for k in range(H.n(0),0,-1):
            f=fast_reduce(f,[var('x'+str(i)+str(j))^k for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0))],[var('a'+str(i)+str(j)+str(k)) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(j)+str(k)),H[i-1,j-1,k-1]) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The hypermatrix must be a third order cube hypermatrix.")
 
def Per(A):
    """
    Computes symbolically the permanent of a square matrix
    using the sum over permutation formula.

    EXAMPLES:

    ::

        sage: M = HM(2, 2, 'm'); Per(M)
        m01*m10 + m00*m11

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the permutations
    P = Permutations(rg(A.nrows()))
    return sum([prod([A[k,p[k]] for k in rg(A.nrows())]) for p in P])

def PerII(A):
    """
    Computes symbolically the permanent of a square matrix
    using the sum over permutation formula. This function 
    follows a maple implementation suggested


    EXAMPLES:

    ::

        sage: M = HM(2, 2, 'm'); PerII(M)
        m01*m10 + m00*m11


    AUTHORS:
    - Edinah K. Gnang, Harry Crane
    """
    # Initializing the symbolic matrix
    sz = min(A.nrows(), A.ncols())
    P = GeneratePartition(sz)
    Pml = []
    for part in P:
        Pml.append((-1)^(max(part))*factorial(max(part))*((Partition2HM(part)).elementwise_product(A)).det())
    return expand(sum(Pml))*(-1)^A.nrows()

def ChowDecompPerHM(sz):
    """
    This function returns the Hypermatrix which
    underlies Ryser s and Glynn s Chow decomposition
    of the permanent polynomial.


    EXAMPLES:

    ::

        sage: sz=Integer(2); A=HM(sz,sz,'a','shift'); [Hr, Hg]=ChowDecompPerHM(sz)
        sage: Hr.p()
        [:, :, 0]=
        [0 0]
        [I I]
        [0 0]
        [1 1]

        [:, :, 1]=
        [0 0]
        [0 0]
        [I I]
        [1 1]

        sage: Hg.p()
        [:, :, 0]=
        [ 1  1]
        [-I -I]
        [ I  I]
        [-1 -1]

        [:, :, 1]=
        [ 1  1]
        [ I  I]
        [-I -I]
        [-1 -1]

        sage: sum(prod(sum(Hr[u,i,j]*A[i,j] for j in rg(sz)) for i in rg(sz)) for u in rg(2^sz)) # Ryser's Hypermatrix
        (a11 + a12)*(a21 + a22) - a11*a21 - a12*a22
        sage: (-1)^sz*sum(prod(sum(Hg[u,i,j]*A[i,j] for j in rg(sz)) for i in rg(sz)) for u in rg(2^sz))/(2^sz) # Glynn's Hypermatrix
        1/2*(a11 + a12)*(a21 + a22) + 1/4*(I*a11 - I*a12)*(I*a21 - I*a22) + 1/4*(-I*a11 + I*a12)*(-I*a21 + I*a22)


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of shift parameter
    shft=Integer(1)
    # Initialization of the list of vertex variables with index shifted by 1
    X=var_list('x',sz,shft)
    # Initialization of the symbolic adjacency matrix for the completed complete graph
    A=HM(sz,sz,'a','shift')
    # Initialization of the symbolic listing of functional directed graphs with in-degree recordings
    Pf=prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(sz))
    # Initialization of the tensor power DFT matrix associated with the finite difference scheme
    M=HM([[Integer(1),Integer(1)],[Integer(1),Integer(-1)]]).tensor_power(sz)
    # Initialization of the list of all length sz binary strings
    Li=List_of_Integers([2 for i in rg(sz)])
    # Initialization of the evaluation (2^sz) x 1 vector of evaluation of Pf
    Hv0=HM(2^sz,1,[Pf.subs([X[i]==l[i] for i in rg(len(l))]) for l in Li])
    Hv1=HM(2^sz,1,[Pf.subs([X[i]==(-1)^l[i] for i in rg(len(l))]) for l in Li])
    # Expressing Ryser's and Glynn's Chow-decomposition of the permanent
    Pm0=(M*Hv0)[2^sz-1,0]; Pm1=(M*Hv1)[2^sz-1,0]/(2^sz)
    # Initialization of the hypermatrix which underlies Ryser's and Glynn's Chow-decomposition of the permanent
    H=HM(2^sz,sz,sz,'zero')
    for l in Li:
        for i in rg(sz):
            for j in rg(sz):
                if l[j]==Integer(1):
                    H[sum(l[u]*(2^u)for u in rg(sz)),i,j]=((-1)^(sz-sum(l)))^(1/sz)
    Hp=HM(2^sz,sz,sz,'one')
    for l in Li:
        for i in rg(sz):
            for j in rg(sz):
                if l[j]==Integer(1):
                    Hp[sum(l[u]*(2^u) for u in rg(sz)),i,j]=(-1)*((-1)^(sz-sum(l)))^(1/sz)
                else:
                    Hp[sum(l[u]*(2^u) for u in rg(sz)),i,j]=((-1)^(sz-sum(l)))^(1/sz)
    return [H, Hp]
 
def MeanApproximation(T):
    """
    Computes  the mean slice approximation. This is mostly used for images
    as a way to get a hold of the background.

    EXAMPLES:

    ::

        sage: MeanApproximation(HM(2,2,2,'a'))
        [[[[1/2*a000 + 1/2*a010, 1/2*a001 + 1/2*a011]], [[1/2*a100 + 1/2*a110, 1/2*a101 + 1/2*a111]]], [[[1/2*a000 + 1/2*a001], [1/2*a010 + 1/2*a011]], [[1/2*a100 + 1/2*a101], [1/2*a110 + 1/2*a111]]], [[[1/2*a000 + 1/2*a100, 1/2*a001 + 1/2*a101], [1/2*a010 + 1/2*a110, 1/2*a011 + 1/2*a111]]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the Slices.
    Ha = HM(T.n(0), 1     , T.n(2), 'zero')
    Hb = HM(T.n(0), T.n(1), 1,      'zero')
    Hc = HM(1     , T.n(1), T.n(2), 'zero')
    # Computing the mean of row depth slice
    for u in range(Ha.nrows()):
        for v in range(Ha.ndpts()):
            Ha[u,0,v] = mean([T[u,i,v] for i in range(T.ncols())])
    # Computing the mean row column slice
    for u in range(Hb.nrows()):
        for v in range(Hb.ncols()):
            Hb[u,v,0] = mean([T[u,v,i] for i in range(T.ndpts())])
    # Computing the mean column depth slice
    for u in range(Hc.ncols()):
        for v in range(Hc.ndpts()):
            Hc[0,u,v] = mean([T[i,u,v] for i in range(T.nrows())])
    # Computing the outer-product of the mean slices.
    return [Ha, Hb, Hc]

def ZeroPadding(A):
    """
    outputs the zero padding into a cube of the cuboid third order hypermatrix.

    EXAMPLES:

    ::

        sage: ZeroPadding(HM(1,1,2,'a'))
        [[[a000, a001], [0, 0]], [[0, 0], [0, 0]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = [max(A.dimensions()) for i in range(A.order())]+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=A[tuple(entry)]
    return Rh

def Permutation_to_PseudoTuple(M):
    """
    Returns list of edge tuple desctiption associated with the 
    input permutation. The encoding is based on the diagonals.
    The first row of the input nxn matrix M determines where the loop
    edge is placed. The second row of the input matrix M determines
    where the edge whose edge weight equals one. This continues
    up utill we reach the edge of weight (n-1) for there is only
    one possible choice 


    EXAMPLES:
    ::
        sage: Permutation_to_PseudoTuple(HM([[1,0,0],[0,1,0],[0,0,1]]))
        [[(0, 0)], [(0, 1), (1, 0)], [(0, 2), (2, 0)]]
        sage: Permutation_to_PseudoTuple(HM([[0,0,1],[0,1,0],[1,0,0]]))
        [[(2, 2)], [(1, 2), (2, 1)], [(0, 2), (2, 0)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of running edge weight parameter and the Tuple list
    edgw=0; tp=[]
    while M.n(0) > 1:
        for i in rg(M.n(0)):
            if M[0,i] == 1:
                M=M.slice([k for k in rg(M.n(1)) if k != i], 'col').slice([j  for j in rg(1,M.n(0))], 'row')
                if edgw == 0:
                    tp.append([(i, i+edgw)])
                else:
                    tp.append([(i, i+edgw), (i+edgw, i)])
                edgw=edgw+1
                break
    tp.append([(0, edgw), (edgw, 0)])
    return tp

def Tuple_to_Adjacency(T):
    """
    The method returns the adjacency matrix of input edge tuple
    description of the input directed graph. This implementation
    is resitricted fuctional directed graphs. The length of the
    input list T determines the co-domain and the domain.


    EXAMPLES:

    ::

        sage: Tuple_to_Adjacency([(0, 1), (1, 2), (2, 0), (3, 3)]).printHM()
        [:, :]= 
        [0 1 0 0]
        [0 0 1 0]
        [1 0 0 0]
        [0 0 0 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the identity matrix
    Id=HM(Integer(2),len(T),'kronecker')
    return (sum([Id.slice([t[0]],'col')*Id.slice([t[1]],'row') for t in T]))

def Tuple_to_AdjacencyII(T,sz):
    """
    The method returns the adjacency matrix of input edge tuple
    description of the input directed graph. Start by creating a sz x sz
    matrix and fills it up. This implementation is not limited to functional
    directed graphs.


    EXAMPLES:

    ::

        sage: Tuple_to_AdjacencyII([(0, 1), (1, 2), (2, 0), (3, 3)], Integer(4)).printHM()
        [:, :]= 
        [0 1 0 0]
        [0 0 1 0]
        [1 0 0 0]
        [0 0 0 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the zero matrix
    A=HM(sz, sz, 'zero')
    # Filling up the matrix
    for t in T:
        A[t]=Integer(1)
    return A

def Tuple_to_Bipartite_Adjacency(T):
    """
    The method returns the adjacency matrix of directed bipartite
    graph description of the input edge tuple description of the 
    input directed graph. It therefore doubles the number of vertices
    by assiuming that the codomain and domain have the same size.
    This implementation can be seen as decoupling the domain and codoamin
    of fuctional directed graphs. The length of the input list T determines
    the co-domain and the domain.


    EXAMPLES:

    ::

        sage: Tuple_to_Bipartite_Adjacency([(0, 1), (1, 2), (2, 0), (3, 3)]).printHM()
        [:, :]= 
        [0 0 0 0 0 1 0 0]
        [0 0 0 0 0 0 1 0]
        [0 0 0 0 1 0 0 0]
        [0 0 0 0 0 0 0 1]
        [0 0 0 0 0 0 0 0]
        [0 0 0 0 0 0 0 0]
        [0 0 0 0 0 0 0 0]
        [0 0 0 0 0 0 0 0]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(T))
    # Initialization of the identity matrix
    Id=HM(Integer(2),sz,'kronecker')
    A_T=(sum([Id.slice([t[0]],'col')*Id.slice([t[1]],'row') for t in T]))
    # Performing the index rotation
    return A_T.index_rotation(-pi/2).block_sum(HM(sz,sz,'zero')).index_rotation(pi/2)

def Tuple_to_Symbolic_Adjacency(T,sz,A):
    """
    The method returns the symbolic adjacency matrix of input edge tuple
    description of the input directed graph. This implementation
    is not resitricted fuctional directed graphs. The length of the
    input list T determines the co-domain and the domain.


    EXAMPLES:

    ::

        sage: sz=Integer(2); A=HM(sz,sz,'a'); Tuple_to_Symbolic_Adjacency([(0, 1), (1, 0)], 2, A).p()
        [:, :]= 
        [  0 a01]
        [a10   0]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    return A.elementwise_product(Tuple_to_AdjacencyII(T,sz))

def Tuple_to_Tutte(T,sz,A):
    """
    The method returns the symbolic adjacency matrix of input edge tuple
    description of the input directed graph. This implementation
    is not resitricted fuctional directed graphs. The length of the
    input list T determines the co-domain and the domain.


    EXAMPLES:

    ::

        sage: od=Integer(2); sz=Integer(2); A=HM(od,sz,'a','skewsym'); Tuple_to_Tutte([(0, 1), (1, 0)], sz, A).p()
        [:, :]= 
        [   0 a01]
        [-a10   0]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Obtaining the adjacency matrix
    Adjm=Tuple_to_AdjacencyII(T,sz)
    if Adjm.is_symmetric() and A == -A.t():
        return A.elementwise_product(Tuple_to_AdjacencyII(T,sz))
    else:
        raise ValueError("Expected the matrix to be skew symmetric and the input tuple to be bi-directed")

def Adjacency_to_Tuple(A):
    """
    The method returns the adjacency matrix of input edge tuple
    description of the input directed graph.


    EXAMPLES:

    ::

        sage: Adjacency_to_Tuple(HM([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1]]))
        [(0, 1), (1, 2), (2, 0), (3, 3)]
        sage: Tuple_to_Adjacency(Adjacency_to_Tuple(HM([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1]]))).printHM()
        [:, :]= 
        [0 1 0 0]
        [0 0 1 0]
        [1 0 0 0]
        [0 0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initlization of the tuple list
    T=[]
    # Loop running througgh the matrix entries
    for i in rg(A.n(0)):
        for j in rg(A.n(1)):
            if A[i,j]==1:
                T.append((i,j))
    # Sorting the tuples
    T.sort()
    return T

def Tuple_to_PseudoTuple(tp):
    """
    Returns list of unidrected edge tuple desctiption associated with the 
    input tuple.


    EXAMPLES:
    ::
        sage: Tuple_to_PseudoTuple([(0, 0), (1, 0), (2, 0)])
        [[(0, 0)], [(0, 1), (1, 0)], [(0, 2), (2, 0)]]
        sage: Tuple_to_PseudoTuple([(0, 2), (1, 2), (2, 2)])
        [[(2, 2)], [(1, 2), (2, 1)], [(0, 2), (2, 0)]]



    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the pseudo tuple list
    psdT = []
    for i in rg(len(tp)):
        if tp[i][0]==tp[i][1]:
            psdT.append([(tp[i][0],tp[i][1])])
        else:
            psdT.append([(min(tp[i][0], tp[i][1]), max(tp[i][0], tp[i][1])),   (max(tp[i][1], tp[i][0]), min(tp[i][1], tp[i][0]))])
    T=[]
    for i in rg(len(tp)):
        for j in rg(len(tp)):
            if abs(psdT[j][0][0]-psdT[j][0][1]) == i:
                T.append(psdT[j])
    return T

def PseudoTuple_to_Permutation(psdT):
    """
    Returns a permutation matrix associated with list of edge specified as a pseudo tuple edge list.


    EXAMPLES:
    ::
        sage: PseudoTuple_to_Permutation([[(0, 0)], [(0, 1), (1, 0)], [(2, 0), (0, 2)]])
        [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        sage: PseudoTuple_to_Permutation([[(2, 2)], [(1, 2), (2, 1)], [(2, 0), (0, 2)]])
        [[0, 0, 1], [0, 1, 0], [1, 0, 0]]
        sage: PseudoTuple_to_Permutation([[(1, 1)], [(1, 2), (2, 1)], [(2, 0), (0, 2)]])
        [[0, 1, 0], [0, 0, 1], [1, 0, 0]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the input matrix
    M=HM(len(psdT),len(psdT),'zero'); M[0,psdT[0][0][0]]=1
    # Initialization of the forbiden index
    allowed_row_index=rg(1,len(psdT))
    allowed_col_index=[i for i in rg(len(psdT)) if i != psdT[0][0][0]]
    # Initialization fo the counter
    for indx in rg(1,len(psdT)):
        M[indx, allowed_col_index[min(psdT[indx][0])]]=1
        # Updating the allowable indices
        allowed_row_index.remove(indx)
        allowed_col_index.remove(allowed_col_index[min(psdT[indx][0])])
    return M

def Permutation_to_InsertionPattern(T):
    """
    Returns list of the list of insertion patterns associated
    with the bijection from permutation to gracefully labeled
    undirected graph having a loop edge (of weight 0). The 
    input is tuple descrition of a permutation. The function 
    checks to see that it is indeed a permutation.
    The output is a list of insertion patterns reflecting the
    edge choice made in deacreasin order of subtractive edge
    weight magnitudes.


    EXAMPLES:
    ::
        sage: Permutation_to_InsertionPattern([(0, 0), (1, 1), (2, 2)])
        [0, 0, 0]
        sage: Permutation_to_InsertionPattern([(0, 2), (1, 1), (2, 0)])
        [0, 1, 2]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the size and order parameters
    sz=len(T); od=2
    # Initialization of the identity matrix
    Id=HM(od, sz, 'kronecker')
    P=sum(Id.slice([T[i][0]],'col')*Id.slice([T[i][1]],'row') for i in rg(sz))
    if (P*P.transpose()-Id).is_zero():
        # Initialization of the list of options for each subtractive edge weights
        Lopt=[[(i,i) for i in rg(sz)]]+[[] for i in rg(sz-1)]
        for i in rg(1,sz):
            for j in rg(i):
                Lopt[abs(i-j)].append((j,i))
        # Initialization of the list of dictionaries for edge weight options
        LDct=[{Lopt[i][j] : j for j in rg(len(Lopt[i]))} for i in rg(sz)]
        # Converting the permutation matrix into a Pseudotuple list
        # to exploit the correspondence between permutations and 
        # gracefully labeled undirected graph having a loop edge.
        pT=Permutation_to_PseudoTuple(P)
        # Returing the reveserd difference this ensure that the insertion
        # entry never exceed the length of the partial list. For instance
        # the first entry is always zero to account for the fact that we
        # start from the constant 1.
        return [LDct[pT[sz-1-i][0][1]-pT[sz-1-i][0][0]][(pT[sz-1-i][0][0],pT[sz-1-i][0][1])] for i in rg(sz)]
    else:
        raise ValueError("The input must be a spanning union of cycles as input.")

def GenerateUnitLpNormVector(n, p = 2, indx=0):
    """
    outputs a unit lp norm vector.

    EXAMPLES:

    ::

        sage: GenerateUnitLpNormVector(2) 
        [cos(t0), sin(t0)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if n == 1:
        return [1]
    else :
        X = []
        X.append(cos(var('t'+str(indx)))^(2/p))
        for i in range(1,n-1):
            X.append((prod([sin(var('t'+str(j+indx))) for j in range(i)])*cos(var('t'+str(i+indx))))^(2/p))
        X.append((prod([sin(var('t'+str(j+indx))) for j in range(n-1)]))^(2/p))
        return X

def GenerateUnitLpNormVectorII(sz,p=2,indx=0):
    """
    outputs a unit lp norm vector.

    EXAMPLES:

    ::

        sage: GenerateUnitLpNormVectorII(2) 
        [1/2*e^(I*t0) + 1/2*e^(-I*t0), -1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    Cos(x)=exp(I*x)/(2*1) + exp(-I*x)/(2*1); Sin(x)=exp(I*x)/(2*I) - exp(-I*x)/(2*I)
    if n == 1:
        return [1]
    else :
        X = []
        X.append( Cos(var('t'+str(indx)))^(2/p) )
        for i in rg(1,sz-1):
            X.append( prod(Sin( var('t'+str(j+indx)) ) for j in range(i))*Cos(var('t'+str(i+indx)))^(2/p) )
        X.append( prod(Sin(var('t'+str(j+indx)))^(2/p) for j in range(sz-1)) )
        return X

def GenerateUnitLpNormVectorIII(sz, p, indx, T):
    """
    outputs a unit lp norm vector. The implmentation
    here uses exponential polynomial expression of 
    of trigonometric polynomials. The input sz
    specifies the length of the vector. The input 
    p specifies the norm which we choose. This implementation
    differs from the ones above in the fact that accounts
    for the insertion pattern specified by the input tuple
    description of the a permutation T. The insertion pattern
    is devised from T by using the correspondence between 
    permutations and gracefully labeled undirected graph having
    a loop edge.
    Crucially T must a tuple description of a permutation of 
    sz-1 elements.


    EXAMPLES:

    ::

        sage: GenerateUnitLpNormVectorIII(2, 2, 0, [(0,0)]) 
        [-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0), 1/2*e^(I*t0) + 1/2*e^(-I*t0)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if n == 1:
        return [1]
    else :
        # Initialization of the exponential encoding of trigonometric functions
        Cos(x) = exp(I*x)/(2*1) + exp(-I*x)/(2*1); Sin(x) = exp(I*x)/(2*I) - exp(-I*x)/(2*I)
        # Initialization of the insertion of sequence
        L = Permutation_to_InsertionPattern(T)
        #X = [Cos(var('t'+str(indx)))^(2/p), Sin(var('t'+str(indx)))^(2/p)]
        X = [1]
        #for i in range(1,sz-1):
        for i in range(sz-1):
            tmp = X[L[i]]
            X[L[i]] = tmp*Cos(var('t'+str(i+indx)))^(2/p)
            X.insert(L[i],tmp*Sin(var('t'+str(i+indx)))^(2/p))
        return X

def ProbabilityMatrix(n, xi=0):
    """
    outputs the symbolic parametrization of a doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilityMatrix(2)
        [     cos(t0)^2      sin(t0)^2]
        [-cos(t0)^2 + 1 -sin(t0)^2 + 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = Matrix(SR, zero_matrix(n,n))
    # Initialixzing the variable index
    indx=xi
    for c in range(n-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVector(n-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Initializing the probability vector associated with the column c
        Lb = GenerateUnitLpNormVector(n-c-1,1,indx)
        # Updating the variable index
        indx = indx+len(Lb)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in range(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in range(c+1)]))*Lb[i-c-1]
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in range(c+1)]))*Lb[i-c-1]
    M[n-1,n-1]=1-sum([M[j,n-1] for j in range(n-1)])
    return M

def ProbabilityHM(sz, xi=0):
    """
    outputs the symbolic parametrization of a doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilityHM(2).printHM()
        [:, :]=
        [     cos(t0)^2      sin(t0)^2]
        [-cos(t0)^2 + 1 -sin(t0)^2 + 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz,sz, 'zero')
    # Initialixzing the variable index
    indx=xi
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVector(sz-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Initializing the probability vector associated with the column c
        Lb = GenerateUnitLpNormVector(sz-c-1,1,indx)
        # Updating the variable index
        indx = indx+len(Lb)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in rg(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in rg(sz-1)])
    return M

def ProbabilityHMII(sz, xi=0):
    """
    outputs the symbolic parametrization of a doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilityHMII(2).printHM()
        [:, :]=
        [                                 1/4*(e^(I*t0) + e^(-I*t0))^2                         (-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2]
        [-1/16*((e^(I*t0) + e^(-I*t0))^2 - 4)*(e^(I*t1) + e^(-I*t1))^2                    -(-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2 + 1]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz,sz,'zero')
    # Initialixzing the variable index
    indx=xi
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVectorII(sz-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Initializing the probability vector associated with the column c
        Lb = GenerateUnitLpNormVectorII(sz-c-1,1,indx)
        # Updating the variable index
        indx = indx+len(Lb)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in rg(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in rg(sz-1)])
    return M

def ProbabilitySymHMIII(sz, xi, Lt):
    """
    Outputs a symbolic parametrization of a symetric doubly stochastic matrix.
    where the points on the unit sphere a constructed according to the permutation
    patterns specified in the list Lt. Lt must be carefully constructed to account
    for every call of the function which generates symbolic vectors of l1 norm 1


    EXAMPLES:

    ::

        sage: ProbabilitySymHMIII(2,0,[[(0,0)]]).printHM()
        [:, :]=
        [(-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2          1/4*(e^(I*t0) + e^(-I*t0))^2]
        [         1/4*(e^(I*t0) + e^(-I*t0))^2     -1/4*(e^(I*t0) + e^(-I*t0))^2 + 1]

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz, sz, 'zero')
    # Initialixzing the variable index
    indx=xi
    # Initialization of the index which keeps track of the permutation
    # specifiying the isertion patterns
    indxp=0
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVectorIII(sz-c, 1, indx, Lt[indxp])
        # Updating the insertion pattern index
        indxp = indxp+1
        # Updating the variable index
        indx = indx+len(La)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in range(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i] 
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in range(sz-1)])
    return M

def ProbabilityHMIII(sz, xi, Lt):
    """
    Outputs a symbolic parametrization of a symetric doubly stochastic matrix.
    where the points on the unit sphere a constructed according to the permutation
    patterns specified in the list Lt


    EXAMPLES:

    ::

        sage: ProbabilityHMIII(2,0,[[(0,0)],[(0,0)]]).printHM()
        [:, :]=
        [                                    (-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2                                              1/4*(e^(I*t0) + e^(-I*t0))^2]
        [-1/4*((-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2 - 1)*(e^(I*t1) + e^(-I*t1))^2                                         -1/4*(e^(I*t0) + e^(-I*t0))^2 + 1] 


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz,sz,'zero')
    # Initialixzing the variable index
    indx=xi
    # Initialization of the index which keeps track of the permutation
    # specifiying the isertion patterns
    indxp=0
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVectorIII(sz-c, 1, indx, Lt[indxp])
        # Updating the insertion pattern index
        indxp = indxp+1
        # Updating the variable index
        indx = indx+len(La)-1
        # Initializing the probability vector associated with the column c
        Lb = GenerateUnitLpNormVectorII(sz-c-1,1,indx)
        # Updating the variable index
        indx = indx+len(Lb)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in rg(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = (1-sum([M[j,c] for j in rg(c+1)]))*Lb[i-c-1]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in rg(sz-1)])
    return M

def ProbabilitySymMatrix(n, xi=0):
    """
    outputs the symbolic parametrization of a symetric doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilitySymMatrix(2)
        [     cos(t0)^2      sin(t0)^2]
        [     sin(t0)^2 -sin(t0)^2 + 1]
        

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = Matrix(SR, zero_matrix(n,n))
    # Initialixzing the variable index
    indx=xi
    for c in range(n-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVector(n-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in range(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i] 
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i]
    M[n-1,n-1]=1-sum([M[j,n-1] for j in range(n-1)])
    return M

def ProbabilitySymHM(sz, xi=0):
    """
    outputs the symbolic parametrization of a symetric doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilitySymHM(2).printHM()
        [:, :]=
        [     cos(t0)^2      sin(t0)^2]
        [     sin(t0)^2 -sin(t0)^2 + 1]
        

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz, sz, 'zero')
    # Initialixzing the variable index
    indx=xi
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVector(sz-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in range(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i] 
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in range(sz-1)])
    return M

def ProbabilitySymHMII(sz, xi=0):
    """
    outputs the symbolic parametrization of a symetric doubly stochastic matrix

    EXAMPLES:

    ::

        sage: ProbabilitySymHMII(2).printHM()
        [:, :]=
        [              1/4*(e^(I*t0) + e^(-I*t0))^2      (-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2]
        [     (-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2 -(-1/2*I*e^(I*t0) + 1/2*I*e^(-I*t0))^2 + 1]        

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz, sz, 'zero')
    # Initialixzing the variable index
    indx=xi
    for c in rg(sz-1):
        # Initializing the probability vector associated with the row c
        La = GenerateUnitLpNormVectorII(sz-c,1,indx)
        # Updating the variable index
        indx = indx+len(La)-1
        # Loop which fills up the Matrix
        for i in range(c, c+len(La)):
            if c > 0:
                # Filling up the row c of the Matrix M
                M[c,i] = (1-sum([M[c,j] for j in range(c)]))*La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i] 
            else:
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = M[c,i]
    M[sz-1,sz-1]=1-sum([M[j,sz-1] for j in range(sz-1)])
    return M

def ProbabilityHMIV(A):
    """
    Outputs a symbolic parametrization of a doubly stochastic matrix.
    Using the analog of the adjoint matrix based upon the permanent.
    The inputs correspond respectively to the size and the caracter
    to use for the symbolic parametrization.


    EXAMPLES:

    ::

        sage: ProbabilityHMIV(HM(2,2,'a')).printHM()
        [:, :]=
        [a00*a11/(a01*a10 + a00*a11) a01*a10/(a01*a10 + a00*a11)]
        [a01*a10/(a01*a10 + a00*a11) a00*a11/(a01*a10 + a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Computing the permanent of the matrix
    F = PerII(A)
    # Initialization of the desired matrix
    return A.transpose().elementwise_product(jnxn(A))

def GenerateRandomOneZeroHM(sz, k):
    """
    Outputs uniformly randomly chosen 0,1 vector having k ones and sz-k zeros
    with the index fi being forbidden

    EXAMPLES:

    ::

        sage: GenerateRandomOneZeroHM(2,2)
        [1, 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if type(k)==type(2) and k > 0 :
        # Initialization of the set of powers of 2
        S=Set([2^i for i in rg(sz)])
        # Initialization of the list of integers
        L=[sum(s) for s in S.subsets(k)]
        # Chosing uniformly at random a memeber of L
        if len(L)==0 :
            return HM(sz,'zero').list()
        else :
            rn=L[randint(0,len(L)-1)]
            # obtaining the bits of the chose number
            bL=rn.bits()
            return bL+[0 for i in rg(len(bL),sz)]
    else :
        return HM(sz,'zero').list()

def Random_d_regular_adjacencyHM(sz, d):
    """
    Outputs a complementary pair of directed graphs where 
    the first graphs has vertex in-degree and out-degree 
    both equal to d for every vertex. While the second has
    vertex in-degree and out-degree both equal to sz-d-1
    for all of it's vertices.


    EXAMPLES:

    ::

        sage: sz=5; [A,B]=Random_d_regular_adjacencyHM(sz,3)
        sage: (A*HM(sz,1,'one')).printHM()
        [:, :]=
        [3]
        [3]
        [3]
        [3]
        [3]
        sage: (HM(1,sz,'one')*A).printHM()
        [:, :]=
        [3 3 3 3 3]
        

    AUTHORS:
    - Edinah K. Gnang, Yan Jiang
    """
    # Initializing the matrix to be filled
    M = HM(sz,sz, 'zero'); M[sz-1,sz-1]=1
    # List of regular graph on 2 vertices
    while M[sz-1,sz-1]!=0 or M*HM(sz,1,'one') != HM(sz,1,'one')*d:
        for c in rg(sz-1):
            # Initializing the vector associated with the row c
            La = [0]+GenerateRandomOneZeroHM(sz-c-1, d-sum(M[c,j] for j in rg(c)))
            # Initializing the vector associated with the column c
            Lb = [ ]+GenerateRandomOneZeroHM(sz-c-1, d-sum(M[j,c] for j in rg(c+1)))
            # Loop which fills up the Matrix
            for i in range(c, c+len(La)):
                    M[c,i] = La[i-c]
                    if i > c:
                        # Filling up the column c of the Matrix M
                        M[i,c] = Lb[i-c-1]
        M[sz-1,sz-1]=d-sum([M[j,sz-1] for j in rg(sz-1)])
    return [M, HM(sz,sz,'one')-M-HM(2,sz,'kronecker')]

def Random_d_regular_undirected_adjacencyHM(sz, d):
    """
    Outputs a complementary pair of undirected graphs where
    the first graphs has vertex in-degree and out-degree
    both equal to d for every vertex. While the second has
    vertex in-degree and out-degree both equal to sz-d-1
    for all of it's vertices.
    Note that if sz is odd, then d must be even because
    2*|E| = sz * d in case both d and sz are odd we have
    a contradictions
    
 
    EXAMPLES:
    
    ::
    
    sage: sz=5; [A,B]=Random_d_regular_undirected_adjacencyHM(sz,2)
    sage: A.printHM()
    [:, :]=
    [0 1 0 0 1]
    [1 0 0 1 0]
    [0 0 0 1 1]
    [0 1 1 0 0]
    [1 0 1 0 0]
    sage: (A*HM(sz,1,'one')).printHM()
    [:, :]=
    [2]
    [2]
    [2]
    [2]
    [2]
    sage: (HM(1,sz,'one')*A).printHM()
    [:, :]=
    [2 2 2 2 2]
    sage: (A-A.transpose()).printHM()
    [:, :]=
    [0 0 0 0 0]
    [0 0 0 0 0]
    [0 0 0 0 0]
    [0 0 0 0 0]
    [0 0 0 0 0]
    
    
    AUTHORS:
    - Yan Jiang, Edinah K. Gnang
    """
    # Initializing the matrix to be filled
    M = HM(sz,sz, 'zero'); M[sz-1,sz-1]=1
    # List of regular graph on 2 vertices
    while M[sz-1,sz-1]!=0 or M*HM(sz,1,'one') != HM(sz,1,'one')*d:
        for c in rg(sz-1):
            # Initializing the vector associated with the row c
            La = [0]+GenerateRandomOneZeroHM(sz-c-1,d-sum(M[c,j] for j in rg(c)))
            # Loop which fills up the Matrix
            for i in range(c, c+len(La)):
                # Filling up the row c of the Matrix M
                M[c,i] = La[i-c]
                if i > c:
                    # Filling up the column c of the Matrix M
                    M[i,c] = La[i-c]
        M[sz-1,sz-1]=d-sum([M[j,sz-1] for j in rg(sz-1)])
    return [M, HM(sz,sz,'one')-M-HM(2,sz,'kronecker')]

def Random_3_regular_directed_adjacencyHM(sz):
    """
    Outputs a complementary pair of undirected graphs where
    the first graphs has vertex in-degree and out-degree
    both equal to 3 for every vertex. While the second has
    vertex in-degree and out-degree both equal to sz-3-1
    for all of it's vertices.
    Note that if sz is odd, then d must be even because
    2*|E| = sz * 3 in case both d and sz are odd we have
    a contradictions
    
 
    EXAMPLES:
    
    ::
    
    sage: sz=12; [A,B]=Random_3_regular_directed_adjacencyHM(sz)
    sage: (A*HM(sz,1,'one')).printHM()
    [:, :]=
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    [3]
    
    
    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the random permutations
    Sigma=RandomDerangementTuple(sz); Gamma=RandomDerangementTuple(sz)
    while prod(Sigma[i][1]-Gamma[i][1] for i in rg(sz)).is_zero() or not (Tuple_to_Adjacency(Sigma) + Tuple_to_Adjacency(Gamma) + HM(2,sz,'kronecker')).index_rotation(pi/2).trace().is_zero():
        Sigma=RandomDerangementTuple(sz); Gamma=RandomDerangementTuple(sz)
    return [(Tuple_to_Adjacency(Sigma) + Tuple_to_Adjacency(Gamma) + HM(2,sz,'kronecker')).index_rotation(pi/2),HM(sz,sz,'one')-(Tuple_to_Adjacency(Sigma) + Tuple_to_Adjacency(Gamma) + HM(2,sz,'kronecker')).index_rotation(pi/2)]

def BipInflateHM(sz):
    """
    outputs bipartite where vertex in-degree and out-degree 
    both equal to (sz-1)/2 for every vertex. The partition
    are made up of complementary adjacency matrices.
    The number of vertices sz must be odd. 

    EXAMPLES:

    ::

        sage: sz=5; A= BipInflateHM(sz)
        sage: (A*HM(2*sz,1,'one')).printHM()
        [:, :]=
        [2]
        [2]
        [2]
        [2]
        [2]
        [2]
        [2]
        [2]
        [2]
        [2]
        sage: (HM(1,2*sz,'one')*A).printHM()
        [:, :]=
        [2 2 2 2 2 2 2 2 2 2]

    AUTHORS:
    - Edinah K. Gnang, James Murphy
    """
    if Integer(mod(sz,2))==1:
        d=Integer((sz-1)/2)
        [A,B]=Random_d_regular_adjacencyHM(sz, d)
        return HM([[0,1],[0,0]]).tensor_product(A)+HM([[0,0],[1,0]]).tensor_product(B)
    else:
        raise ValueError("The number of vertices must be odd")

def HypermatrixPseudoInversePairsII(A,B):
    """
     Outputs the pseudo inverse pairs associated with the input pairs of hypermatrices

    EXAMPLES:

    ::

        sage: A1=HM([[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]] ,[[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]])
        sage: A2=HM([[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]] ,[[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]])
        sage: [B1,B2]=HypermatrixPseudoInversePairsII(A1,A2)


    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    sz = len(A.listHM())
    # Initializing the list of linear constraints
    CnstrLst = []
    # Initilizing the variable list
    Vrbls  = [var('ln_al'+str(i)+str(j)+str(k))  for i in range(sz) for j in range(sz) for k in range(sz)]+[var('ln_bt'+str(i)+str(j)+str(k)) for i in range(sz) for j in range(sz) for k in range(sz)]

    for m in range(sz):
        for p in range(sz):
            for n in range(sz):
                V=Matrix(CC, sz, sz, [(A[m,k1,k0])*(B[k0,k1,p]) for k0 in range(sz) for k1 in range(sz)]).inverse()
                CnstrLst=CnstrLst+[var('ln_al'+str(m)+str(n)+str(k1))+var('ln_bt'+str(k1)+str(n)+str(p))==ln(V[k1,n])  for k1 in range(sz)]
    [A,b]=ConstraintFormator(CnstrLst,Vrbls)
    # Importing the Numerical Python package
    # for computing the matrix pseudo inverse
    import numpy
    sln = matrix(numpy.linalg.pinv(A))*b
    R1 = HM(sz,sz,sz,'zero')
    for i in range(sz):
        for j in range(sz):
            for k in range(sz):
                R1[i,j,k] = exp(sln[i*sz^2+j*sz^1+k*sz^0,0])
    R2 = HM(sz, sz, sz,'zero')
    for i in range(sz):
        for j in range(sz):
            for k in range(sz):
                R2[i,j,k] = exp(sln[sz^3+i*sz^2+j*sz^1+k*sz^0,0])
    return [R1,R2]

def HypermatrixPseudoInversePairsUnsplit(A,B):
    """
     Outputs the pseudo inverse pairs associated with the input pairs of matrices

    EXAMPLES:

    ::

        sage: A1=HM([[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]], [[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]])
        sage: A2=HM([[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]], [[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]])
        sage: B1B2=HypermatrixPseudoInversePairsUnsplit(A1,A2)

    AUTHORS:
    - Edinah K. Gnang and Ori Parzanchevski
    """
    # Initializing the size
    sz = A.nrows()
    # Initializing the symbolic matrix
    T = HM(sz,sz,sz,'one')
    # We adopt the entry convention XY_mnjp=X_mnj*Y_jnp
    XY = HM(sz,sz,sz,sz, 'xy')
    # Initialization of the variables list
    Vrbls = XY.list()
    Tmp = T*(A,B)
    # Initializing the list of linear constraints
    CnstrLst = [sum([Tmp[m,j,p]*XY[m,n,j,p] for j in range(sz)]) == T[m,n,p] for m in range(sz) for n in range(sz) for p in range(sz)]
    # Formatting the constraints
    [M,b] = ConstraintFormator(CnstrLst,Vrbls)
    # Importing the Numerical Python package for computing the matrix pseudo inverse
    import numpy; sln = matrix(numpy.linalg.pinv(M))*b
    # Filling up the hypermartix XY
    # Initialization of the list specifying the dimensions of the output
    l = [XY.n(i) for i in range(XY.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        XY[tuple(entry)]=sln[i][0]
    return XY

def HypermatrixPseudoInversePairAction(T, A, B):
    """
     Outputs the pseudo inverse pairs associated with the input pairs of matrices

    EXAMPLES:

    ::

        sage: A1=HM([[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]], [[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]])
        sage: A2=HM([[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]], [[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]])
        sage: B=HypermatrixPseudoInversePairAction(HM(2,2,2,'one'),A1,A2)

    AUTHORS:
    - Edinah K. Gnang
    """
    # Computing the unsplit Inverse pairs
    XY = HypermatrixPseudoInversePairsUnsplit(A,B)
    Rs = HM(A.nrows(), A.ncols(), A.ndpts(),'zero')
    for m in range(Rs.nrows()):
        for n in range(Rs.ncols()):
            for p in range(Rs.ndpts()):
                Rs[m,n,p] = sum([T[m,j,p]*XY[m,n,j,p] for j in range(A.nrows())])
    return Rs 

def GenerateRandomHypermatrix(*l):
    """
     Outputs a random hypermatrix

    EXAMPLES:

    ::

        sage: A=GenerateRandomHypermatrix(2,2,2); A.dimensions()
        [2, 2, 2]

    AUTHORS:
    - Edinah K. Gnang
    """
    if prod(list(l)) != 0:
        # Initializing the input for generating a symbolic hypermatrix
        inpts = list(l)+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=random()
        return Rh
    else :
        raise ValueError("The Dimensions must all be non-zero.")

def GenerateRandomRationalHypermatrix(*l):
    """
     Outputs a random hypermatrix

    EXAMPLES:

    ::

        sage: A=GenerateRandomRationalHypermatrix(2,2,2); A.dimensions()
        [2, 2, 2]

    AUTHORS:
    - Edinah K. Gnang
    """
    if prod(list(l)) != 0:
        # Initializing the input for generating a symbolic hypermatrix
        inpts = list(l)+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=QQ(random())
        return Rh
    else :
        raise ValueError("The Dimensions must all be non-zero.")

def GenerateRandomIntegerHypermatrix(*l):
    """
     Outputs a random hypermatrix

    EXAMPLES:

    ::

        sage: A=GenerateRandomIntegerHypermatrix(3,3,3); A.dimensions()
        [3, 3, 3]

    AUTHORS:
    - Edinah K. Gnang
    """
    if prod(list(l)) != 0:
        # Initializing the input for generating a symbolic hypermatrix
        inpts = list(l)+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=ZZ.random_element()
        return Rh
    else :
        raise ValueError("The Dimensions must all be non-zero.")

def GenerateRandomBinaryHypermatrix(*l):
    """
     Outputs a random hypermatrix

    EXAMPLES:

    ::

        sage: A=GenerateRandomBinaryHypermatrix(3,3,3); A.dimensions()
        [3, 3, 3]

    AUTHORS:
    - Edinah K. Gnang
    """
    if prod(list(l)) != 0:
        # Initializing the input for generating a symbolic hypermatrix
        inpts = list(l)+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)]=Integer(mod(ZZ.random_element(),2))
        return Rh
    else :
        raise ValueError("The Dimensions must all be non-zero.")

def GeneralStochasticHypermatrix(t, od):
    """
    Generates an stochastic hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized.

    EXAMPLES:

    ::

        sage: Q = GeneralStochasticHypermatrix(var('t'), 2); Q
        [[cos(t)^2, sin(t)^2], [sin(t)^2, cos(t)^2]]

    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski
    """
    if od < 2 and type(od)==type(1):
        raise ValueError("The order must be greater or equal to 2.")
    elif od == 2:
        return HM([[cos(t)^2, sin(t)^2], [sin(t)^2, cos(t)^2]])
    elif od > 2 and type(od) == type(1):
        dms = [2,2]
        B = GeneralStochasticHypermatrix(t,2)
        for z in range(2,od):
            A = B 
            dms.append(2) 
            #B = apply(HM, dms+['zero'])
            B = HM(*(dms+['zero']))
            l = [A.n(i) for i in range(A.order())]
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                B[tuple(entry+[0])]=A[tuple(entry)]
                if A[tuple(entry)] == cos(t)^2:
                    B[tuple(entry+[1])]=sin(t)^2
                else :
                    B[tuple(entry+[1])]=cos(t)^2
        return B
    else :
        raise ValueError("The order must be a positive integer")

def GeneralStochasticHypermatrixII(t, od):
    """
    Generates an stochastic hypermatrix of the appropriate order
    for which each one of the dimensions are equal to 2.
    The vectors are not normalized.

    EXAMPLES:

    ::

        sage: GeneralStochasticHypermatrixII(var('t'), 2)
        [[1/4*(e^(I*t) + e^(-I*t))^2, (-1/2*I*e^(I*t) + 1/2*I*e^(-I*t))^2], [(-1/2*I*e^(I*t) + 1/2*I*e^(-I*t))^2, 1/4*(e^(I*t) + e^(-I*t))^2]]


    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski
    """
    if od < 2 and type(od)==type(1):
        raise ValueError("The order must be greater or equal to 2.")
    elif od == 2:
        return HM([[(exp(I*t)/2+exp(-I*t)/2)^2, (exp(I*t)/(2*I)-exp(-I*t)/(2*I))^2], [(exp(I*t)/(2*I)-exp(-I*t)/(2*I))^2, (exp(I*t)/2+exp(-I*t)/2)^2]])
    elif od > 2 and type(od) == type(1):
        dms = [2,2]
        B = GeneralStochasticHypermatrixII(t,2)
        for z in range(2,od):
            A = B 
            dms.append(2) 
            #B = apply(HM, dms+['zero'])
            B = HM(*(dms+['zero']))
            l = [A.n(i) for i in range(A.order())]
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                B[tuple(entry+[0])]=A[tuple(entry)]
                if A[tuple(entry)] == (exp(I*t)/2+exp(-I*t)/2)^2:
                    B[tuple(entry+[1])]=(exp(I*t)/(2*I)-exp(-I*t)/(2*I))^2
                else :
                    B[tuple(entry+[1])]=(exp(I*t)/2+exp(-I*t)/2)^2
        return B
    else :
        raise ValueError("The order must be a positive integer")

def SecondOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input second order hypermatrices.

    EXAMPLES:

    ::

        sage: SecondOrderSliceKroneckerProduct(HM(2,2,'a'),HM(2,2,'b'))
        [[a00*b00, a00*b01, a01*b00, a01*b01], [a00*b10, a00*b11, a01*b10, a01*b11], [a10*b00, a10*b01, a11*b00, a11*b01], [a10*b10, a10*b11, a11*b10, a11*b11]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for j0 in range(Hb.n(0)):
                for j1 in range(Hb.n(1)):
                    Hc[Hb.n(0)*i0+j0,Hb.n(1)*i1+j1]=Ha[i0,i1]*Hb[j0,j1]
    return Hc

def ThirdOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input third order hypermatrices.

    EXAMPLES:

    ::

        sage: ThirdOrderSliceKroneckerProduct(HM(2,2,2,'a'),HM(3,3,3,'b'))
        [[[a000*b000, a000*b001, a000*b002, a001*b000, a001*b001, a001*b002], [a000*b010, a000*b011, a000*b012, a001*b010, a001*b011, a001*b012], [a000*b020, a000*b021, a000*b022, a001*b020, a001*b021, a001*b022], [a010*b000, a010*b001, a010*b002, a011*b000, a011*b001, a011*b002], [a010*b010, a010*b011, a010*b012, a011*b010, a011*b011, a011*b012], [a010*b020, a010*b021, a010*b022, a011*b020, a011*b021, a011*b022]], [[a000*b100, a000*b101, a000*b102, a001*b100, a001*b101, a001*b102], [a000*b110, a000*b111, a000*b112, a001*b110, a001*b111, a001*b112], [a000*b120, a000*b121, a000*b122, a001*b120, a001*b121, a001*b122], [a010*b100, a010*b101, a010*b102, a011*b100, a011*b101, a011*b102], [a010*b110, a010*b111, a010*b112, a011*b110, a011*b111, a011*b112], [a010*b120, a010*b121, a010*b122, a011*b120, a011*b121, a011*b122]], [[a000*b200, a000*b201, a000*b202, a001*b200, a001*b201, a001*b202], [a000*b210, a000*b211, a000*b212, a001*b210, a001*b211, a001*b212], [a000*b220, a000*b221, a000*b222, a001*b220, a001*b221, a001*b222], [a010*b200, a010*b201, a010*b202, a011*b200, a011*b201, a011*b202], [a010*b210, a010*b211, a010*b212, a011*b210, a011*b211, a011*b212], [a010*b220, a010*b221, a010*b222, a011*b220, a011*b221, a011*b222]], [[a100*b000, a100*b001, a100*b002, a101*b000, a101*b001, a101*b002], [a100*b010, a100*b011, a100*b012, a101*b010, a101*b011, a101*b012], [a100*b020, a100*b021, a100*b022, a101*b020, a101*b021, a101*b022], [a110*b000, a110*b001, a110*b002, a111*b000, a111*b001, a111*b002], [a110*b010, a110*b011, a110*b012, a111*b010, a111*b011, a111*b012], [a110*b020, a110*b021, a110*b022, a111*b020, a111*b021, a111*b022]], [[a100*b100, a100*b101, a100*b102, a101*b100, a101*b101, a101*b102], [a100*b110, a100*b111, a100*b112, a101*b110, a101*b111, a101*b112], [a100*b120, a100*b121, a100*b122, a101*b120, a101*b121, a101*b122], [a110*b100, a110*b101, a110*b102, a111*b100, a111*b101, a111*b102], [a110*b110, a110*b111, a110*b112, a111*b110, a111*b111, a111*b112], [a110*b120, a110*b121, a110*b122, a111*b120, a111*b121, a111*b122]], [[a100*b200, a100*b201, a100*b202, a101*b200, a101*b201, a101*b202], [a100*b210, a100*b211, a100*b212, a101*b210, a101*b211, a101*b212], [a100*b220, a100*b221, a100*b222, a101*b220, a101*b221, a101*b222], [a110*b200, a110*b201, a110*b202, a111*b200, a111*b201, a111*b202], [a110*b210, a110*b211, a110*b212, a111*b210, a111*b211, a111*b212], [a110*b220, a110*b221, a110*b222, a111*b220, a111*b221, a111*b222]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), Ha.n(2)*Hb.n(2), 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for i2 in range(Ha.n(2)):
                for j0 in range(Hb.n(0)):
                    for j1 in range(Hb.n(1)):
                        for j2 in range(Hb.n(2)):
                            Hc[Hb.n(0)*i0+j0, Hb.n(1)*i1+j1, Hb.n(2)*i2+j2]=Ha[i0,i1,i2]*Hb[j0,j1,j2]
    return Hc

def FourthOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input fourth order hypermatrices.

    EXAMPLES:

    ::

        sage: Hc=FourthOrderSliceKroneckerProduct(HM(2,2,2,2,'a'),HM(2,2,2,2,'b'))
        sage: Hc.dimensions()
        [4, 4, 4, 4]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), Ha.n(2)*Hb.n(2), Ha.n(3)*Hb.n(3) , 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for i2 in range(Ha.n(2)):
                for i3 in range(Ha.n(3)):
                    for j0 in range(Hb.n(0)):
                        for j1 in range(Hb.n(1)):
                            for j2 in range(Hb.n(2)):
                                for j3 in range(Hb.n(3)):
                                    Hc[Hb.n(0)*i0+j0,Hb.n(1)*i1+j1,Hb.n(2)*i2+j2,Hb.n(3)*i3+j3]=Ha[i0,i1,i2,i3]*Hb[j0,j1,j2,j3]
    return Hc

def FifthOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input fifth order hypermatrices.

    EXAMPLES:

    ::

        sage: Hc=FifthOrderSliceKroneckerProduct(HM(2,2,2,2,2,'a'),HM(2,2,2,2,2,'b'))
        sage: Hc.dimensions()
        [4, 4, 4, 4, 4]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), Ha.n(2)*Hb.n(2), Ha.n(3)*Hb.n(3), Ha.n(4)*Hb.n(4), 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for i2 in range(Ha.n(2)):
                for i3 in range(Ha.n(3)):
                    for i4 in range(Ha.n(4)):
                        for j0 in range(Hb.n(0)):
                            for j1 in range(Hb.n(1)):
                                for j2 in range(Hb.n(2)):
                                    for j3 in range(Hb.n(3)):
                                        for j4 in range(Hb.n(4)):
                                            Hc[Hb.n(0)*i0+j0,Hb.n(1)*i1+j1,Hb.n(2)*i2+j2,Hb.n(3)*i3+j3,Hb.n(4)*i4+j4]=Ha[i0,i1,i2,i3,i4]*Hb[j0,j1,j2,j3,j4]
    return Hc

def SixthOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input fifth order hypermatrices.

    EXAMPLES:

    ::

        sage: Hc=SixthOrderSliceKroneckerProduct(HM(2,2,2,2,2,2,'a'),HM(2,2,2,2,2,2,'b'))
        sage: Hc.dimensions()
        [4, 4, 4, 4, 4, 4]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), Ha.n(2)*Hb.n(2), Ha.n(3)*Hb.n(3), Ha.n(4)*Hb.n(4), Ha.n(5)*Hb.n(5), 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for i2 in range(Ha.n(2)):
                for i3 in range(Ha.n(3)):
                    for i4 in range(Ha.n(4)):
                        for i5 in range(Ha.n(5)):
                            for j0 in range(Hb.n(0)):
                                for j1 in range(Hb.n(1)):
                                    for j2 in range(Hb.n(2)):
                                        for j3 in range(Hb.n(3)):
                                            for j4 in range(Hb.n(4)):
                                                for j5 in range(Hb.n(5)):
                                                    Hc[Hb.n(0)*i0+j0,Hb.n(1)*i1+j1,Hb.n(2)*i2+j2,Hb.n(3)*i3+j3,Hb.n(4)*i4+j4,Hb.n(5)*i5+j5]=Ha[i0,i1,i2,i3,i4,i5]*Hb[j0,j1,j2,j3,j4,j5]
    return Hc

def SeventhOrderSliceKroneckerProduct(Ha, Hb):
    """
    Computes the Kronecker Product for the two input fifth order hypermatrices.

    EXAMPLES:

    ::

        sage: A=SeventhOrderSliceKroneckerProduct(HM(2,2,2,2,2,2,2,'a'),HM(2,2,2,2,2,2,2,'b'))
        sage: A.dimensions()
        [4, 4, 4, 4, 4, 4, 4]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Hc = HM(Ha.n(0)*Hb.n(0), Ha.n(1)*Hb.n(1), Ha.n(2)*Hb.n(2), Ha.n(3)*Hb.n(3), Ha.n(4)*Hb.n(4), Ha.n(5)*Hb.n(5), Ha.n(6)*Hb.n(6), 'zero')
    for i0 in range(Ha.n(0)):
        for i1 in range(Ha.n(1)):
            for i2 in range(Ha.n(2)):
                for i3 in range(Ha.n(3)):
                    for i4 in range(Ha.n(4)):
                        for i5 in range(Ha.n(5)):
                            for i6 in range(Ha.n(6)):
                                for j0 in range(Hb.n(0)):
                                    for j1 in range(Hb.n(1)):
                                        for j2 in range(Hb.n(2)):
                                            for j3 in range(Hb.n(3)):
                                                for j4 in range(Hb.n(4)):
                                                    for j5 in range(Hb.n(5)):
                                                        for j6 in range(Hb.n(6)):
                                                            Hc[Hb.n(0)*i0+j0,Hb.n(1)*i1+j1,Hb.n(2)*i2+j2,Hb.n(3)*i3+j3,Hb.n(4)*i4+j4,Hb.n(5)*i5+j5,Hb.n(6)*i6+j6]=Ha[i0,i1,i2,i3,i4,i5,i6]*Hb[j0,j1,j2,j3,j4,j5,j6]
    return Hc

def HypermatrixSliceKroneckerPower(U,n):
    """
    Computes the repeated Kronecker Product.

    EXAMPLES:

    ::

        sage: HypermatrixSliceKroneckerPower(HM(2,2,'a'),2)
        [[a00^2, a00*a01, a00*a01, a01^2], [a00*a10, a00*a11, a01*a10, a01*a11], [a00*a10, a01*a10, a00*a11, a01*a11], [a10^2, a10*a11, a10*a11, a11^2]]


    AUTHORS:
    - Edinah K. Gnang
    """
    T = U.copy()
    for i in range(n-1):
        T = T.tensor_product(U)
    return T

def ThirdOrderHypermatrixKroneckerSum(A,B):
    """
    Computes the  Kronecker sum for third order hypermatrix.

    EXAMPLES:

    ::

        sage: ThirdOrderHypermatrixKroneckerSum(HM(2,2,2,'a'),HM(2,2,2,'b'))
        [[[a000, a001, 0, 0], [a010, a011, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[a100, a101, 0, 0], [a110, a111, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, b000, b001], [0, 0, b010, b011]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, b100, b101], [0, 0, b110, b111]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order()==B.order() and A.order()==3:
        # Initializing the hypermatrix
        T = HM(A.n(0)+B.n(0), A.n(1)+B.n(1), A.n(2)+B.n(2), 'zero')
        # Loop filling up the top part of the hypermatrix
        for i in range(A.n(0)):
            for j in range(A.n(1)):
                for k in range(A.n(2)):
                    T[i,j,k]=A[i,j,k]
        # Loop filling up the bottom part of the hypermatrix
        for i in range(B.n(0)):
            for j in range(B.n(1)):
                for k in range(B.n(2)):
                    T[A.n(0)+i,A.n(1)+j,A.n(2)+k] = B[i,j,k]
        return T
    elif A.order()==B.order() and A.order()==4:
        # Initializing the hypermatrix
        T=HM(A.n(0)+B.n(0), A.n(1)+B.n(1), A.n(2)+B.n(2), A.n(3)+B.n(3), 'zero')
        # Loop filling up the top part of the hypermatrix
        for i in range(A.n(0)):
            for j in range(A.n(1)):
                for k in range(A.n(2)):
                    for l in range(A.n(3)):
                        T[i,j,k,l]=A[i,j,k,l]
        # Loop filling up the bottom part of the hypermatrix
        for i in range(B.n(0)):
            for j in range(B.n(1)):
                for k in range(B.n(2)):
                    for l in range(B.n(3)):
                        T[A.n(0)+i,A.n(1)+j,A.n(2)+k,A.n(3)+l]=B[i,j,k,l]
        return T
    elif A.order()==B.order() and A.order()==5:
        # Initializing the hypermatrix
        T=HM(A.n(0)+B.n(0), A.n(1)+B.n(1), A.n(2)+B.n(2), A.n(3)+B.n(3), A.n(4)+B.n(4), 'zero')
        # Loop filling up the top part of the hypermatrix
        for i in range(A.n(0)):
            for j in range(A.n(1)):
                for k in range(A.n(2)):
                    for l in range(A.n(3)):
                        for m in range(A.n(4)):
                            T[i,j,k,l,m]=A[i,j,k,l,m]
        # Loop filling up the bottom part of the hypermatrix
        for i in range(B.n(0)):
            for j in range(B.n(1)):
                for k in range(B.n(2)):
                    for l in range(B.n(3)):
                        for m in range(B.n(4)):
                            T[A.n(0)+i,A.n(1)+j,A.n(2)+k,A.n(3)+l,A.n(4)+m]=B[i,j,k,l,m]
        return T
    else:
        raise ValueError("The order of the input hypermatrices must match and be equal to 3.")

def GeneralHypermatrixKroneckerSum(A,B):
    """
    Computes the  Kronecker sum for arbitrary order hypermatrix.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixKroneckerSum(HM(2,2,'a'), HM(2,2,'b'))
        [[a00, a01, 0, 0], [a10, a11, 0, 0], [0, 0, b00, b01], [0, 0, b10, b11]]

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order()==B.order():
        # Initialization of the output hypermatrix
        #T=apply(HM,[A.n(i)+B.n(i) for i in range(A.order())]+['zero'])
        T=HM(*([A.n(i)+B.n(i) for i in range(A.order())]+['zero']))
        # Initialization of the list specifying the dimensions of A
        la = [A.n(i) for i in range(A.order())]
        # Main loop performing the transposition of the entries
        for i in range(prod(la)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,la[0]))]
            sm = Integer(mod(i,la[0]))
            for k in range(len(la)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(la[0:k+1])),la[k+1])))
                sm = sm+prod(la[0:k+1])*entry[len(entry)-1]
            T[tuple(entry)]=A[tuple(entry)]
        # Initialization of the list specifying the dimensions of B
        lb = [B.n(j) for j in range(A.order())]
        # Main loop performing the transposition of the entries
        for j in range(prod(lb)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(j,lb[0]))]
            sm = Integer(mod(j,lb[0]))
            for k in range(len(lb)-1):
                entry.append(Integer(mod(Integer((j-sm)/prod(lb[0:k+1])),lb[k+1])))
                sm = sm+prod(lb[0:k+1])*entry[len(entry)-1]
            T[tuple((Matrix(ZZ,entry)+Matrix(ZZ,A.dimensions())).list())]=B[tuple(entry)]
        return T
    else:
        raise ValueError("The order of the input hypermatrices must match.")

def GeneralHypermatrixPseudoKroneckerSum(A,B):
    """
    Computes the Pseudo Kronecker sum for arbitrary order hypermatrix.
    The operation ammounts to a blowup of the 0,0 entry of B into a matrix
    this came in up in the undiagonalization infimum analysis


    EXAMPLES:

    ::

        sage: GeneralHypermatrixPseudoKroneckerSum(HM(2,2,'a'), HM(2,2,'b'))
        [[a00, a01, 0], [a10, a11, b01], [0, b10, b11]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order()==B.order() and A.is_cubical() and B.is_cubical():
        # Initialization of the dimensions of the hypermatrix container
        dms=(HM(1,A.order(),A.dimensions())+HM(1,B.order(),B.dimensions())-HM(1,A.order(),'one')).list()
        # Initialization of  the arguments to passed on to the HM constructor
        inpts=dms+['zero']
        # Initialization of the hypermatrix container
        Ht=HM(*inpts)
        # Filling up the container with B
        Ht=Ht.fill_with(B,[v-1 for v in A.dimensions()])
        # Filling up the container with A
        Ht=Ht.fill_with(A,[0 for v in rg(A.order())])
        return Ht 
    else:
        raise ValueError("The order of the input hypermatrices must match.")

def GeneralHypermatrixKroneckerSumList(L):
    """
    Computes the Kronecker sum for a list of arbitrary order hypermatrices.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixKroneckerSumList([HM(2,2,'a'), HM(2,2,'b')])
        [[a00, a01, 0, 0], [a10, a11, 0, 0], [0, 0, b00, b01], [0, 0, b10, b11]]

    AUTHORS:
    - Edinah K. Gnang
    """
    A=L[0]
    for i in rg(1,len(L)):
        A=A.block_sum(L[i])
    return A


def GeneralHypermatrixKroneckerProduct(A,B):
    """
    Computes the  Kronecker product of arbitrary hypermatrices A, B of the same order.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixKroneckerProduct(HM(2,2,'a'), HM(2,2,'b'))
        [[a00*b00, a00*b01, a01*b00, a01*b01], [a00*b10, a00*b11, a01*b10, a01*b11], [a10*b00, a10*b01, a11*b00, a11*b01], [a10*b10, a10*b11, a11*b10, a11*b11]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order()==B.order():
        # Initialization of the output hypermatrix
        T=HM(*([A.n(i)*B.n(i) for i in range(A.order())]+['zero']))
        # Initialization of the list specifying the dimensions of A and B
        la = [A.n(i) for i in range(A.order())]; lb = [B.n(j) for j in range(B.order())]
        # Main loop performing the transposition of the entries
        for i in range(prod(la)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entrya = [Integer(mod(i,la[0]))]
            sma = Integer(mod(i,la[0]))
            for ka in range(len(la)-1):
                entrya.append(Integer(mod(Integer((i-sma)/prod(la[0:ka+1])),la[ka+1])))
                sma = sma+prod(la[0:ka+1])*entrya[len(entrya)-1]
            # Main loop performing the transposition of the entries
            for j in range(prod(lb)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entryb = [Integer(mod(j,lb[0]))]
                smb = Integer(mod(j,lb[0]))
                for kb in range(len(lb)-1):
                    entryb.append(Integer(mod(Integer((j-smb)/prod(lb[0:kb+1])),lb[kb+1])))
                    smb = smb+prod(lb[0:kb+1])*entryb[len(entryb)-1]
                T[tuple([lb[z]*Integer(entrya[z])+Integer(entryb[z]) for z in range(A.order())])]=A[tuple(entrya)]*B[tuple(entryb)]
        return T
    else:
        raise ValueError("The order of the input hypermatrices must match.")

def T2Pre(expr):
    """
    Converts formula written in the bracket tree encoding to the Prefix string encoding notation
    the symbol m will stand for the input -1


    EXAMPLES:

    The function implemented here tacitly assume that the input is valid

    ::

        sage: T2Pre(['+',1,1])
        '+11'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    s = str(expr)
    return ((((s.replace("[","")).replace("]","")).replace(",","")).replace("'","")).replace(" ","").replace('-1','m')


def T2P(expr):
    """
    Converts the formula tree to Postfix notation


    EXAMPLES:
    The tacitly assume that the input is valid

    ::

        sage: T2P(['+',1,1])
        '11+'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    s = str(expr)
    return ((((s.replace("[","")).replace("]","")).replace(",","")).replace("'","")).replace(" ","")[::-1].replace('-1','m')

def RollLD(L):
    """
    Given an Loaded die, L, the procedures rolls it
    the function output numbers from 1 to len(L)
    each weighted by the 


    EXAMPLES:
    The tacitly assume that the input list is made up of positve integers

    ::

        sage: RollLD([1])
        1


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    N = sum(L)
    r = randint(1,N)
    for i in rg(len(L)):
        if sum(L[:i+1]) >= r:
            return 1+i

@cached_function
def FaT(n):
    """
    The list of formula-binary trees only using addition gates
    which evaluates to the input integer n.

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: FaT(3)
        [['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return [1]
    else :
        gu = []
        for i in range(1,n):
            gu = gu + [['+', g1, g2] for g1 in FaT(i) for g2 in FaT(n-i)]
        return gu

@cached_function
def FaPre(n):
    """
    The list of formula only using addition gates
    which evaluates to the input integer n in prefix notation.

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: FaPre(3)
        ['+1+11', '++111']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2Pre(g) for g in FaT(n)]

@cached_function
def FaP(n):
    """
    The list of formula only using addition gates
    which evaluates to the input integer n in postfix notation.

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: FaP(3)
        ['11+1+', '111++']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2P(g) for g in FaT(n)]

@cached_function
def Ca(n):
    """
    Outputs the number of formula-binary trees only using addition gates.

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: Ca(3)
        2


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return 1
    else :
        return sum([Ca(i)*Ca(n-i) for i in range(1,n)])

@cached_function
def LopFaT(n):
    """
    Outputs all the formula-binary trees only using addition
    but the first term of the addition is >= the second term

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: LopFaT(3)
        [['+', ['+', 1, 1], 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return [1]
    else :
        gu = []
        for i in range(1, 1+floor(n/2)):
            gu = gu + [['+', g1, g2] for g1 in LopFaT(n-i) for g2 in LopFaT(i)]
        return gu

@cached_function
def LopCa(n):
    """
    Outputs the number of formula-binary trees only using addition gates
    such that the first term of the addition is >= the second term.
    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: LopCa(3)
        1


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return 1
    else :
        return sum([LopCa(i)*LopCa(n-i) for i in range(1,1+floor(n/2))])

def RaFaT(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n.
    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: RaFaT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return 1
    else :
        # Rolling the Loaded Die.
        j = RollLD([Ca(i)*Ca(n-i) for i in range(1,n+1)])
        return ['+', RaFaT(j), RaFaT(n-j)]

def RaFaPre(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n in Prefix notation.

    EXAMPLES:
    The input n must be greater than 0

    ::

        sage: RaFaPre(2)
        '+11'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return(T2Pre(RaFaT(n)))

def RaFaP(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n in Prefix notation.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFaP(2)
        '11+'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return(T2P(RaFaT(n)))

def RaLopFaT(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n such that the first
    term of the addition is >= the second term.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaLopFaT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return 1
    else:
        # Rolling the Loaded Die.
        j = RollLD([LopCa(i)*LopCa(n-i) for i in range(1,2+floor(n/2))])
        return ['+', RaLopFaT(n-j), RaLopFaT(j)]

def RaLopFaPre(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n such that the first
    term of the addition is >= the second term in prefix notation.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaLopFaPre(2)
        '+11'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2Pre(RaLopFaT(n))

def RaLopFaP(n):
    """
    Outputs a uniformly randomly chosen formula-binary tree
    which evaluate to the input integer n such that the first
    term of the addition is >= the second term in poistfix notation.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaLopFaP(2)
        '11+'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2P(RaLopFaT(n))

def LopFaPre(n):
    """
    Outputs all the formula-binary tree
    which evaluate to the input integer n such that the first
    term of the addition is >= the second term in prefix notation.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: LopFaPre(2)
        ['+11']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2Pre(f) for f in LopFaT(n)]

def LopFaP(n):
    """
    Outputs all the formula-binary tree
    which evaluate to the input integer n such that the first
    term of the addition is >= the second term in prefix notation.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: LopFaP(2)
        ['11+']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2P(f) for f in LopFaT(n)]

def FamTa(n):
    """
    The list of formula-binary trees only using addition  and
    multiplication gates with the top gate being an addition
    gate which evaluates to the input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FamTa(2)
        [['+', 1, 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return [1]
    else :
        gu = []
        for i in range(1,n):
            gu = gu + [['+', g1, g2] for g1 in FamT(i) for g2 in FamT(n-i)]
        return gu

@cached_function
def FamTm(n):
    """
    The list of formula-binary trees only using addition  and
    multiplication gates with the top gate being a multiplication
    gate which evaluates to the input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FamTm(4)
        [['*', ['+', 1, 1], ['+', 1, 1]]]
        

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return []
    else :
        gu = []
        for i in range(2,1+floor(n/2)):
            if mod(n,i) == 0:
                gu = gu + [['*', g1, g2] for g1 in FamT(i) for g2 in FamT(n/i)]
        return gu

def FamT(n):
    """
    The list of formula-binary trees only using addition and
    multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FamT(3)
        [['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return FamTa(n) + FamTm(n)

@cached_function
def Cama(n):
    """
    Output the size of the set of formulas produced by the procedure FamTa(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Cama(6)
        48


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return 1
    else:
        return sum([Cam(i)*Cam(n-i) for i in range(1,n)])

@cached_function
def Camm(n):
    """
    Output the size of the set of formulas produced by the procedure FamTa(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Camm(6)
        4


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return sum([Cam(i)*Cam(n/i) for i in range(2,1+floor(n/2)) if mod(n,i)==0])

@cached_function
def Cam(n):
    """
    Output the size of the set of formulas produced by the procedure FamTa(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Cam(2)
        1


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return Cama(n)+Camm(n)

def RaFamTa(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return 1
    else:
        j = RollLD([Cam(i)*Cam(n-i) for i in range(1,n)])
        return ['+', RaFamT(j), RaFamT(n-j)]

def RaFamTm(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamTm(4)
        ['*', ['+', 1, 1], ['+', 1, 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if not is_prime(n):
        lu = []
        L  = []
        for i in range(2,1+floor(n/2)):
            if mod(n,i)==0:
                lu.append(i)
                L.append(Cam(i)*Cam(n/i))
        j = RollLD(L)
        return ['*', RaFamT(lu[j-1]), RaFamT(n/lu[j-1])]

def RaFamT(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return 1
    else:
        i = RollLD([Cama(n),Camm(n)])
        if i==1:
            return RaFamTa(n)
        else :
            return RaFamTm(n)

@cached_function
def FamP(n):
    """
    Outputs the set of formula-binary tree written in postfix notation
    which evaluates to the input integer n using only addition
    and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FamP(3)
        ['11+1+', '111++']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2P(f) for f in FamT(n)]

@cached_function
def FamPre(n):
    """
    Outputs the set of formula-binary tree written in prefix notation
    which evaluates to the input integer n using only addition
    and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FamPre(3)
        ['+1+11', '++111']


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return [T2Pre(f) for f in FamT(n)]

def RaFamP(n):
    """
    Outputs a uniformly randomly sample formula-binary tree written
    in postfix notation which evaluates to the input integer n using
    only addition and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamP(2)
        '11+'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2P(RaFamT(n))

def RaFamPre(n):
    """
    Outputs a uniformly randomly sample formula-binary tree written
    in prefix notation which evaluates to the input integer n using
    only addition and multiplication gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamPre(2)
        '+11'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2Pre(RaFamT(n))

@cached_function
def FameTa(n):
    """
    The list of formula-binary trees only using addition,
    multiplication, and exponentiation gates. The top gate
    being an addition gate and and the formula evaluates to
    the input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::
        sage: FameTa(3)
        [['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return [1]
    else:
        gu = []
        for i in range(1,n):
            gu = gu + [['+', g1, g2] for g1 in FameT(i) for g2 in FameT(n-i)]
        return gu

@cached_function
def FameTm(n):
    """
    The list of formula-binary trees only using addition.
    multiplication and exponentiation gates with the top
    gate being a multiplication gate which evaluates to the
    input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FameTm(6)
        [['*', ['+', 1, 1], ['+', 1, ['+', 1, 1]]],
         ['*', ['+', 1, 1], ['+', ['+', 1, 1], 1]],
         ['*', ['+', 1, ['+', 1, 1]], ['+', 1, 1]],
         ['*', ['+', ['+', 1, 1], 1], ['+', 1, 1]]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return []
    else :
        gu = []
        for i in range(2,1+floor(n/2)):
            if mod(n,i) == 0:
                gu = gu + [['*', g1, g2] for g1 in FameT(i) for g2 in FameT(n/i)]
        return gu

@cached_function
def FameTe(n):
    """
    The list of formula-binary trees only using addition.
    multiplication and exponentiation gates with the top
    gate being an exponetiation gate which evaluates to the
    input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FameTe(4)
        [['^', ['+', 1, 1], ['+', 1, 1]]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return []
    else :
        gu = []
        for i in range(2,2+floor(log(n)/log(2))):
            if floor(n^(1/i)) == ceil(n^(1/i)):
                gu = gu + [['^', g1, g2] for g1 in FameT(i) for g2 in FameT(n^(1/i))]
        return gu

@cached_function
def FameT(n):
    """
    The list of formula-binary trees only using addition.
    multiplication and exponentiation gates which evaluates to the
    input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: FameT(3)
        [['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return FameTa(n) + FameTm(n) + FameTe(n)

@cached_function
def Camea(n):
    """
    Output the size of the set of formulas produced by the procedure FameTa(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Camea(6)
        54


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return 1
    else:
        return sum([Came(i)*Came(n-i) for i in range(1,n)])

@cached_function
def Camem(n):
    """
    Output the size of the set of formulas produced by the procedure FameTm(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Camem(6)
        4


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return sum([Came(i)*Came(n/i) for i in range(2,1+floor(n/2)) if mod(n,i)==0])

@cached_function
def Camee(n):
    """
    Output the size of the set of formulas produced by the procedure FameTe(n).

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Camee(9)
        2


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return sum([Came(i)*Came(n^(1/i)) for i in range(2,2+floor(log(n)/log(2))) if floor(n^(1/i)) == ceil(n^(1/i))])

@cached_function
def Came(n):
    """
    Output the size of the set of formulas produced by the procedure FameT(n).
    Which counts all monotone formula encodings evaluating using a combination
    of fanin two addition, multiplication and exponentiation gates which evaluates
    to the input integer n

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Came(6)
        58


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return Camea(n)+Camem(n)+Camee(n)

def RaFameTa(n):
    """
    Output a Random Formula Tres chosen uniformly at random amoung all
    Tree representation of the positive integer n which use a combination
    of addition, multiplication and exponentiation gates with the top gate
    being the addition gate

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFameTa(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return 1
    else:
        j = RollLD([Came(i)*Came(n-i) for i in range(1,n)])
        return ['+', RaFameT(j), RaFameT(n-j)]
        
def RaFameTm(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    and multiplication and exponentiaiton gates, with the top
    gate being a multiplication gate.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFameT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if not is_prime(n):
        lu = []
        L  = []
        for i in range(2,1+floor(n/2)):
            if mod(n,i)==0:
                lu.append(i)
                L.append(Came(i)*Came(n/i))
        j = RollLD(L)
        return ['*', RaFameT(lu[j-1]), RaFameT(n/lu[j-1])]

def RaFameTe(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    and multiplication and exponentiaiton gates, with the top
    gate being an exponentiation gate.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFameTe(4)
        ['^', ['+', 1, 1], ['+', 1, 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if not is_prime(n) and n>1:
        lu = []
        L  = []
        for i in range(2,1+floor(n/2)):
            if floor(n^(1/i)) == ceil(n^(1/i)):
                lu.append(i)
                L.append(Came(i)*Came(n^(1/i)))
        j = RollLD(L)
        return ['^', RaFameT( n^(1/lu[j-1]) ), RaFameT(lu[j-1])]

def RaFameT(n):
    """
    Outputs a formula-binary tree sampled uniformly at random
    which evaluates to the input integer n using only addition
    multiplication and exponentiation gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFameT(2)
        ['+', 1, 1]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return 1
    else:
        i = RollLD([Camea(n),Camem(n),Camee(n)])
        if i==1:
            return RaFameTa(n)
        elif i==2:
            return RaFameTm(n)
        else :
            return RaFameTe(n)

def RaFameP(n):
    """
    Outputs a uniformly randomly sample formula-binary tree written
    in postfix notation which evaluates to the input integer n using
    only addition, multiplication and exponentiation gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFameP(2)
        '11+'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2P(RaFameT(n))

def RaFamePre(n):
    """
    Outputs a uniformly randomly sample formula-binary tree written
    in prefix notation which evaluates to the input integer n using
    only addition, multiplication  and exponentiation gates.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: RaFamePre(2)
        '+11'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return T2Pre(RaFameT(n))

def Tsize(T):
    """
    Outputs the size of the Tree associated with the formula.
 
    EXAMPLES:
    
    ::

        sage: Tsize(['+', 1, 1])
        3


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if T==1:
        return 1
    elif T==-1:
        return 1
    else:
        return 1+Tsize(T[1])+Tsize(T[2])

@cached_function
def ShortestTame(n):
    """
    Outputs the length and an example of the smallest binary-tree
    formula using addition, multiplication and exponentiation

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: ShortestTame(2)
        [3, ['+', 1, 1]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n==1:
        return [1,1]
    else:
        aluf = []
        si = 2*n
        for i in range(1,n):
            T1 = ShortestTame(i)
            T2 = ShortestTame(n-i)
            if (T1[0]+T2[0]+1) < si:
                si = T1[0]+T2[0]+1
                if EvalT(T1[1]) <= EvalT(T2[1]):
                    aluf = ['+', T1[1], T2[1]]
                else:
                    aluf = ['+', T2[1], T1[1]]
        for i in range(2,floor(n/2)):
            if mod(n,i)==0:
                T1 = ShortestTame(i)
                T2 = ShortestTame(n/i)
                if (T1[0]+T2[0]+1) < si:
                    si = T1[0]+T2[0]+1
                    if EvalT(T1[1]) <= EvalT(T2[1]):
                        aluf = ['*', T1[1], T2[1]]
                    else:
                        aluf = ['*', T2[1], T1[1]]
        for i in range(2,2+floor(log(n)/log(2))):
            if floor(n^(1/i)) == ceil(n^(1/i)):
                T1 = ShortestTame(n^(1/i))
                T2 = ShortestTame(i)
                if (T1[0]+T2[0]+1) < si:
                    si = T1[0]+T2[0]+1
                    aluf = ['^', T1[1], T2[1]]
        return [si, aluf]

@cached_function
def ShortestTameList(n):
    """
    Outputs the list of the smallest binary-tree
    formula using addition, multiplication and exponentiation

    EXAMPLES:

    ::

        sage: ShortestTameList(4)
        [['+', 1, ['+', 1, ['+', 1, 1]]], ['+', 1, ['+', ['+', 1, 1], 1]], ['+', ['+', 1, 1], ['+', 1, 1]], ['+', ['+', 1, ['+', 1, 1]], 1], ['+', ['+', ['+', 1, 1], 1], 1], ['*', ['+', 1, 1], ['+', 1, 1]], ['^', ['+', 1, 1], ['+', 1, 1]]]


    AUTHORS:
    - Edinah K. Gnang

    To Do :
    - Try to implement faster version of this procedure

    """
    # Obtaining the minimal size
    si=ShortestTame(n)[0]
    return [f for f in FameT(n) if Tsize(f)==si]

def get_permutation(la,lb):
    """
    Obtains a permutation list from two lists of the same size.
    No check is performed here the user must be very carefull
    to input lists of the same size
    
    EXAMPLES:

    ::

        sage: get_permutation([1, 2, 3, 4, 6, 8],[1, 2, 4, 8, 3, 6])
        [0, 1, 4, 2, 5, 3]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the output
    L = list()
    # Loop performing the evaluation.
    for i1 in rg(len(la)):
        for i2 in rg(len(lb)):
            if la[i1] == lb[i2]:
                L.append(i2)
                break
    return L

def get_tuple_permutation(la,lb):
    """
    Obtains a permutation list from two lists of the same size.
    No check is performed here the user must be very carefull
    to input lists of the same size
    
    EXAMPLES:

    ::

        sage: get_tuple_permutation([1, 2, 3, 4, 6, 8],[1, 2, 4, 8, 3, 6])
        [(0, 0), (1, 1), (2, 4), (3, 2), (4, 5), (5, 3)]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the output
    L = list()
    # Loop performing the evaluation.
    for i1 in rg(len(la)):
        for i2 in rg(len(lb)):
            if la[i1] == lb[i2]:
                L.append(i2)
                break
    return [(i,L[i]) for i in rg(len(L))]

def permute(l,p):
    """
    Permutes the entries of the list l according to the permutation p
    No check is performed here the user must be very carefull
    to input lists of the same size
 
    EXAMPLES:

    ::

        sage: permute([1, x, x^x, x^(x + 1), x + 1, (x + 1)*x],[0, 1, 4, 2, 5, 3])
        [1, x, x + 1, x^x, (x + 1)*x, x^(x + 1)]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the output
    L = list()
    # Loop performing the evaluation.
    for i in range(len(l)):
        L.append(l[p[i]])
    return L

@cached_function
def NaiveZetaT(nbit):
    """
    Produces Tree associated with the Second Canonical Forms.

    EXAMPLES:

    ::

        sage: NaiveZetaT(1)
        [[['+', 1, 1]], [1, ['+', 1, 1]]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 

    """

    # Initial conditions
    Pk = [['+',1,1]]
    Nk = [1] + Pk
    for it in range(1,nbit):
        L = []
        for p in Pk:
            if L == []:
                L = [1] + [p] + [['^',p,Nk[i]] for i in range(1,len(Nk))]

            else:
                Lp = [p] + [['^',p,Nk[i]] for i in range(1,len(Nk))]
                L  = L + [['*',L[i],n] for i in range(1,len(L)) for n in Lp] + Lp

        # Sorting the list
        Va = [EvalT(l) for l in L]
        Vb = copy(Va)
        Vb.sort()
        perm = get_permutation(Vb, Va)
        # Reinitialization of the list Nk
        Nk = permute(L, perm)
        # Set completion
        l = len(Nk)
        i = 0
        while i < l-1:
            if EvalT(Nk[i+1]) - EvalT(Nk[i]) == 2 :
                Pk.append(['+',1,Nk[i]])
                Nk.insert(i+1, ['+',1,Nk[i]])
                l = l+1
            else:
                i = i+1
    return [Pk, Nk]


@cached_function
def Goodstein(number_of_iterations=1):
    """
    Produces the set of symbolic expressions associated with the
    the first canonical form. In all the expressions the symbolic
    variable x stands for a short hand notation for the formula (1+1).

    EXAMPLES:

    ::

        sage: Goodstein(1)[:3]
        [1, x, x + 1]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initial condition of Initial set
    Ng0 = [1, x]
    # Main loop performing the iteration
    for iteration in range(number_of_iterations):
        # Implementation of the set recurrence
        Ng0 = [1] + [x^n for n in Ng0]
        # Initialization of a buffer list Ng1
        # which will store updates to Ng0
        Ng1 = []
        for n in Set(Ng0).subsets():
            if n.cardinality() > 0:
                Ng1.append(sum(n))
        Ng0 = list(Ng1)
    Nf = []
    for i in range(len(Ng0)):
        Nf.append([])
    for i in range(len(Nf)):
        Nf[(Ng0[i]).subs(x=2)-1].append(Ng0[i])
    Ng0=[]
    for i in range(len(Nf)):
        Ng0.append(Nf[i][0])
    return Ng0

@cached_function
def GoodsteinT(number_of_iterations=1):
    """
    Produces Tree associated with Goodstein Trees.

    ::

        sage: GoodsteinT(1)
        [1,
         ['+', 1, 1],
         ['+', 1, ['+', 1, 1]],
         ['^', ['+', 1, 1], ['+', 1, 1]],
         ['+', 1, ['^', ['+', 1, 1], ['+', 1, 1]]],
         ['+', ['+', 1, 1], ['^', ['+', 1, 1], ['+', 1, 1]]],
         ['+', ['+', 1, ['+', 1, 1]], ['^', ['+', 1, 1], ['+', 1, 1]]]]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initial condition of Initial set
    Ng0 = [1, ['+',1,1]]
    # Main loop performing the iteration
    for iteration in range(number_of_iterations):
        # Implementation of the set recurrence
        Tmp = copy(Ng0)
        Tmp.pop(0)
        Ng0 = [1] + [['+',1,1]] + [['^',['+',1,1], m] for m in Tmp]
        # Initialization of a buffer list Ng1
        # which will store updates to Ng0
        Ng1 = []
        for n in Set(range(len(Ng0))).subsets():
            if n.cardinality() == 1:
                Ng1.append(Ng0[n[0]])
            elif n.cardinality() > 1:
                T = Ng0[n[0]]
                for j in range(1,n.cardinality()):
                    T = ['+', T, Ng0[n[j]]]
                Ng1.append(T)
        Ng0 = copy(Ng1)
    # Sorting the obtained list
    Nf = []
    for i in range(len(Ng0)):
        Nf.append([])
    for i in range(len(Nf)):
        Nf[EvalT(Ng0[i])-1].append(Ng0[i])
    Ng0=[]
    for i in range(len(Nf)):
        Ng0.append(Nf[i][0])
    return Ng0

def list_eval(L):
    """
    Perform the evaluation of the list to integers
 
    EXAMPLES:

    ::

        sage: x=var('x'); list_eval([1, x, x+1, x^x])
        [1, 2, 3, 4]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return [i.substitute(x=2) for i in L]

def get_permutation(la,lb):
    """
    Obtains a permutation list from two lists of the same size.
    No check is performed here the user must be very carefull
    to input lists of the same size
    
 
    EXAMPLES:

    ::

        sage: get_permutation([1, 2, 3, 4, 6, 8], [1, 2, 4, 8, 3, 6])
        [0, 1, 4, 2, 5, 3]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the output
    L = list()
    # Loop performing the evaluation.
    for i1 in range(len(la)):
        for i2 in range(len(lb)):
            if la[i1] == lb[i2]:
                L.append(i2)
                break
    return L

def permute(l,p):
    """
    Permutes the entries of the list l according to the permutation p
    No check is performed here the user must be very carefull
    to input lists of the same size
 
    EXAMPLES:

    ::

        sage: permute([1, x, x^x, x^(x + 1), x + 1, (x + 1)*x],[0, 1, 4, 2, 5, 3])
        [1, x, x + 1, x^x, (x + 1)*x, x^(x + 1)]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the output
    L = list()
    # Loop performing the evaluation.
    for i in range(len(l)):
        L.append(l[p[i]])
    return L

@cached_function
def base2expansion(n):
    """
    Returns the polynomial encoding the binary expansion
     
    EXAMPLES:

    The function is a crucial first step to the recursive encoding
    
    ::

        sage: p = base2expansion(10)
        sage: p
        x^3 + x

    AUTHORS:
    - Edinah K. Gnang
    -  
    """
    x = var('x')
    # polynomial
    p = 0
    k = 2
    if n == 1:
        return 1
    elif n > 1:
        while k < n:
            k = k^2
        if k == n:
            return x^(log(k,2))
        elif k > n:
            k = sqrt(k)
            while k < n:
                k = 2*k
                if k == n:
                    return x^(log(k,2))
                elif k > n:
                    p = x^(floor(log(k/2,2))) + base2expansion(n-k/2)
    return p

@cached_function
def base2expansionT(n):
    """
    Returns the polynomial encoding the binary expansion
     
    EXAMPLES: 
    The function is a crucial first step to the recursive encoding
    
    ::

        sage: base2expansionT(2)
        ['^', ['+', 1, 1], 1]


    AUTHORS:
    - Edinah K. Gnang
    -  
    """
    x = var('x')
    # polynomial
    p = 0; k = 2
    if n == 1:
        return 1
    elif n > 1:
        while k < n:
            k = k^2
        if k == n:
            return ['^',['+',1,1],log(k,2)]
        elif k > n:
            k = sqrt(k)
            while k < n:
                k = 2*k
                if k == n:
                    return ['^',['+',1,1],log(k,2)]
                elif k > n:
                    p = ['+',['^',['+',1,1],(floor(log(k/2,2)))],base2expansionT(n-k/2)]
    return p

@cached_function
def recurse_base2expansion(n):
    """
    Returns the Goodstein encoding of the input integer n
     
    EXAMPLES: 
    The function builds the crucial base2expansion function
    however it should be noted that it's a horrible idea
    to use this function to compute the recursive encoding
    for a list of consecutive integer the number of recursive
    call is unmanageable
    
    ::

        sage: recurse_base2expansion(4)
        x^x
        

    AUTHORS:
    - Edinah K. Gnang
    -  
    """
    p = 0; k = 2
    if n == 1:
        return 1
    elif n > 1:
        while k < n:
            k = k^2
        if k == n:
            return x^recurse_base2expansion(log(k,2))
        elif k > n:
            k = sqrt(k)
            while k < n:
                k = 2*k
                if k == n:
                    return x^recurse_base2expansion(log(k,2))
                elif k > n:
                    p = x^recurse_base2expansion(floor(log(k/2,2))) + recurse_base2expansion(n-k/2)
    return p

@cached_function
def recurse_base2expansionT(n):
    """
    Returns the Goodstein Tree encoding of the input integer n
     
    EXAMPLES: 
    The function builds the crucial base2expansion function
    however it should be noted that it's a horrible idea
    to use this function to compute the recursive encoding
    for a list of consecutive integer the number of recursive
    call is unmanageable
    
    ::

        sage: recurse_base2expansionT(2)
        ['^', ['+', 1, 1], 1]


    AUTHORS:
    - Edinah K. Gnang
    -  
    """
    p = 0; k = 2
    if n == 1:
        return 1
    elif n > 1:
        while k < n:
            k = k^2
        if k == n:
            return ['^',['+',1,1],recurse_base2expansionT(log(k,2))]
        elif k > n:
            k = sqrt(k)
            while k < n:
                k = 2*k
                if k == n:
                    return ['^',['+',1,1],recurse_base2expansionT(log(k,2))]
                elif k > n:
                    p = ['+',['^',['+',1,1],recurse_base2expansionT(floor(log(k/2,2)))],recurse_base2expansionT(n-k/2)]
    return p

@cached_function
def Fa3T(n):
    """
    The list of formula-binary trees only using fan-in three addition gates
    which evaluates to the input integer n.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Fa3T(3)
        [['+', 1, 1, 1]]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1:
        return [1]
    else :
        gu = []
        for i in range(1,n,2):
            for j in range(1,n-i,2):
                gu = gu + [['+', g1, g2, g3] for g1 in Fa3T(i) for g2 in Fa3T(j) for g3 in Fa3T(n-i-j)]
        return gu

@cached_function
def Ca3(n):
    """
    Outputs the number of formula-binary trees only using fan-in three addition gates.
    This is a special  case of the Fuss-Catalan sequence.

    EXAMPLES:

    The input n must be greater than 0

    ::

        sage: Ca3(3)
        1


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger
    To Do :
    - Try to implement faster version of this procedure

    """
    if n == 1 :
        return 1
    else :
        return sum([Ca3(i)*Ca3(j)*Ca3(n-i-j) for i in range(1,n,2) for j in range(1,n-i,2)])

def Zeta(nbitr):
    """
    Produces Tree associated with the Second Canonical Forms.
    Implements an improved version of the zeta recurrence and
    the combinatorial tower sieve.

    EXAMPLES:

    ::

        sage: Zeta(1)
        The current iteration will uncover 1.00000000000000 new primes in the range [2.00000000000000, 4.00000000000000]
        [[x, x + 1], [1, x, x + 1, x^x]]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger
    
    To Do :
    - Try to implement faster version of this procedure

    """
    x = var('x')
    # Pr corresponds to the initial list of primes
    Pr = [x]
    # Nu corresponds to the initial list of integer
    NuC  = [1,x]; TNuC = [1,x]
    # Initializing the upper and lower bound
    upr_bnd = 2^2; lwr_bnd = 2
    # Computing the set recurrence
    for itr in range(nbitr):
        for jtr in range(log(upr_bnd,2)-log(lwr_bnd,2)):
            TpNu = [1]
            for p in Pr:
                TpNu=TpNu+[m*pn for m in TpNu for pn in [p^n for n in NuC if (p^n).subs(x=2)<=2^(log(lwr_bnd,2)+jtr+1)] if (m*pn).subs(x=2)<=2^(log(lwr_bnd,2)+jtr+1)]
            # Keeping only the elements within the range of the upper and lower bound
            Nu = [f for f in TpNu if (2^(log(lwr_bnd,2)+jtr)<f.subs(x=2) and f.subs(x=2)<=2^(log(lwr_bnd,2)+jtr+1))]
            print('The current iteration will uncover '+str(2^(N(log(lwr_bnd,2))+jtr+1)-2^(N(log(lwr_bnd,2))+jtr)-len(Nu))+' new primes in the range ['+str(2^(N(log(lwr_bnd,2))+jtr))+', '+str(2^(N(log(lwr_bnd,2))+jtr+1))+']')
            # Obtaining the corresponding sorted integer list
            la = [f.subs(x=2) for f in Nu]; lb = copy(la); lb.sort()
            # Obtaining the sorting permutation
            perm = []
            for i1 in range(len(la)):
                for i2 in range(len(lb)):
                    if lb[i1]==la[i2]:
                        perm.append(i2)
                        break
            # Sorting the list using the obtained permutation
            Nu = [Nu[perm[j]] for j in range(len(Nu))]
            # Computing the set completion
            TNuC = TNuC + Nu
            l = len(TNuC)
            i = 2^(log(lwr_bnd,2)+jtr-1)
            while i<l-1:
                if(TNuC[i+1].subs(x=2)-TNuC[i].subs(x=2)==2):
                    Pr.append(TNuC[i]+1)
                    TNuC.insert(i+1,TNuC[i]+1)
                    l=l+1
                else:
                    i=i+1
        # Updating the list of integers
        NuC = TNuC
        # Updating the upper and lower bound
        lwr_bnd = upr_bnd
        upr_bnd = 2^upr_bnd
    return [Pr,NuC]        

@cached_function
def ZetaT(nbitr):
    """
    Produces Tree associated with the Second Canonical Forms.
    Implements an improved version of the zeta recurrence and
    the combinatorial tower sieve.

    EXAMPLES:

    ::

        sage: ZetaT(1)
        The current iteration will uncover 1.00000000000000 new primes in the range [2.00000000000000, 4.00000000000000]
        [[['+', 1, 1], ['+', 1, ['+', 1, 1]]],
         [1, ['+', 1, 1], ['+', 1, ['+', 1, 1]], ['^', ['+', 1, 1], ['+', 1, 1]]]]

    AUTHORS:
    - Edinah K. Gnang

    To Do :
    - Try to implement faster version of this procedure

    """
    # Pr corresponds to the initial list of primes
    Pr = [ ['+',1,1] ]
    # Nu corresponds to the initial list of integer
    NuC  = [1] + Pr
    TNuC = [1] + Pr
    # Initializing the upper and lower bound
    upr_bnd = 2^2
    lwr_bnd = 2
    # Computing the set recurrence
    for itr in range(nbitr):
        for jtr in range(log(upr_bnd,2)-log(lwr_bnd,2)):
            TpNu = [1]
            for p in Pr:
                TpNu = TpNu+[pn for pn in [['^',p,n] for n in NuC if EvalT(['^',p,n])<=2^(log(lwr_bnd,2)+jtr+1)]]+[['*',m,pn] for m in TpNu[1:] for pn in [['^',p,n] for n in NuC if EvalT(['^',p,n])<=2^(log(lwr_bnd,2)+jtr+1)]  if EvalT(['*',m,pn])<=2^(log(lwr_bnd,2)+jtr+1)]
            # Keeping only the elements within the range of the upper and lower bound
            Nu = [f for f in TpNu if (2^(log(lwr_bnd,2)+jtr)<EvalT(f) and EvalT(f)<=2^(log(lwr_bnd,2)+jtr+1))] 
            print('The current iteration will uncover '+str(2^(N(log(lwr_bnd,2))+jtr+1)-2^(N(log(lwr_bnd,2))+jtr)-len(Nu))+' new primes in the range ['+str(2^(N(log(lwr_bnd,2))+jtr))+', '+str(2^(N(log(lwr_bnd,2))+jtr+1))+']')
            # Obtaining the corresponding sorted integer list
            la = [EvalT(f) for f in Nu]; lb = copy(la); lb.sort()
            # Obtaining the sorting permutation
            perm = []
            for i1 in range(len(la)):
                for i2 in range(len(lb)):
                    if lb[i1]==la[i2]:
                        perm.append(i2)
                        break
            # Sorting the list using the obtained permutation
            Nu = [Nu[perm[j]] for j in range(len(Nu))]
            # Perfoming the set completion
            TNuC = TNuC + Nu
            l = len(TNuC)
            i = 2^(log(lwr_bnd,2)+jtr-1)
            while i<l-1:
                if(EvalT(TNuC[i+1])-EvalT(TNuC[i])==2):
                    Pr.append(['+',1,TNuC[i]])
                    TNuC.insert(i+1,['+',1,TNuC[i]])
                    l=l+1
                else:
                    i=i+1
        # Updating the list of integers
        NuC = TNuC
        # Updating the upper and lower bound
        lwr_bnd = upr_bnd
        upr_bnd = 2^upr_bnd
    return [Pr,NuC]        

def Horner(nbitr):
    """
    Produces list of symbolic expressions associated with recursive horner encoding.

    EXAMPLES:

    ::

        sage: Horner(2)
        [1, x, x + 1, x^x, (x + 1)*x, (x + 1)*x^x, x^(x^x), x^(x + 1), x^x + 1, (x^x + 1)*x, (x^x + 1)*x^x, (x^x + 1)*x^(x^x), x^(x + 1)*(x^x + 1), x^((x + 1)*x), x^((x + 1)*x^x), x^(x^(x^x)), x^(x^(x + 1)), x^(x^x + 1), (x + 1)*x + 1, (x + 1)*x^x + 1, x^(x^x) + 1, x^(x + 1) + 1]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 

    """
    x = var('x')
    Nk  = [1, x, 1+x, x^x]
    # Initialization of the lists
    LEk = [x^x]; LOk = [1+x]; LPk = [x, x^x]
    # Main loop computing the encoding
    for i in range(nbitr):
        # Updating the list
        LEkp1 = [lp*lo for lp in LPk for lo in LOk] + [x^m for m in LEk+LOk]
        LOkp1 = [n+1 for n in LEk]
        LPkp1 = LPk + [x^m for m in LEk+LOk]
        # The New replaces the old
        Nk = Nk + LEkp1+LOkp1
        LEk = LEkp1; LOk = LOkp1; LPk = LPkp1
    return Nk

def HornerT(nbitr):
    """
    Produces Tree associated with the recursive Horner encoding

    EXAMPLES:

    ::

        sage: HornerT(1)
        [1,
         ['+', 1, 1],
         ['+', 1, ['+', 1, 1]],
         ['^', ['+', 1, 1], ['+', 1, 1]],
         ['*', ['+', 1, 1], ['+', 1, ['+', 1, 1]]],
         ['*', ['^', ['+', 1, 1], ['+', 1, 1]], ['+', 1, ['+', 1, 1]]],
         ['^', ['+', 1, 1], ['^', ['+', 1, 1], ['+', 1, 1]]],
         ['^', ['+', 1, 1], ['+', 1, ['+', 1, 1]]],
         ['+', 1, ['^', ['+', 1, 1], ['+', 1, 1]]]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 

    """
    # Initial set
    Nk  = [ 1, ['+',1,1], ['+',1,['+',1,1]], ['^',['+',1,1],['+',1,1]] ]
    # Initialization of the lists
    LEk = [ ['^',['+',1,1],['+',1,1]] ]
    LOk = [ ['+',1,['+',1,1]] ]
    LPk = [ ['+',1,1], ['^',['+',1,1],['+',1,1]] ]
    # Main loop computing the recursive horner encoding
    for i in range(nbitr):
        # Updating the list
        LEkp1 = [['*',lp,lo] for lp in LPk for lo in LOk] + [['^',['+',1,1],m] for m in LEk+LOk]
        LOkp1 = [['+',1,n] for n in LEk]
        LPkp1 = LPk + [['^',['+',1,1],m] for m in LEk+LOk]
        # The New replaces the old
        Nk = Nk+LEkp1+LOkp1
        LEk = LEkp1; LOk = LOkp1; LPk = LPkp1
    return Nk

def EvalT(T):
    """
    Outputs the evaluation value of a tree.

    EXAMPLES:

    ::

        sage: EvalT(['+', ['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]])
        6

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger
    """
    if T == 1:
        return 1
    elif T == -1:
        return -1
    elif T[0] == '+':
        return EvalT(T[1]) + EvalT(T[2])
    elif T[0] == '*':
        return EvalT(T[1]) * EvalT(T[2])
    elif T[0] == '^':
        return EvalT(T[1]) ^ EvalT(T[2])
    else:
        print('IMPROPER INPUT !!!')

def EvalPolyT(P, X, Tg):
    """
    Outputs the evaluation or substitution of the polynomial at tuple 
    description. The first input is the polynomial. The second is the
    list of variable. The second input is the tuple description of the 
    function. The code does not check that T is a list of size len(X).

    EXAMPLES:

    ::

        sage: sz=Integer(6); X=var_list('x',sz); P=sum(X); Tg=[(0,0)]+[(i,i-1) for i in rg(1,sz)]; EvalPolyT(P, X, Tg)
        6

    AUTHORS:
    - Edinah K. Gnang and Kailee Lin
    """
    return P.subs([X[i]==Tg[i][1] for i in rg(len(X))])
 
@cached_function
def MonotoneFormula(n):
    """
    Outputs Monotone formula encodings of length at most n.

    EXAMPLES:

    ::

        sage: MonotoneFormula(3)
        [[], [1], [], []]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n<=3:
        return [[], [1], [], []]
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for o in ['+', '*', '^']:
                for i in range(1,sz-1):
                        A[sz]=A[sz]+[[o,s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0)]
        return A 

@cached_function
def ReducedMonotoneFormula(n):
    """
    Outputs monotone formula encodings of length at most n.

    EXAMPLES:

    ::

        sage: ReducedMonotoneFormula(3)
        [[], [1], [], []]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n<=3:
        return [[], [1], [], []]
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['+',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and not EvalT(s).is_zero() and not EvalT(t).is_zero() and not EvalT(['+',s,t]).is_zero()]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['*',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['*',s,t])!=1]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['^',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['^',s,t])!=1]
        return A

def ReducedMonotoneFormulaSets(sz):
    """
    Outputs set of numbers associated with monotone encodings
    of complexity less then the size input parameter sz.

    EXAMPLES:

    ::

        sage: ReducedMonotoneFormulaSets(5)
        [{}, {1}, {}, {2}, {}, {3}]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    Lt=ReducedMonotoneFormula(sz)
    # Filling up the result list
    Rslt=[]
    for n in range(sz+1):
        L=[]; i=0
        while i<len(Lt[n]):
            L.append(Lt[n][i])
            i=i+1
        Rslt.append(Set([EvalT(L[i]) for i in range(len(L))]))
    # Cleaning up the list
    for i in range(1,len(Rslt)):
        for j in range(i):
            Rslt[i]=Rslt[i].difference(Rslt[j])
    return Rslt

@cached_function
def NonMonotoneFormula(n):
    """
    Outputs non-monotone formula encodings of length at most n.

    EXAMPLES:

    ::

        sage: NonMonotoneFormula(3)
        [[], [1, -1], [], []]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n<=3:
        return [[], [1,-1], [], []]
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1,-1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for o in ['+', '*', '^']:
                for i in range(1,sz-1):
                        A[sz]=A[sz]+[[o,s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0)]
        return A

@cached_function
def ReducedNonMonotoneFormula(n):
    """
    Outputs non-monotone formula encodings of length at most n.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneFormula(3)
        [[], [1, -1], [], []]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n<=3:
        return [[], [1,-1], [], []]
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1,-1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['+',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and not EvalT(s).is_zero() and not EvalT(t).is_zero() and not EvalT(['+',s,t]).is_zero()]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['*',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['*',s,t])!=1]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['^',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['^',s,t])!=1]
        return A

def ReducedNonMonotoneFormulaSets(sz):
    """
    Outputs set of numbers associated with non monotone encodings
    of complexity less then the size input parameter sz.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneFormulaSets(5)
        [{}, {1, -1}, {}, {2, -2}, {}, {3, -1/2, -3, 1/2}]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    Lt=ReducedNonMonotoneFormula(sz)
    # Filling up the result list
    Rslt=[]
    for n in range(sz+1):
        L=[]; i=0
        while i<len(Lt[n]):
            L.append(Lt[n][i])
            i=i+1
        Rslt.append(Set([EvalT(L[i]) for i in range(len(L))]))
    # Cleaning up the list
    for i in range(1,len(Rslt)):
        for j in range(i):
            Rslt[i]=Rslt[i].difference(Rslt[j])
    return Rslt

@cached_function
def NonMonotoneShortestTameList(m):
    """
    Outputs the list of the smallest binary-tree
    formula using addition, multiplication and exponentiation

    EXAMPLES:

    ::

        sage: NonMonotoneShortestTameList(10)
        [['+', 1, ['^', ['+', 1, ['+', 1, 1]], ['+', 1, 1]]],
         ['+', 1, ['^', ['+', -1, ['+', -1, -1]], ['+', 1, 1]]],
         ['+', 1, ['^', ['+', ['+', 1, 1], 1], ['+', 1, 1]]],
         ['+', 1, ['^', ['+', ['+', -1, -1], -1], ['+', 1, 1]]],
         ['+', ['^', ['+', 1, ['+', 1, 1]], ['+', 1, 1]], 1],
         ['+', ['^', ['+', -1, ['+', -1, -1]], ['+', 1, 1]], 1],
         ['+', ['^', ['+', ['+', 1, 1], 1], ['+', 1, 1]], 1],
         ['+', ['^', ['+', ['+', -1, -1], -1], ['+', 1, 1]], 1]]
        

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Obtaining the length of the shortes monotone formula
    n=ShortestTame(m)[0]
    # Initialization of the stop flag
    StopFlag=False
    if n<=3:
        return m
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1,-1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['+',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and not EvalT(s).is_zero() and not EvalT(t).is_zero() and not EvalT(['+',s,t]).is_zero()]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['*',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['*',s,t])!=1]
            for i in range(1,sz-1):
                A[sz]=A[sz]+[['^',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['^',s,t])!=1]
            if m in [EvalT(T) for T in A[sz]]:
                StopFlag=True
                break
        return [T for T in A[sz] if EvalT(T)==m]

def EvalTn(T, dgts):
    """
    Outputs the evaluation value of a tree using numerically truncated complex numbers
    where the number of digits is specified by the second input
    it is a real mystery how the branches are being chosen however.

    EXAMPLES:

    ::

        sage: EvalTn(['+', ['+', 1, ['+', 1, 1]], ['+', ['+', 1, 1], 1]], 50)
        6.0000000000000

    AUTHORS:
    - Edinah K. Gnang
    """
    if T == ComplexField(dgts)(1,0):
        return ComplexField(dgts)(1,0)
    elif T == ComplexField(dgts)(-1,0):
        return ComplexField(dgts)(-1,0)
    elif T[0] == '+':
        return ComplexField(dgts)(EvalTn(T[1], dgts) + EvalTn(T[2], dgts))
    elif T[0] == '*':
        return ComplexField(dgts)(EvalTn(T[1], dgts) * EvalTn(T[2], dgts))
    elif T[0] == '^':
        return ComplexField(dgts)(EvalTn(T[1], dgts) ^ EvalTn(T[2], dgts))
    else:
        print('IMPROPER INPUT !!!')

@cached_function
def nReducedNonMonotoneFormula(n, dgts):
    """
    Outputs non-monotone formula encodings of length at most n.

    EXAMPLES:

    ::

        sage: nReducedNonMonotoneFormula(3, 4)
        [[], [1, -1], [], []]

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if n<=3:
        return [[], [1,-1], [], []]
    elif n>3:
        # Initialization of the list of formula.
        A=[[], [1,-1]] + [[] for t in range(n-1)]
        # Main loop.
        for sz in range(3,n+1):
            # Initialization of the fifth entry
            for i in range(1,sz-1):
                #A[sz]=A[sz]+[['+',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and not EvalTn(s).is_zero() and not EvalT(t).is_zero() and not EvalT(['+',s,t]).is_zero()]
                A[sz]=A[sz]+[['+',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and abs(EvalTn(s,dgts)) > ComplexField(dgts)(10^(-dgts),0) and abs(EvalTn(t,dgts)) > ComplexField(dgts)(10^(-dgts),0) and abs(EvalTn(['+',s,t],dgts)) > ComplexField(dgts)(10^(-dgts),0)]
            for i in range(1,sz-1):
                #A[sz]=A[sz]+[['*',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['*',s,t])!=1]
                A[sz]=A[sz]+[['*',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and abs(EvalTn(s,dgts) - ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0) and abs(EvalTn(t,dgts)-ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0) and abs(EvalTn(['*',s,t],dgts)-ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0)]
            for i in range(1,sz-1):
                #A[sz]=A[sz]+[['^',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and EvalT(s)!=1 and EvalT(t)!=1 and EvalT(['^',s,t])!=1]
                A[sz]=A[sz]+[['^',s,t] for s in A[i] for t in A[sz-i-1] if (len(A[i])>0) and (len(A[sz-i-1])>0) and abs(EvalTn(s,dgts)-ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0) and (EvalTn(t,dgts)-ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0) and abs(EvalTn(['^',s,t],dgts)-ComplexField(dgts)(1,0)) > ComplexField(dgts)(10^(-dgts),0)]
        return A

def nReducedNonMonotoneFormulaSets(sz, dgts):
    """
    Outputs set of numbers associated with non monotone encodings
    of complexity less then the size input parameter sz.

    EXAMPLES:

    ::

        sage: nReducedNonMonotoneFormulaSets(5,50)
        [{},
         {1.0000000000000, -1.0000000000000},
         {},
         {2.0000000000000, -2.0000000000000},
         {},
         {3.0000000000000, 1.0000000000000 - 2.4492935982947e-16*I, -3.0000000000000}]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    Lt=nReducedNonMonotoneFormula(sz,dgts)
    # Filling up the result list
    Rslt=[]
    for n in rg(sz+1):
        L=[]; i=0
        while i < len(Lt[n]):
            L.append(Lt[n][i])
            i=i+1
        Rslt.append(Set([EvalTn(L[i], dgts) for i in rg(len(L))]))
    # Cleaning up the list
    for i in rg(1,len(Rslt),2):
        for j in range(i):
            Rslt[i]=Rslt[i].difference(Rslt[j])
    return Rslt

def T2PreBool(expr):
    """
    Converts the Boolean formula written in the bracket tree encoding to the 
    Prefix string encoding notation


    EXAMPLES:

    The function implemented here tacitly assume that the input is valid

    ::

        sage: T2PreBool(['OR',var('x0'),var('x1')])
        '+x0x1'


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    s = str(expr)
    return ((((s.replace("[","")).replace("]","")).replace(",","")).replace("'","")).replace(" ","").replace('NOT','-').replace('OR','+').replace('AND','*')

def IncrementVariablesBool(T, incr):
    """
    Returns the same boolean formula with all variables are
    have their index incremented.


    EXAMPLES:

    The function implemented here tacitly assume that the input is valid

    ::

        sage: IncrementVariablesBool(['OR',var('x0'),var('x1')], 1)
        ['OR', x1, x2]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if type(T) == type(x):
        return var('x'+str(Integer(str(T)[1])+incr))
    elif T == 1:
        return 1
    elif T == 0:
        return 0
    elif T[0] == 'OR':
        return ['OR', IncrementVariablesBool(T[1], incr), IncrementVariablesBool(T[2], incr)]
    elif T[0] == 'AND':
        return ['AND', IncrementVariablesBool(T[1], incr), IncrementVariablesBool(T[2], incr)]
    elif T[0] == 'NOT':
        return ['NOT',IncrementVariablesBool(T[1], incr)]
    else:
        print('IMPROPER INPUT !!!')

def VariablesBool(T):
    """
    Returns the set of variables in the boolean formula


    EXAMPLES:

    The function implemented here tacitly assume that the input is valid

    ::

        sage: VariablesBool(['OR',var('x0'),var('x1')])
        {x1, x0}


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if type(T) == type(x):
        return Set([T])
    elif T == 0:
        return Set([])
    elif T == 1:
        return Set([])
    elif T[0] == 'OR':
        return VariablesBool(T[1]).union(VariablesBool(T[2]))
    elif T[0] == 'AND':
        return VariablesBool(T[1]).union(VariablesBool(T[2]))
    elif T[0] == 'NOT':
        return VariablesBool(T[1])
    else:
        print('IMPROPER INPUT !!!')

def CountVariablesBool(T):
    """
    Returns the number of variables in the boolean formula
    


    EXAMPLES:

    The function implemented here tacitly assume that the input is valid

    ::

        sage: CountVariablesBool(['OR',var('x0'),var('x1')])
        2


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    return VariablesBool(T).cardinality()

def EvalTBool(T):
    """
    Outputs the evaluation value of the output with binary assignement.

    EXAMPLES:

    ::

        sage: EvalTBool(['AND', ['OR', 1, ['OR', 1, 1]], ['AND', ['AND', 1, 1], 1]])
        1

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger
    """
    if T == 1:
        return 1
    elif T == 0:
        return 0
    elif T[0] == 'OR':
        return EvalTBool(T[1]) or EvalTBool(T[2])
    elif T[0] == 'AND':
        return EvalTBool(T[1]) and EvalTBool(T[2])
    elif T[0] == 'NOT':
        return Integer(not EvalTBool(T[1]) )
    else:
        print('IMPROPER INPUT !!!')

def SubsTBool(T, Lx, Lv):
    """
    Outputs the evaluation value of the output with binary assignement.

    EXAMPLES:

    ::

        sage: SubsTBool(['AND', ['OR', 1, ['OR', 1, 1]], ['AND', ['AND', 1, 1], var('x0')]], [var('x0')], [1])
        1

    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger
    """
    if type(T) == type(x):
        return T.subs([Lx[i] == Lv[i] for i in rg(len(Lx))])
    elif T == 1:
        return 1
    elif T == 0:
        return 0
    elif T[0] == 'OR':
        if type(T[1]) == type(x) and type(T[2]) == type(x):
            return T[1].subs([Lx[u]==Lv[u] for u in rg(len(Lx))]) or T[2].subs([Lx[u]==Lv[u] for u in rg(len(Lx))])
        elif type(T[1]) == type(x) and type(T[2]) != type(x):
            return T[1].subs([Lx[u]==Lv[u] for u in rg(len(Lx))]) or SubsTBool(T[2], Lx, Lv)
        elif type(T[1]) != type(x) and type(T[2]) == type(x):
            return SubsTBool(T[1], Lx, Lv) or T[2].subs([Lx[u]==Lv[u] for u in rg(len(Lx))])
        else:
            return SubsTBool(T[1], Lx, Lv) or SubsTBool(T[2], Lx, Lv)
    elif T[0] == 'AND':
        if type(T[1]) == type(x) and type(T[2]) == type(x):
            return T[1].subs([Lx[u]==Lv[u] for u in rg(len(Lx))]) and T[2].subs([Lx[u]==Lv[u] for u in rg(len(Lx))])
        elif type(T[1]) == type(x) and type(T[2]) != type(x):
            return T[1].subs([Lx[u]==Lv[u] for u in rg(len(Lx))]) and SubsTBool(T[2], Lx, Lv)
        elif type(T[1]) != type(x) and type(T[2]) == type(x):
            return SubsTBool(T[1], Lx, Lv) and T[2].subs([Lx[u]==Lv[u] for u in rg(len(Lx))])
        else:
            return SubsTBool(T[1], Lx, Lv) and SubsTBool(T[2], Lx, Lv)
    elif T[0] == 'NOT':
        if type(T[1]) == type(x):
            return Integer(not T[1].subs([Lx[u]==Lv[u] for u in rg(len(Lx))]))
        else:
            return Integer(not SubsTBool(T[1], Lx, Lv))
    else:
        print('IMPROPER INPUT !!!')

def Bool2HM(T):
    """
    Outputs the hypermatrix encoding of the boolean formula
    the index correspond to the values assigned to the variables
    and the entry itself corresponds the 

    EXAMPLES:

    ::

        sage: Bool2HM(['AND', ['OR', var('x0'), ['OR', var('x0'), 1]], ['AND', ['AND', 1, var('x1')], 1]]).printHM()
        [:, :]=
        [0 1]
        [0 1]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    if CountVariablesBool(T) == 0:
        return HM(1,1,[Bool2Poly(T)])
    elif T == 1:
        return HM(1,1,[Bool2Poly(T)])
    else:
        # Initialization of the list specifying the dimensions of the output
        l = [2 for i in rg(CountVariablesBool(T))]
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            # Sorting the list of variables
            if VariablesBool(T).cardinality() == 1:
                LstVar=VariablesBool(T).list()
            else:
                LstVar=sum(VariablesBool(T)).operands()
            Rh[tuple(entry)]=SubsTBool(T, LstVar, entry)
        return Rh

def Bool2HM2(T, LstVar):
    """
    Outputs the hypermatrix encoding of the boolean formula
    the index correspond to the values assigned to the variables
    and the entry itself corresponds the 

    EXAMPLES:

    ::

        sage: Bool2HM2(['AND', ['OR', var('x0'), ['OR', var('x0'), 1]], ['AND', ['AND', 1, var('x1')], 1]],[var('x0') ,var('x1')]).printHM()
        [:, :]=
        [0 1]
        [0 1]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the list specifying the dimensions of the output
    l = [2 for i in rg(len(LstVar))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=SubsTBool(T, LstVar, entry)
    return Rh

def Bool2Integer(T):
    """
    Outputs the binary encoding of the boolean formula
    the integer is obtained by suming the output of 
    evaluation scaled by distinct powers of two

    EXAMPLES:

    ::

        sage: Bool2Integer(['AND', ['OR', var('x0'), ['OR', var('x0'), 1]], ['AND', ['AND', 1, var('x1')], 1]])
        16
        sage: X=var_list('x',2); Bool2Integer(x0)
        4
        sage: Bool2Integer(['NOT',['NOT', x0]])
        4
        sage: Bool2Integer(['NOT', x0])
        3
        sage: Bool2Integer(0)
        0
        sage: Bool2Integer(1)
        1
        sage: Bool2Integer(['OR', x0, ['NOT', x0]])
        5
        sage: Bool2Integer(['AND', x0, ['NOT', x0]])
        2


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    if T == 0:
        return Integer(0)
    elif T == 1:
        return Integer(1)
    else:
        # Initialization of the list of evaliations
        L=Bool2HM(T).list()
        if CountVariablesBool(T) == 1:
            return Integer(2)+sum(L[i]*2^i for i in rg(len(L)))
        else: 
            # Adding up the geomertric like sum 
            return sum(2^(2^k) for k in rg(1,CountVariablesBool(T)))+sum(L[i]*2^i for i in rg(len(L)))

def Bool2Poly(T):
    """
    Outputs the evaluation value of the output with binary assignement.

    EXAMPLES:

    ::

        sage: Bool2Poly(['AND', ['OR', var('x0'), ['OR', var('x1'), var('x2')]], ['AND', ['AND', var('x3'), var('x0')], ['NOT', var('x1')]]])
        -((x1*x2 - x1 - x2)*x0 - x1*x2 + x0 + x1 + x2)*x0*(x1 - 1)*x3

    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    if T == 1:
        return SR(1)
    elif T == 0:
        return SR(0)
    elif type(T) == type(x):
        return T
    elif T[0] == 'OR':
        return Bool2Poly(T[1]) + Bool2Poly(T[2]) - Bool2Poly(T[1]) * Bool2Poly(T[2])
    elif T[0] == 'AND':
        return Bool2Poly(T[1]) * Bool2Poly(T[2])
    elif T[0] == 'NOT':
        return  1 - Bool2Poly(T[1])
    else:
        print('IMPROPER INPUT !!!')

def Bool2Poly2(T, LstVar):
    """
    Outputs the hypermatrix encoding of the boolean formula
    the index correspond to the values assigned to the variables
    and the entry itself corresponds the 

    EXAMPLES:

    ::

        sage: Bool2Poly2(['AND', ['OR', var('x0'), ['OR', var('x0'), 1]], ['AND', ['AND', 1, var('x1')], 1]],[var('x0') ,var('x1')])
        -(x0 - 1)*x1 + x0*x1


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the list specifying the dimensions of the output
    l = [2 for i in rg(len(LstVar))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    F = 0
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        F=F+SubsTBool(T, LstVar, entry)*prod( (LstVar[u]-(1-entry[u]))/(2*entry[u]-1) for u in rg(len(LstVar)))
    return F
 
def BoolTsize(T):
    """
    Outputs the size of the boolean formual associated with the formula.
 
    EXAMPLES:
    
    ::

        sage: BoolTsize(['AND', 0, 1])
        3


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    if T == 0 or T == 1 or type(T)==type(x):
        return 1
    elif T[0]=='NOT':
        return 1+BoolTsize(T[1])
    else:
        return 1+BoolTsize(T[1])+BoolTsize(T[2])

@cached_function
def ReducedNonMonotoneBooleanFormula(SZ):
    """
    Outputs the list of non-monotone boolean formula stratified by their
    size. The second output is the list of integer recording the tables
    which have occured thus far.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneBooleanFormula(3)[0]
        [[],
         [0, 1, x0],
         [['NOT', x0]],
         [['AND', 0, x0], ['AND', x0, x1], ['OR', 1, x0], ['OR', x0, x1]]]
        sage: sz=5; X=var_list('x',sz); A=ReducedNonMonotoneBooleanFormula(sz)[0]; Lr = [[] for i in rg(len(A))]
        sage: for i in rg(len(A)):
        ....:     if len(A[i])>0:
        ....:         for T in A[i]:
        ....:             Lr[i].append((T, Bool2Integer(T)))
        ....:
        sage: Lr
        [[],
         [(0, 0), (1, 1), (x0, 4)],
         [(['NOT', x0], 3)],
         [(['AND', 0, x0], 2),
          (['AND', x0, x1], 12),
          (['OR', 1, x0], 5),
          (['OR', x0, x1], 18)],
         [(['AND', x0, ['NOT', x1]], 6),
          (['AND', ['NOT', x0], x1], 8),
          (['OR', x0, ['NOT', x1]], 15),
          (['OR', ['NOT', x0], x1], 17),
          (['NOT', ['AND', x0, x1]], 11)],
         [(['AND', x0, ['AND', x1, x2]], 148),
          (['AND', x0, ['OR', 1, x1]], 14),
          (['AND', x0, ['OR', x1, x2]], 188),
          (['AND', ['OR', 1, x0], x1], 16),
          (['AND', ['OR', x0, x1], x2], 244),
          (['OR', 1, ['AND', x0, x1]], 19),
          (['OR', x0, ['AND', x1, x2]], 254),
          (['OR', x0, ['OR', x1, x2]], 274),
          (['OR', ['AND', x0, x1], x2], 268)]]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the list of variables
    X=var_list('x',SZ)
    # Initialization of the list which store the integer encodings
    L = [Integer(0), Integer(1), Bool2Integer(X[0]), Bool2Integer(['NOT',X[0]])]
    if SZ <= 2:
        return [[[], [Integer(0), Integer(1), X[0]], [['NOT',X[0]]]], L]
    elif SZ > 2:
        # Initialization of the list of formula.
        A=[[], [Integer(0), Integer(1), X[0]],  [['NOT',X[0]]]] + [[] for t in range(SZ-2)]
        # Main loop.
        for sz in range(2,SZ+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]))
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]))
            for s in A[sz-1]:
                if (len(A[sz-1])>0) and not Bool2Integer(['NOT',s]) in L:
                    A[sz].append(['NOT', s])
                    L.append(Bool2Integer(['NOT', s]))
        return [A,L]

@cached_function
def ReducedNonMonotoneBooleanFormulaII(SZ):
    """
    Outputs the list of non-monotone boolean formula encoded as polynomial
    stratified by the size of the corresponding boolean formula. 
    The second output is the list of integer recording the tables
    which have occured thus far.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneBooleanFormulaII(3)[0]
        [[], [0, 1, x0], [['NOT', x0]], [['AND', x0, x1], ['OR', x0, x1]]]
        sage: sz=5; X=var_list('x',sz); A=ReducedNonMonotoneBooleanFormulaII(sz)[0]; Lr = [[] for i in rg(len(A))]
        sage: for i in rg(len(A)):
        ....:     if len(A[i])>0:
        ....:         for T in A[i]:
        ....:             Lr[i].append((T, Bool2Integer(T)))
        ....:
        sage: Lr
        [[],
         [(0, 0), (1, 1), (x0, 4)],
         [(['NOT', x0], 3)],
         [(['AND', x0, x1], 12), (['OR', x0, x1], 18)],
         [(['AND', x0, ['NOT', x1]], 6),
          (['AND', ['NOT', x0], x1], 8),
          (['OR', x0, ['NOT', x1]], 15),
          (['OR', ['NOT', x0], x1], 17),
          (['NOT', ['AND', x0, x1]], 11),
          (['NOT', ['OR', x0, x1]], 5)],
         [(['AND', x0, ['AND', x1, x2]], 148),
          (['AND', x0, ['OR', x1, x2]], 188),
          (['AND', ['OR', x0, x1], x1], 16),
          (['AND', ['OR', x0, x1], x2], 244),
          (['OR', x0, ['AND', x1, x2]], 254),
          (['OR', x0, ['OR', x1, x2]], 274),
          (['OR', ['AND', x0, x1], x2], 268)]]


    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the list of variables
    X=var_list('x',SZ)
    # Initialization of the list which store the integer encodings
    L = [SR(0), SR(1), X[0], 1-X[0]]
    if SZ <= 2:
        return [[[], [Integer(0), Integer(1), X[0]],  [['NOT',X[0]]]], L]
    elif SZ > 2:
        # Initialization of the list of formula.
        A=[[], [Integer(0), Integer(1), X[0]],  [['NOT',X[0]]]] + [[] for t in range(SZ-2)]
        # Main loop.
        for sz in range(2,SZ+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            Ft=expand(Bool2Poly2(['AND', s, IncrementVariablesBool(t,j)],X))
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Ft in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Ft)
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            Ft=expand(Bool2Poly2(['OR', s, IncrementVariablesBool(t,j)],X))
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Ft in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Ft)
            for s in A[sz-1]:
                Ft=expand(Bool2Poly2(['NOT',s],X))
                if (len(A[sz-1])>0) and not Ft in L:
                    A[sz].append(['NOT', s])
                    L.append(Ft)
        # Returning Boolean formulas encoded as polynomials
        return [A, L]

@cached_function
def ReducedNonMonotoneBooleanFormulaPoly(SZ):
    """
    Outputs the list of non-monotone boolean formula encoded as polynomial
    stratified by the size of the corresponding boolean formula. 
    The second output is the list of integer recording the tables
    which have occured thus far.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneBooleanFormulaPoly(3)[0]
        [[], [x0], [-x0 + 1], [x0*x1, -x0*x1 + x0 + x1]]
        sage: sz=5; X=var_list('x',sz); [A, Lp, Li]=ReducedNonMonotoneBooleanFormulaPoly(sz)[0]
        sage: Lp
        sage: Li
        sage: sz=5; X=var_list('x',sz); A=ReducedNonMonotoneBooleanFormulaPolyII(sz)[0]; Lr = [[] for i in rg(len(A))]
        sage: for i in rg(len(A)):
        ....:     if len(A[i])>0:
        ....:         for T in A[i]:
        ....:             Lr[i].append((T, Bool2Integer(T)))
        ....:
        sage: Lr




    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the list of variables
    X=var_list('x',SZ)
    # Initialization of the list which store the integer encodings
    L = [Integer(0), Integer(1), Bool2Integer(X[0]), Bool2Integer(['NOT',X[0]])]
    if SZ <= 2:
        return [[[], [SR(0), SR(1), X[0]], [1-X[0]]], L]
    elif SZ > 2:
        # Initialization of the list of formula.
        A=[[], [Integer(0), Integer(1), X[0]],  [['NOT',X[0]]]] + [[] for t in range(SZ-2)]
        # Main loop.
        for sz in range(2,SZ+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]))
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]))
            for s in A[sz-1]:
                if (len(A[sz-1])>0) and not Bool2Integer(['NOT',s]) in L:
                    A[sz].append(['NOT', s])
                    L.append(Bool2Integer(['NOT', s]))
        # Returning Boolean formulas encoded as polynomials
        return [[[Bool2Poly(F) for F in A[t]] for t in rg(SZ+1)], L]

@cached_function
def ReducedNonMonotoneBooleanFormulaPolyII(SZ):
    """
    Outputs the list of non-monotone boolean formula encoded as polynomial
    stratified by the size of the corresponding boolean formula. 
    The second output is the list of integer recording the tables
    which have occured thus far.

    EXAMPLES:

    ::

        sage: ReducedNonMonotoneBooleanFormulaPolyII(3)[0]
        [[], [0, 1, x0], [['NOT', x0]], [x0*x1, -x0*x1 + x0 + x1]]
        sage: sz=5; X=var_list('x',sz); [A, Lp, Li]=ReducedNonMonotoneBooleanFormulaPoly(sz)[0]
        sage: Lp
        sage: Li
        sage: sz=5; X=var_list('x',sz); A=ReducedNonMonotoneBooleanFormulaPolyII(sz)[0]
        sage: Lr = [[] for i in rg(len(A))]
        sage: for i in rg(len(A)):
        ....:     if len(A[i])>0:
        ....:         for T in A[i]:
        ....:             Lr[i].append((Bool2Poly(T), Bool2Integer(T)))
        ....:
        sage: Lr



    AUTHORS:
    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the list of variables
    X=var_list('x',SZ)
    # Initialization of the list which store the integer encodings
    L = [SR(0), SR(1), X[0], 1-X[0]]
    if SZ <= 2:
        return [[[], [SR(0), SR(1), X[0]], [1-X[0]]], L]
    elif SZ > 2:
        # Initialization of the list of formula.
        A=[[], [Integer(0), Integer(1), X[0]],  [['NOT',X[0]]]] + [[] for t in range(SZ-2)]
        # Main loop.
        for sz in range(2,SZ+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            Ft=expand(Bool2Poly2(['AND', s, IncrementVariablesBool(t,j)],X))
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Ft in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Ft)
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            Ft=expand(Bool2Poly2(['OR', s, IncrementVariablesBool(t,j)],X))
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Ft in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Ft)
            for s in A[sz-1]:
                Ft=expand(Bool2Poly2(['NOT',s],X))
                if (len(A[sz-1])>0) and not Ft in L:
                    A[sz].append(['NOT', s])
                    L.append(Ft)
        # Returning Boolean formulas encoded as polynomials
        return [[[Bool2Poly(F) for F in A[t]] for t in rg(SZ+1)], L]

def ShortestNonMonotoneBooleanFormula(T):
    """
    Outputs the list of non-monotone boolean formula of minimal size
    having the same truth table as T

    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); ShortestNonMonotoneBooleanFormula(['OR',['OR', x0, x1],['AND',x0,x1]])
        [['OR', x0, x1]]



    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the stoping flag
    Ivl=Bool2Integer(T)
    # Initialization of the list of variables
    X=var_list('x',CountVariablesBool(T))
    # Initialization of the list which store the integer encodings
    L = [Bool2Integer(X[0]), Bool2Integer(['NOT',var('x0')]), Bool2Integer(['AND', var('x0'), var('x1')]), Bool2Integer(['OR', var('x0'), var('x1')])]
    if BoolTsize(T) <= 3:
        return T
    elif BoolTsize(T) > 3:
        # Initialization of the list of formula.
        A=[[], [X[0]], [['NOT',var('x0')]], [['AND', var('x0'), var('x1')], ['OR', var('x0'), var('x1')]]] + [[] for t in range(BoolTsize(T)-3)]
        # Main loop.
        for sz in range(3,BoolTsize(T)+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]))
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]))
            for s in A[sz-1]:
                if (len(A[sz-1])>0) and not Bool2Integer(['NOT',s]) in L:
                    A[sz].append(['NOT', s])
                    L.append(Bool2Integer(['NOT', s]))
            if Ivl in L:
                break
        return [F for F in A[sz] if Ivl==Bool2Integer(F)]

def Poly2HM(P,X):
    """
    Outputs the hypermatrix encoding of the boolean formula
    the index correspond to the values assigned to the variables
    and the entry itself corresponds the output of the boolean
    function at those particular inputs. 

    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); Poly2HM((x0 - 1)*(x1 - 1) + x0*x1, [x0,x1]).printHM()
        [:, :]=
        [1 0]
        [0 1]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the list specifying the dimensions of the output
    l = [2 for i in rg(len(X))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=P.subs([X[v]==entry[v] for v in rg(len(l))])
    return Rh

def Poly2HMII(P,X):
    """
    Outputs the hypermatrix encoding of the input polynomial using
    evaluations from the (Z_n)^Z_n lattice. The value n is len(X)


    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); Poly2HMII((x0 - 1)*(x1 - 1) + x0*x1, [x0,x1]).p()
        [:, :]=
        [1 0]
        [0 1]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the list specifying the dimensions of the output
    l = [len(X) for i in rg(len(X))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=P.subs([X[v]==entry[v] for v in rg(len(l))])
    return Rh

def Poly2HMIII(P,X):
    """
    Outputs the hypermatrix encoding of the input polynomial using
    evaluations from roots of unity  w^((Z_n)^Z_n) lattice. The value n is len(X)


    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); Poly2HMIII((x0 - 1)*(x1 - 1) + x0*x1, [x0,x1]).p()
        [:, :]=
        [ 1 -1]
        [-1  5]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the primitive root of unity
    w=exp(sqrt(-1)*2*pi/len(X))
    # Initialization of the list specifying the dimensions of the output
    l = [len(X) for i in rg(len(X))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=P.subs([X[v]==w^entry[v] for v in rg(len(l))])
    return Rh

def Poly2Integer(P,X):
    """
    Outputs the binary encoding of the boolean formula
    the integer is obtained by suming the output of 
    evaluation scaled by distinct powers of two.
    The inputs are polynomial P and a list of variable X
    accounting for all the variables in P


    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); Poly2Integer((x0 - 1)*(x1 - 1) + x0*x1, [x0,x1])
        13


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger
    """
    # Initialization of the list of evaliations
    H=Poly2HM(P,X); L=H.list()
    if H.order() == 1:
        return sum(L[i]*2^i for i in rg(len(L)))
    else: 
        # Adding up the geomertric like sum 
        return sum(2^(2^k) for k in rg(1,H.order()))+sum(L[i]*2^i for i in rg(len(L)))

def ShortestNonMonotoneBooleanFormulaII(P,X):
    """
    Outputs the list of non-monotone boolean formula of minimal size.
    having the same truth table as the input polynomial P.
    The difference with the implementation above is that it takes as
    input a polynomial


    EXAMPLES:

    ::

        sage: x0,x1=var('x0,x1'); ShortestNonMonotoneBooleanFormulaII((x0 - 1)*(x1 - 1) + x0*x1, [x0,x1])
        [['OR', ['AND', x0, x1], ['NOT', ['OR', x0, x1]]]]


    AUTHORS:

    - Edinah K. Gnang and Doron Zeilberger

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the stoping flag
    Ivl=Poly2Integer(P,X)
    # Initialization of the size of the formula from the size of the infix polynomial interpolation
    SZ=len(str(P))
    # Initialization of the list which store the integer encodings
    L = [Bool2Integer(X[0]), Bool2Integer(['NOT',var('x0')]), Bool2Integer(['AND', var('x0'), var('x1')]), Bool2Integer(['OR', var('x0'), var('x1')])]
    if SZ <= 3:
        return P
    elif SZ > 3:
        # Initialization of the list of formula.
        A=[[], [X[0]], [['NOT',var('x0')]], [['AND', var('x0'), var('x1')], ['OR', var('x0'), var('x1')]]] + [[] for t in range(SZ-3)]
        # Main loop.
        for sz in range(3,SZ+1):
            # Initialization of the fifth entry
            for i in rg(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['AND', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['AND', s, IncrementVariablesBool(t,j)]))
            for i in range(1,sz-1):
                for s in A[i]:
                    for t in A[sz-i-1]:
                        for j in rg(CountVariablesBool(s)+1):
                            if (len(A[i])>0) and (len(A[sz-i-1])>0) and not Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]) in L:
                                A[sz].append(['OR', s, IncrementVariablesBool(t,j)])
                                L.append(Bool2Integer(['OR', s, IncrementVariablesBool(t,j)]))
            for s in A[sz-1]:
                if (len(A[sz-1])>0) and not Bool2Integer(['NOT',s]) in L:
                    A[sz].append(['NOT', s])
                    L.append(Bool2Integer(['NOT', s]))
            if Ivl in L:
                break
        return [F for F in A[sz] if Ivl==Bool2Integer(F)]

def Boolean_interpolant(iL, X):
    """
    This function expresses a polynomial interpolant.
    determined by the variables assignements for which the Boolean
    function outputs true. We use the Lagrange interpolation construction
    to express express an interpolant and then proceed to use the reduction
    to obtain the multilinear polynomial used to specify the PDE.
    The first input list iL correspond to integers whose binary expansion express
    indicator vector of variable assignment for which the Boolean function
    evaluates to 1. The second input X is the list of variables.
    The original polynomial is obtain via Lagrange interpolation.
    then we reduce modulo algebrait relations to determine the 
    corresponding multilinear polynomial


    EXAMPLES:

    ::

        sage: X=var_list('x',2); F=expand(Boolean_interpolant([0, 2, 3] ,X)); F
        -1/2*x0^3 - 3*x0^2*x1 - 6*x0*x1^2 - 4*x1^3 + 5/2*x0^2 + 10*x0*x1 + 10*x1^2 - 3*x0 - 6*x1 + 1
        sage: fast_reduce(F,[x0^3,x1^3,x0^2,x1^2],[x0,x1,x0,x1])
        x0*x1 - x0 + 1


    AUTHORS:

    - Edinah K. Gnang

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the the polynomial
    return sum(prod((sum(2^k*X[k] for k in rg(len(X)))-j)/(i-j) for j in rg(2^len(X)) if j !=i) for i in iL)

def Boolean_interpolantII(H, X):
    """
    This function expresses the multilinear polynomial interpolant.
    determined by the variables assignements for which the Boolean
    function outputs true. 
    The first input is a side length two hypermatrix correspond to 
    integers whose binary expansion express indicator vector of 
    variable assignment for which the Boolean function
    evaluates to 1. The second input X is the list of variables.


    EXAMPLES:

    ::

        sage: od=Integer(2); X=var_list('x',od); F=expand(Boolean_interpolantII(HM(od,2,'kronecker') ,X)); F
        x0*x1 - x0 + 1
        sage: od=Integer(3); X=var_list('x',od); F=expand(Boolean_interpolantII(HM(od,2,'kronecker') ,X)); F
        x0*x1 + x0*x2 + x1*x2 - x0 - x1 - x2 + 1


    AUTHORS:

    - Edinah K. Gnang

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the order parameter
    ord=Integer(H.order())
    if ord == len(X):
        # Initialization of the list specifying the dimensions of the output
        l=[Integer(2) for i in rg(ord)]
        # Initialization of the the polynomial
        F=SR(0)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            F=F+H[tuple(entry)]*prod((X[i]-(Integer(1)-entry[i]))/(Integer(2)*entry[i]-1) for i in rg(ord))
        return F
    else:
        raise ValueError("Expected the order of the hypermatrix to match the number of variables")

def fast_reduce_bool(f, VrbL):
    """
    computes the reduction by monomial substitution
    by converting the symbolic expression into a string
    of characters and performing the substition on the
    string and converts back in the end the obtained
    string back into a symbolic expression SR
    This implementation is specialized to polynomial
    interpolant to Boolean function.

    
    EXAMPLES:
 
    ::

        sage: x0, x1=var('x0, x1'); fast_reduce_bool(expand(Boolean_interpolant([0, 2, 3], [x0, x1])),[x0, x1])
        x0*x1 + x0 + 1        


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the monomial list
    monom = []
    for v in VrbL:
        monom = monom + [v^(f.degree(v)-k) for k in rg(f.degree(v)-1)]
    subst=[] 
    for v in VrbL:
        subst = subst + [v for k in rg(f.degree(v)-1)]
    if len(monom) == len(subst):
        s = str(f)
        for i in range(len(monom)):
            s=s.replace(str(monom[i]), '('+str(subst[i])+')')
        g=expand((SR(s)).simplify_full())
        return sum([Integer(mod(mnm.subs([v==1 for v in VrbL]),2))*(mnm/mnm.subs([v==1 for v in VrbL])) for mnm in g.operands()])
    else:
        print('Error the monomial list and the substitution list must have the same length')

def Indicator_to_PDE_poly(iL, X):
    """
    The multilinear polynomial of a Boolean function is completly
    determined by the variables assignements for which the Boolean
    function outputs true. We use the Lagrange interpolation construction
    to express express an interpolant and then proceed to use the reduction
    to obtain the multilinear polynomial used to specify the PDE.
    The first input list iL correspond to integers whose binary expansion express
    indicator vector of variable assignment for which the Boolean function
    evaluates to 1. The second input X is the list of variables.
    The original polynomial is obtain via Lagrange interpolation.
    then we reduce modulo algebrait relations to determine the 
    corresponding multilinear polynomial


    EXAMPLES:

    ::

        sage: X=var_list('x',2);  Indicator_to_PDE_poly([0, 2, 3] ,X)
        x0*x1 + x0 + 1


    AUTHORS:

    - Edinah K. Gnang

    To Do :
    - Try to implement faster version of this procedure

    """
    # Initialization of the the polynomial
    F=expand(Boolean_interpolant(iL, X))
    return fast_reduce_bool(F,X)

def GeneralDualHypermatrixProductB(*args):
    """
    Outputs a list of lists associated with the general
    Dual to the Bhattacharya-Mesner product of the input 
    hypermatrices with non trivial background.
    The code only handles the Hypermatrix HM class objects.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,2,'a'); Hb=HM(2,2,2,'b'); Hc=HM(2,2,2,'c')
        sage: Rslt=GeneralDualHypermatrixProductB(Ha,Hb,Hc,HM(2,2,2,'b')); Rslt
        [[[a000*b000^2*c000 + a100*b001*b100*c000 + a001*b000*b010*c001 + a101*b011*b100*c001 + a000*b010*b100*c010 + a100*b101*b110*c010 + a001*b010*b110*c011 + a101*b110*b111*c011, a000*b000*b001*c000 + a100*b001*b101*c000 + a001*b001*b010*c001 + a101*b011*b101*c001 + a000*b011*b100*c010 + a100*b101*b111*c010 + a001*b011*b110*c011 + a101*b111^2*c011], [a010*b000^2*c000 + a110*b001*b100*c000 + a011*b000*b010*c001 + a111*b011*b100*c001 + a010*b010*b100*c010 + a110*b101*b110*c010 + a011*b010*b110*c011 + a111*b110*b111*c011, a010*b000*b001*c000 + a110*b001*b101*c000 + a011*b001*b010*c001 + a111*b011*b101*c001 + a010*b011*b100*c010 + a110*b101*b111*c010 + a011*b011*b110*c011 + a111*b111^2*c011]], [[a000*b000^2*c100 + a100*b001*b100*c100 + a001*b000*b010*c101 + a101*b011*b100*c101 + a000*b010*b100*c110 + a100*b101*b110*c110 + a001*b010*b110*c111 + a101*b110*b111*c111, a000*b000*b001*c100 + a100*b001*b101*c100 + a001*b001*b010*c101 + a101*b011*b101*c101 + a000*b011*b100*c110 + a100*b101*b111*c110 + a001*b011*b110*c111 + a101*b111^2*c111], [a010*b000^2*c100 + a110*b001*b100*c100 + a011*b000*b010*c101 + a111*b011*b100*c101 + a010*b010*b100*c110 + a110*b101*b110*c110 + a011*b010*b110*c111 + a111*b110*b111*c111, a010*b000*b001*c100 + a110*b001*b101*c100 + a011*b001*b010*c101 + a111*b011*b101*c101 + a010*b011*b100*c110 + a110*b101*b111*c110 + a011*b011*b110*c111 + a111*b111^2*c111]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args)-1)]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    # Initializing the background hypermatrix
    B = (args[len(args)-1]).transpose(args[len(args)-1].order()-1)
    args = tuple([args[id] for id in range(len(args)-1)])
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args) < 2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)] = 0
            l2 = [B.n(sz) for sz in range(B.order())]
            for j in range(prod(l2)):
                # Turning the index j into an hypermatrix array location using the decimal encoding trick
                entry2 = [Integer(mod(j,l2[0]))]
                sm2 = Integer(mod(j,l2[0]))
                for z in range(len(l2)-1):
                    entry2.append(Integer(mod(Integer((j-sm2)/prod(l2[0:z+1])),l2[z+1])))
                    sm2 = sm2+prod(l2[0:z+1])*entry2[len(entry2)-1]
                Rh[tuple(entry)] = Rh[tuple(entry)]+prod([args[s][tuple(entry2[0:Integer(mod(s+1,len(args)))]+[entry[Integer(mod(s+1,len(args)))]]+entry2[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry2[0:len(entry2)-1]+[entry[len(entry2)-1]])]]+[args[len(args)-1][tuple([entry[0]]+entry2[1:])]])*B[tuple(entry2)]
    return Rh

def PathAdjcencyHypermatrix(A, pthl):
    """
    Procedure for Generating a (k-1)-Path adjacency hypermatrix

    EXAMPLES:

    ::

        sage: PathAdjcencyHypermatrix(HM(2,2,'a'), 3)
        [[[a00^2, a00*a01], [a01*a10, a01*a11]], [[a00*a10, a01*a10], [a10*a11, a11^2]]]

    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order() == 2 and pthl == 1:
        return A
    elif A.order() == 2 and pthl > 1:
        # Initializing the number of vertices in the graph.
        sz = max(A.n(0), A.n(1))
        # Initialization of the list specifying the dimensions of the output
        l = [sz for i in range(pthl)] 
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the hypermatrix
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            Rh[tuple(entry)] = prod([A[tuple([entry[i],entry[i+1]])] for i in range(pthl-1)])
    else:
        raise ValueError("Input hypermatrix must be order 2 and the path length must be an integer greater then 0")
    return Rh

def  GeneralHypermatrixCayleyHamiltonB(A, t):
    """
    Implements the background hypermatrix approach to the Cayley-Hamilton theorem.

    EXAMPLES:

    ::

        sage: GeneralHypermatrixCayleyHamiltonB(HM(2,2,'a'), 0) 
        [  1   0   0   1]
        [a00 a10 a01 a11]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the hypermatrix order.
    od = A.order()
    # Verifying that the input hypermatrix is cubic
    if len(Set([A.n(i) for i in range(od)]).list()) == 1:
        # initial conditions for the recurrence.
        A0 = GeneralHypermatrixKroneckerDelta(od, A.n(0))
        A1 = A
        # Initializing the list assoaciated with the first two rows of the output matrix
        L = [A0.list(), A1.list()]
        # Loop filling up the remaining lists which make up the rows of the matrix
        for j in range(t):
            # Computing the two next matrices of the recurence.
            #A0 = apply(GeneralHypermatrixProductB, [A for k in range(od)]+[A0])
            A0 = GeneralHypermatrixProductB( *([A for k in range(od)]+[A0]) )
            #A1 = apply(GeneralHypermatrixProductB, [A for k in range(od)]+[A1])
            A1 = GeneralHypermatrixProductB( *([A for k in range(od)]+[A1]) )
            # Append the result to the list
            L.append(A0.list()); L.append(A1.list())
        return Matrix(SR,L)
    else:
        # return the error message if the input hypermatrix is cubic
        raise ValueError("The input hypermpatrix must be cubic")

def fast_reduce(f, monom, subst):
    """
    computes the reduction by monomial substitution
    by converting the symbolic expression into a string
    of characters and performing the substition on the
    string and converts back in the end the obtained
    string back into a symbolic expression SR
    
    EXAMPLES:
 
    ::

        sage: x1,x2,x3=var('x1, x2, x3'); fast_reduce(x1^3+x2+x3^3,[x3^3],[1])
        x1^3 + x2 + 1
        sage: x1,x2,x3=var('x1, x2, x3'); y1,y2=var('y1, y2'); fast_reduce(x1^3*x2+x2*x3+x3^3+5,[x1^3*x2,x2*x3],[y1, y2])
        x3^3 + y1 + y2 + 5

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(monom) == len(subst):
        s = str(f)
        for i in range(len(monom)):
            s = s.replace(str(monom[i]), '('+str(subst[i])+')')
        return expand((SR(s)).simplify_full())
    else:
        print('Error the monomial list and the substitution list must have the same length')

def fast_reduce_no_expand(f, monom, subst):
    """
    computes the reduction by the symbolic expression substitution
    does not expand the resulting polynomial
    
    EXAMPLES:
 
    ::

        sage: x1,x2,x3=var('x1, x2, x3'); fast_reduce_no_expand(x1^3+x2+x3^3,[x3^3+x2],[(x2+x3)^2])
        x1^3 + (x2 + x3)^2

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(monom) == len(subst):
        s = str(f)
        for i in range(len(monom)):
            s = s.replace(str(monom[i]), '('+str(subst[i])+')')
        return SR(s)
    else:
        print('Error the monomial list and the substitution list must have the same length')

def fast_reduceII(f, monom, subst, Dct):
    """
    computes the reduction by monomial substitution
    by converting the symbolic expression into a string
    of characters and performing the substition on the
    string and converts back in the end the obtained
    string back into an expression.
    The difference with the implementation above is the
    fact that this implementation handles matrix input
    of type HM

    
    EXAMPLES:
 
    ::

        sage: x1,x2,x3,A,B,C=var('x1, x2, x3, A, B, C')
        sage: fast_reduceII(x1^3+x2+x3^3,[x1,x2,x3],[A,B,C],{'A':HM(2,2,'a'),'B':HM(2,2,'b'),'C':HM(2,2,'c')}).printHM()
        [:, :]=
        [(a00^2 + a01*a10)*a00 + (a00*a10 + a10*a11)*a01 + (c00^2 + c01*c10)*c00 + (c00*c10 + c10*c11)*c01 + b00 (a00*a01 + a01*a11)*a00 + (a01*a10 + a11^2)*a01 + (c00*c01 + c01*c11)*c00 + (c01*c10 + c11^2)*c01 + b01]
        [(a00^2 + a01*a10)*a10 + (a00*a10 + a10*a11)*a11 + (c00^2 + c01*c10)*c10 + (c00*c10 + c10*c11)*c11 + b10 (a00*a01 + a01*a11)*a10 + (a01*a10 + a11^2)*a11 + (c00*c01 + c01*c11)*c10 + (c01*c10 + c11^2)*c11 + b11]
        sage: od=2; sz=3; X=var_list('x',sz); U,V,W=var('U,V,W'); A = HM(sz,sz,'a').transpose() # Initialization of the matrices
        sage: f = expand(prod(A[j,1]+A[i,1] for i in rg(sz) for j in rg(sz) if i<j)) # Expanding the analog of the Vandermonde determinant polynomial
        sage: I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)]); c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)]) # Initialization of the 2x2 matrices
        sage: Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)] # matrix representation of the Grassmanian variables
        sage: prm = expand(prod(A[u,0]*X[0] for u in rg(sz))*fast_reduce(f, [A[i,1]^(sz-j-1) for j in rg(sz-1) for i in rg(sz)],[A[i,sz-j-1]*X[sz-j-1]/(A[i,0]*X[0]) for j in rg(sz-1) for i in rg(sz)]))
        sage: M = fast_reduceII(prm,var_list('x',3),[U,V,W],{'U':Lm[0],'V':Lm[1],'W':Lm[2], 'a00':A[0,0], 'a10':A[1,0], 'a20':A[2,0], 'a01':A[0,1], 'a11':A[1,1], 'a21':A[2,1], 'a02':A[0,2], 'a12':A[1,2], 'a22':A[2,2]}) # Substitution
        sage: M[2^sz-1,0]
        a02*a11*a20 + a01*a12*a20 + a02*a10*a21 + a00*a12*a21 + a01*a10*a22 + a00*a11*a22
        sage: sz=Integer(3); X=var_list('x',sz); Y=var_list('y',sz); Z=var_list('z',sz); Ha=HM(sz,sz,'a')
        sage: p=prod((X[Integer(mod(i+0,sz))])^i for i in rg(sz))*prod((Y[Integer(mod(i+1,sz))])^i for i in rg(sz))*prod((Z[Integer(mod(i+2,sz))])^i for i in rg(sz))
        sage: A,B,C=var('A,B,C') #Initialization of the substitution variables
        sage: Hr=fast_reduceII(p, [x1*x2^2,y0^2*y2,z0*z1^2], [A,B,C],{'A':HM(2,2,[1,0,Ha[0,0]*Ha[1,1]*Ha[2,2],1]),'B':HM(2,2,[1,0,Ha[0,1]*Ha[1,2]*Ha[2,0],1]),'C':HM(2,2,[1,0,Ha[0,2]*Ha[1,0]*Ha[2,1],1])})
        sage: Hr.p() # Orbital listing construction for the cyclic group
        [:, :]=
        [                                      1 a01*a12*a20 + a02*a10*a21 + a00*a11*a22]
        [                                      0                                       1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(monom) == len(subst):
        s = str(f)
        for i in range(len(monom)):
            s = s.replace(str(monom[i]), str(subst[i]))
        return sage_eval(s, locals=Dct)
    else:
        print('Error the monomial list and the substitution list must have the same length')

def find_and_replace_into_poly(P, mnm, submnm):
    """
    computes the input polynomial P reduction modulo
    a binomial relations. This implementation expects
    input polynomial P not to be a monomial.
 
    
    EXAMPLES:
 
    ::

        sage: x1,x2,x3=var('x1, x2, x3'); find_and_replace_into_poly(x1^3+x2+x3^3,x3^3,1)
        x1^3 + x2 + 1
        sage: sz=Integer(3); A=HM(sz,sz,'a'); Z=HM(sz,sz,factorial(sz),'z'); Lm=var_list('M',factorial(sz)); Lr=var_list('U',factorial(sz))
        sage: Sn=PermutationFunctionList(sz); An=[T for T in Sn if signf(T)>0]; Orb=HM(sz,sz,[prod(Z[i,T[j][1],Permutation_lex(T)] for T in An) for j in rg(sz) for i in rg(sz)])
        sage: P=prod(Orb[i,i] for i in rg(sz))-Orb[0,1]*Orb[1,0]*prod(Orb[i,i] for i in rg(2,sz)); Pn=P # Initialization of the  polynomial
        sage: for T in Sn:
        ....:     for u in rg(factorial(sz)):
        ....:         Pn=find_and_replace_into_poly(Pn, prod(Z[i,T[i][1],u] for i in rg(sz)), Lm[Permutation_lex(T)])
        sage: Lsm=[HM(2, 2, [1, 0, prod(A[i,T[i][1]] for i in rg(sz)), 1]) for T in Sn] # Initialization of the matrix to be substituted
        sage: F=fast_reduceII(Pn, Lm, Lr, {'U0':Lsm[0],'U1':Lsm[1],'U2':Lsm[2],'U3':Lsm[3],'U4':Lsm[4],'U5':Lsm[5],'a00':A[0,0], 'a10':A[1,0], 'a20':A[2,0], 'a01':A[0,1], 'a11':A[1,1], 'a21':A[2,1], 'a02':A[0,2], 'a12':A[1,2], 'a22':A[2,2]})[0,1]; F
        -a02*a11*a20 + a01*a12*a20 + a02*a10*a21 - a00*a12*a21 - a01*a10*a22 + a00*a11*a22



    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the operations
    add = var('x0') + var('x1')
    mul = var('x0') * var('x1')
    xpo = var('x0') ^ var('x1')
    if P.operator() == add.operator():
        # Collecting the terms
        L0=P.operands()
        # Initialization of the new loop
        L1=copy(L0)
        for i in rg(len(L0)):
            if ((L0[i]/mnm).denominator()-1).is_zero():
                # Performing the search and replace
                L1[i]=(L0[i]/mnm)*submnm
        return sum(L1) 
    elif P.operator() == mul.operator():
        raise ValueError("Expected a polynomial seems to have receibed a monomial")
    elif P.operator() == xpo.operator():
        raise ValueError("Expected a polynomial seems to have receibed a monomial or worse")
    else :
        raise ValueError("Expected a polynomial")

def reduce_modulo_binomial_ideal(P, monom, subst):
    """
    computes the canonical representative of the congruence
    class. The implementation assumes that the relations
    are ordered in decreasing degree order.
 
    
    EXAMPLES:
 
    ::

        sage: sz=3; A=HM(sz,sz,'a'); X=HM(sz,sz,'x'); Y=HM(sz,sz,'y') # Illustration of Rongyu's PDP-relaxation construction
        sage: F=sum(prod(X.elementwise_product(Y)[i,t[i][1]] for i in rg(sz)) for t in TupleFunctionList(sz))
        sage: monom=[X[i,j]*Y[j,k] for k in rg(sz) for j in rg(sz) for i in rg(sz)] # list of monomials to be replaced
        sage: subst=[A[i,k]*Y[j,k] for k in rg(sz) for j in rg(sz) for i in rg(sz)] # list of replacement monomials
        sage: G=reduce_modulo_binomial_ideal(F, monom, subst); G
        a00*a10*a20*y00*y10*y20 + a00*a11*a21*y01*y10*y20 + a00*a12*a22*y02*y10*y20 + a00*a11*a20*y00*y11*y20 + a01*a11*a21*y01*y11*y20 + a00*a11*a22*y02*y11*y20 + a00*a10*a20*y00*y12*y20 + a02*a10*a21*y01*y12*y20 + a00*a10*a22*y02*y12*y20 + a00*a10*a20*y00*y10*y21 + a00*a11*a20*y01*y10*y21 + a01*a12*a20*y02*y10*y21 + a00*a11*a21*y00*y11*y21 + a01*a11*a21*y01*y11*y21 + a01*a11*a21*y02*y11*y21 + a00*a11*a22*y00*y12*y21 + a02*a11*a22*y01*y12*y21 + a01*a11*a22*y02*y12*y21 + a00*a10*a22*y00*y10*y22 + a00*a11*a22*y01*y10*y22 + a02*a12*a22*y02*y10*y22 + a00*a11*a22*y00*y11*y22 + a01*a11*a22*y01*y11*y22 + a02*a11*a22*y02*y11*y22 + a00*a12*a22*y00*y12*y22 + a02*a12*a22*y01*y12*y22 + a02*a12*a22*y02*y12*y22 


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Testing that the lists have the same length
    if len(monom)==len(subst):
        # Initialization of the polynomial
        Po=P 
        # Loop performing the reduction
        for i in rg(len(monom)):
            Pn=find_and_replace_into_poly(Po, monom[i], subst[i])
            while not (Po-Pn).is_zero():
                Po=Pn; Pn=find_and_replace_into_poly(Po, monom[i], subst[i])
        return Pn
    else:
        print('Error the monomial list and the substitution list must have the same length')

def SecondOrderHyperdeterminant(H):
    """
    computes second order i.e. matrix determinant using the Cauchy umbral mnemonic device
    The algorithm used here is worst then sum over signed permutation monomials because it
    constructs 2^binomial(n,2) monomials in the expanded form. There is however a massive
    amount of cancelation which will leaves out only factorial(n) terms.
    
    EXAMPLES:
 
    ::

        sage: SecondOrderHyperdeterminant(HM(2,2,'a'))
        -a01*a10 + a00*a11
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==2:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),1,[var('x'+str(i)) for i in range(1,1+H.n(0))])
        L=expand(prod([A[u,0]-A[v,0] for u in range(1,A.nrows()) for v in range(u)])*prod([A[i,0] for i in range(A.nrows())])).operands()
        # Computing the polynomial
        f=sum(L)
        # Loop performing the umbral expression
        for k in range(H.n(0),0,-1):
            f=fast_reduce(f,[var('x'+str(i))^k for i in range(1,1+H.n(0))],[var('a'+str(i)+str(k)) for i in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(k)),H[i-1,k-1]) for i in range(1,1+H.n(0)) for k in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The matrix must be square.")

def ThirdOrderHyperdeterminant(H):
    """
    computes third order hypermatrix determinant using the recursive determinant construction.
    Where the base case is the matrix case. The third order hyperdeterminant are only defined
    for cubic third order hypermatrices.
    
    EXAMPLES:
 
    ::

        sage: ThirdOrderHyperdeterminant(HM(2,2,2,'a'))
        a000*a011*a101*a110 - a001*a010*a100*a111
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: Implement a faster and more generic version.
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==3:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),H.n(0),[var('x'+str(i)+str(j)) for j in range(1,1+H.n(0)) for i in range(1,1+H.n(0))])
        # Computing the mnemonique polynomial
        L=expand(SecondOrderHyperdeterminant(A)*prod([sum([sqrt(g^2).canonicalize_radical() for g in SecondOrderHyperdeterminant(A.elementwise_exponent(j)).operands()]) for j in range(2,1+A.n(0))])).operands()
        # Computing the polynomial
        f=sum([l for l in L if len((l^2).operands())==(H.n(0))^2])
        # Loop performing the umbral expression
        for k in range(H.n(0),0,-1):
            f=fast_reduce(f,[var('x'+str(i)+str(j))^k for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0))],[var('a'+str(i)+str(j)+str(k)) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(j)+str(k)),H[i-1,j-1,k-1]) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The hypermatrix must be a third order cube hypermatrix.")

def FourthOrderHyperdeterminant(H):
    """
    computes fourth order hyperdeterminant using the recusive construction.
    The base case of the recusrion is the matrix determinant.
    
    EXAMPLES:
 
    ::

        sage: FourthOrderHyperdeterminant(HM(2,2,2,2,'a'))
        -a0001*a0010*a0100*a0111*a1000*a1011*a1101*a1110 + a0000*a0011*a0101*a0110*a1001*a1010*a1100*a1111

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==4:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),H.n(0),H.n(0), [var('x'+str(i)+str(j)+str(k)) for k in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for i in range(1,1+H.n(0))])
        # Computing the polynomial
        L=expand(ThirdOrderHyperdeterminant(A)*prod([sum([sqrt(g^2).canonicalize_radical() for g in ThirdOrderHyperdeterminant(A.elementwise_exponent(j)).operands()]) for j in range(2,1+A.n(0))])).operands()
        # Computing the polynomial
        f = sum([l for l in L if len((l^2).operands())==(H.n(0))^3])
        # Loop performing the umbral expression
        for l in range(H.n(0),0,-1):
            f = fast_reduce(f,[var('x'+str(i)+str(j)+str(k))^l for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0))],[var('a'+str(i)+str(j)+str(k)+str(l)) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(j)+str(k)+str(l)),H[i-1,j-1,k-1,l-1]) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The hypermatrix must be a fourth order hypercube hypermatrix.")

def FifthOrderHyperdeterminant(H):
    """
    computes the fifth order hyperderterminant using the recusrive construction using the matrix determinant as
    the base case.
    
    EXAMPLES:
 
    ::

        sage: FifthOrderHyperdeterminant(HM(2,2,2,2,2,'a'))
        a00000*a00011*a00101*a00110*a01001*a01010*a01100*a01111*a10001*a10010*a10100*a10111*a11000*a11011*a11101*a11110 - a00001*a00010*a00100*a00111*a01000*a01011*a01101*a01110*a10000*a10011*a10101*a10110*a11001*a11010*a11100*a11111

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==5:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),H.n(0),H.n(0),H.n(0),[var('x'+str(i)+str(j)+str(k)+str(l)) for l in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for i in range(1,1+H.n(0))])
        # Computing the polynomial
        L = expand(FourthOrderHyperdeterminant(A)*prod([sum([sqrt(g^2).canonicalize_radical() for g in FourthOrderHyperdeterminant(A.elementwise_exponent(j)).operands()]) for j in range(2,1+A.n(0))])).operands()
        f = sum([l for l in L if len((l^2).operands())==(H.n(0))^4])
        # Loop performing the umbral expression
        for m in range(H.n(0),0,-1):
            f = fast_reduce(f,[var('x'+str(i)+str(j)+str(k)+str(l))^m for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0))],[var('a'+str(i)+str(j)+str(k)+str(l)+str(m)) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(j)+str(k)+str(l)+str(m)),H[i-1,j-1,k-1,l-1,m-1]) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0)) for m in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The hypermatrix must be a fifth order hypercube hypermatrix.")

def SixthOrderHyperdeterminant(H):
    """
    computes the sixth order hypermatrix determinant using the recursive construction.
    The base case of the recursion being the matrix determinant formula
    
    EXAMPLES:
 
    ::

        sage: SixthOrderHyperdeterminant(HM(2,2,2,2,2,2,'a'))
        -a000001*a000010*a000100*a000111*a001000*a001011*a001101*a001110*a010000*a010011*a010101*a010110*a011001*a011010*a011100*a011111*a100000*a100011*a100101*a100110*a101001*a101010*a101100*a101111*a110001*a110010*a110100*a110111*a111000*a111011*a111101*a111110 + a000000*a000011*a000101*a000110*a001001*a001010*a001100*a001111*a010001*a010010*a010100*a010111*a011000*a011011*a011101*a011110*a100001*a100010*a100100*a100111*a101000*a101011*a101101*a101110*a110000*a110011*a110101*a110110*a111001*a111010*a111100*a111111
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Testing to see that the hypermatrix is indeed a cube
    if len(Set(H.dimensions()).list())==1 and H.order()==6:
        # Initializing the matrix for the mnemonic construction
        A=HM(H.n(0),H.n(0),H.n(0),H.n(0),H.n(0),[var('x'+str(i)+str(j)+str(k)+str(l)+str(m)) for m in range(1,1+H.n(0)) for l in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for i in range(1,1+H.n(0))])
        # Computing the polynomial
        L = expand(FifthOrderHyperdeterminant(A)*prod([sum([sqrt(g^2).canonicalize_radical() for g in FifthOrderHyperdeterminant(A.elementwise_exponent(j)).operands()]) for j in range(2,1+A.n(0))])).operands()
        f = sum([l for l in L if len((l^2).operands())==(H.n(0))^5])
        # Loop performing the umbral expression
        for p in range(H.n(0),0,-1):
            f = fast_reduce(f,[var('x'+str(i)+str(j)+str(k)+str(l)+str(m))^p for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0)) for m in range(1,1+H.n(0))],[var('a'+str(i)+str(j)+str(k)+str(l)+str(m)+str(p)) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0)) for m in range(1,1+H.n(0))])
        return f.subs(dict([(var('a'+str(i)+str(j)+str(k)+str(l)+str(m)+str(p)),H[i-1,j-1,k-1,l-1,m-1,p-1]) for i in range(1,1+H.n(0)) for j in range(1,1+H.n(0)) for k in range(1,1+H.n(0)) for l in range(1,1+H.n(0)) for m in range(1,1+H.n(0)) for p in range(1,1+H.n(0))]))
    else :
        # Print an error message indicating that the matrix must be a cube.
        raise ValueError("The hypermatrix must be a sixth order hypercube hypermatrix.")

def general_side_length_2_det(A):
    """
    outputs the symbolic expression with the determinant of hypermatrices of arbitrary orders.
    but every size of the hypermatrix must be equal to two. It ouputs an equality derived via
    the rank one argument. The difference with the function above is that this function
    takes a hypermatrix as input.

    EXAMPLES:
 
    ::

        sage: general_side_length_2_det(HM(2,2,'a'))
        -a01*a10 + a00*a11

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if A.is_cubical() and A.n(0)==2:
        # Initialization of the list specifying the dimensions of the output
        l = [A.n(i) for i in range(A.order())]
        # Initializing the input for generating a symbolic hypermatrix
        inpts = l+['zero']
        # Initialization of the list of odd and even index list
        Lodd=[]; Leven=[]
        Rh = HM(*inpts)
        # Main loop performing the transposition of the entries
        for i in range(prod(l)):
            # Turning the index i into an hypermatrix array location using the decimal encoding trick
            entry = [Integer(mod(i,l[0]))]
            sm = Integer(mod(i,l[0]))
            for k in range(len(l)-1):
                entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
            if Integer(mod(sum(entry),2)) == 0:
                Leven.append(A[tuple(entry)])
            else:
                Lodd.append(A[tuple(entry)])
        return prod(Leven)-prod(Lodd)
    else:
        raise ValueError("The input hypermatrix must cubical with side lentgh 2.")

def DodgsonCondensation(A):
    """
    outputs the symbolic expression deduced from the Dodgson condensation applied to matrices
    and hypermatrices. The side length of the input hypermatrix must be greater then 2.

    EXAMPLES:
 
    ::

        sage: DodgsonCondensation(HM(3,3,'a')) 
        -((a02*a11 - a01*a12)*(a11*a20 - a10*a21) - (a01*a10 - a00*a11)*(a12*a21 - a11*a22))/a11

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    if A.is_cubical() and A.n(0)>2:
        # Initializing the copy
        Bold=A.copy()
        #Bnew=apply(HM,[i-1 for i in Bold.dimensions()]+['zero'])
        Bnew=HM( *([i-1 for i in Bold.dimensions()]+['zero']) )
        Temp=HM( *([i-2 for i in Bold.dimensions()]+['zero']) )
        while Bnew.n(0)>1:
            # Filling up Bnew
            l=Bnew.dimensions()
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry=[Integer(mod(i,l[0]))]
                sm=Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm=sm+prod(l[0:k+1])*entry[len(entry)-1]
                # Initialization of the summand
                Bl=[]
                l2=[2 for j in range(A.order())]
                for j in range(prod(l2)):
                    ent=[Integer(mod(j,l2[0]))]
                    ms=Integer(mod(j,l2[0]))
                    for t in range(len(l2)-1):
                        ent.append(Integer(mod(Integer((j-ms)/prod(l2[0:t+1])),l2[t+1])))
                        ms=ms+prod(l2[0:t+1])*ent[len(ent)-1]
                    Bl.append((Matrix(ZZ,entry)+Matrix(ZZ,ent)).list())
                Bnew[tuple(entry)]=general_side_length_2_det(HM(*([2 for j in range(A.order())]+[[Bold[tuple(entry2)] for entry2 in Bl ]])))
            # Filling up Temp
            Temp=HM(*([i-2 for i in Bold.dimensions()]+['zero']))
            l=Temp.dimensions()
            # Main loop performing the transposition of the entries
            for i in range(prod(l)):
                # Turning the index i into an hypermatrix array location using the decimal encoding trick
                entry = [Integer(mod(i,l[0]))]
                sm = Integer(mod(i,l[0]))
                for k in range(len(l)-1):
                    entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                    sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                # Initialization of the summand
                Bl=[]
                l2=[2 for j in range(A.order())]
                for j in range(prod(l2)):
                    ent=[Integer(mod(j,l2[0]))]
                    ms=Integer(mod(j,l2[0]))
                    for t in range(len(l2)-1):
                        ent.append(Integer(mod(Integer((j-ms)/prod(l2[0:t+1])),l2[t+1])))
                        ms = ms+prod(l2[0:t+1])*ent[len(ent)-1]
                    Bl.append((Matrix(ZZ,entry)+Matrix(ZZ,ent)).list())
                #Temp[tuple(entry)]=general_side_length_2_det(apply(HM,[2 for j in range(A.order())]+[[Bnew[tuple(entry2)] for entry2 in Bl ]]))/Bold[tuple((Matrix(ZZ,entry)+ones_matrix(1,len(entry))).list())]
                Temp[tuple(entry)]=general_side_length_2_det(HM(*([2 for j in range(A.order())]+[[Bnew[tuple(entry2)] for entry2 in Bl ]])))/Bold[tuple((Matrix(ZZ,entry)+ones_matrix(1,len(entry))).list())]
            # Performing the update
            if Temp.n(0)>0:
                Bold=Bnew.copy()
                Bnew=Temp.copy()
        return (Temp.list())[0]
    else:
        raise ValueError("The input hypermatrix must be hypercubic of size 2")

def GeneralHyperdeterminantExpression(od,sz):
    """
    computes the general hyperdeterminant expression using the recursive determinant
    construction. Where the base case is the matrix determinant.
    
    EXAMPLES:
 
    ::

        sage: GeneralHyperdeterminantExpression(3,2)
        x111*x122*x212*x221 - x112*x121*x211*x222
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: Implement a faster and more generic version.
    """
    # Testing to see that the hypermatrix is indeed a cube
    if od==2:
        return HM(sz,sz,'x','shift').det()
    elif od>2:
        # Initializing the base case of the recursion
        A=HM(sz,sz,'x','shift').copy()
        # Computing the matrix determinant and permanent pair
        Ldtm=[Deter(A)]+[Per(A.elementwise_exponent(j)) for j in range(2,1+sz)]
        # Main loop performing the recursion computation
        for o in range(2,od):
            # ReInitialization of the Hypermatrix A
            #A=apply(HM,[sz for i in range(o)]+['x']+['shift']).copy()
            A=HM(*([sz for i in range(o)]+['x']+['shift'])).copy()
            # Computing the mnemonique polynomial
            L=expand(prod(Ldtm)).operands()
            # Computing the polynomial
            f=sum([l for l in L if len((l^2).operands())==prod(A.dimensions())])
            # Loop performing the umbral transformation
            for k in range(sz,0,-1):
                f=fast_reduce(f,A.elementwise_exponent(k).list(), HM(*([sz for i in range(o)]+['a']+['shift'])).append_index(k).list())
            B=HM(*([sz for i in range(o+1)]+['x']+['shift'])).copy()
            L1=HM(*([sz for i in range(o+1)]+['x']+['shift'])).list();L2=HM(*([sz for i in range(o+1)]+['a']+['shift'])).list()
            f=f.subs(dict([(L2[i],L1[i]) for i in range(len(L1))]))
            Ldtm=[f]+[sum([sqrt(g^2).canonicalize_radical() for g in f.operands()]).subs(dict([(B.list()[i],B.elementwise_exponent(j).list()[i]) for i in range(prod(B.dimensions()))])) for j in range(2,1+sz)]
        return f

def GeneralHyperdeterminant(H):
    """
    computes the general hyperdeterminant using the recursive determinant construction.
    Where the base case is the matrix determinant.
    
    EXAMPLES:
 
    ::

        sage: GeneralHyperdeterminant(HM(2,2,2,'a','shift'))
        a111*a122*a212*a221 - a112*a121*a211*a222
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: Implement a faster and more generic version.
    """
    if H.is_cubical(): 
        f=GeneralHyperdeterminantExpression(H.order(),H.n(0))
        Lh=H.list()
        #Lx=apply(HM,[H.n(0) for i in range(H.order())]+['x']+['shift']).list()
        Lx=HM(*([H.n(0) for i in range(H.order())]+['x']+['shift'])).list()
        return f.subs(dict([(Lx[i],Lh[i]) for i in range(len(Lh))]))
    else:
        raise ValueError("The hypermatrix must be cubical.")

def LatinHypermatrixList(od,sz):
    """
    computes list of latin hypercubes of order od and side length sz.
    
    EXAMPLES:
 
    ::

        sage: LatinHypermatrixList(2,2)
        [[[0, x01], [x10, 0]], [[x00, 0], [0, x11]]]
        

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the hyperdeterminant expression.
    #Dt=GeneralHyperdeterminant(apply(HM,[sz for i in range(od)]+['x']))
    Dt=GeneralHyperdeterminant(HM(*([sz for i in range(od)]+['x'])))
    Lt = [sqrt(tm^2).canonicalize_radical() for tm in Dt.operands()]
    Sa = Set(HM(*([sz for i in range(od)]+['x'])).list())
    L = []
    for f in Lt:
        Tmp=HM(*([sz for i in range(od)]+['x']))
        Lsf=Sa.difference(Set(f.operands()))
        L.append(Tmp.subs(dict([(g,0) for g in Lsf])))
    return L

def GeneralHypermatrixRank1Parametrization(sz,od):
    """
    Outputs the symbolic constraints associated with rank one parametrization
    of hypermatrices.

    EXAMPLES:
 
    ::

        sage: GeneralHypermatrixRank1Parametrization(2,2) 
        [1 0 1 0]
        [0 1 1 0]
        [1 0 0 1]
        [0 1 0 1]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization the alphabet list
    AlphaB=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    # Initializing the list of hypermatrices
    L=[]
    for j in rg(1,od)+[0]:
        TmpL=[sz for i in rg(j)]+[1]+[sz for i in rg(j+1,od)]+[AlphaB[j]]
        L.append(HM(*TmpL))
    # Initilizing the list of variable
    VrbLst=[]
    for Q in L:
        VrbLst = VrbLst+Q.list()
    Eq=Prod(*[Q for Q in L])
    CnstrLst=[eq==1 for eq in Eq.list()]
    [A,b]=multiplicativeConstraintFormator(CnstrLst, VrbLst)
    return A

def SecondOrderHadamardBlockU(l):
    """
    outputs the  direct sum construction of hadamard block matrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: SecondOrderHadamardBlockU(2)
        [[1, 1], [1, -1]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    bns = Integer(l).str(2)
    Szl = [(2^(len(bns)-1-i),bns[i]) for i in range(len(bns)) if bns[i]!='0']
    H = Matrix(QQ,hadamard_matrix(Szl[0][0]))
    for i in range(1,len(Szl)):
        if Szl[i][0]==1:
            H = H.block_sum(Matrix(QQ,1,1,[1]))
        else:
            H = H.block_sum(Matrix(QQ,hadamard_matrix(Szl[i][0])))
    return HM(l,l,H.list())

def SecondOrderHadamardBlock(l):
    """
    outputs the  direct sum construction of hadamard block matrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: SecondOrderHadamardBlock(2)
        [[1/2*sqrt(2), 1/2*sqrt(2)], [1/2*sqrt(2), -1/2*sqrt(2)]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    bns = Integer(l).str(2)
    Szl = [(2^(len(bns)-1-i),bns[i]) for i in range(len(bns)) if bns[i]!='0']
    H = (1/sqrt(Szl[0][0]))*Matrix(QQ,hadamard_matrix(Szl[0][0]))
    for i in range(1,len(Szl)):
        if Szl[i][0]==1:
            H = H.block_sum(Matrix(QQ,1,1,[1]))
        else:
            H = H.block_sum((1/sqrt(Szl[i][0]))*Matrix(QQ,hadamard_matrix(Szl[i][0])))
    return HM(l,l,H.list())

def SecondOrderInverseBlock(l):
    """
    Outputs the  direct sum construction of an invertible lxl
    matrix and its inverse use the binary expansion of l.


    EXAMPLES:
 
    ::

        sage: [A, Ai]=SecondOrderInverseBlock(3)
        sage: A.printHM()
        [:, :]=
        [a00 a01   0]
        [a10 a11   0]
        [  0   0   1]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    - To Do: 
    """
    # Initialization of the size
    sz=Integer(2)
    bns = Integer(l).str(2)
    Szl = [(len(bns)-1-i,bns[i]) for i in range(len(bns)) if bns[i]!='0']
    # Initialization of the initial 2x2
    H=HM(sz, sz, 'a'); Hi=i2x2(H)
    # Initialization of the binary expansion
    H=H.tensor_power(Szl[0][0]); Hi=Hi.tensor_power(Szl[0][0])
    for i in rg(1,len(Szl)):
        if Szl[i][0]==0:
            H = H.block_sum(HM(1,1,[1])); Hi = Hi.block_sum(HM(1,1,[1]))
        else:
            Tmp=HM(sz, sz, 'a'); Tmpi=i2x2(Tmp)
            Tmp=Tmp.tensor_power(Szl[i][0]); Tmpi=Tmpi.tensor_power(Szl[i][0])
            H = H.block_sum(Tmp); Hi = Hi.block_sum(Tmpi)
    return [H, Hi]

def ThirdOrderHadamardBlockU(l):
    """
    outputs the  direct sum construction of hadamard block hypermatrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: ThirdOrderHadamardBlockU(2)
        [[[1, 1], [1, 1]], [[-1, 1], [1, 1]]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the 2x2x2 hadamard Hypermatrix.
    Hd = HM([[[1, 1], [1, 1]], [[-1, 1], [1, 1]]]) 
    # Obtaining the binary encoding of the input integer
    bns = Integer(l).str(2)
    Szl = [len(bns)-1-i for i in range(len(bns)) if bns[i] != '0']
    Lh = [HypermatrixSliceKroneckerPower(Hd, i) for i in Szl if i > 0]
    H = Lh[0]
    if Integer(mod(l,2)) == 0:
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
    else :
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
        H = H.block_sum(HM(1,1,1,'one')) 
    return H

def ThirdOrderHadamardBlock(l):
    """
    outputs the  direct sum construction of hadamard block hypermatrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: ThirdOrderHadamardBlock(2)
        [[[(1/2)^(1/3), (1/2)^(1/3)], [(1/2)^(1/3), (1/2)^(1/3)]], [[-(1/2)^(1/3), (1/2)^(1/3)], [(1/2)^(1/3), (1/2)^(1/3)]]]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the 2x2x2 hadamard Hypermatrix.
    Hd = (1/2)^(1/3)*HM([[[1, 1], [1, 1]], [[-1, 1], [1, 1]]]) 
    # Obtaining the binary encoding of the input integer
    bns = Integer(l).str(2)
    Szl = [len(bns)-1-i for i in range(len(bns)) if bns[i] != '0']
    Lh = [HypermatrixSliceKroneckerPower(Hd, i) for i in Szl if i > 0]
    H = Lh[0]
    if Integer(mod(l,2)) == 0:
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
    else :
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
        H = H.block_sum(HM(1,1,1,'one')) 
    return H

def FifthOrderHadamardBlockU(l):
    """
    outputs the  direct sum construction of hadamard block hypermatrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: FifthOrderHadamardBlockU(2)
        [[[[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]]], [[[[1, 1], [-1, -1]], [[1, 1], [1, 1]]], [[[-1, 1], [1, 1]], [[1, 1], [1, 1]]]]]

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the 2x2x2x2x2 hadamard hypermatrix.
    Hd=HM([[[[[1,1],[1,1]],[[1,1],[1,1]]],[[[1,1],[1,1]],[[1,1],[1,1]]]],[[[[1,1],[-1,-1]],[[1,1],[1,1]]],[[[-1,1],[1,1]],[[1,1],[1,1]]]]])
    # Obtaining the binary encoding of the input integer
    bns = Integer(l).str(2)
    Szl = [len(bns)-1-i for i in range(len(bns)) if bns[i] != '0']
    Lh = [HypermatrixSliceKroneckerPower(Hd, i) for i in Szl if i > 0]
    H = Lh[0]
    if Integer(mod(l,2))==0:
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
    else :
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
        H = H.block_sum(HM(1,1,1,1,1,'one')) 
    return H

def FifthOrderHadamardBlock(l):
    """
    outputs the  direct sum construction of hadamard block hypermatrices.
    the vectors of the matrices are not normalized.

    EXAMPLES:
 
    ::

        sage: FifthOrderHadamardBlock(2)
        [[[[[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]], [[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]]], [[[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]], [[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]]]], [[[[(1/2)^(1/5), (1/2)^(1/5)], [-(1/2)^(1/5), -(1/2)^(1/5)]], [[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]]], [[[-(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]], [[(1/2)^(1/5), (1/2)^(1/5)], [(1/2)^(1/5), (1/2)^(1/5)]]]]]

    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing the 2x2x2x2x2 hadamard Hypermatrix.
    Hd = (1/2)^(1/5)*HM([[[[[1,1],[1,1]],[[1,1],[1,1]]],[[[1,1],[1,1]],[[1,1],[1,1]]]],[[[[1,1],[-1,-1]],[[1,1],[1,1]]],[[[-1,1],[1,1]],[[1,1],[1,1]]]]])
    # Obtaining the binary encoding of the input integer
    bns = Integer(l).str(2)
    Szl = [len(bns)-1-i for i in range(len(bns)) if bns[i] != '0']
    Lh = [HypermatrixSliceKroneckerPower(Hd, i) for i in Szl if i > 0]
    H = Lh[0]
    if Integer(mod(l,2)) == 0:
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
    else :
        for i in range(1,len(Lh)):
            H = H.block_sum(Lh[i])
        H = H.block_sum(HM(1,1,1,1,1,'one')) 
    return H

def RandomTransposition(n):
    """
    Outputs  the random transposition permutation of n elements.
    The fucntion is used for randominzing the Hadamard block construction
    

    EXAMPLES:
 
    ::

        sage: min(RandomTransposition(3))
        0 

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the vector
    p = [0 .. n-1]
    idx = ZZ.random_element(n)
    jdx = idx
    # avoiding the trivial transposition
    while jdx == idx:
        jdx = ZZ.random_element(n)
    # recording the transposition
    tmp = p[idx]; p[idx] = p[jdx]; p[jdx] = tmp
    return p

def RandomColumnSlicePermutation(H):
    """
    Outputs a permutation of the slices of the input third order hypermatrix.

    EXAMPLES:
 
    ::

        sage: RandomColumnSlicePermutation(HM(2,2,2,'a'))
        [[[a010, a011], [a000, a001]], [[a110, a111], [a100, a101]]] 
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    sz = H.n(2)
    for i in range(Integer(ceil(sqrt(sz)))+1):
        # Initialization of the permutation
        P = HypermatrixPermutation(RandomTransposition(sz))
        H = Prod(H, HM(P), HM(P).transpose())
    return H

def SecondOrderHypermatrixResolutionPartition(U, V, Ha, Hb, NbPrts=2):
    """
    outputs the spliting of a second order hypermatrix into the pieces
    as suggested by the resolution of identity. The first three input
    hypermatrices are uncorrelated tuples.
    the last three inputs correspond to the factors for the spliting.

    EXAMPLES:
 
    ::

        sage: [U,V]=GeneralUncorrelatedHypermatrixTuple(2)
        sage: L=SecondOrderHypermatrixResolutionPartition(U, V, HM(2,2,'a'), HM(2,2,'b'))
        sage: len(L)
        2
        sage: sum(L).simplify_full()
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the list storing the projectors
    L = []
    for i in range(U.n(1)):
        # Filling up the slice
        Tp0 = U.slice([i],'col')
        # Filling up the slice
        Tp1 = V.slice([i],'row')
        # Appending the components to the list
        L.append(Prod(Tp0, Tp1))
    if len(L)>NbPrts:
        return [ProdB(Ha,Hb,sum(L[j*NbPrts:min((j+1)*NbPrts,len(L))])) for j in range(ceil(len(L)/NbPrts))]
    else:
        return [ProdB(Ha,Hb,L[j]) for j in range(len(L))]

def SecondOrderHypermatrixResolutionPartitionII(U, V, Ha, Hb, NbPrts=2):
    """
    outputs the spliting of a second order hypermatrix into the pieces
    as suggested by the resolution of identity. The first three input
    hypermatrices are uncorrelated tuples.
    the last three inputs correspond to the factors for the spliting.

    EXAMPLES:
 
    ::

        sage: [U,V]=GeneralUncorrelatedHypermatrixTuple(2)
        sage: L=SecondOrderHypermatrixResolutionPartitionII(U.matrix(), V.matrix(), HM(2,2,'a').matrix(), HM(2,2,'b').matrix())
        sage: len(L)
        2
        sage: sum(L).simplify_full()
        [a00*b00 + a01*b10 a00*b01 + a01*b11]
        [a10*b00 + a11*b10 a10*b01 + a11*b11]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the list storing the projectors
    L = []
    for i in rg(U.nrows()):
        # Filling up the slice
        Tp0 = U[:,i]
        # Filling up the slice
        Tp1 = V[i,:]
        # Appending the components to the list
        L.append(Tp0*Tp1)
    if len(L)>NbPrts:
        return [Ha*sum(L[j*NbPrts:min((j+1)*NbPrts,len(L))])*Hb for j in range(ceil(len(L)/NbPrts))]
    else:
        return [Ha*L[j]*Hb for j in range(len(L))]

def ThirdOrderHypermatrixResolutionPartition(U, V, W, Ha, Hb, Hc, NbPrts=2):
    """
    outputs the spliting of a third order hypermatrix into the pieces
    as suggested by the resolution of identity. The first three input
    hypermatrices are uncorrelated tuples.
    the last three inputs correspond to the factors for the spliting.

    EXAMPLES:
 
    ::

        sage: [U,V,W]=GeneralUncorrelatedHypermatrixTuple(3)
        sage: L=ThirdOrderHypermatrixResolutionPartition(U,V,W,HM(2,2,2,'a'),HM(2,2,2,'b'),HM(2,2,2,'c'))
        sage: len(L)
        2
        sage: sum(L).simplify_full()
        [[[a000*b000*c000 + a010*b001*c100, a001*b000*c001 + a011*b001*c101], [a000*b010*c010 + a010*b011*c110, a001*b010*c011 + a011*b011*c111]], [[a100*b100*c000 + a110*b101*c100, a101*b100*c001 + a111*b101*c101], [a100*b110*c010 + a110*b111*c110, a101*b110*c011 + a111*b111*c111]]]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    L = []
    for i in range(U.n(1)):
        # Filling up the slice
        Tp0 = HM(U.n(0), 1, U.n(2), 'zero')
        for u in range(Tp0.n(0)):
            for w in range(Tp0.n(2)):
                Tp0[u,0,w] = U[u,i,w]
        # Filling up the slice
        Tp1 = HM(V.n(0), V.n(1), 1, 'zero')
        for u in range(Tp1.n(0)):
            for v in range(Tp1.n(1)):
                Tp1[u,v,0] = V[u,v,i]
        # Filling up the slice
        Tp2 = HM(1, W.n(1), W.n(2), 'zero')
        for v in range(Tp2.n(1)):
            for w in range(Tp2.n(2)):
                Tp2[0,v,w] = W[i,v,w]
        # Appending the components to the list
        L.append(Prod(Tp0, Tp1, Tp2))
    if len(L)>NbPrts:
        return [ProdB(Ha,Hb,Hc,sum(L[j*NbPrts:min((j+1)*NbPrts,len(L))])) for j in range(ceil(len(L)/NbPrts))]
    else:
        return [ProdB(Ha,Hb,Hc,L[j]) for j in range(len(L))]

def FourthOrderHypermatrixResolutionPartition(Q, U, V, W, Ha, Hb, Hc, Hd):
    """
    outputs the spliting of a fourth order hypermatrix into the pieces
    as suggested by the resolution of identity. The first three input
    hypermatrices are uncorrelated tuples.
    the last three imputs correspond to the factors for the spliting.

    EXAMPLES:
 
    ::

        sage: [Q, U, V, W] = GeneralUncorrelatedHypermatrixTuple(4)
        sage: L = FourthOrderHypermatrixResolutionPartition(Q,U,V,W,HM(2,2,2,2,'a'),HM(2,2,2,2,'b'),HM(2,2,2,2,'c'), HM(2,2,2,2,'d'))
        sage: len(L)
        2
        sage: sum(L).simplify_full()
        [[[[a0000*b0000*c0000*d0000 + a0100*b0010*c0001*d1000, a0001*b0001*c0000*d0001 + a0101*b0011*c0001*d1001], [a0010*b0000*c0010*d0010 + a0110*b0010*c0011*d1010, a0011*b0001*c0010*d0011 + a0111*b0011*c0011*d1011]], [[a0000*b0100*c0100*d0100 + a0100*b0110*c0101*d1100, a0001*b0101*c0100*d0101 + a0101*b0111*c0101*d1101], [a0010*b0100*c0110*d0110 + a0110*b0110*c0111*d1110, a0011*b0101*c0110*d0111 + a0111*b0111*c0111*d1111]]], [[[a1000*b1000*c1000*d0000 + a1100*b1010*c1001*d1000, a1001*b1001*c1000*d0001 + a1101*b1011*c1001*d1001], [a1010*b1000*c1010*d0010 + a1110*b1010*c1011*d1010, a1011*b1001*c1010*d0011 + a1111*b1011*c1011*d1011]], [[a1000*b1100*c1100*d0100 + a1100*b1110*c1101*d1100, a1001*b1101*c1100*d0101 + a1101*b1111*c1101*d1101], [a1010*b1100*c1110*d0110 + a1110*b1110*c1111*d1110, a1011*b1101*c1110*d0111 + a1111*b1111*c1111*d1111]]]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    L = []
    for i in range(Q.n(1)):
        # Filling up the slice
        Tp0 = HM(Q.n(0), 1, Q.n(2), Q.n(3), 'zero')
        for q in range(Tp0.n(0)):
            for v in range(Tp0.n(2)):
                for w in range(Tp0.n(3)):
                    Tp0[q,0,v,w] = Q[q,i,v,w]
        # Filling up the slice
        Tp1 = HM(U.n(0), U.n(1), 1, U.n(3), 'zero')
        for q in range(Tp1.n(0)):
            for u in range(Tp1.n(1)):
                for w in range(Tp1.n(3)):
                    Tp1[q,u,0,w] = U[q,u,i,w]
        # Filling up the slice
        Tp2 = HM(V.n(0), V.n(1), V.n(2), 1, 'zero')
        for q in range(Tp2.n(0)):
            for u in range(Tp2.n(1)):
                for v in range(Tp2.n(2)):
                    Tp2[q,u,v,0] = V[q,u,v,i]
        # Filling up the slice
        Tp3 = HM(1, W.n(1), W.n(2), W.n(3), 'zero')
        for u in range(Tp3.n(1)):
            for v in range(Tp3.n(2)):
                for w in range(Tp3.n(3)):
                    Tp3[0,u,v,w] = W[i,u,v,w]
        # Appending the components to the list
        L.append(ProdB(Ha, Hb, Hc, Hd, Prod(Tp0, Tp1, Tp2, Tp3)))
    return L

def CanonicalThirdOrderHypermatrixFactors(A):
    """
    Outputs the canonical factorization for third order hypermatrices. 
    The canonical factorization results from the fact that any sum of
    outer products is a hypermatrix product.

    EXAMPLES:
 
    ::

        sage: [Q,U,V] = CanonicalThirdOrderHypermatrixFactors(HM(2,2,2,'a'))
        sage: Prod(Q,U,V)-HM(2,2,2,'a')
        [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the size parameters
    sz = A.dimensions()
    # Initializing the list of column vectors
    e_i=[identity_matrix(sz[0])[:,i] for i in range(sz[0])]
    e_j=[identity_matrix(sz[1])[:,j] for j in range(sz[1])]
    e_k=[identity_matrix(sz[2])[:,k] for k in range(sz[2])]
    # Initializing the first hypermatrix
    T0 = HM(sz[0],prod(sz),sz[2],'zero')
    # Initializing the second hypermatrix
    T1 = HM(sz[0],sz[1],prod(sz),'zero')
    # Filling up of the third hypermatrix
    T2 = HM(prod(sz),sz[1],sz[2],'zero')
    cnt = 0
    for i in range(len(e_i)):
        for j in range(len(e_j)):
            for k in range(len(e_k)):
                M0 = e_i[i]*e_k[k].transpose()
                M1 = e_i[i]*e_j[j].transpose()
                M2 = e_j[j]*e_k[k].transpose()
                for r in range(sz[0]):
                    for d in range(sz[2]):
                        T0[r,cnt,d]=(A[i,j,k])^(1/3)*M0[r,d]
                for r in range(sz[0]):
                    for c in range(sz[1]):
                        T1[r,c,cnt]=(A[i,j,k])^(1/3)*M1[r,c]
                for c in range(sz[1]):
                    for d in range(sz[2]):
                        T2[cnt,c,d]=(A[i,j,k])^(1/3)*M2[c,d]
                cnt = cnt+1
    return [T0,T1,T2]


def GeneralHypermatrixLogProductTermList(*args):
    """
    Outputs the matrix constraints associated with the Logproduct 
    this came up when I tried to use system of linear algebra
    and resoltion of identity to express a composition rule.
    This was not overall successfull.

    EXAMPLES:
 
    ::

        sage: GeneralHypermatrixLogProductTermList(HM(2,1,'a'),HM(1,2,'b'))
        [a00 + b00, a10 + b00, a00 + b01, a10 + b01]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = []
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh = Rh + [sum([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)] + [args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+[args[len(args)-1][tuple([t]+entry[1:])]]) for t in range((args[0]).n(1))]
    return Rh

def BlockSweep(A,k):
    """
    Outputs the result of the sweep operator a  block partion second order hypermatrix

    EXAMPLES:

    ::

        sage: cL=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']; sz=3; sz0=2; sz1=1 
        sage: A=HM(sz,sz,[HM(sz0,sz0,cL[0]),HM(sz1,sz0,cL[1]),HM(sz1,sz0,cL[2]), HM(sz0,sz1,cL[3]),HM(sz1,sz1,cL[4]),HM(sz1,sz1,cL[5]), HM(sz0,sz1,cL[6]),HM(sz1,sz1,cL[7]),HM(sz1,sz1,cL[8])])
        sage: B=A.copy()
        sage: for k in range(B.n(0)):
        ....:     B=BlockSweep(B,k)
        ....:
        sage: (A*B).simplify_full()
        [[[[-1, 0], [0, -1]], [[0], [0]], [[0], [0]]], [[[0, 0]], [[-1]], [[0]]], [[[0, 0]], [[0]], [[-1]]]]


    AUTHORS:
    - Edinah K. Gnang and Jeanine Gnang
    """
    # Initialization of the hypermatrix B
    B=HM(A.n(0),A.n(1), [HM(*(H.dimensions()+['zero'])) for H in A.list()])
    B[k,k] = -A[k,k].inverse()
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            if i != k:
                B[i,k]= A[i,k]*A[k,k].inverse()
            if j != k:
                B[k,j]= A[k,k].inverse()*A[k,j]
            if i != k and j!= k:
                B[i,j] = A[i,j]-(A[i,k]*A[k,k].inverse()*A[k,j])
    return B.copy()

def SweepHM(A,k):
    """
    Outputs the result of the sweep operator on a block partition 
    second order hypermatrix. This version implements the BM
    product take on the sweep operator.

    EXAMPLES:

    ::

        sage: Ha=HM(2,2,'a'); Hb=HM(2,2,'b'); Hc=HM(2,2,'c'); Hd=HM(2,2,'d')
        sage: A=HM([[Ha,Hb],[Hc,Hd]]); B=A.copy()
        sage: for k in range(B.n(0)):
        ....:     B=SweepHM(B,k)[3]
        ....:
        sage: (A*B).simplify_full()
        [[[[-1, 0], [0, -1]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[-1, 0], [0, -1]]]]
        sage: Ha=HM(2, 2, 'a'); A=HM(2, 2, [HM(1,1,[f]) for f in Ha.list()])
        sage: B=A.copy()
        sage: for k in range(B.n(0)):
        ....:     B=SweepHM(B,k)[3]
        ....:
        sage: (A*B).simplify_full()
        [[[[-1]], [[0]]], [[[0]], [[-1]]]]
        sage: sz=3; indx=1 # Initialization of the size  sweep index parameter
        sage: Ha=HM(sz, sz, 'a'); A=HM(sz, sz, [HM(1, 1, [f]) for f in Ha.list()]); B=A.copy()
        sage: [U, V, W, Rt]=SweepHM(A, indx) # Performing the sweep
        sage: Hu=HM(sz, 2, 1, [U[i,j,0][0,0] for j in range(2) for i in range(sz)]); Hu.printHM()
        [:, :, 0]=
        [  1 a01]
        [  0   1]
        [  1 a21]
        sage: Hv=HM(sz, sz, 2, [V[i,j,k][0,0] for k in range(2) for j in range(sz) for i in range(sz)]); Hv.printHM()
        [:, :, 0]=
        [a00 a01 a02]
        [a10 a11 a12]
        [a20 a21 a22]
        <BLANKLINE>
        [:, :, 1]=
        [-1/a11  1/a11 -1/a11]
        [ 1/a11 -1/a11  1/a11]
        [-1/a11  1/a11 -1/a11]
        <BLANKLINE>
        sage: Hw=HM(2, sz, 1, [W[i,j,0][0,0] for j in range(sz) for i in range(2)]);Hw.printHM()
        [:, :, 0]=
        [  1   0   1]
        [a10   1 a12]
        sage: Prod(Hu,Hv,Hw).printHM()
        [:, :, 0]=
        [ a00 - a01*a10/a11            a01/a11  a02 - a01*a12/a11]
        [           a10/a11             -1/a11            a12/a11]
        [ a20 - a10*a21/a11            a21/a11 -a12*a21/a11 + a22]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Checking that the input hypermatrix is of order 2
    if A.is_cubical() and A[k,k].is_cubical() and A.order()==2:
        # Initializing the hypermatrix U
        U=HM(A.n(0),2,1,[HM(A[i,j].n(0),A[i,j].n(1),'zero') for z in range(1) for j in range(2) for i in range(A.n(0))])
        for i in range(A.n(0)):
            if i!=k:
                U[i,0,0]=HM(2,A[i,k].n(0),'kronecker')
                U[i,1,0]=A[i,k]
            if i==k:
                U[i,0,0]=HM(A[k,k].n(1),A[k,k].n(0),'zero')
                U[i,1,0]=HM(2,A[k,k].n(0),'kronecker')
        # Initializing the hypermatrix W        
        W=HM(2,A.n(1),1,[HM(A[i,j].n(1),A[i,j].n(0),'zero') for z in range(1) for j in range(A.n(1)) for i in range(2)])
        for j in range(A.n(1)):
            if j!=k:
                W[0,j,0]=HM(2,A[k,j].n(1),'kronecker')
                W[1,j,0]=A[k,j]
            if j==k:
                W[0,j,0]=HM(A[k,k].n(1),A[k,k].n(0),'zero')
                W[1,j,0]=HM(2,A[k,k].n(0),'kronecker')
        # Computing the inverse of the entry A[k,k]
        if A[k,k].dimensions()==[1,1]:
            AkkI=A[k,k].inverse()
        else:
            # Part of the code responsible for computing the inverse by sweeping
            AkkI=A[k,k].copy()
            Tmp=HM(AkkI.n(0),AkkI.n(1),'zero')
            for t in range(AkkI.n(0)):
                Tmp[t,t]=-(AkkI[t,t])^(-1)
                for u in range(Tmp.n(0)):
                    for v in range(Tmp.n(1)):
                        if u!=t:
                            Tmp[u,t]=AkkI[u,t]*(AkkI[t,t]^(-1))
                        if v!=t:
                            Tmp[t,v]=(AkkI[t,t]^(-1))*AkkI[t,v]
                        if u!=t and t!=v:
                            Tmp[u,v]=AkkI[u,v]-AkkI[u,t]*(AkkI[t,t]^(-1))*AkkI[t,v]
                AkkI=Tmp.copy()
            AkkI=-AkkI.copy()
        # Initialization of the hypermatrix V
        V=HM(A.n(0),A.n(1),2,[HM(A[i,j].n(0),A[i,j].n(1),'zero') for k in range(2) for j in range(A.n(1)) for i in range(A.n(0))])
        for i in range(V.n(0)):
            for j in range(V.n(1)):
                V[i,j,0]=A[i,j]
                if i==k and j==k:
                    V[i,j,1]=-AkkI
                if i==k and j!=k:
                    V[i,j,1]=AkkI
                if i!=k and j==k:
                    V[i,j,1]=AkkI
                if i!=k and j!=k:
                    V[i,j,1]=-AkkI
        # Returning the BM product.
        return [U,V,W,HM(A.n(0),A.n(1),Prod(U,V,W).list())]
    else:
        raise ValueError("Expected square second order hypermatrix with square diagonal blocks")

def gaussian_elimination(Cf, rs):
    """
    Outputs the row echelon form of the input matrix and the right hand side.

    EXAMPLES:
 
    ::

        sage: [RefA, c] = gaussian_elimination(HM(2,2,'a').matrix(), HM(2,1,'b').matrix())
        sage: RefA
        [      1 a01/a00]
        [      0       1]
        sage: c
        [                                b00/a00]
        [(a10*b00/a00 - b10)/(a01*a10/a00 - a11)]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    A=copy(Cf); b=copy(rs)
    # Initialization of the row and column index
    i = 0; j = 0;
    while i < A.nrows() and j < A.ncols():
        while (A[i:,j]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if (A[i:,:].is_zero()) == False:
            while (A[i,j]).is_zero(): 
                Ta=A[i:,:]
                Tb=b[i:,:]
                # Initializing the cyclic shift permutation matrix
                Id=identity_matrix(Ta.nrows())
                P=sum([Id[:,k]*Id[Integer(mod(k+1,Ta.nrows())),:] for k in range(Ta.nrows())])
                Ta=P*Ta; Tb=P*Tb
                A[i:,:]=Ta
                b[i:,:]=Tb
            # Performing the row operations.
            b[i,:]=(1/A[i,j])*b[i,:]
            A[i,:]=(1/A[i,j])*A[i,:]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if A[r,:].is_zero():
                    r=r+1
                else:
                    b[r,:]=-A[r,j]*b[i,:]+b[r,:]
                    A[r,:]=-A[r,j]*A[i,:]+A[r,:]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def gaussian_eliminationHM(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    This implementation works perfectly well if the entries are matrices or hypermatrices
    associated with appropriate block partitions.

    EXAMPLES:
 
    ::

        sage: [A,b] = gaussian_eliminationHM(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [      1 a01/a00]
        [      0       1]
        sage: b.printHM()
        [:, :]=
        [                                b00/a00]
        [(a10*b00/a00 - b10)/(a01*a10/a00 - a11)]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b') # Initialization of the factors.
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gaussian_eliminationHM(Ha,Hb) # performing the gaussian elimination where entries are hypermatrices.
        sage: A
        [[[[1, 0], [0, 1]], [[a01/a00, 0], [0, a01/a00]]], [[[0, 0], [0, 0]], [[1, 0], [0, 1]]]]
        sage: b
        [[[[b00/a00, 0], [0, b00/a00]]], [[[(a10*b00/a00 - b10)/(a01*a10/a00 - a11), 0], [0, (a10*b00/a00 - b10)/(a01*a10/a00 - a11)]]]]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,HM(2,'b').list())
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,3,'kronecker'), Ta[1,0]*HM(2,3,'c'), Ta[0,1]*HM(3,2,'d'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,3,'kronecker'), Tb[1,0]*HM(2,3,'zero')])
        sage: [A,b]=gaussian_eliminationHM(Ha,Hb)
        sage: A[0,0].printHM()
        [:, :]=
        [1 0 0]
        [0 1 0]
        [0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while A.slice(rg(i,A.n(0)),'row').slice([j],'col').is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        if A.slice(rg(i,A.n(0)),'row').is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=A.slice(rg(i,A.n(0)),'row')
                Tb=b.slice(rg(i,b.n(0)),'row')
                # Initializing the cyclic shift permutation matrix
                P=HM(2,rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for j0 in range(b.n(1)):
                b[i,j0]=(cf1^(-1))*b[i,j0]
            for j0 in range(A.n(1)):
                A[i,j0]=(cf1^(-1))*A[i,j0]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    for j0 in range(b.n(1)):
                        b[r,j0]=-cf2*b[i,j0]+b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=-cf2*A[i,j0]+A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def gaussian_eliminationHMII(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    This implementation tacitly assumes that the entries commute.
 

    EXAMPLES:
 
    ::

        sage: [A,b]=gaussian_eliminationHMII(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [              a00               a01]
        [                0 a01*a10 - a00*a11]
        sage: b.printHM()
        [:, :]=
        [              b00]
        [a10*b00 - a00*b10]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b')
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gaussian_eliminationHMII(Ha,Hb)
        sage: A
        [[[[a00, 0], [0, a00]], [[a01, 0], [0, a01]]], [[[0, 0], [0, 0]], [[a01*a10 - a00*a11, 0], [0, a01*a10 - a00*a11]]]]
        sage: b
        [[[[b00, 0], [0, b00]]], [[[a10*b00 - a00*b10, 0], [0, a10*b00 - a00*b10]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Tb=HM(b.n(0)-i, b.n(1), [b[i0,j0] for j0 in range(b.n(1)) for i0 in range(i,b.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    for j0 in range(b.n(1)):
                        b[r,j0]=cf2*b[i,j0]-cf1*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=cf2*A[i,j0]-cf1*A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def gaussian_eliminationHMIII(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1.
    The difference with the previous implementation is the fact that the row linear combination
    operations are performed in such a way as to not change the absolute value of the determinant.
    This implementation is skew fields or division ring friendly by inputing hypermatrices
    whose entries are themselve hypermatrices of the approprioate size. 


    EXAMPLES:
 
    ::

        sage: [A,b]=gaussian_eliminationHMIII(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [               a00                a01]
        [                 0 -a01*a10/a00 + a11]
        sage: b.printHM()
        [:, :]=
        [               b00]
        [-a10*b00/a00 + b10]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b')
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gaussian_eliminationHMIII(Ha,Hb)
        sage: A
        [[[[a00, 0], [0, a00]], [[a01, 0], [0, a01]]], [[[0, 0], [0, 0]], [[-a01*a10/a00 + a11, 0], [0, -a01*a10/a00 + a11]]]]
        sage: b
        [[[[b00, 0], [0, b00]]], [[[-a10*b00/a00 + b10, 0], [0, -a10*b00/a00 + b10]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Tb=HM(b.n(0)-i, b.n(1), [b[i0,j0] for j0 in range(b.n(1)) for i0 in range(i,b.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            if A.n(0)-i-1 > 0 and not (HM(A.n(0)-i-1, 1, [A[i0,j] for i0 in range(i+1,A.n(0))]).is_zero() and j <= A.ncols()-1):
                # Performing the row operations.
                cf1=A[i,j]
                for r in range(i+1,A.nrows()):
                    # Taking care of the zero row
                    if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                        r=r+1
                    else:
                        # Initialization of the coefficient
                        cf2=A[r,j]
                        for j0 in range(b.n(1)):
                            b[r,j0]=-(cf2*cf1^(-1))*b[i,j0]+b[r,j0]
                        for j0 in range(A.n(1)):
                            A[r,j0]=-(cf2*cf1^(-1))*A[i,j0]+A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def gaussian_eliminationHMIV(Cf):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    This implementation tacitly assumes that the entries commute.
    The computation is performed in such a way that the last entry on the main diagonal is 
    the determinant.
     

    EXAMPLES:
 
    ::

        sage: A=gaussian_eliminationHMIV(HM(2,2,'a'))
        sage: A.printHM()
        [:, :]=
        [               a00                a01]
        [                 0 -a01*a10 + a00*a11]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b')
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: A=gaussian_eliminationHMIV(Ha)
        sage: A
        [[[[a00, 0], [0, a00]], [[a01, 0], [0, a01]]], [[[0, 0], [0, 0]], [[-a01*a10 + a00*a11, 0], [0, -a01*a10 + a00*a11]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1, Ta.n(0))+[0],'perm')
                Ta=P*Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    if r==j+1:
                        for j0 in range(j,A.n(1)):
                            A[r,j0]=-cf2*A[i,j0]+cf1*A[r,j0]
                    else:
                        for j0 in range(j,A.n(1)):
                            A[r,j0]=(-cf2*A[i,j0]+cf1*A[r,j0])/cf1
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return A

def gaussian_eliminationHMV(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    This implementation works perfectly well if the entries are matrices or hypermatrices
    associated with appropriate block partitions. The implmentation follows the spirit
    of the Cauchy trick inspired by the Vandermonde determinant construction.

    EXAMPLES:
 
    ::

        sage: sz=2; [A, b, prd] = gaussian_eliminationHMV(HM(sz,sz,'a'), HM(sz,1,'b'))
        sage: A.printHM()
        [:, :]=
        [      1 a01/a00]
        [      0       1]
        sage: b.printHM()
        [:, :]=
        [                                b00/a00]
        [(b00/a00 - b10/a10)/(a01/a00 - a11/a10)]
        sage: prd
        -a00*a10*(a01/a00 - a11/a10)
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b') # Initialization of the factors.
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A, b, prd]=gaussian_eliminationHMV(Ha,Hb) # performing the gaussian elimination where entries are hypermatrices.
        sage: A
        [[[[1, 0], [0, 1]], [[a01/a00, 0], [0, a01/a00]]], [[[0, 0], [0, 0]], [[1, 0], [0, 1]]]]
        sage: b
        [[[[b00/a00, 0], [0, b00/a00]]], [[[(b00/a00 - b10/a10)/(a01/a00 - a11/a10), 0], [0, (b00/a00 - b10/a10)/(a01/a00 - a11/a10)]]]]
        sage: prd.printHM()
        [:, :]=
        [-a00*a10*(a01/a00 - a11/a10)                            0]
        [                           0 -a00*a10*(a01/a00 - a11/a10)]
        sage: sz=3; [A, b, prd] = gaussian_eliminationHMV(HM(sz,sz,'a'), HM(sz,1,'b'))
        sage: prd
        -a00*a10*a20*(a01/a00 - a11/a10)*(a01/a00 - a21/a20)*((a02/a00 - a12/a10)/(a01/a00 - a11/a10) - (a02/a00 - a22/a20)/(a01/a00 - a21/a20))


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the product
    prd=1
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while A.slice(rg(i,A.n(0)),'row').slice([j],'col').is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        if A.slice(rg(i,A.n(0)),'row').is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=A.slice(rg(i,A.n(0)),'row'); Tb=b.slice(rg(i,b.n(0)),'row')
                # Initializing the cyclic shift permutation matrix
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]; prd = prd*cf1
            for j0 in range(b.n(1)):
                b[i,j0]=(cf1^(-1))*b[i,j0]
            for j0 in range(A.n(1)):
                A[i,j0]=(cf1^(-1))*A[i,j0]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]; prd = prd*cf2
                    for j0 in range(b.n(1)):
                        b[r,j0]=-b[i,j0]+(cf2^(-1))*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=-A[i,j0]+(cf2^(-1))*A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, prd]

def permanent_eliminationHM(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    This implementation works perfectly well if the entries are matrices or hypermatrices
    associated with appropriate block partitions. The implmentation follows the spirit
    of the Cauchy trick inspired by the Vandermonde determinant construction.

    EXAMPLES:
 
    ::

        sage: sz=2; [A, b, prd] = permanent_eliminationHM(HM(sz,sz,'a'), HM(sz,1,'b'))
        sage: A.printHM()
        [:, :]=
        [                    1               a01/a00]
        [2/(a01/a00 + a11/a10)                     1]
        sage: b.printHM()
        [:, :]=
        [                                b00/a00]
        [(b00/a00 + b10/a10)/(a01/a00 + a11/a10)]
        sage: prd
        a00*a10*(a01/a00 + a11/a10)
        sage: sz=3; [A, b, prd] = permanent_eliminationHM(HM(sz,sz,'a'), HM(sz,1,'b'))
        sage: prd
        a00*a10*a20*(a01/a00 + a11/a10)*(a01/a00 + a21/a20)*((a02/a00 + a12/a10)/(a01/a00 + a11/a10) + (a02/a00 + a22/a20)/(a01/a00 + a21/a20))


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the product
    prd=1
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while A.slice(rg(i,A.n(0)),'row').slice([j],'col').is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        if A.slice(rg(i,A.n(0)),'row').is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=A.slice(rg(i,A.n(0)),'row'); Tb=b.slice(rg(i,b.n(0)),'row')
                # Initializing the cyclic shift permutation matrix
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]; prd = prd*cf1
            for j0 in range(b.n(1)):
                b[i,j0]=(cf1^(-1))*b[i,j0]
            for j0 in range(A.n(1)):
                A[i,j0]=(cf1^(-1))*A[i,j0]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]; prd = prd*cf2
                    for j0 in range(b.n(1)):
                        b[r,j0]=b[i,j0]+(cf2^(-1))*b[r,j0]
                    for j0 in range(j):
                        A[r,j0]=0
                    for j0 in range(j,A.n(1)):
                        A[r,j0]=A[i,j0]+(cf2^(-1))*A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, prd]

def gaussian_elimination_ReductionHM(Cf, rs, VrbL, Rlts):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    The algorithm perform the reduction assuming that the the leading term in each relations
    is a monic powers in a distinct variable as illustrated in the example bellow.

    EXAMPLES:
 
    ::

        sage: x1, x2=var('x1, x2')
        sage: Cf=HM([[-2, -2*x1 + 3], [-12*x1 + 10, -2*x1 + 3]])
        sage: rs=HM(2,1,'zero')
        sage: VrbL=[x1, x2]
        sage: Rlts=[x1^2 - 3*x1 + 2, x2^2 - 3*x2 + 2]
        sage: [A,b]=gaussian_elimination_ReductionHM(Cf, rs, VrbL, Rlts)
        sage: A.printHM()
        [:, :]=
        [        -2  -2*x1 + 3]
        [         0 12*x1 - 12]
        sage: b.printHM()
        [:, :]=
        [0]
        [0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Tb=HM(b.n(0)-i, b.n(1), [b[i0,j0] for j0 in range(b.n(1)) for i0 in range(i,b.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    for j0 in range(b.n(1)):
                        # Performing the reduction
                        #b[r,j0]=cf2*b[i,j0]-cf1*b[r,j0]
                        f=expand(cf2*b[i,j0]-cf1*b[r,j0])
                        for v in range(len(VrbL)):
                            for d in range(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                                f=expand(fast_reduce(f,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
                        b[r,j0]=f
                    for j0 in range(A.n(1)):
                        # Performing the reduction
                        #A[r,j0]=cf2*A[i,j0]-cf1*A[r,j0]
                        g=expand(cf2*A[i,j0]-cf1*A[r,j0])
                        for v in range(len(VrbL)):
                            for d in range(g.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                                g=expand(fast_reduce(g,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)]))
                        A[r,j0]=g
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def gaussian_elimination_ReductionHMII(Cf, VrbL, Rlts):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    The algorithm perform the reduction assuming that the the leading term in each relations
    is a monic powers in a distinct variable as illustrated in the example bellow.
    The computation is perform in such a way that the last diagonal entry holds the determinant
    of the whole matrix it is also true that each diagonal entry corresponds to the determinant
    of the corresponding top diagonal block of the matrix. Note that the relation in Rlts are
    assumed to be univariate leading term. This implementaion also gets the sign right for the
    determinant. This implementation is considerably more efficient then the previous one above
    because the extra multiplicative factor is kept minimal.


    EXAMPLES:
 
    ::

        sage: x1, x2=var('x1, x2')
        sage: Cf=HM([[-2, -2*x1 + 3], [-12*x1 + 10, -2*x1 + 3]])
        sage: VrbL=[x1, x2]
        sage: Rlts=[x1^2 - 3*x1 + 2, x2^2 - 3*x2 + 2]
        sage: A=gaussian_elimination_ReductionHMII(Cf, VrbL, Rlts)
        sage: A.printHM()
        [:, :]=
        [         -2   -2*x1 + 3]
        [          0 -12*x1 + 12]
        sage: od=2; sz=3 # Initialization of the order and size parameter
        sage: A=HM(od,sz,'a','sym'); X=HM(sz,sz,[x^(sz^abs(j-i)) for j in rg(sz) for i in rg(sz)])
        sage: Hb=HM(sz,binomial(sz,2),'zero'); clidx=0 # Initialization of the incidence matrix
        sage: for i in rg(sz):
        ....:     for j in rg(sz):
        ....:         if i < j:
        ....:             Hb[i,clidx]=-sqrt(A[i,j]*X[i,j])
        ....:             Hb[j,clidx]=+sqrt(A[i,j]*X[i,j])
        ....:             clidx=clidx+1
        ....:
        sage: t=0; B=HM(sz-1,Hb.n(1),[Hb[i,j] for j in rg(Hb.n(1)) for i in rg(Hb.n(0)) if i!=t]) # Grounding at the vertex t
        sage: M=(HM(od,[x*A[t,t]]+[1 for i in rg(sz-2)],'diag')*(B*B.transpose())).expand() # Initialization of the fundamental matrix
        sage: d=1+sum(sz^k for k in rg(1+floor((sz-1)/2),sz))+sum(sz^(sz-1-k) for k in rg(1,1+floor((sz-1)/2))) # Initializing the max degree
        sage: Rh=gaussian_elimination_ReductionHMII(M,[x],[x^(1+d)])
        sage: Rh[1,1]
        a00*a10*a20*x^13 + a00*a20*a21*x^13 + a00*a10*a21*x^7


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    if r==j+1:
                        for j0 in range(j,A.n(1)):
                            # Performing the reduction
                            f=(-cf2*A[i,j0]+cf1*A[r,j0]).numerator()
                            for v in range(len(VrbL)):
                                #f=f.maxima_methods().divide(Rlts[v])[1]
                                for d in range(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                                    f=expand(fast_reduce(f,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
                            A[r,j0]=f
                    else:
                        for j0 in range(j,A.n(1)):
                            # Performing the reduction
                            g=expand((-cf2*A[i,j0]+cf1*A[r,j0])/cf1)
                            A[r,j0]=g
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return A

def gaussian_elimination_ReductionHMIII(Cf, VrbL, Rlts, RltsII):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    The algorithm perform the reduction assuming that the the leading term in each relations
    is a monic powers in a distinct variable as illustrated in the example bellow.
    The computation is perform in such a way that the last diagonal entry holds the determinant
    of the whole matrix it is also true that each diagonal entry corresponds to the determinant
    of the corresponding top diagonal block of the matrix. Note that the relation in Rlts are
    assumed to be univariate leading term. This implementaion also gets the sign right for the
    determinant. This implementation is considerably more efficient then the previous one above
    because the extra multiplicative factor is kept minimal.


    EXAMPLES:
 
    ::

        sage: x1, x2=var('x1, x2')
        sage: Cf=HM([[-2, -2*x1 + 3], [-12*x1 + 10, -2*x1 + 3]])
        sage: VrbL=[x1, x2]
        sage: Rlts=[x1^2 - 3*x1 + 2, x2^2 - 3*x2 + 2]
        sage: A=gaussian_elimination_ReductionHMIII(Cf, VrbL, Rlts, Rlts)
        sage: A.printHM()
        [:, :]=
        [         -2   -2*x1 + 3]
        [          0 -12*x1 + 12]
        sage: od=2; sz=3 # Initialization of the order and size parameter
        sage: A=HM(od,sz,'a','sym'); X=HM(sz,sz,[x^(sz^abs(j-i)) for j in rg(sz) for i in rg(sz)])
        sage: Hb=HM(sz,binomial(sz,2),'zero'); clidx=0 # Initialization of the incidence matrix
        sage: for i in rg(sz):
        ....:     for j in rg(sz):
        ....:         if i < j:
        ....:             Hb[i,clidx]=-sqrt(A[i,j]*X[i,j])
        ....:             Hb[j,clidx]=+sqrt(A[i,j]*X[i,j])
        ....:             clidx=clidx+1
        ....:
        sage: t=0; B=HM(sz-1,Hb.n(1),[Hb[i,j] for j in rg(Hb.n(1)) for i in rg(Hb.n(0)) if i!=t]) # Grounding at the vertex t
        sage: M=(HM(od,[x*A[t,t]]+[1 for i in rg(sz-2)],'diag')*(B*B.transpose())).expand() # Initialization of the fundamental matrix
        sage: d=1+sum(sz^k for k in rg(1+floor((sz-1)/2),sz))+sum(sz^(sz-1-k) for k in rg(1,1+floor((sz-1)/2))) # Initializing the max degree
        sage: Rh=gaussian_elimination_ReductionHMIII(M,[x],[x^(1+d)],[x^(1+d)])
        sage: Rh[1,1]
        a00*a10*a20*x^13 + a00*a20*a21*x^13 + a00*a10*a21*x^7
        sage: od=2; sz=4 # Initialization of the order and size parameter
        sage: Lx=var_list('x',sz) # Initialization of the list of vraiables
        sage: A=HM(od,sz,'a','sym') # Initialization of the adjacency matrix
        sage: X=HM(sz,sz,[Lx[abs(i-j)] for j in rg(sz) for i in rg(sz)]) # initialization of the edge weight matrix
        sage: Hb=HM(sz,binomial(sz,2),'zero'); clidx=0 # Initialization of the incidence matrix
        sage: for i in rg(sz):
        ....:     for j in rg(sz):
        ....:         if i < j:
        ....:             Hb[i,clidx]=-sqrt(A[i,j]*X[i,j])
        ....:             Hb[j,clidx]=+sqrt(A[i,j]*X[i,j])
        ....:             clidx=clidx+1
        ....:
        sage: t=0; B=HM(sz-1,Hb.n(1),[Hb[i,j] for j in rg(Hb.n(1)) for i in rg(Hb.n(0)) if i!=t]) # Grounding at the vertex t
        sage: M=(HM(od,[Lx[0]*A[t,t]]+[1 for i in rg(sz-2)],'diag')*(B*B.transpose())).expand() # Initialization of the fundamental matrix
        sage: d0=3; d1=2; Rh=gaussian_elimination_ReductionHMIII(M,Lx,[v^d0 for v in Lx],[v^d1 for v in Lx])
        sage: Rh[sz-2,sz-2]
        a00*a10*a20*a30*x0*x1*x2*x3 + a00*a20*a21*a30*x0*x1*x2*x3 + a00*a21*a30*a31*x0*x1*x2*x3 + a00*a30*a31*a32*x0*x1*x2*x3
        sage: od=2; sz=4 # Initialization of the order and size parameter
        sage: Lx=var_list('x',sz) # Initialization of the list of variables
        sage: A=HM(sz,sz,'a') # Initialization of part of the adjacency matrix
        sage: X=HM(sz,sz,[Lx[abs(j-i)] for j in rg(sz) for i in rg(sz)]) # Initialization of the symbolic edge weights
        sage: Hb=Matrix2HM((HM(od,(A.elementwise_product(X)*HM(sz,1,'one')).list(),'diag')-A.elementwise_product(X)).matrix()[1:,1:]) # Directed Laplacian
        sage: d0=3; d1=2; Rh2=A[0,0]*Lx[0]*gaussian_elimination_ReductionHMIII(Hb,Lx,[v^3 for v in Lx],[v^2 for v in Lx])
        sage: Rh2[sz-2,sz-2]
        (a10*a20*a30*x1*x2*x3 + a12*a20*a30*x1*x2*x3 + a13*a21*a30*x1*x2*x3 + a13*a23*a30*x1*x2*x3)*a00*x0


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    if r==j+1 and r!=A.n(0)-1:
                        for j0 in range(j,A.n(1)):
                            # Performing the reduction
                            f=(-cf2*A[i,j0]+cf1*A[r,j0]).numerator()
                            for v in range(len(VrbL)):
                                #f=f.maxima_methods().divide(Rlts[v])[1]
                                for d in range(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                                    f=expand(fast_reduce(f,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
                            A[r,j0]=f
                    elif r==j+1 and r==A.n(0)-1:
                        for j0 in range(j,A.n(1)):
                            # Performing the reduction
                            f=(-cf2*A[i,j0]+cf1*A[r,j0]).numerator()
                            for v in range(len(VrbL)):
                                #f=f.maxima_methods().divide(Rlts[v])[1]
                                for d in range(f.degree(VrbL[v])-RltsII[v].degree(VrbL[v]),-1,-1):
                                    f=expand(fast_reduce(f,[VrbL[v]^(d+RltsII[v].degree(VrbL[v]))],[VrbL[v]^(d+RltsII[v].degree(VrbL[v]))-expand(RltsII[v]*VrbL[v]^d)])) 
                            A[r,j0]=f
                    else:
                        for j0 in range(j,A.n(1)):
                            # Performing the reduction
                            g=expand((-cf2*A[i,j0]+cf1*A[r,j0])/cf1)
                            A[r,j0]=g
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return A

def gauss_jordan_elimination(Cf,rs):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.

    EXAMPLES:
 
    ::

        sage: [RefA, c] = gauss_jordan_elimination(Matrix(SR,HM(2,2,'a').listHM()), Matrix(SR,HM(2,1,'b').listHM()))
        sage: RefA
        [1 0]
        [0 1]
        sage: c
        [-a01*(a10*b00/a00 - b10)/(a00*(a01*a10/a00 - a11)) + b00/a00]
        [                     (a10*b00/a00 - b10)/(a01*a10/a00 - a11)]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = gaussian_elimination(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        if (A[i,:]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                A[r,:] = -A[r,j]*A[i,:]+A[r,:]
            i=i-1; j=0
    return [A,b]

def gauss_jordan_eliminationHM(Cf,rs):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.
    This implementation is skew field friendly as illustrated in some of the examples
    below. We do not assume that the input entries commute. 


    EXAMPLES:
 
    ::

        sage: [RefA, c] = gauss_jordan_eliminationHM(HM(2,2,'a'), HM(2,1,'b'))
        sage: RefA.printHM()
        [:, :]=
        [1 0]
        [0 1]
        sage: c.printHM()
        [:, :]=
        [-a01*(a10*b00/a00 - b10)/(a00*(a01*a10/a00 - a11)) + b00/a00]
        [                     (a10*b00/a00 - b10)/(a01*a10/a00 - a11)]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,HM(2,'b').list()) # Initialization of the factors.
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gauss_jordan_eliminationHM(Ha,Hb) # performing the gaussian elimination where entries are hypermatrices.
        sage: A
        [[[[1, 0], [0, 1]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[1, 0], [0, 1]]]]
        sage: b
        [[[[-a01*(a10*b0/a00 - b1)/(a00*(a01*a10/a00 - a11)) + b0/a00, 0], [0, -a01*(a10*b0/a00 - b1)/(a00*(a01*a10/a00 - a11)) + b0/a00]]], [[[(a10*b0/a00 - b1)/(a01*a10/a00 - a11), 0], [0, (a10*b0/a00 - b1)/(a01*a10/a00 - a11)]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = gaussian_eliminationHM(Cf, rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                #Tb0=HM(1, b.n(1), [b[i,j0] for j0 in range(b.n(1))])
                #Tb1=HM(1, b.n(1), [b[r,j0] for j0 in range(b.n(1))])
                Trb=-HM(1, b.n(1), [A[r,j]*b[i,j0] for j0 in range(b.n(1))]) + HM(1, b.n(1), [b[r,j0] for j0 in range(b.n(1))])
                for j0 in range(b.n(1)):
                    b[r,j0]=Trb[0,j0]
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                #Ta0=HM(1, A.n(1), [A[i,j0] for j0 in range(A.n(1))])
                #Ta1=HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))])
                Tra=-HM(1, A.n(1), [A[r,j]*A[i,j0] for j0 in range(A.n(1))]) + HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))])
                for j0 in range(A.n(1)):
                    A[r,j0]=Tra[0,j0]
            i=i-1; j=0
    return [A,b]

def gauss_jordan_eliminationHMII(Cf,rs):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.
    This implementation assumes that the input entries commute and is therefore NOT
    skew field friendly


    EXAMPLES:
 
    ::

        sage: [RefA, c] = gauss_jordan_eliminationHMII(HM(2,2,'a'), HM(2,1,'b'))
        sage: RefA.printHM()
        [:, :]=
        [-(a01*a10 - a00*a11)*a00                        0]
        [                       0        a01*a10 - a00*a11]
        sage: c.printHM()
        [:, :]=
        [(a10*b00 - a00*b10)*a01 - (a01*a10 - a00*a11)*b00]
        [                                a10*b00 - a00*b10] 
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,'b')
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gauss_jordan_eliminationHMII(Ha,Hb)
        sage: A
        [[[[-(a01*a10 - a00*a11)*a00, 0], [0, -(a01*a10 - a00*a11)*a00]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[a01*a10 - a00*a11, 0], [0, a01*a10 - a00*a11]]]]
        sage: b
        [[[[(a10*b00 - a00*b10)*a01 - (a01*a10 - a00*a11)*b00, 0], [0, (a10*b00 - a00*b10)*a01 - (a01*a10 - a00*a11)*b00]]], [[[a10*b00 - a00*b10, 0], [0, a10*b00 - a00*b10]]]]



    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = gaussian_eliminationHMII(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                for j0 in range(b.n(1)):
                    b[r,j0]=cf2*b[i,j0]-cf1*b[r,j0]
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                for j0 in range(A.n(1)):
                    A[r,j0]=cf2*A[i,j0]-cf1*A[r,j0]
            i=i-1; j=0
    return [A,b]

def gauss_jordan_elimination_ReductionHM(Cf, rs, VrbL, Rlts):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.

    EXAMPLES:
 
    ::

        sage: x1, x2=var('x1, x2')
        sage: Cf=HM([[-2, -2*x1 + 3], [-12*x1 + 10, -2*x1 + 3]])
        sage: rs=HM(2,1,'zero')
        sage: VrbL=[x1, x2]
        sage: Rlts=[x1^2 - 3*x1 + 2, x2^2 - 3*x2 + 2]
        sage: [A,b]=gauss_jordan_elimination_ReductionHM(Cf, rs, VrbL, Rlts)
        sage: A.printHM()
        [:, :]=
        [24*x1 - 24          0]
        [         0 12*x1 - 12]        
        sage: b.printHM()
        [:, :]=
        [0]
        [0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = gaussian_elimination_ReductionHM(Cf, rs, VrbL, Rlts)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                for j0 in range(b.n(1)):
                    #b[r,j0]=cf2*b[i,j0]-cf1*b[r,j0]
                    f=expand(cf2*b[i,j0]-cf1*b[r,j0])
                    for v in range(len(VrbL)):
                        for d in range(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                            f=expand(fast_reduce(f,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
                    b[r,j0]=f
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                for j0 in range(A.n(1)):
                    #A[r,j0]=cf2*A[i,j0]-cf1*A[r,j0]
                    g=expand(cf2*A[i,j0]-cf1*A[r,j0])
                    for v in range(len(VrbL)):
                        for d in range(g.degree(VrbL[v])-Rlts[v].degree(VrbL[v]),-1,-1):
                            g=expand(fast_reduce(g,[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))],[VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)]))
                    A[r,j0]=g
            i=i-1; j=0
    return [A,b]

def gauss_jordan_eliminationHMIII(Cf,rs):
    """
    Outputs the reduced row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1.
    The difference with gauss_jordan_eliminationHMII is the fact that the row linear combination
    operations are performed in such a way as to not change the absolute value of the determinant.
    

    EXAMPLES:
 
    ::

        sage: [RefA, c] = gauss_jordan_eliminationHMIII(HM(2,2,'a'), HM(2,1,'b'))
        sage: RefA.printHM()
        [:, :]=
        [               a00                  0]
        [                 0 -a01*a10/a00 + a11]
        sage: c.printHM()
        [:, :]=
        [-a01*(a10*b00/a00 - b10)/(a01*a10/a00 - a11) + b00]
        [                                -a10*b00/a00 + b10]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = gaussian_eliminationHMIII(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                for j0 in range(b.n(1)):
                    b[r,j0]=-(cf2*cf1^(-1))*b[i,j0]+b[r,j0]
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                for j0 in range(A.n(1)):
                    A[r,j0]=-(cf2*cf1^(-1))*A[i,j0]+A[r,j0]
            i=i-1; j=0
    return [A,b]

def gauss_jordan_eliminationHMIV(Cf,rs):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.
    This implementation is skew field friendly as illustrated in some of the examples
    below. We do not assume that the input entries commute. Improves the design of the
    previous verision by reducing the problem to two calls of the gaussian elimination
    procedure which puts the system in Row Echelon Form. 


    EXAMPLES:
 
    ::

        sage: [RRefA, c] = gauss_jordan_eliminationHMIV(HM(2,2,'a'), HM(2,1,var_list('b',2)))
        sage: RRefA.p()
        [:, :]=
        [1 0]
        [0 1]
        sage: c.printHM()
        [:, :]=
        [-a01*(a10*b0/a00 - b1)/(a00*(a01*a10/a00 - a11)) + b0/a00]
        [                     (a10*b0/a00 - b1)/(a01*a10/a00 - a11)]
        sage: Ta=HM(2,2,'a'); Tb=HM(2,1,HM(2,'b').list()) # Initialization of the factors.
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: Hb=HM(2,1,[Tb[0,0]*HM(2,2,'kronecker'), Tb[1,0]*HM(2,2,'kronecker')])
        sage: [A,b]=gauss_jordan_eliminationHMIV(Ha,Hb) # performing the gaussian elimination where entries are hypermatrices.
        sage: A
        [[[[1, 0], [0, 1]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[1, 0], [0, 1]]]]
        sage: b
        [[[[-a01*(a10*b0/a00 - b1)/(a00*(a01*a10/a00 - a11)) + b0/a00, 0], [0, -a01*(a10*b0/a00 - b1)/(a00*(a01*a10/a00 - a11)) + b0/a00]]], [[[(a10*b0/a00 - b1)/(a01*a10/a00 - a11), 0], [0, (a10*b0/a00 - b1)/(a01*a10/a00 - a11)]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # First call of the gaussian elimination procedure to put the system in REF
    [A, b]=gaussian_eliminationHM(Cf, rs)
    # Flipping things around to put the system in the RREF via a second call of the gaussian elimination procedure
    Cf=A.index_rotation(4*pi/4).copy(); rs=HM([[b[i, j] for j in rg(b.n(1))] for i in rg(b.n(0)-1,-1,-1)])
    # Second call of the gaussian elimination procedure to put the system in REF
    [A, b]=gaussian_eliminationHM(Cf, rs)
    A=A.index_rotation(4*pi/4).copy(); b=HM([[b[i, j] for j in rg(b.n(1))] for i in rg(b.n(0)-1,-1,-1)])
    return [A, b]

def multiplicative_gaussian_elimination(Cf,rs,jndx=0):
    """
    Outputs the row echelon form of the input matrix and the right hand side.

    EXAMPLES:
 
    ::

        sage: [EfA,c,indx,Lst]=multiplicative_gaussian_elimination(Matrix(SR,HM(2,2,'a').listHM()), Matrix(SR,HM(2,1,'b').listHM()))
        sage: EfA
        [      1 a01/a00]
        [      0       1]
        sage: c
        [                                                                    (b00*e^(2*I*pi*k0))^(1/a00)]
        [1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    A = copy(Cf); b = copy(rs)
    # Initialization of the row and column index
    i=0; j=0; indx=jndx; Lst = []
    while i<A.nrows() and j<A.ncols():
        while (A[i:,j]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if A[i:,:].is_zero()==False:
            while A[i,j].is_zero():
                Ta=A[i:,:]
                Tb=b[i:,:]
                # Initializing the cyclic shift permutation matrix
                Id=identity_matrix(Ta.nrows())
                P =sum([Id[:,k]*Id[Integer(mod(k+1,Ta.nrows())),:] for k in range(Ta.nrows())])
                Ta=P*Ta; Tb=P*Tb
                A[i:,:]=Ta
                b[i:,:]=Tb 
            # Performing the row operations.
            b[i,0]=(b[i,0]*exp(I*2*pi*var('k'+str(indx))))^(1/A[i,j])
            indx = indx+1
            Lst.append(A[i,j])
            A[i,:]=(1/A[i,j])*A[i,:]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if A[r,:].is_zero():
                    r=r+1
                else:
                    b[r,0]=(b[i,0]*exp(I*2*pi*var('k'+str(indx))))^(-A[r,j])*b[r,0]
                    if (A[r,j]).is_zero()==False:
                        indx = indx+1
                        Lst.append(A[r,j])
                    A[r,:]=-A[r,j]*A[i,:]+A[r,:]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, indx, Lst]

def multiplicative_gauss_jordan_elimination(Cf,rs,jndx=0):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.

    EXAMPLES:
 
    ::

        sage: [RefA, c, indx, Lst] = multiplicative_gauss_jordan_elimination(Matrix(SR,HM(2,2,'a').listHM()), Matrix(SR,HM(2,1,'b').listHM()))
        sage: RefA
        [1 0]
        [0 1]
        sage: c
        [(b00*e^(2*I*pi*k0))^(1/a00)/(e^(2*I*pi*k3)/(b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))^(a01/a00)]
        [                                                  1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b, indx, Lst] = multiplicative_gaussian_elimination(Cf,rs,jndx)
    # Initialization of the row and column index
    i = A.nrows()-1; j = 0
    while i > 0 or j > 0:
        if (A[i,:]).is_zero():
            # decrementing the row index and initializing the column index
            i =i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j=j+1
            # performing row operations
            for r in range(i-1, -1, -1):
                b[r,0]=(b[i,0]*exp(I*2*pi*var('k'+str(indx))))^(-A[r,j])*b[r,0]
                if (A[r,j]).is_zero()==False:
                    indx = indx+1
                    Lst.append(A[r,j])
                A[r,:] = -A[r,j]*A[i,:]+A[r,:]
            i = i - 1; j = 0
    return [A, b, indx, Lst]

def multiplicative_gaussian_eliminationII(Cf,rs,jndx=0):
    """
    Outputs the row echelon form of the input matrix and the right hand side.
    The solver here differs from the one above in the fact that it assumes
    that the entries of the Cf matrix are not symbolic and checks during
    the elimination steps whether or we are indeed adding new branches.

    EXAMPLES:
 
    ::

        sage: [EfA,c,indx,Lst]=multiplicative_gaussian_eliminationII(HM(2,2,'a').matrix(), HM(2,1,'b').matrix())
        sage: EfA
        [      1 a01/a00]
        [      0       1]
        sage: c
        [                                                                    (b00*e^(2*I*pi*k0))^(1/a00)]
        [1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]


    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    A = copy(Cf); b = copy(rs)
    # Initialization of the row and column index
    i=0; j=0; indx=jndx; Lst = []
    while i<A.nrows() and j<A.ncols():
        while (A[i:,j]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if A[i:,:].is_zero()==False:
            while A[i,j].is_zero():
                Ta=A[i:,:]
                Tb=b[i:,:]
                # Initializing the cyclic shift permutation matrix
                Id=identity_matrix(Ta.nrows())
                P =sum([Id[:,k]*Id[Integer(mod(k+1,Ta.nrows())),:] for k in range(Ta.nrows())])
                Ta=P*Ta; Tb=P*Tb
                A[i:,:]=Ta
                b[i:,:]=Tb 
            # Performing the row operations.
            #if A[i,j]==-1 or A[i,j]==1:
            if (A[i,j].numerator()==1 or A[i,j].numerator()==-1) and A[i,j].denominator().is_integer():
                # In the case where no branching is introduced by log scaling the pivot
                for j0 in rg(b.ncols()):
                    b[i,j0]=b[i,j0]^(1/A[i,j])
            else:
                # In the case where some branching is introduced by log scaling the pivot
                for j0 in rg(b.ncols()):
                    b[i,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(1/A[i,j])
                indx = indx+1
                Lst.append(A[i,j])
            A[i,:]=(1/A[i,j])*A[i,:]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if A[r,:].is_zero():
                    r=r+1
                else:
                    #if A[r,j]==-1 or A[r,j]==1:
                    if A[r,j].is_integer():
                        # In the case where no branching is introduced by log scaling the pivot
                        for j0 in rg(b.ncols()):
                            b[r,j0]=b[i,j0]^(-A[r,j])*b[r,j0]
                    else:
                        # In the case where some branching is introduced by log scaling the pivot
                        for j0 in rg(b.ncols()):
                            b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-A[r,j])*b[r,j0]
                        if (A[r,j]).is_zero()==False:
                            indx = indx+1
                            Lst.append(1/A[r,j])
                    A[r,:]=-A[r,j]*A[i,:]+A[r,:]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, indx, Lst]

def multiplicative_gauss_jordan_eliminationII(Cf,rs,jndx=0):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.
    The solver here differs from the one above in the fact that it assumes
    that the entries of the Cf matrix are not symbolic and checks during
    the elimination steps whether or we are indeed adding new branches.

    EXAMPLES:
 
    ::

        sage: [RefA, c, indx, L] = multiplicative_gauss_jordan_eliminationII(HM(2,2,'a').matrix(), HM(2,1,'b').matrix())
        sage: RefA
        [1 0]
        [0 1]
        sage: c
        [(b00*e^(2*I*pi*k0))^(1/a00)/(e^(2*I*pi*k3)/(b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))^(a01/a00)]
        [                                                  1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b, indx, Lst] = multiplicative_gaussian_eliminationII(Cf,rs,jndx)
    # Initialization of the row and column index
    i = A.nrows()-1; j = 0
    while i > 0 or j > 0:
        if (A[i,:]).is_zero():
            # decrementing the row index and initializing the column index
            i =i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j=j+1
            # performing row operations
            for r in range(i-1, -1, -1):
                #if A[r,j]==-1 or A[r,j]==1:
                if A[r,j].is_integer():
                    # In the case where no branching is introduced by log scaling the pivot
                    for j0 in rg(b.ncols()):
                        b[r,j0]=b[i,j0]^(-A[r,j])*b[r,j0]
                else:
                    # In the case where some branching is introduced by log scaling the pivot
                    for j0 in rg(b.ncols()):
                        b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-A[r,j])*b[r,j0]
                    if (A[r,j]).is_zero()==False:
                        indx = indx+1
                        Lst.append(1/A[r,j])
                A[r,:] = -A[r,j]*A[i,:]+A[r,:]
            i = i - 1; j = 0
    return [A, b, indx, Lst]

def multiplicative_gaussian_eliminationHM(Cf,rs,jndx=0):
    """
    Outputs the row echelon form of the input matrix and the right hand side.
    The solver here differs from the one above in the fact that it assumes
    that the entries of the Cf HM are not symbolic and checks during
    the elimination steps whether or we are indeed adding new branches.

    EXAMPLES:
 
    ::

        sage: [EfA,c,indx,Lst]=multiplicative_gaussian_eliminationHM(HM(2,2,'a'), HM(2,1,'b'))
        sage: EfA.printHM()
        [:, :]=
        [      1 a01/a00]
        [      0       1]
        sage: c.printHM()
        [:, :]=
        [                                                                    (b00*e^(2*I*pi*k0))^(1/a00)]
        [1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]


    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    A = Cf.copy(); b = rs.copy()
    # Initialization of the row and column index
    i=0; j=0; indx=jndx; Lst = []
    #while i<A.nrows() and j<A.ncols():
    while i < A.n(0) and j < A.n(1):
        #while (A[i:,j]).is_zero() and j < A.ncols()-1:
        while A.slice(rg(i,A.n(0)),'row').slice([j],'col').is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        #if A[i:,:].is_zero()==False:
        if A.slice(rg(i,A.n(0)),'row').is_zero()==False:
            while A[i,j].is_zero():
                #Ta=A[i:,:]
                Ta=A.slice(rg(i,A.n(0)),'row')
                #Tb=b[i:,:]
                Tb=b.slice(rg(i,b.n(0)),'row')
                # Initializing the cyclic shift permutation matrix
                P=HM(2, [Integer(mod(fi-1, Ta.n(0))) for fi in rg(Ta.n(0))], 'perm')
                Ta=P*Ta; Tb=P*Tb
                #A[i:,:]=Ta
                for u in rg(i,A.n(0)):
                    for v in rg(A.n(1)):
                        A[u,v]=Ta[u-i,v]
                #b[i:,:]=Tb 
                for u in rg(i,b.n(0)):
                    for v in rg(b.n(1)):
                        b[u,v]=Tb[u-i,v]
            # Performing the row operations.
            if (A[i,j].numerator()==1 or A[i,j].numerator()==-1) and A[i,j].denominator().is_integer():
                for j0 in rg(b.ncols()):
                    b[i,j0]=b[i,j0]^(1/A[i,j])
            else:
                for j0 in rg(b.ncols()):
                    b[i,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(1/A[i,j])
                indx = indx+1
                Lst.append(A[i,j])
            #A[i,:]=(1/A[i,j])*A[i,:]
            tpv=A[i,j]
            for v in rg(A.n(1)):
                A[i,v]=(1/tpv)*A[i,v]
            for r in rg(i+1,A.nrows()):
                # Taking care of the zero row
                #if A[r,:].is_zero():
                if A.slice([r],'row').is_zero():
                    r=r+1
                else:
                    if A[r,j].is_integer():
                        for j0 in rg(b.ncols()):
                            b[r,j0]=b[i,j0]^(-A[r,j])*b[r,j0]
                    else:
                        for j0 in rg(b.ncols()):
                            b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-A[r,j])*b[r,j0]
                        if (A[r,j]).is_zero()==False:
                            indx = indx+1
                            Lst.append(1/A[r,j])
                    #A[r,:]=-A[r,j]*A[i,:]+A[r,:]
                    tpv=-A[r,j]
                    for v in rg(A.n(1)):
                        A[r,v]=tpv*A[i,v]+A[r,v]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, indx, Lst]

def multiplicative_gauss_jordan_eliminationHM(Cf,rs):
    """
    Outputs the reduced row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1.
    The difference with previous implementations is the fact that the row linear combination
    operations are performed in such a way as to not change the absolute value of the determinant.
    

    EXAMPLES:
 
    ::

        sage: [A, b, indx, Lst] = multiplicative_gauss_jordan_eliminationHM(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [1 0]
        [0 1]
        sage: b.printHM()
        [:, :]=
        [(b00*e^(2*I*pi*k0))^(1/a00)/(e^(2*I*pi*k3)/(b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))^(a01/a00)]
        [                                                  1/((b10*e^(2*I*pi*k2)/((b00*e^(2*I*pi*k0))^(1/a00)*e^(2*I*pi*k1))^a10)^(1/(a01*a10/a00 - a11)))]
        sage: indx
        4
        sage: Lst
        [a00, 1/a10, -a01*a10/a00 + a11, -a01/a00]



    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b, indx, Lst] = multiplicative_gaussian_eliminationHM(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                # Performing the row operations.
                if (cf2/cf1).is_integer():
                    for j0 in range(b.n(1)):
                        b[r,j0] = b[i,j0]^(-cf2/cf1)*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                else:
                    for j0 in range(b.n(1)):
                        b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-cf2/cf1)*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                    indx = indx+1
                    Lst.append(-cf2/cf1)
            i=i-1; j=0
    return [A, b, indx, Lst]

def multiplicative_gaussian_eliminationHMII(Cf, rs, jndx=0):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1.
    The difference with the previous implementation is the fact that the row linear combination
    operations are performed in such a way as to not change the absolute value of the determinant.
    This implementation is skew fields or division ring friendly by inputing hypermatrices
    whose entries are themselve hypermatrices of the approprioate size. 


    EXAMPLES:
 
    ::

        sage: [A, b, indx, Lst] = multiplicative_gaussian_eliminationHMII(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [               a00                a01]
        [                 0 -a01*a10/a00 + a11]
        sage: b.printHM()
        [:, :]=
        [                              b00]
        [b10/(b00*e^(2*I*pi*k0))^(a10/a00)]
        sage: indx
        1
        sage: Lst
        [-a10/a00]



    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0; indx=jndx; Lst = []
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Tb=HM(b.n(0)-i, b.n(1), [b[i0,j0] for j0 in range(b.n(1)) for i0 in range(i,b.n(0))])
                # Initializing the cyclic shift permutation matrix
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                P=HM(2, [Integer(mod(fi-1, Ta.n(0))) for fi in rg(Ta.n(0))], 'perm')
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            if A.n(0)-i-1 > 0 and not (HM(A.n(0)-i-1, 1, [A[i0,j] for i0 in range(i+1,A.n(0))]).is_zero() and j <= A.ncols()-1):
                # Performing the row operations.
                cf1=A[i,j]
                for r in range(i+1,A.nrows()):
                    # Taking care of the zero row
                    if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                        r=r+1
                    else:
                        # Initialization of the coefficient
                        cf2=A[r,j]
                        # Performing the row operations.
                        if (cf2/cf1).is_integer():
                            for j0 in range(b.n(1)):
                                b[r,j0] = b[i,j0]^(-cf2/cf1)*b[r,j0]
                            for j0 in range(A.n(1)):
                                #A[r,j0] = A[i,j0]^(-cf2/cf1)*A[r,j0]
                                A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                        else:
                            for j0 in range(b.n(1)):
                                b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-cf2/cf1)*b[r,j0]
                            for j0 in range(A.n(1)):
                                #A[r,j0]=A[i,j0]^(-cf2/cf1)*A[r,j0]
                                A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                            indx = indx+1
                            Lst.append(-cf2/cf1)
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A, b, indx, Lst]

def multiplicative_gauss_jordan_eliminationHMII(Cf,rs):
    """
    Outputs the reduced row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1.
    The difference with previous implementations is the fact that the row linear combination
    operations are performed in such a way as to not change the absolute value of the determinant.
    

    EXAMPLES:
 
    ::

        sage: [A, b, indx, Lst] = multiplicative_gauss_jordan_eliminationHMII(HM(2,2,'a'), HM(2,1,'b'))
        sage: A.printHM()
        [:, :]=
        [               a00                  0]
        [                 0 -a01*a10/a00 + a11]
        sage: b.printHM()
        [:, :]=
        [b00*(b10*e^(2*I*pi*k1)/(b00*e^(2*I*pi*k0))^(a10/a00))^(a01/(a01*a10/a00 - a11))]
        [                                              b10/(b00*e^(2*I*pi*k0))^(a10/a00)]
        sage: indx
        2
        sage: Lst
        [-a10/a00, a01/(a01*a10/a00 - a11)]



    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b, indx, Lst] = multiplicative_gaussian_eliminationHMII(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                # Performing the row operations.
                if (cf2/cf1).is_integer():
                    for j0 in range(b.n(1)):
                        b[r,j0] = b[i,j0]^(-cf2/cf1)*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                else:
                    for j0 in range(b.n(1)):
                        b[r,j0]=(b[i,j0]*exp(I*2*pi*var('k'+str(indx))))^(-cf2/cf1)*b[r,j0]
                    for j0 in range(A.n(1)):
                        A[r,j0]=A[i,j0]*(-cf2/cf1)+A[r,j0]
                    indx = indx+1
                    Lst.append(-cf2/cf1)
            i=i-1; j=0
    return [A, b, indx, Lst]

def multiplicative_matrix_product(A,B):
    """
    Outputs the result of the multiplicative product of the
    two input matrices.

    EXAMPLES:
 
    ::

        sage: multiplicative_matrix_product(Matrix(SR,HM(2,2,'a').listHM()), Matrix(SR,HM(2,2,'b').listHM()))
        [b00^a00*b10^a01 b01^a00*b11^a01]
        [b00^a10*b10^a11 b01^a10*b11^a11]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    Rslt=Matrix(SR,zero_matrix(A.nrows(), B.ncols()))
    for i in range(A.nrows()):
        for k in range(B.ncols()):
            Rslt[i,k]=prod([B[j,k]^A[i,j] for j in range(A.ncols())])
    return Rslt

def multiplicative_matrix_productHM(A,B):
    """
    Outputs the result of the multiplicative product of the
    two input matrices.

    EXAMPLES:
 
    ::

        sage: multiplicative_matrix_productHM(HM(2,2,'a'), HM(2,2,'b')).printHM()
        [:, :]=
        [b00^a00*b10^a01 b01^a00*b11^a01]
        [b00^a10*b10^a11 b01^a10*b11^a11]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    Rslt=HM(A.nrows(), B.ncols(), 'zero')
    for i in range(A.nrows()):
        for k in range(B.ncols()):
            Rslt[i,k]=prod([B[j,k]^A[i,j] for j in range(A.ncols())])
    return Rslt

def vec_exp(vx,A):
    """
    Outputs the result of the multiplicative product of a
    matrix by a vector. Does not check that the left input
    actually is a vector.

    EXAMPLES:
 
    ::

        sage: vec_exp(HM(2,1,HM(2,'x').list()), HM(2,2,'a')).printHM()
        [:, :]=
        [x0^a00*x1^a01]
        [x0^a10*x1^a11]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    #return mprod(A,x)
    return GProdIII([A,vx],prod,BaseExp)

def linear_solver(A,b,x,v):
    """
    Outputs the Reduced Row Echelon Form of the input matrix and the right hand side.
    where A denotes the input matrix, b denotes the right-hand side vector, x denotes
    the variable vector coming from the original system of equations, and v denotes 
    the free variable vector.

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))+var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=ConstraintFormatorII(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: Mx=Matrix(SR,A.ncols(),1,[var('x'+str(i)) for i in range(A.ncols())])
        sage: Mv=Matrix(SR,A.ncols(),1,[var('t'+str(i)) for i in range(A.ncols())])
        sage: linear_solver(A,b,Mx,Mv)
        [x0 == a00 - a10 + a11 - t3,
         x1 == a11 - t3,
         x2 == a10 - a11 + t3,
         0  == -a00 + a01 + a10 - a11]

    AUTHORS:
    - Initial implementation by Edinah K. Gnang updates to the doc string by Jeanine S. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=gauss_jordan_elimination(A,b)
    Id1 = identity_matrix(Ap.nrows())
    Id2 = identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1=Pm*x; tp2=bp-(Ap-Pm)*v
    return [tp1[i,0]==tp2[i,0] for i in range(tp1.nrows())]

def linear_solverHM(A,b,x,v):
    """
    Outputs the Reduced Row Echelon Form of the input matrix and the right hand side.
    where A denotes the input matrix, b denotes the right-hand side vector, x denotes
    the variable vector coming from the original system of equations, and v denotes 
    the free variable vector.


    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))+var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=ConstraintFormatorHM(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: linear_solverHM(A,b,HM(A.n(1),1,var_list('x',A.n(1))),HM(A.n(1),1,var_list('t',A.n(1))))
        [x0 == a00 - a10 + a11 - t3,
         x1 == a11 - t3,
         x2 == a10 - a11 + t3,
         0  == -a00 + a01 + a10 - a11]
        sage: sz=Integer(2); A=HM(sz, sz, 'a'); Ha=HM([A.elementwise_exponent(i).list() for i in rg(sz^2)])
        sage: linear_solverHM(Ha.t(),HM(sz^2,1,'zero'),HM(Ha.n(1),1,var_list('x',Ha.n(1))),HM(Ha.n(1),1,var_list('t',Ha.n(1))))
        [x0 == 0, x1 == 0, x2 == 0, x3 == 0]
        sage: sz=Integer(2); A=HM(sz, sz, 'a'); Ha=HM([(A^i).list() for i in rg(sz^2-1)])
        sage: linear_solverHM(Ha.t(), HM(sz^2,1,'zero'), HM(Ha.n(1),1,var_list('x',Ha.n(1))), HM(Ha.n(1),1,var_list('t',Ha.n(1))))
        [x0 == -(a00^2 + a01*a10 - (a00*a10 + a10*a11)*a00/a10)*t2,
         x1 == -(a00*a10 + a10*a11)*t2/a10,
         0 == -(a00*a01 + a01*a11 - (a00*a10 + a10*a11)*a01/a10)*t2,
         0 == (a00^2 - a11^2 - (a00*a10 + a10*a11)*(a00 - a11)/a10)*t2]


    AUTHORS:
    - Initial implementation by Edinah K. Gnang updates to the doc string by Jeanine S. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=gauss_jordan_eliminationHM(A,b)
    Id1 = HM(2, Ap.n(0), 'kronecker')
    Id2 = HM(2, Ap.n(1), 'kronecker')
    # Obtainin the list of pivot variables.
    Pm=HM(Ap.n(0), Ap.n(1), 'zero')
    for i in range(Ap.n(0)):
        if not HM(1, Ap.n(1), [SR(Ap[i,u]) for u in range(Ap.n(1))]).is_zero():
            for j in range(Ap.n(1)):
                if Ap[i,j]==1:
                    break
            Pm=Pm+HM(Id1.n(0), 1, [SR(Id1[s,i]) for s in range(Id1.n(0))])*HM(1,Id2.n(1),[SR(Id2[j,t]) for t in range(Id2.n(1))])
    # Expressing the solutions
    tp1=Pm*x; tp2=bp-(Ap-Pm)*v
    return [tp1[i,0]==tp2[i,0] for i in range(tp1.n(0))]

def default_linear_solver(EqL, Lv, Lf):
    """
    Formats the constraints and outputs the solution of the system of linear constraints.
    The input EqL is the list of constraints. The input Lv corresponds to the list of
    variable constraints appearing in EqL. The input Lf corresponds to the free variable
    name each of which is put in correspondent with the entries of Lv.


    EXAMPLES:
 
    ::

        sage: sz=2; EqL=[var('x'+str(i))+var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: default_linear_solver(EqL, var_list('x', 2*sz), var_list('t', 2*sz))
        [x0 == a00 - a10 + a11 - t3,
         x1 == a11 - t3,
         x2 == a10 - a11 + t3,
         0  == -a00 + a01 + a10 - a11]

    AUTHORS:
    - Initial implementation by Edinah K. Gnang updates to the doc string by Jeanine S. Gnang
    - To Do: 
    """
    # Formating the constraints
    [A,b]=ConstraintFormatorHM(EqL,Lv)
    # Initialization of the variable vectors
    x=HM(A.ncols(), 1, Lv); v=HM(A.ncols(), 1, Lf)
    # Initialization of the reduced echelon form.
    [Ap,bp]=gauss_jordan_eliminationHM(A,b)
    Id1 = HM(2, Ap.n(0), 'kronecker')
    Id2 = HM(2, Ap.n(1), 'kronecker')
    # Obtainin the list of pivot variables.
    Pm=HM(Ap.n(0), Ap.n(1), 'zero')
    for i in range(Ap.n(0)):
        if not HM(1, Ap.n(1), [SR(Ap[i,u]) for u in range(Ap.n(1))]).is_zero():
            for j in range(Ap.n(1)):
                if Ap[i,j]==1:
                    break
            Pm=Pm+HM(Id1.n(0), 1, [SR(Id1[s,i]) for s in range(Id1.n(0))])*HM(1,Id2.n(1),[SR(Id2[j,t]) for t in range(Id2.n(1))])
    # Expressing the solutions
    tp1=Pm*x; tp2=bp-(Ap-Pm)*v
    return [tp1[i,0]==tp2[i,0] for i in range(tp1.n(0))]

def multiplicative_linear_solver(A,b,x,v):
    """
    Outputs the solution to a multiplicative linear system of equations.

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))*var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=multiplicativeConstraintFormator(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: Mx=Matrix(SR,A.ncols(),1,[var('x'+str(i)) for i in range(A.ncols())])
        sage: Mv=Matrix(SR,A.ncols(),1,[var('t'+str(i)) for i in range(A.ncols())])
        sage: multiplicative_linear_solver(A,b,Mx,Mv)
        [x0 == a00*a11/(a10*t3),
         x1 == a11/t3,
         x2 == a10*t3/a11,
         1 == a01*a10/(a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=multiplicative_gauss_jordan_eliminationII(A,b)[:2]
    Id1=identity_matrix(Ap.nrows())
    Id2=identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1=multiplicative_matrix_product(Pm,x)
    tp2=multiplicative_matrix_product((Ap-Pm),v)
    return [tp1[i,0]==bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def multiplicative_linear_solverHM(A,b,x,v):
    """
    Outputs the solution to a multiplicative linear system of equations.

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))*var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=multiplicativeConstraintFormatorHM(Eq,var_list('x',2*sz))
        sage: Mx=HM(A.ncols(),1,var_list('x',A.ncols()))
        sage: Mv=HM(A.ncols(),1,var_list('t',A.ncols()))
        sage: multiplicative_linear_solverHM(A,b,Mx,Mv)
        [x0 == a00*a11/(a10*t3),
         x1 == a11/t3,
         x2 == a10*t3/a11,
         1 == a01*a10/(a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=multiplicative_gauss_jordan_eliminationII(A.matrix(),b.matrix())[:2]
    Id1=identity_matrix(Ap.nrows())
    Id2=identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1=multiplicative_matrix_product(Pm,x)
    tp2=multiplicative_matrix_product((Ap-Pm),v)
    return [tp1[i,0]==bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def default_multiplicative_linear_solver(EqL, Lv, Lf):
    """
    Formats the constraints performs and solves the multiplicatively linear constraints.
    Outputs the solutions. The input EqL corresponds to a list of constraints. The input Lv
    corresponds to the list of variables appearing in the constraints. The input Lf corresponds
    to the list of free varaibles each taken in correspondence with the entries of Lv. This 
    implementation tacitly assumes that the  the input constraints are indeed multiplicatively linear.


    EXAMPLES:
 
    ::

        sage: sz=2; EqL=[var('x'+str(i))*var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: default_multiplicative_linear_solver(EqL, var_list('x', 2*sz), var_list('t', 2*sz))
        [x0 == a00*a11/(a10*t3),
         x1 == a11/t3,
         x2 == a10*t3/a11,
         1 == a01*a10/(a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Formatting the constraints
    [A,b]=multiplicativeConstraintFormatorHM(EqL, Lv)
    # Initialization of the variables
    x=HM(A.ncols(), 1, Lv); v=HM(A.ncols(), 1, Lf)
    # Initialization of the reduced echelon form.
    [Ap,bp]=multiplicative_gauss_jordan_eliminationII(A.matrix(),b.matrix())[:2]
    #Id1=identity_matrix(Ap.nrows())
    Id1=HM(2, Ap.nrows(), 'kronecker')
    #Id2=identity_matrix(Ap.ncols())
    Id2=HM(2, Ap.ncols(), 'kronecker')
    # Obtainin the list of pivot variables.
    #Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    Pm=HM(Ap.nrows(), Ap.ncols(), 'zero')
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+HM(Ap.nrows(),1,[Id1[f,i] for f in rg(Ap.nrows())])*HM(1,Ap.ncols(),[Id2[j,g] for g in rg(Ap.ncols())])
    # Expressing the solutions
    tp1=x^Pm; tp2=v^(Matrix2HM(Ap)-Pm)
    return [tp1[i,0]==bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def multiplicative_least_square_linear_solver(A,b,x,v):
    """
    Outputs the solution to the multiplicative least square problem

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))+var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=ConstraintFormatorII(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: Mx=Matrix(SR,A.ncols(),1,[var('x'+str(i)) for i in range(A.ncols())])
        sage: Mv=Matrix(SR,A.ncols(),1,[var('t'+str(i)) for i in range(A.ncols())])
        sage: multiplicative_least_square_linear_solver(A,b,Mx,Mv)
        [x0 == sqrt(a00*a01)*e^(3/2*I*pi*k0 + 1/2*I*pi*k1 - I*pi*k3)/(sqrt(a00*a10/(sqrt(a00*a01)*sqrt(a10*a11)))*t3),
         x1 == sqrt(a10*a11)*e^(1/2*I*pi*k0 + 3/2*I*pi*k1 - I*pi*k2)/(sqrt(a00*a10/(sqrt(a00*a01)*sqrt(a10*a11)))*t3),
         x2 == a00*a10*t3*e^(-I*pi*k0 - I*pi*k1)/(sqrt(a00*a01)*sqrt(a10*a11)),
         1 == e^(-2*I*pi*k0 - 2*I*pi*k1)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=multiplicative_gauss_jordan_eliminationII(A.transpose()*A, multiplicative_matrix_product(A.transpose(),b))[:2]
    Id1=identity_matrix(Ap.nrows())
    Id2=identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1=multiplicative_matrix_product(Pm,x)
    tp2=multiplicative_matrix_product((Ap-Pm),v)
    return [tp1[i,0]==bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def multiplicative_least_square_linear_solverHM(A,b,x,v):
    """
    Outputs the solution to the multiplicative least square problem

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))*var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=multiplicativeConstraintFormatorHM(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: Mx=HM(A.ncols(),1,[var('x'+str(i)) for i in range(A.ncols())])
        sage: Mv=HM(A.ncols(),1,[var('t'+str(i)) for i in range(A.ncols())])
        sage: multiplicative_least_square_linear_solverHM(A,b,Mx,Mv)
        [x0 == sqrt(a00*a01)*e^(3/2*I*pi*k0 + 1/2*I*pi*k1 - I*pi*k3)/(sqrt(a00*a10/(sqrt(a00*a01)*sqrt(a10*a11)))*t3),
         x1 == sqrt(a10*a11)*e^(1/2*I*pi*k0 + 3/2*I*pi*k1 - I*pi*k2)/(sqrt(a00*a10/(sqrt(a00*a01)*sqrt(a10*a11)))*t3),
         x2 == a00*a10*t3*e^(-I*pi*k0 - I*pi*k1)/(sqrt(a00*a01)*sqrt(a10*a11)),
         1 == e^(-2*I*pi*k0 - 2*I*pi*k1)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=multiplicative_gauss_jordan_eliminationII((A.transpose()*A).matrix(), multiplicative_matrix_productHM(A.transpose(),b).matrix())[:2]
    Id1=identity_matrix(Ap.nrows())
    Id2=identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm=Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j]==1:
                    break
            Pm=Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1=multiplicative_matrix_product(Pm,x)
    tp2=multiplicative_matrix_product((Ap-Pm),v)
    return [tp1[i,0]==bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def default_multiplicative_linear_solverHM(EqL, Lv, Lf):
    """
    Formats the constraints performs and solves the multiplicatively linear constraints.
    Outputs the solutions. The input EqL corresponds to a list of constraints. The input Lv
    corresponds to the list of variables appearing in the constraints. The input Lf corresponds
    to the list of free varaibles each taken in correspondence with the entries of Lv. This 
    implementation tacitly assumes that the  the input constraints are indeed multiplicatively linear.


    EXAMPLES:
 
    ::

        sage: sz=2; EqL=[GProdIII([HM(sz,sz,'a'), HM(sz,1,var_list('x',sz))], prod, BaseExp)[i,0]==var_list('b',sz)[i] for i in rg(sz)]
        sage: default_multiplicative_linear_solverHM(EqL, var_list('x', sz), var_list('t', sz))
        [[x0 == (b0*(b1*e^(2*I*pi*k1)/(b0*e^(2*I*pi*k0))^(a10/a00))^(a01/(a01*a10/a00 - a11))*e^(2*I*pi*k2))^(1/a00),
          x1 == (b1*e^(2*I*pi*k3)/(b0*e^(2*I*pi*k0))^(a10/a00))^(1/a11)],
         4,
         [-a10/a00, a01/(a01*a10/a00 - a11), 1/a00, -1/(a01*a10/a00 - a11)]]
        sage: sz=2; Eq=[var('x'+str(i))*var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: sz=2; default_multiplicative_linear_solverHM(Eq, var_list('x',2*sz), var_list('t',2*sz))
        [[x0 == a01, x1 == a11, x2 == a00/a01, 1 == a01*a10/(a00*a11)], 0, []]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Formatting the constraints
    [A, b]=multiplicativeConstraintFormatorIIIHM(EqL, Lv)
    # Initialization of the variables
    Hx = HM(A.ncols(), 1, Lv); Hv = HM(A.ncols(), 1, Lf)
    # Initialization of the reduced echelon form.
    [Ap, bp, indx, Lst] = multiplicative_gauss_jordan_eliminationHMII(A, b)
    Id1=HM(2, Ap.nrows(), 'kronecker'); Id2=HM(2, Ap.ncols(), 'kronecker')
    # Obtainin the list of pivot variables.
    Pm=HM(Ap.nrows(), Ap.ncols(), 'zero'); Qm=HM(Ap.nrows(), Ap.ncols(), 'zero')
    for i in range(Ap.nrows()):
        if not Ap.slice([i],'row').is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j] != 0:
                    break
            Pm=Pm+HM(Ap.nrows(),1,[Id1[f,i] for f in rg(Ap.nrows())])*HM(1,Ap.ncols(),[Ap[j,g] for g in rg(Ap.ncols())])
            Qm=Qm+HM(Ap.nrows(),1,[Id1[f,i] for f in rg(Ap.nrows())])*HM(1,Ap.ncols(),[Id2[j,g] for g in rg(Ap.ncols())])
    # Expressing the solutions
    tp1=GProdIII([Pm, Hx], prod, BaseExp); tp2=GProdIII([Ap-Pm, Hv], prod, BaseExp); tq=GProdIII([Qm, Hx], prod, BaseExp)
    # Initialization of the variables
    [Af, bf]=multiplicativeConstraintFormatorIIIHM([tp1[gi,0] == bp[gi,0]/tp2[gi,0] for gi in range(tp1.nrows())], [vb for vb in tq.list() if vb in Lv])
    for r in rg(min(Af.dimensions())):
        if (1/Af[r,r]).is_integer():
            for j0 in rg(bf.n(1)):
                bf[r,j0]=(bf[r,j0])^(1/Af[r,r])
        else:
            for j0 in rg(bf.n(1)):
                bf[r,j0]=(bf[r,j0]*exp(I*2*pi*var('k'+str(indx))))^(1/A[r,r])
            indx = indx+1
            Lst.append(1/Af[r,r])
    return [[tq[i,0] == bf[i,0] for i in range(tq.nrows())], indx, Lst]

def exponential_linear_solverHM(Ha,b,x,v):
    """
    Outputs the solution to a multiplicative linear system of equations.

    EXAMPLES:
 
    ::

        sage: sz=2; X=var_list('x',sz); A=HM(sz,sz,'a'); Eq=[(A[0,0]^X[0])*(A[0,1]^X[1])==7, (A[1,0]^X[0])*(A[1,1]^X[1])==2]
        sage: [A,b]=exponentialConstraintFormatorHM(Eq,X); Mx=HM(sz,1,X); Mv=HM(sz,1,var_list('t',sz))
        sage: exponential_linear_solverHM(A,b,Mx,Mv)
        [e^x0 == (7*e^(2*I*pi*k0))^(1/log(a00))/(e^(2*I*pi*k3)/(2*e^(2*I*pi*k2)/((7*e^(2*I*pi*k0))^(1/log(a00))*e^(2*I*pi*k1))^log(a10))^(1/(log(a01)*log(a10)/log(a00) - log(a11))))^(log(a01)/log(a00)),
         e^x1 == (1/((2*e^(2*I*pi*k2)/((7*e^(2*I*pi*k0))^(1/log(a00))*e^(2*I*pi*k1))^log(a10))^(1/(log(a01)*log(a10)/log(a00) - log(a11)))))]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    phi = lambda x: ln(x)
    #A = apply(HM, Ha.dimensions()+[ Ha.apply_map(phi).list() ])
    A = HM(*(Ha.dimensions()+[ Ha.apply_map(phi).list() ]))
    # Initialization of the reduced echelon form.
    [Ap,bp] = multiplicative_gauss_jordan_eliminationII(A.matrix(),b.matrix())[:2]
    Id1 = identity_matrix(Ap.nrows()); Id2 = identity_matrix(Ap.ncols())
    # Obtainin the list of pivot variables.
    Pm = Matrix(SR,zero_matrix(Ap.nrows(),Ap.ncols()))
    for i in range(Ap.nrows()):
        if not Ap[i,:].is_zero():
            for j in range(Ap.ncols()):
                if Ap[i,j] == 1:
                    break
            Pm = Pm+Id1[:,i]*Id2[j,:]
    # Expressing the solutions
    tp1 = multiplicative_matrix_product(Pm,x)
    tp2 = multiplicative_matrix_product((Ap-Pm),v)
    return [exp(tp1[i,0]) == bp[i,0]/tp2[i,0] for i in range(tp1.nrows())]

def SecondOrderHadamardFactorization(A,B):
    """
    Outputs the matrix factorization induced by hadamard matrices.

    EXAMPLES:
 
    ::

        sage: [U,V]=SecondOrderHadamardFactorization(HM(2,2,'a'),HM(2,2,'b'))
        sage: Prod(U,V).simplify_full()
        [[a00*b00 + a01*b10, a00*b01 + a01*b11], [a10*b00 + a11*b10, a10*b01 + a11*b11]]


    AUTHORS:

    - Edinah K. Gnang
    - To Do: 
    """
    if A.n(0)==B.n(1) and A.n(1)==B.n(0) and (log(Integer(A.n(0)),2)).is_integer():
        # Initializing the hadamard matrix
        H = SecondOrderHadamardBlockU(Integer(A.n(0)))
        L = [GeneralUncorrelatedHypermatrixTuple(2) for i in range(log(Integer(A.n(0)),2))]
        # Initializing the temporary hypermatrices.
        Tp0 = L[0][0]; Tp1 = L[0][1]
        for i in range(1,len(L)):
            Tp0 = Tp0.slicekroneckerproduct(L[i][0])
            Tp1 = Tp1.slicekroneckerproduct(L[i][1])
        Tp0 = sqrt(Tp0.n(0))*Tp0
        Tp1 = sqrt(Tp1.n(0))*Tp1
        # initializing the extened matrices
        M0 = HM(A.n(0), 2*A.n(0)-1, 'zero')
        for j in range(1,A.n(0)):
            for i in range(A.n(0)):
                M0[i,j-1] = H[i,j]
        for j in range(A.n(0), 2*A.n(0)):
            for i in range(A.n(0)):
                M0[i,j-1] = Tp0[i,j-A.n(0)]
        M1 = HM(2*A.n(0)-1,A.n(0), 'zero')
        for j in range(1,A.n(0)):
            for i in range(A.n(0)):
                M1[j-1,i] = -H[i,j]
        for j in range(A.n(0), 2*A.n(0)):
            for i in range(A.n(0)):
                M1[j-1,i] = Tp1[j-A.n(0),i]
        # Filling up the hypermatrices.
        U = HM(A.n(0), (2*A.n(0)-1)*A.n(1),'zero')
        for i in range(A.n(1)):
            for j in range(M0.n(1)):
                for k in range(A.n(0)):
                    U[k, A.n(1)*j+i] = A[k,i]*M0[k,j]
        V = HM((2*A.n(0)-1)*A.n(1), A.n(0),'zero')
        for i in range(B.n(0)):
            for j in range(M1.n(0)):
                for k in range(B.n(1)):
                    V[A.n(1)*j+i,k] = B[i,k]*M1[j,k]
        return [U,V]
    else:
        # return the error message if the input hypermatrix is cubic
        raise ValueError("The input hypermpatrix are of inapropriate sizes")

def RealRow_Gram_Schmidt(M):
    """
    Implements the naive Gram-Schmidt algorithm for rows.

    EXAMPLES:

    ::

        sage: Q=RealRow_Gram_Schmidt(Matrix(SR,HM(2,2,'a').listHM())); Matrix(SR,[[(Q*Q.transpose())[i,j].simplify_full() for i in range(2)] for j in range(2)])
        [                                                  a00^2 + a01^2                                                               0]
        [                                                              0 (a01^2*a10^2 - 2*a00*a01*a10*a11 + a00^2*a11^2)/(a00^2 + a01^2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the resulting matrix
    Rs = Matrix(SR, zero_matrix(M.nrows(),M.ncols()))
    # Initializing the first vector
    # the implementation assumes that the first vector is non zero
    Rs[0,:]=M[0,:]
    for i in range(1,M.nrows()):
        v = M[i,:]
        v = v-sum([(v*Rs[j,:].transpose())[0,0]/sum(Rs[j,s]^2 for s in range(Rs.ncols()))*Rs[j,:] for j in range(i) if not sum(Rs[j,s]^2 for s in range(Rs.ncols())).is_zero()])
        Rs[i,:] = v
    return Rs

def RealRow_Gram_SchmidtHM(Hm):
    """
    Implements the naive Gram-Schmidt algorithm for rows.
    The implementation here is a naive varian of the 
    implementation above.

    EXAMPLES:

    ::

        sage: Q=RealRow_Gram_SchmidtHM(HM(2,2,'a')); (Q*Q.transpose()).simplify_full().printHM()
        [:, :]=
        [                                                  a00^2 + a01^2                                                               0]
        [                                                              0 (a01^2*a10^2 - 2*a00*a01*a10*a11 + a00^2*a11^2)/(a00^2 + a01^2)]
        sage: A = HM([[-2*I + 3, -2], [5*I - 1, -I + 2]]); od=2; sz = 2
        sage: B=HM(2*sz, 2*sz,'zero') # Conversion from complex to real
        sage: for i in range(sz):
        ....:     for j in range(sz):
        ....:         Tmp=HM(sz, sz,'zero'); Tmp[i,j]=1
        ....:         B=B+Tmp.tensor_product(HM([[A[i,j].real(),-A[i,j].imag()],[A[i,j].imag(),A[i,j].real()]]))
        ....:
        sage: Q=RealRow_Gram_SchmidtHM(B) # Performing the orthogonalization
        sage: U=HM(sz, sz,'zero') # Conversion from real back to complex
        sage: for i in range(0, 2*sz, 2):
        ....:     for j in range(0, 2*sz, 2):
        ....:         U[i/2,j/2]=Q[i,j]+I*Q[i+1,j]
        ....:
        sage: U.printHM()
        [:, :]=
        [     -2*I + 3            -2]
        [6/17*I + 4/17       13/17*I]
        sage: U*U.conjugate_transpose()
        [[17, 0], [0, 13/17]]
        sage: A = HM([[-2*I + 3, -2], [5*I - 1, -I + 2]]); U = RR2CC_deflate(RealRow_Gram_SchmidtHM(CC2RR_inflate(A))); U
        [[-2*I + 3, -2], [6/17*I + 4/17, 13/17*I]]
        sage: U*U.conjugate_transpose()
        [[17, 0], [0, 13/17]]


    AUTHORS:
    - Edinah K. Gnang
    """
    M=Hm.matrix()
    # Initialization of the resulting matrix
    Rs = Matrix(SR, zero_matrix(M.nrows(),M.ncols()))
    # Initializing the first vector
    # the implementation assumes that the first vector is non zero
    Rs[0,:]=M[0,:]
    for i in range(1,M.nrows()):
        v = M[i,:]
        v = v-sum([(v*Rs[j,:].transpose())[0,0]/sum(Rs[j,s]^2 for s in range(Rs.ncols()))*Rs[j,:] for j in range(i) if not sum(Rs[j,s]^2 for s in range(Rs.ncols())).is_zero()])
        Rs[i,:] = v
    return HM(M.nrows(),M.ncols(),Rs.transpose().list())

def RealColumn_Gram_Schmidt(M):
    """
    Implements the naive Gram-Schmidt algorithm for the columns.

    EXAMPLES:

    ::

        sage: Q=RealColumn_Gram_Schmidt(Matrix(SR,HM(2,2,'a').listHM())); Matrix(SR,[[(Q.transpose()*Q)[i,j].simplify_full() for i in range(2)] for j in range(2)])
        [                                                  a00^2 + a10^2                                                               0]
        [                                                              0 (a01^2*a10^2 - 2*a00*a01*a10*a11 + a00^2*a11^2)/(a00^2 + a10^2)]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the symbolic matrix to be used as output
    Rs = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
    # This implementation assumes that the first column is a non zero column.
    # Initializing the first vector to a unit vector.
    Rs[:,0]=M[:,0]
    # Loop removing the bad components for all the remaining vectors
    for i in range(1, M.ncols()):
        v = M[:,i]
        v = v-sum([(v.transpose()*Rs[:,j])[0,0]/sum(Rs[s,j]^2 for s in range(Rs.nrows()))*Rs[:,j] for j in range(i) if not sum(Rs[s,j]^2 for s in range(Rs.nrows())).is_zero()])
        Rs[:,i] = v
    return Rs

def RealColumn_Gram_SchmidtHM(Hm):
    """
    Implements the naive Gram-Schmidt algorithm for the columns.
    This implementation is a naive variant of the implementation
    above.

    EXAMPLES:

    ::

        sage: Q=RealColumn_Gram_SchmidtHM(HM(2,2,'a')); (Q.transpose()*Q).simplify_full().printHM()
        [:, :]=
        [                                                  a00^2 + a10^2                                                               0]
        [                                                              0 (a01^2*a10^2 - 2*a00*a01*a10*a11 + a00^2*a11^2)/(a00^2 + a10^2)]
        sage: A = HM([[-2*I + 3, -2], [5*I - 1, -I + 2]]); od=2; sz = 2
        sage: B=HM(2*sz, 2*sz,'zero') # Conversion from complex to real
        sage: for i in range(sz):
        ....:     for j in range(sz):
        ....:         Tmp=HM(sz, sz,'zero'); Tmp[i,j]=1
        ....:         B=B+Tmp.tensor_product(HM([[A[i,j].real(),-A[i,j].imag()],[A[i,j].imag(),A[i,j].real()]]))
        ....:
        sage: Q=RealColumn_Gram_SchmidtHM(B) # Performing the orthogonalization
        sage: U=HM(sz, sz,'zero') # Conversion from real back to complex
        sage: for i in range(0, 2*sz, 2):
        ....:     for j in range(0, 2*sz, 2):
        ....:         U[i/2,j/2]=Q[i,j]+I*Q[i+1,j]
        ....:
        sage: U.printHM()
        [:, :]=
        [   -2*I + 3 1/3*I - 1/3]
        [    5*I - 1       1/3*I]
        sage: U.conjugate_transpose()*U
        [[39, 0], [0, 1/3]]


    AUTHORS:
    - Edinah K. Gnang
    """
    M=Hm.matrix()
    # Initialization of the symbolic matrix to be used as output
    Rs = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
    # This implementation assumes that the first column is a non zero column.
    # Initializing the first vector to a unit vector.
    Rs[:,0]=M[:,0]
    # Loop removing the bad components for all the remaining vectors
    for i in range(1, M.ncols()):
        v = M[:,i]
        v = v-sum([(v.transpose()*Rs[:,j])[0,0]/sum(Rs[s,j]^2 for s in range(Rs.nrows()))*Rs[:,j] for j in range(i) if not sum(Rs[s,j]^2 for s in range(Rs.nrows())).is_zero()])
        Rs[:,i] = v
    return HM(M.nrows(), M.ncols(), Rs.transpose().list())

def All_RealRow_Gram_Schmidt(M):
    """
    Takes a square matrix as input and returns an orthognal martix with minimal row distance.

    EXAMPLES:

    ::

        sage: All_RealRow_Gram_Schmidt(Matrix(SR,HM(2,2,'a').listHM()))
        [
        [                                           a00                                            a01]  [a00 - (a00*a10 + a01*a11)*a10/(a10^2 + a11^2) a01 - (a00*a10 + a01*a11)*a11/(a10^2 + a11^2)]
        [-(a00*a10 + a01*a11)*a00/(a00^2 + a01^2) + a10 -(a00*a10 + a01*a11)*a01/(a00^2 + a01^2) + a11], [                                          a10                                           a11]
        ]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initilization of the list of Permutations
    P = Permutations(range(M.nrows()))
    # Initialization of the list
    L=[]
    # Initialization of the final matrix
    Q = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
    for p in P:
        # Initialization of the temporary matrix.
        Rs = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
        # Initialization of the first vector.
        # the implementation assumes that the first vector is non zero
        Rs[p[0],:] = M[p[0],:]
        for i in range(1,M.nrows()):
            v = M[p[i],:]
            v = v-sum([(v*Rs[p[j],:].transpose())[0,0]/sum(Rs[p[j],s]^2 for s in range(Rs.ncols()))*Rs[p[j],:] for j in range(i) if not sum(Rs[p[j],s]^2 for s in range(Rs.ncols())).is_zero()])
            Rs[p[i],:] = v
        L.append(copy(Rs))
    return L

def All_RealColumn_Gram_Schmidt(M):
    """
    Takes a square matrix as input and returns an orthognal martix with minimal row distance.

    EXAMPLES:

    ::

        sage: All_RealColumn_Gram_Schmidt(Matrix(SR,HM(2,2,'a').listHM()))
        [
        [                                           a00 -(a00*a01 + a10*a11)*a00/(a00^2 + a10^2) + a01]  [a00 - (a00*a01 + a10*a11)*a01/(a01^2 + a11^2)                                           a01]
        [                                           a10 -(a00*a01 + a10*a11)*a10/(a00^2 + a10^2) + a11], [a10 - (a00*a01 + a10*a11)*a11/(a01^2 + a11^2)                                           a11]
        ]

    AUTHORS:
    - Edinah K. Gnang
    """
    M = M.transpose()
    # Initilization of the list of Permutations
    P = Permutations(range(M.nrows()))
    # Initialization of the list
    L=[]
    # Initialization of the final matrix
    Q = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
    for p in P:
        # Initialization of the temporary matrix.
        Rs = Matrix(SR, zero_matrix(M.nrows(), M.ncols()))
        # Initialization of the first vector.
        # the implementation assumes that the first vector is non zero
        Rs[p[0],:] = M[p[0],:]
        for i in range(1,M.nrows()):
            v = M[p[i],:]
            v = v-sum([(v*Rs[p[j],:].transpose())[0,0]/sum(Rs[p[j],s]^2 for s in range(Rs.ncols()))*Rs[p[j],:] for j in range(i) if not sum(Rs[p[j],s]^2 for s in range(Rs.ncols())).is_zero()])
            Rs[p[i],:] = v
        L.append(copy(Rs).transpose())
    return L

def Nearest_RealRow_Gram_Schmidt(M):
    """
    Takes a square matrix as input and returns an orthognal martix with minimal row distance.

    EXAMPLES:

    ::

        sage: Nearest_RealRow_Gram_Schmidt(Matrix(QQ,2,2,[1, -1/2, -1, 0]))
        Distance from the zero matrix  9/4
        The current error for p= [0, 1] is 4/5
        The current error for p= [1, 0] is 1
        [
        [   1 -1/2]  [   1 -1/2]     
        [  -1    0], [-1/5 -2/5], 4/5
        ]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Normalizing the Rows of the matrix
    for i in range(M.nrows()):
        M[i,:]=M[i,:]
    # Initilization of the list of Permutations
    P = Permutations(range(M.nrows()))
    # Initialization of the current error.
    cur_err=sum(nt^2 for nt in M.list())
    print("Distance from the zero matrix "+str(cur_err))
    # Initialization of the final matrix
    Q = Matrix(QQ, zero_matrix(M.nrows(), M.ncols()))
    for p in P:
        # Initialization of the temporary matrix.
        Rs = Matrix(QQ, zero_matrix(M.nrows(), M.ncols()))
        # Initialization of the first vector.
        # the implementation assumes that the first vector is non zero
        Rs[0,:]=M[p[0],:]
        for i in range(1,M.nrows()):
            v=M[p[i],:]
            v = v-sum([(v*Rs[p[j],:].transpose())[0,0]/sum(Rs[p[j],s]^2 for s in range(Rs.ncols()))*Rs[p[j],:] for j in range(i) if not sum(Rs[p[j],s]^2 for s in range(Rs.ncols())).is_zero()])
            Rs[p[i],:] = v
        tmp_err=sum(nt^2 for nt in (Rs-M).list())
        print('The current error for p= '+str(p)+' is '+str(tmp_err))
        if(tmp_err < cur_err):
            cur_err=tmp_err
            Q[:,:] = Rs[:,:]
    return [M, Q, cur_err]

def Nearest_RealColumn_Gram_Schmidt(M):
    """
    Takes a square matrix as input and returns an orthognal martix with minimal column distance.
    This function simply uses the Nearest Real Row Gram-Schmidt function.

    EXAMPLES:

    ::

        sage: Nearest_RealColumn_Gram_Schmidt(Matrix(QQ,2,2,[1, -1/2, -1, 0]))
        Distance from the zero matrix  9/4
        The current error for p= [0, 1] is 1/8
        The current error for p= [1, 0] is 1/4
        [
        [   1 -1/2]  [   1 -1/4]     
        [  -1    0], [  -1 -1/4], 1/8
        ]


    AUTHORS:
    - Edinah K. Gnang
    """
    [M, Q, cur_err]=Nearest_RealRow_Gram_Schmidt(M.transpose())
    return [M.transpose(), Q.transpose(), cur_err]

def GeneralHypermatrixConstrainedOrthogonalization(H, X):
    """
    Implements the general hypermatrix constrained orthogonalization algorithm.
    The function simply returns the solution to the corresponding constraints.


    EXAMPLES:

    ::

        sage: od=2; sz=2; Sln=GeneralHypermatrixConstrainedOrthogonalization(HM(*([sz for i in range(od)]+['h'])), HM(*([sz for i in range(od)]+['x']))); Sln
        [x00 == 1/2*(h00*h10 - h01*h11)/x10, x01 == -1/2*(h00*h10 - h01*h11)/x11]
        sage: H=HM(*([sz for i in range(od)]+['x'])).subs(dict([(s.lhs(),s.rhs()) for s in Sln]))
        sage: Prod(*[H.transpose(od-i) for i in range(od)])
        [[1/4*(h00*h10 - h01*h11)^2/x10^2 + 1/4*(h00*h10 - h01*h11)^2/x11^2, 0], [0, x10^2 + x11^2]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if H.order() > 1:
        # Initializing the order and the size
        od = H.order(); szL = H.dimensions()
        # Constrained Orthogonalization procedure.
        DltL=GeneralHypermatrixKroneckerDeltaL(od,szL[0])
        Dlt=sum(DltL)
        # Loop initializing the hypermartrix enrtry list 
        Lx=[]; Lh=[]
        for t in range(H.n(1)):
            Lx=Lx+((HM(*(szL+['one']))-Dlt).elementwise_product(ProdB(*([X.transpose(od-j) for j in range(od)]+[DltL[t]])))).list()
            Lh=Lh+((HM(*(szL+['one']))-Dlt).elementwise_product(ProdB(*([H.transpose(od-j) for j in range(od)]+[DltL[t]]))-(1/H.n(1))*Prod(*[H.transpose(od-j) for j in range(od)]))).list()
        # Initialization of the equation
        EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not Lx[i].is_zero()]).list()
        # Formating the constraints
        if len(X.list())==len(Set(X.list()).list()):
            VrbL=X.list()
        else:
            VrbL=Set(X.list()).list()
        [A, b]=multiplicativeConstraintFormator(EqL, VrbL)
        # Initialization of the vector of variables
        v=Matrix(SR, A.ncols(), 1, VrbL)
        # returning the solutions to the system obtained via Gauss-Jordan elimination
        return multiplicative_linear_solver(A, b, v, v)
    else :
        raise ValueError("The input hypermatrix must be order greater then 1")

def GeneralHypermatrixConstrainedOrthogonalizationII(H, X, sz):
    """
    Implements the general hypermatrix constrained orthogonalization algorithm.
    The difference with the implementation above is that we can change here the
    size of the support of the inner product. This enables orthogonalization
    of a smaller hypermatrix block. The function returns the solutions


    EXAMPLES:

    ::

        sage: od=2; sz=2; Sln=GeneralHypermatrixConstrainedOrthogonalizationII(HM(*([sz for i in range(od)]+['h'])), HM(*([sz for i in range(od)]+['x'])), 2); Sln
        [x00 == 1/2*(h00*h10 - h01*h11)/x10, x01 == -1/2*(h00*h10 - h01*h11)/x11]
        sage: H=HM(*([sz for i in range(od)]+['x'])).subs(dict([(s.lhs(),s.rhs()) for s in Sln]))
        sage: Prod(*[H.transpose(od-i) for i in range(od)])
        [[1/4*(h00*h10 - h01*h11)^2/x10^2 + 1/4*(h00*h10 - h01*h11)^2/x11^2, 0], [0, x10^2 + x11^2]]
        sage: Ha=HM(3,2,'a'); A=ZeroPadding(Ha)
        sage: Hx=HM(3,2,'x'); X=ZeroPadding(Hx)
        sage: k0,k1=var('k0,k1')
        sage: Sln=GeneralHypermatrixConstrainedOrthogonalizationII(A, X, 2)
        sage: H=Hx.subs(dict([(s.lhs(),s.rhs()) for s in Sln])).subs(dict([(k0,0), (k1,0)]))
        sage: Prod(H,H.transpose())
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if H.order() > 1:
        # Initializing the order and the size
        od = H.order(); szL = H.dimensions()
        # Constrained Orthogonalization procedure.
        DltL=GeneralHypermatrixKroneckerDeltaL(od,szL[0])
        Dlt=sum(DltL)
        # Loop initializing the hypermartrix enrtry list 
        Lx=[]; Lh=[]
        for t in range(H.n(1)):
            Lx=Lx+((HM(*(szL+['one']))-Dlt).elementwise_product(ProdB(*([X.transpose(od-j) for j in range(od)]+[DltL[t]])))).list()
            Lh=Lh+((HM(*(szL+['one']))-Dlt).elementwise_product(ProdB(*([H.transpose(od-j) for j in range(od)]+[DltL[t]]))-(1/sz)*Prod(*[H.transpose(od-j) for j in range(od)]))).list()
        # Initialization of the equation
        EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not (Lx[i].is_zero() and Lh[i].is_zero())]).list()
        # Formating the constraints
        if len(X.list())==len(Set(X.list()).list()):
            VrbL=X.list()
        else:
            VrbL=Set(X.list()).list()
        [A, b]=multiplicativeConstraintFormator(EqL, VrbL)
        # Initialization of the vector of variables
        v=Matrix(SR, A.ncols(), 1, VrbL)
        # returning the solutions to the system obtained via Gauss-Jordan elimination
        return multiplicative_linear_solver(A, b, v, v)
    else :
        raise ValueError("The input hypermatrix must be order greater then 1")

def Filmus_GnangConstrainedOrthogonalizationHM(Hm):
    """
    Implements Filmus-Gnang orthogonalization procedure.


    EXAMPLES:

    ::

        sage: Q=Filmus_GnangConstrainedOrthogonalizationHM(HM(2,2,'a')); od=Q.order() 
        sage: Prod(*[Q.transpose(od-i) for i in range(od)]).printHM()
        [:, :]=
        [1/4*(a00*a10 - a01*a11)^2/x10^2 + 1/4*(a00*a10 - a01*a11)^2/x11^2                                                                 0]
        [                                                                0                                                     x10^2 + x11^2]
        sage: Q=Filmus_GnangConstrainedOrthogonalizationHM(HM(3,3,'a')).subs(k0=0,k1=0,k2=0); od=Q.order()
        sage: Prod(*[Q.transpose(od-i) for i in range(od)]).elementwise_product(HM(3,3,'one')-HM(2,3,'kronecker'))
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if Hm.is_cubical():
        # Initialization of the parameters
        od = Hm.order()
        sz = Hm.n(0)
        Sln=GeneralHypermatrixConstrainedOrthogonalizationII(Hm, HM(*([sz for i in range(od)]+['x'])), sz)
        return HM(*([sz for i in range(od)]+['x'])).subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs() !=1 ]))
    else:
        raise ValueError("Expected a cubical  hypermatrix")

def GeneralHypermatrixConstrainedUncorrelatedTuples(Hl, Xl):
    """
    Implements the general hypermatrix constrained uncorrelated tuple  algorithm. 


    EXAMPLES:

    ::

        sage: Hl=[HM(2,2,'u'),HM(2,2,'v')]; Xl=[HM(2,2,'x'),HM(2,2,'y')] 
        sage: Sln=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl, Xl); Sln
        [x00 == 1/2*(u00*v01 - u01*v11)/y01,
         x10 == 1/2*(u10*v00 - u11*v10)/y00,
         x01 == -1/2*(u00*v01 - u01*v11)/y11,
         x11 == -1/2*(u10*v00 - u11*v10)/y10]
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))
        [[1/2*(u00*v01 - u01*v11)*y00/y01 - 1/2*(u00*v01 - u01*v11)*y10/y11, 0], [0, 1/2*(u10*v00 - u11*v10)*y01/y00 - 1/2*(u10*v00 - u11*v10)*y11/y10]]
        sage: sz=2; od=2; Hl=[HM(sz,sz,'u'),HM(sz,sz,'v')]; Xl=[HM(sz,sz,'x'),HM(sz,sz,'y')]
        sage: Sln=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl, Xl) 
        sage: (HM(sz,sz,'one')-HM(od,sz,'kronecker')).elementwise_product(Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))).printHM()
        [0 0]
        [0 0]
        sage: sz=3; od=2; Hl=[HM(sz,sz,'u'),HM(sz,sz,'v')]; Xl=[HM(sz,sz,'x'),HM(sz,sz,'y')];  Sln=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl, Xl)
        sage: Sln
        [x00 == 1/3*(2*u00*v02 - u01*v12 - u02*v22)/y02,
         x10 == 1/3*(2*u10*v02 - u11*v12 - u12*v22)/y02,
         x20 == 1/3*(2*u20*v00 - u21*v10 - u22*v20)*(2*u10*v02 - u11*v12 - u12*v22)/((2*u10*v00 - u11*v10 - u12*v20)*y02),
         x01 == -1/3*(u00*v02 - 2*u01*v12 + u02*v22)/y12,
         x11 == -1/3*(u10*v02 - 2*u11*v12 + u12*v22)/y12,
         x21 == -1/3*(u20*v00 - 2*u21*v10 + u22*v20)*(u10*v02 - 2*u11*v12 + u12*v22)/((u10*v00 - 2*u11*v10 + u12*v20)*y12),
         x02 == -1/3*(u00*v02 + u01*v12 - 2*u02*v22)/y22,
         x12 == -1/3*(u10*v02 + u11*v12 - 2*u12*v22)/y22,
         x22 == -1/3*(u20*v01 + u21*v11 - 2*u22*v21)*(u00*v02 + u01*v12 - 2*u02*v22)/((u00*v01 + u01*v11 - 2*u02*v21)*y22),
         y00 == (2*u10*v00 - u11*v10 - u12*v20)*y02/(2*u10*v02 - u11*v12 - u12*v22),
         y10 == (u10*v00 - 2*u11*v10 + u12*v20)*y12/(u10*v02 - 2*u11*v12 + u12*v22),
         y20 == (u20*v00 + u21*v10 - 2*u22*v20)*(u00*v01 + u01*v11 - 2*u02*v21)*y22/((u20*v01 + u21*v11 - 2*u22*v21)*(u00*v02 + u01*v12 - 2*u02*v22)),
         y01 == (2*u10*v00 - u11*v10 - u12*v20)*(2*u20*v01 - u21*v11 - u22*v21)*y02/((2*u20*v00 - u21*v10 - u22*v20)*(2*u10*v02 - u11*v12 - u12*v22)),
         y11 == (u10*v00 - 2*u11*v10 + u12*v20)*(u20*v01 - 2*u21*v11 + u22*v21)*y12/((u20*v00 - 2*u21*v10 + u22*v20)*(u10*v02 - 2*u11*v12 + u12*v22)),
         y21 == (u00*v01 + u01*v11 - 2*u02*v21)*y22/(u00*v02 + u01*v12 - 2*u02*v22),
         1 == (u20*v00 - 2*u21*v10 + u22*v20)*(u00*v01 - 2*u01*v11 + u02*v21)*(u10*v02 - 2*u11*v12 + u12*v22)/((u10*v00 - 2*u11*v10 + u12*v20)*(u20*v01 - 2*u21*v11 + u22*v21)*(u00*v02 - 2*u01*v12 + u02*v22)),
         1 == (u10*v00 + u11*v10 - 2*u12*v20)*(u20*v01 + u21*v11 - 2*u22*v21)*(u00*v02 + u01*v12 - 2*u02*v22)/((u20*v00 + u21*v10 - 2*u22*v20)*(u00*v01 + u01*v11 - 2*u02*v21)*(u10*v02 + u11*v12 - 2*u12*v22)),
         1 == (2*u20*v00 - u21*v10 - u22*v20)*(2*u00*v01 - u01*v11 - u02*v21)*(2*u10*v02 - u11*v12 - u12*v22)/((2*u10*v00 - u11*v10 - u12*v20)*(2*u20*v01 - u21*v11 - u22*v21)*(2*u00*v02 - u01*v12 - u02*v22))]
        sage: (HM(sz,sz,'one')-HM(od,sz,'kronecker')).elementwise_product(Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln]))))
        [[0, -1/3*u00*v01 - 1/3*u01*v11 + 2/3*u02*v21 + 1/3*(2*u10*v00 - u11*v10 - u12*v20)*(2*u20*v01 - u21*v11 - u22*v21)*(2*u00*v02 - u01*v12 - u02*v22)/((2*u20*v00 - u21*v10 - u22*v20)*(2*u10*v02 - u11*v12 - u12*v22)) - 1/3*(u10*v00 - 2*u11*v10 + u12*v20)*(u20*v01 - 2*u21*v11 + u22*v21)*(u00*v02 - 2*u01*v12 + u02*v22)/((u20*v00 - 2*u21*v10 + u22*v20)*(u10*v02 - 2*u11*v12 + u12*v22)), 0], [1/3*u10*v00 + 1/3*u11*v10 - 2/3*u12*v20 - 1/3*(u20*v00 + u21*v10 - 2*u22*v20)*(u00*v01 + u01*v11 - 2*u02*v21)*(u10*v02 + u11*v12 - 2*u12*v22)/((u20*v01 + u21*v11 - 2*u22*v21)*(u00*v02 + u01*v12 - 2*u02*v22)), 0, 0], [0, 0, 0]]
        sage: sz=2; od=3; Hl=[HM(sz,sz,sz,'u'),HM(sz,sz,sz,'v'),HM(sz,sz,sz,'w')]; Xl=[HM(sz,sz,sz,'x'),HM(sz,sz,sz,'y'),HM(sz,sz,sz,'z')]
        sage: Sln=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl, Xl); Sln
        [x000 == 1/2*(u000*v010*w010 - u010*v011*w110)/(y010*z010),
         x100 == 1/2*(u100*v110*w010 - u110*v111*w110)/(y110*z010),
         x010 == -1/2*(u000*v010*w010 - u010*v011*w110)/(y011*z110),
         x110 == -1/2*(u100*v110*w010 - u110*v111*w110)/(y111*z110),
         x001 == 1/2*(u001*v010*w011 - u011*v011*w111)/(y010*z011),
         x101 == 1/2*(u101*v100*w001 - u111*v101*w101)*(u100*v110*w010 - u110*v111*w110)*z000/((u100*v100*w000 - u110*v101*w100)*y110*z001*z010),
         x011 == -1/2*(u001*v010*w011 - u011*v011*w111)/(y011*z111),
         x111 == -1/2*(u101*v100*w001 - u111*v101*w101)*(u100*v110*w010 - u110*v111*w110)*z100/((u100*v100*w000 - u110*v101*w100)*y111*z101*z110),
         y000 == (u001*v000*w001 - u011*v001*w101)*y010*z011/((u001*v010*w011 - u011*v011*w111)*z001),
         y100 == (u100*v100*w000 - u110*v101*w100)*y110*z010/((u100*v110*w010 - u110*v111*w110)*z000),
         y001 == (u001*v000*w001 - u011*v001*w101)*y011*z111/((u001*v010*w011 - u011*v011*w111)*z101),
         y101 == (u100*v100*w000 - u110*v101*w100)*y111*z110/((u100*v110*w010 - u110*v111*w110)*z100)]
        sage: (HM(sz,sz,sz,'one')-HM(od,sz,'kronecker')).elementwise_product(Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])), Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[2].subs(dict([(s.lhs(),s.rhs()) for s in Sln]))))
        [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order and the size
    od = Hl[0].order(); dimL=[Hl[i].dimensions() for i in range(len(Hl))]
    # Constrained Orthogonalization procedure.
    DltL=GeneralHypermatrixKroneckerDeltaL(od, Hl[0].n(1))
    Dlt=sum(DltL)
    # Loop initializing the hypermartrix enrtry list 
    Lx=[]; Lh=[]
    for t in range(Hl[0].n(1)):
        Lx=Lx+((HM(*(min(dimL)+['one']))-Dlt).elementwise_product(ProdB(*([X for X in Xl]+[DltL[t]])))).list()
        Lh=Lh+((HM(*(min(dimL)+['one']))-Dlt).elementwise_product(ProdB(*([H for H in Hl]+[DltL[t]]))-(1/Hl[0].n(1))*Prod(*[H for H in Hl]))).list()
    # Initialization of the equation
    EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not Lx[i].is_zero()]).list()
    # Formating the constraints
    LstX=[]
    for x in Xl:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # returning the solutions to the system obtained via Gauss-Jordan elimination
    return multiplicative_linear_solver(A, b, v, v)

def GeneralHypermatrixConstrainedUncorrelatedTuplesII(Hl, Xl, sz):
    """
    Implements the general hypermatrix constrained uncorrelated tuple  algorithm. 


    EXAMPLES:

    ::

        sage: Hl=[HM(2,2,'u'),HM(2,2,'v')]; Xl=[HM(2,2,'x'),HM(2,2,'y')] 
        sage: Sln=GeneralHypermatrixConstrainedUncorrelatedTuplesII(Hl, Xl, 2); Sln
        [x00 == 1/2*(u00*v01 - u01*v11)/y01,
         x10 == 1/2*(u10*v00 - u11*v10)/y00,
         x01 == -1/2*(u00*v01 - u01*v11)/y11,
         x11 == -1/2*(u10*v00 - u11*v10)/y10]
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))
        [[1/2*(u00*v01 - u01*v11)*y00/y01 - 1/2*(u00*v01 - u01*v11)*y10/y11, 0], [0, 1/2*(u10*v00 - u11*v10)*y01/y00 - 1/2*(u10*v00 - u11*v10)*y11/y10]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order and the size
    od = Hl[0].order(); dimL=[Hl[i].dimensions() for i in range(len(Hl))]
    # Constrained Orthogonalization procedure.
    DltL=GeneralHypermatrixKroneckerDeltaL(od, Hl[0].n(1))
    Dlt=sum(DltL)
    # Loop initializing the hypermartrix enrtry list 
    Lx=[]; Lh=[]
    for t in range(Hl[0].n(1)):
        #Lx=Lx+((apply(HM,dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[X for X in Xl]+[DltL[t]]))).list()
        Lx=Lx+((HM(*(min(dimL)+['one']))-Dlt).elementwise_product(ProdB(*([X for X in Xl]+[DltL[t]])))).list()
        #Lh=Lh+((apply(HM,dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[H for H in Hl]+[DltL[t]])-(1/sz)*apply(Prod,[H for H in Hl]))).list()
        Lh=Lh+((HM(*(min(dimL)+['one']))-Dlt).elementwise_product(ProdB(*([H for H in Hl]+[DltL[t]]))-(1/sz)*Prod(*[H for H in Hl]))).list()
    # Initialization of the equation
    EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not (Lx[i].is_zero() and Lh[i].is_zero())]).list()
    # Formating the constraints
    LstX=[]
    for x in Xl:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # returning the solutions to the system obtained via Gauss-Jordan elimination
    return multiplicative_linear_solver(A, b, v, v)

def GeneralHypermatrixPerturbedUncorrelatedTuples(Hl, Xl, A):
    """
    Implements the general hypermatrix perturbation algorithm.


    EXAMPLES:

    ::

        sage: Hl=[HM(2,2,'u'), HM(2,2,'u').inverse()]; Xl=[HM(2,2,'x'), HM(2,2,'y')] 
        sage: Sln=GeneralHypermatrixPerturbedUncorrelatedTuples(Hl, Xl, HM(2,2,'a')); Sln
        [x00 == 1/2*(a01 + 2*u01/(u01*u10/u00 - u11))/y01,
         x10 == 1/2*(2*u10*(1/u00 - u01*u10/(u00^2*(u01*u10/u00 - u11))) + a10)/y00,
         x01 == 1/2*(a01 - 2*u01/(u01*u10/u00 - u11))/y11,
         x11 == 1/2*(a10 + 2*u10*u11/(u00*(u01*u10/u00 - u11)))/y10] 
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))[0,1].simplify_rational()
        a01 
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))[1,0].simplify_rational()
        a10 
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order and the size
    od = Hl[0].order(); dimL=[Hl[i].dimensions() for i in range(len(Hl))]
    # Constrained Orthogonalization procedure.
    DltL=GeneralHypermatrixKroneckerDeltaL(od,Hl[0].n(1))
    Dlt=sum(DltL)
    # Loop initializing the hypermartrix enrtry list 
    Lx=[]; Lh=[]
    for t in range(Hl[0].n(1)):
        #Lx=Lx+((apply(HM, dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[X for X in Xl]+[DltL[t]]))).list()
        Lx=Lx+((HM(*(dimL[t]+['one']))-Dlt).elementwise_product(ProdB(*([X for X in Xl]+[DltL[t]])))).list()
        #Lh=Lh+((apply(HM, dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[H for H in Hl]+[DltL[t]])+(1/Hl[0].n(1))*A)).list()
        Lh=Lh+((HM(*(dimL[t]+['one']))-Dlt).elementwise_product(ProdB(*([H for H in Hl]+[DltL[t]]))+(1/Hl[0].n(1))*A)).list()
    # Initialization of the equation
    EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not Lx[i].is_zero()]).list()
    # Formating the constraints
    LstX=[]
    for x in Xl:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # returning the solutions to the system obtained via Gauss-Jordan elimination
    return multiplicative_linear_solver(A, b, v, v)

def GeneralHypermatrixPerturbedUncorrelatedTuplesII(Hl, Xl, A, sz):
    """
    Implements the general hypermatrix perturbation algorithm.


    EXAMPLES:

    ::

        sage: Hl=[HM(2,2,'u'), HM(2,2,'u').inverse()]; Xl=[HM(2,2,'x'), HM(2,2,'y')] 
        sage: Sln=GeneralHypermatrixPerturbedUncorrelatedTuplesII(Hl, Xl, HM(2,2,'a'), 2); Sln
        [x00 == 1/2*(a01 + 2*u01/(u01*u10/u00 - u11))/y01,
         x10 == 1/2*(2*u10*(1/u00 - u01*u10/(u00^2*(u01*u10/u00 - u11))) + a10)/y00,
         x01 == 1/2*(a01 - 2*u01/(u01*u10/u00 - u11))/y11,
         x11 == 1/2*(a10 + 2*u10*u11/(u00*(u01*u10/u00 - u11)))/y10] 
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))[0,1].simplify_rational()
        a01 
        sage: Prod(Xl[0].subs(dict([(s.lhs(),s.rhs()) for s in Sln])),Xl[1].subs(dict([(s.lhs(),s.rhs()) for s in Sln])))[1,0].simplify_rational()
        a10 
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order and the size
    od = Hl[0].order(); dimL=[Hl[i].dimensions() for i in range(len(Hl))]
    # Constrained Orthogonalization procedure.
    DltL=GeneralHypermatrixKroneckerDeltaL(od,Hl[0].n(1))
    Dlt=sum(DltL)
    # Loop initializing the hypermartrix enrtry list 
    Lx=[]; Lh=[]
    for t in range(Hl[0].n(1)):
        #Lx=Lx+((apply(HM, dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[X for X in Xl]+[DltL[t]]))).list()
        Lx=Lx+((HM(*(dimL[t]+['one']))-Dlt).elementwise_product(ProdB(*([X for X in Xl]+[DltL[t]])))).list()
        #Lh=Lh+((apply(HM, dimL[t]+['one'])-Dlt).elementwise_product(apply(ProdB,[H for H in Hl]+[DltL[t]])+(1/sz)*A)).list()
        Lh=Lh+((HM(*(dimL[t]+['one']))-Dlt).elementwise_product(ProdB(*([H for H in Hl]+[DltL[t]]))+(1/sz)*A)).list()
    # Initialization of the equation
    EqL=Set([Lx[i]==Lh[i] for i in range(len(Lx)) if not (Lx[i].is_zero() and Lh[i].is_zero())]).list()
    # Formating the constraints
    LstX=[]
    for x in Xl:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # returning the solutions to the system obtained via Gauss-Jordan elimination
    return multiplicative_linear_solver(A, b, v, v) 

def matrix_conjugate_orthogolaization(M, dgts=10, normalized=False):
    """
    Outputs an unitary matrix of the original
    input numerical square matrix. Output matrix
    column-wise orthogonal.

     EXAMPLES:

    ::

        sage: He=0.002*HM([[2,1,1],[4,3,1],[8,7,9]]); t=pi/3
        sage: U=\
        sage: HM([[cos(t),-sin(t),0],[sin(t),cos(t),0],[0,0,1]])*\
        sage: HM([[cos(t),0,-sin(t)],[0,1,0],[sin(t),0,cos(t)]])*\
        sage: HM([[1,0,0],[0,cos(t),-sin(t)],[0,sin(t),cos(t)]])
        sage: M=(U+He).numerical(25)
        sage: Q = matrix_conjugate_orthogolaization(M); Prod(Q.transpose(),Q).printHM()
        [:, :]=
        [    1.0285 -9.5367e-7 -9.5367e-7]
        [-9.5367e-7     1.0535 -2.3842e-7]
        [-9.5367e-7 -2.3842e-7    0.97568]


    AUTHORS:
    - Fan Tian and Edinah K. Gnang
    """
    sz=M.ncols()
    M=M.numerical(dgts)
    # Check if initial input matrix is orthogonal
    Mp=M*(((M.conjugate_transpose()*M).elementwise_product(HM(2,sz,'kronecker'))).elementwise_exponent(-1/2))
    T=(Mp.conjugate_transpose()*Mp)
    if ((T-HM(2,sz,'kronecker')).numerical(dgts)).norm() < 10^(-1*dgts):
        Hh=M
        if normalized is True:
            Hh=Mp
    else:
        # Intialization of the unknown variables
        Hr=HM(sz,sz,'r'); Ht=HM(sz,sz,'theta')
        VrbL0=Hr.listHM(); VrbL1=Ht.listHM()
        # Intialization of the unknown complex matrix
        Hh=HM(sz,sz,[Hr[i,j]*exp(I*Ht[i,j]) for j in rg(sz) for i in rg(sz)])
        # Initialization of the list of Modulus constraints
        EqL0=[[Hr[t,u]*Hr[t,v]  == abs(conjugate(M[t,u])*M[t,v]-sum(conjugate(M[s,u])*M[s,v] for s in rg(sz))/sz) for u in rg(sz) for v in rg(sz) if u<v] for t in rg(sz)]
        # Initialization of the list of Arguments constraints
        EqL1=[[-Ht[t,u]+Ht[t,v] == arg(conjugate(M[t,u])*M[t,v]-sum(conjugate(M[s,u])*M[s,v] for s in rg(sz))/sz) for u in rg(sz) for v in rg(sz) if u<v] for t in rg(sz)]
        # Solve list of Modulus constraints
        Slnr=[]
        for i in rg(sz):
            [Ai,bi]=multiplicativeConstraintFormatorHM(EqL0[i], VrbL0[i])
            Mx=HM(Ai.ncols(),1,VrbL0[i]);Mv=HM(Ai.ncols(),1,VrbL0[i])
            Slnr.append([eq.lhs()==eq.rhs().subs([v==0 for v in var_list('k',sz)]) for eq in multiplicative_linear_solverHM(Ai,bi,Mx,Mv)])
        # Solve list of Aruguments constraints
        Slnt=[]
        for i in rg(sz):
            [Ai,bi]=ConstraintFormatorHM(EqL1[i], VrbL1[i])
            Mx=HM(Ai.ncols(),1,VrbL1[i]);Mv=HM(Ai.ncols(),1,VrbL1[i])
            sln=linear_solverHM(Ai,bi,Mx,Mv)
            Slnt.append([eq.lhs()==eq.rhs().subs([v==0 for v in Ht.list()]) for eq in sln])
        # Performing substitution
        for i in rg(sz):
            Hh=Hh.subs([eq for eq in Slnr[i] if not eq.lhs() == 1])
            Hh=Hh.subs([eq for eq in Slnt[i] if not eq.lhs() == 0])
        Hh=Hh.subs([v==1 for v in Hr.list()]).real()
        Hh=Hh.subs([v==0 for v in Ht.list()]).real()
        if normalized is True:
            # Normalize diagonal entries
            Hh=Hh*(((Hh.conjugate_transpose()*Hh).elementwise_product(HM(2,sz,'kronecker'))).elementwise_exponent(-1/2))
    return Hh.numerical(dgts)

def hypermatrix_orthogonalization(Ha, dgts=10, normalized=False):
    """
    Outputs a thrid order orthogonal hypermatrix derived from the
    input cubic numerical hypermatrix.

     EXAMPLES:

    ::

        sage: sz=2; He=0.02*HM([[[0.0280,0.0140], [0.0440,0.0020]], [[-0.0140,0.0000], [0.0020,0.0020]]]); t,x,y=var('t, x, y'); dgts=15
        sage: A=(Orthogonal2x2x2Hypermatrix(t,x,y).subs(t=pi/2, x=1, y=1)+He).numerical(dgts)
        sage: Q=hypermatrix_orthogonalization(A, dgts)
        sage: Prod(Q.transpose(2), Q.transpose(), Q).printHM()
        [:, :, 0]=
        [  3.18079313432961e13 -2.77555756156289e-17]
        [-2.77555756156289e-17     0.000000000000000]
        
        [:, :, 1]=
        [-2.77555756156289e-17     0.000000000000000]
        [    0.000000000000000      2.00000000000000]


    AUTHORS:
    - Fan Tian, Edinah K. Gnang
    """
    sz=Ha.dimensions()[0]
    # Intialization of unknown variables
    Hx=HM(sz,sz,sz,'x')
    # Form list of constraints
    EqL=[[Hx[t,k,i]*Hx[t,i,j]*Hx[t,j,k] == Ha[t,k,i]*Ha[t,i,j]*Ha[t,j,k]-sum(Ha[s,k,i]*Ha[s,i,j]*Ha[s,j,k] for s in rg(sz))/sz for i in rg(sz) for j in rg(sz) for k in rg(sz) if Set([i,j,k]).cardinality() > 1] for t in rg(sz)]
    # Solve list of constraints
    SlnL=[]
    for i in rg(sz):
        EqLi = [eq.lhs() ==  eq.rhs() for eq in EqL[i] if not eq.rhs().is_zero()]
        VrbLi=Hx.slice([i],0).list()
        [Ai,bi]=multiplicativeConstraintFormatorHM(EqLi, VrbLi)
        Mx=HM(Ai.ncols(),1,VrbLi); Mv=HM(Ai.ncols(),1,VrbLi)
        SlnL.append([eq.lhs()==eq.rhs().subs([v==0 for v in var_list('k', sz^2)]) for eq in multiplicative_linear_solverHM(Ai,bi,Mx,Mv)])
    # Performing substitution
    X=Hx.copy()
    for i in rg(sz):
        X=X.subs([eq for eq in SlnL[i] if not eq.lhs() == 1])
    X=X.subs([v==1 for v in Hx.list()])
    if normalized:
        # Normalizing diagonal entries
        X2=X.copy()
        # Scale diagonal entries
        for t in rg(sz):
            for i in rg(sz):
                X2[t,i,i] = X[t,i,i]/(Prod(X.transpose(2),X.transpose(),X)[i,i,i])^(1/3)
        X=X2.copy()
    if dgts == None:
        return(X)
    else:
        return(X.numerical(dgts))

def TriangulationCompositionStringList(n, c):
    """
    Outputs a composition list of strings associated with triangulations

     EXAMPLES:

    ::

        sage: sz=4; A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,'one')-HM(2,sz,'kronecker'))
        sage: for i0 in range(1,sz):
        ....:   for i1 in range(i0):
        ....:       A[i0,i1]=0
        sage: L = TriangulationCompositionStringList(sz-1,'A'); L
        ['A.elementwise_product(Prod(A, A.elementwise_product(Prod(A, A))))',
         'A.elementwise_product(Prod(A.elementwise_product(Prod(A, A)), A))'] 
        sage: eval(L[0])
        [[0, 0, 0, a01*a03*a12*a13*a23], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
        sage: eval(L[1])
        [[0, 0, 0, a01*a02*a03*a12*a23], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

    AUTHORS:

    - Edinah K. Gnang
    """
    if n == 1:
        return [c]
    else:
        gu = []
        for i in range(1,n):
            gu = gu+[c+".elementwise_product(Prod("+g1+", "+g2+"))" for g1 in TriangulationCompositionStringList(i,c) for g2 in TriangulationCompositionStringList(n-i,c)]
        return gu

def Triangulations(A,Ha,n,sz):
    """
    Outputs a list of second order hypermatrices each of which have a single nonzero symbolic entry which
    describes a triangulation of a regular polygon on n vertices. The input matrix is meant to be 
    upper-triangular matrices.

     EXAMPLES:

    ::

        sage: sz=4
        sage: A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,'one')-HM(2,sz,'kronecker'))
        sage: for i0 in range(1,sz):
        ....:   for i1 in range(i0):
        ....:       A[i0,i1]=0
        sage: L=Triangulations(A,A,sz-1,sz)
        sage: L[0]
        [[0, 0, 0, a01*a03*a12*a13*a23], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

    AUTHORS:

    - Edinah K. Gnang
    """
    if n == 1:
        return [A]
    else:
        gu = []
        for i in range(1,n):
            gu = gu+[Ha.elementwise_product(Prod(g1,g2)).expand() for g1 in Triangulations(A,Ha,i,sz) for g2 in Triangulations(A,Ha,n-i,sz)]
        return gu

def TriangulationsII(A,Ha,n,sz):
    """
    Outputs a list of second order hypermatrices each of which have a single nonzero symbolic entry which
    describes a triangulation of a regular polygon on n vertices. The input matrix is meant to be 
    upper-triangular matrices. The difference with the implementaiton above is that we do not expand the
    polynomials. This implementation is well suited for non commuting variables defined over free fields.

     EXAMPLES:

    ::

        sage: sz=4
        sage: A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,'one')-HM(2,sz,'kronecker'))
        sage: for i0 in range(1,sz):
        ....:   for i1 in range(i0):
        ....:       A[i0,i1]=0
        sage: L=TriangulationsII(A,A,sz-1,sz)
        sage: L[0]
        [[0, 0, 0, a01*a03*a12*a13*a23], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

    AUTHORS:

    - Edinah K. Gnang
    """
    if n == 1:
        return [A]
    else:
        gu = []
        for i in range(1,n):
            gu = gu+[Prod(g1,g2).elementwise_product(Ha) for g1 in TriangulationsII(A,Ha,i,sz) for g2 in TriangulationsII(A,Ha,n-i,sz)]
        return gu

def generate_triangulation_script(sz):
    """
    Creates a sage file which corresponds to a script
    which computes triangulation using non-commutative
    variables. The script starts with a stricly upper-
    triangular symbolic adjacency matrix whose non-
    zero entries defined as free variables.


    EXAMPLES:

    ::

        sage: generate_triangulation_script(4)
        sage: load('triangulation_4.sage')
        sage: L[0].printHM()
        [:, :]=
        [                  0                   0                   0 a01*a12*a23*a13*a03]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: L[1].printHM()
        [:, :]=
        [                  0                   0                   0 a01*a12*a02*a23*a03]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: from subprocess import call
        sage: call("rm triangulation_4.sage", shell=True)
        0

        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrices.
    A=HM(sz,sz,'a')
    for i in rg(sz):
        for j in rg(sz):
            if i >= j:
                A[i,j]=0
    Al=[HM(sz,sz,'a')[i,j] for i in rg(sz) for j in rg(sz) if i<j]
    # Creating the file name string.
    filename='triangulation_'+str(sz)+'.sage'
    # Opening the file
    f=open(filename,'w')
    #f.write('# Loading the Hypermatrix Package\n')
    #f.write("load('./Hypermatrix_Algebra_tst.sage')\n\n")
    f.write('# Initializing the number of constraints and the number of variableas\n')
    f.write('sz='+str(sz)+'\n\n')
    f.write('# Initialization of the variables\n')
    f.write("La=[HM(sz,sz,'a')[i,j] for i in rg(sz) for j in rg(sz) if i<j]\n")
    f.write('# Initializing the free variables\n')
    f.write('F=FreeAlgebra(QQ,len(La),La)\n')
    f.write('F.<'+str(Al)[1:len(str(Al))-1]+'>=FreeAlgebra(QQ,len(La))\n\n')
    f.write('# Initialization of the hypermatrices with symbolic variable entries which do not commute\n')
    f.write('Ha=HM(sz,sz,'+str(A.list())+')\n')
    f.write('L=TriangulationsII(Ha,Ha,sz-1,sz)')
    # Closing the file
    f.close()

def TriangulationGraphsEdgeList(sz):
    """
    Takes as input the size paramater which corresponds to the number of vertices of the graph
    and outputs list of triangulation of the convex regular polygon. Each graph in the list
    is describe by as a list of edges.
    
     EXAMPLES:

    ::

        sage: TriangulationGraphsEdgeList(4)
        [[a01, a03, a12, a13, a23], [a01, a02, a03, a12, a23]]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix 
    A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,'one')-HM(2,sz,'kronecker'))
    for i0 in range(1,sz):
        for i1 in range(i0):
            A[i0,i1]=0
    # Computing the list of triangulations
    L=Triangulations(A,A,sz-1,sz)
    # Initializing the list which will store triangulations
    # as a list of edges  
    list_of_graphs=[]
    for h in L:
        list_of_graphs.append((Set(h.list()).list())[1].operands())
    return list_of_graphs

def TriangulationGraphsAdjacencyMatrix(sz):
    """
    Takes as input the size paramater which corresponds to the number of vertices of the graph
    and outputs list of triangulation of the convex regular polygon. Each graph in the list
    is describe by its adjacency matrix.
    
     EXAMPLES:

    ::

        sage: TriangulationGraphsAdjacencyMatrix(4)
        [
        [0 1 0 1]  [0 1 1 1]
        [1 0 1 1]  [1 0 1 0]
        [0 1 0 1]  [1 1 0 1]
        [1 1 1 0], [1 0 1 0]
        ]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Obtaining the list of triangles from edge list
    L=TriangulationGraphsEdgeList(sz)
    # Initializing the list of graphs
    list_of_graphs=[]
    for l in L:
        Ha=HM(sz,sz,'a'); Ht=HM(sz,sz,'zero')
        for i in range(1,sz):
            for j in range(i):
                if Ha[j,i] in l:
                    Ht[j,i]=1; Ht[i,j]=1
        # Initialization of the result
        list_of_graphs.append(Matrix(SR,Ht.listHM()))
    return list_of_graphs

def TriangulationGraphsTriangleList(sz):
    """
    Takes as input the size paramater which corresponds to the number of vertices of the graph
    and outputs list of triangulation of the convex regular polygon. Each graph in the list
    is describe by as a list of triangle specified by their edges.
    
     EXAMPLES:

    ::

        sage: len(TriangulationGraphsTriangleList(6))
        14


    AUTHORS:

    - Edinah K. Gnang
    """
    # Obtaining the list of triangles from edge list
    L=TriangulationGraphsEdgeList(sz)
    # Initializing the list of graphs
    list_of_graphs=[]
    for l in L:
        # Initializing the color variables
        Ha=HM(sz,sz,'a')
        # Initialzing the colored hypermatrix
        Ht=Ha
        for i in range(sz):
            for j in range(sz):
                if Ha[i,j] not in l:
                    Ht[i,j]=0
        # Initialization of the result
        Hr=GeneralHypermatrixHadamardProduct(Prod(Ht,Ht),Ht)
        list_of_graphs.append([f.operands() for f in Set(Hr.list()).difference(Set([0])).list()])
    return list_of_graphs

def TriangulationGraphsDualAdjacencyMatrixList(sz):
    """
    Takes as input the size paramater which corresponds to the number of vertices of the graph
    and outputs list of descriptions of triangulation of the convex regular polygon. Each list
    is made up of a dual adjancency matrix followed by list of triangle specified by their edges.
    
     EXAMPLES:

    ::

        sage: len(TriangulationGraphsDualAdjacencyMatrixList(5))
        5
        
    AUTHORS:
    - Edinah K. Gnang
    """
    # Obtaining the list of graphs as list of triangles
    L = TriangulationGraphsTriangleList(sz)
    L2= TriangulationGraphsEdgeList(sz)
    list_of_graphs=[]
    for l in range(len(L)):
        # Initialization of the temporary adjacency matrix
        TmpA = Matrix(SR,HM(sz-2,sz-2,'zero').listHM())
        for i in range(1,len(L[l])):
            for j in range(i):
                if not Set(L[l][i]).intersection(Set(L[l][j])).is_empty():
                    TmpA[i,j]=1; TmpA[j,i]=1
        list_of_graphs.append([copy(TmpA),L2[l],L[l]]) 
    return list_of_graphs

def TriangulationListing(A,B,m,sz):
    """
    Outputs a list of third order hypermatrices of size sz x sz x 1 each describing a
    triangulation of a regular polygon on n vertices. The input hypermatrix A of size
    sz x sz x 1 is meant to be a symbolic upper-triangular with free variable entries.
    defined over free fields. This implements is construct centric.


     EXAMPLES:

    ::

        sage: sz=4;a01,a02,a03,a12,a13,a23,b01,b02,b03,b12,b13,b23,c01,c02,c03,c12,c13,c23,z0,z1=\
        ....: var('a01,a02,a03,a12,a13,a23,b01,b02,b03,b12,b13,b23,c01,c02,c03,c12,c13,c23,z0,z1')
        sage: F=FreeAlgebra(QQ,20,[a01,a02,a03,a12,a13,a23,b01,b02,b03,b12,b13,b23,c01,c02,c03,c12,c13,c23,z0,z1])
        sage: F.<a01,a02,a03,a12,a13,a23,b01,b02,b03,b12,b13,b23,c01,c02,c03,c12,c13,c23,z0,z1>=FreeAlgebra(QQ,20)
        sage: A=HM(sz,sz,1,[QQ(0),QQ(0),QQ(0),QQ(0),a01,QQ(0),QQ(0),QQ(0),a02,a12,QQ(0),QQ(0),a03,a13,a23,0])
        sage: Tb=HM(sz,sz,[QQ(0),QQ(0),QQ(0),QQ(0),b01,QQ(0),QQ(0),QQ(0),b02,b12,QQ(0),QQ(0),b03,b13,b23,0])
        sage: B=HM(sz,sz,sz,[Tb[i,j] for k in rg(sz) for j in rg(sz) for i in rg(sz)])*z0*z1
        sage: len(TriangulationListing(A,B,sz-1,sz))
        2


    AUTHORS:

    - Edinah K. Gnang
    """
    if m == 1:
        return [A]
    else:
        gu = []
        for i in range(1,m):
            gu = gu+[GProdII([g1,B,g2],sum,[z0,z1],1) for g1 in TriangulationListing(A,B,i,sz) for g2 in TriangulationListing(A,B,m-i,sz)]
        return gu

def generate_triangulation_scriptII(sz):
    """
    Creates a sage file which corresponds to a script
    which computes triangulation using non-commutative
    variables. The script starts with a stricly upper-
    triangular symbolic adjacency matrix whose non-
    zero entries are defined as free variables.
    this implementation is construct centric


    EXAMPLES:

    ::

        sage: generate_triangulation_scriptII(4)
        sage: load('triangulation_4.sage')
        sage: L[0].printHM()
        [:, :, 0]=
        [                  0                   0                   0 b03*a01*b13*a12*a23]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: L[1].printHM()
        [:, :, 0]=
        [                  0                   0                   0 b03*b02*a01*a12*a23]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: from subprocess import call
        sage: call("rm triangulation_4.sage", shell=True)
        0
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrices and the construct variables
    A=HM(sz,sz,'a'); TpB=HM(sz,sz,'b'); z0,z1=var('z0,z1')
    for i in rg(sz):
        for j in rg(sz):
            if i >= j:
                A[i,j]=0; TpB[i,j]=0
    B=HM(sz,sz,sz,[TpB[i,j] for k in rg(sz) for j in rg(sz) for i in rg(sz)])
    # Initialization of the list which will store the variable to be set free
    Al=[HM(sz,sz,'a')[i,j] for i in rg(sz) for j in rg(sz) if i<j]
    Bl=[HM(sz,sz,'b')[i,j] for i in rg(sz) for j in rg(sz) if i<j]
    Zl=[z0,z1]
    # Creating the file name string.
    filename='triangulation_'+str(sz)+'.sage'
    # Opening the file
    f=open(filename,'w')
    f.write('# Loading the Hypermatrix Package\n')
    f.write("load('./Hypermatrix_Algebra_0.0.1.sage')\n\n")
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n\n')
    f.write('# Initialization of the variables\n')
    f.write("z0,z1=var('z0,z1')\n")
    f.write("La=[HM(od,sz,'a','sym')[i,j] for i in rg(sz) for j in rg(sz) if i<j]\n")
    f.write("Lb=[HM(od,sz,'b','sym')[i,j] for i in rg(sz) for j in rg(sz) if i<j]\n")
    f.write("Lz=[z0,z1]\n\n")
    f.write('# Initializing the free variables\n')
    f.write('F=FreeAlgebra(QQ,len(La+Lb+Lz),La+Lb+Lz)\n')
    f.write('F.<'+str(Al+Bl+Zl)[1:len(str(Al+Bl+Zl))-1]+'>=FreeAlgebra(QQ,len(La+Lb+Lz))\n\n')
    f.write('# Initialization of the hypermatrices with symbolic variable entries which do not commute\n')
    f.write('Ha=HM(sz,sz,1,'+str(A.list())+')\n')
    f.write('Hb=HM(sz,sz,sz,'+str(B.list())+')*z0*z1\n\n')
    f.write('# Obtaining the triangulations\n')
    f.write('L=TriangulationListing(Ha,Hb,sz-1,sz)')
    # Closing the file
    f.close()

def generate_triangulation_scriptIII(sz):
    """
    Creates a sage file which corresponds to a script
    which computes triangulation using non-commutative
    variables. The script starts with a stricly upper-
    triangular symbolic adjacency matrix whose non-
    zero entries are defined as free variables.
    this implementation is construct centric


    EXAMPLES:

    ::

        sage: generate_triangulation_scriptIII(4)
        sage: load('triangulation_4.sage')
        sage: L[0].printHM()
        [:, :, 0]=
        [                  0                   0                   0 a01*a12*a23*b13*b03]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: L[1].printHM()
        [:, :, 0]=
        [                  0                   0                   0 a01*a12*b02*a23*b03]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        [                  0                   0                   0                   0]
        sage: from subprocess import call
        sage: call("rm triangulation_4.sage", shell=True)
        0
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrices and the construct variables
    A=HM(sz,sz,'a'); TpB=HM(sz,sz,'b'); z0,z1=var('z0,z1')
    for i in rg(sz):
        for j in rg(sz):
            if i >= j:
                A[i,j]=0; TpB[i,j]=0
    B=HM(sz,sz,sz,[TpB[i,j] for k in rg(sz) for j in rg(sz) for i in rg(sz)])
    # Initialization of the list which will store the variable to be set free
    Al=[HM(sz,sz,'a')[i,j] for i in rg(sz) for j in rg(sz) if i<j]
    Bl=[HM(sz,sz,'b')[i,j] for i in rg(sz) for j in rg(sz) if i<j]
    Zl=[z0,z1]
    # Creating the file name string.
    filename='triangulation_'+str(sz)+'.sage'
    # Opening the file
    f=open(filename,'w')
    f.write('# Loading the Hypermatrix Package\n')
    f.write("load('./Hypermatrix_Algebra_0.0.1.sage')\n\n")
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n\n')
    f.write('# Initialization of the variables\n')
    f.write("z0,z1=var('z0,z1')\n")
    f.write("La=[HM(od,sz,'a','sym')[i,j] for i in rg(sz) for j in rg(sz) if i<j]\n")
    f.write("Lb=[HM(od,sz,'b','sym')[i,j] for i in rg(sz) for j in rg(sz) if i<j]\n")
    f.write("Lz=[z0,z1]\n\n")
    f.write('# Initializing the free variables\n')
    f.write('F=FreeAlgebra(QQ,len(La+Lb+Lz),La+Lb+Lz)\n')
    f.write('F.<'+str(Al+Bl+Zl)[1:len(str(Al+Bl+Zl))-1]+'>=FreeAlgebra(QQ,len(La+Lb+Lz))\n\n')
    f.write('# Initialization of the hypermatrices with symbolic variable entries which do not commute\n')
    f.write('Ha=HM(sz,sz,1,'+str(A.list())+')\n')
    f.write('Hb=z0*z1*HM(sz,sz,sz,'+str(B.list())+')\n\n')
    f.write('# Obtaining the triangulations\n')
    f.write('L=TriangulationListing(Ha,Hb,sz-1,sz)')
    # Closing the file
    f.close()

def Tetrahedralizations(A,B,n,sz):
    """
    Outpts a list of hypermatrices whoes nonzero symbolic entries describes
    a tetrahedral partition of a regular convex polytope on n vertices.
    In order to avoid degenerate hyperedges in the triangulation induced
    by the BM algebra, the input hypermatrix should be of the type illustrated
    in the example bellow.

     EXAMPLES:

    ::

        sage: sz=4; S=HM(sz,sz,sz,'zero')
        sage: for i in range(sz):
        ....:   for j in range(sz):
        ....:       for k in range(sz):
        ....:           if i<j and j<k:
        ....:               S[i,j,k]=1; S[i,k,j]=1
        sage: A=HM(sz,sz,sz,'a').elementwise_product(S)
        sage: L=Tetrahedralizations(A,A,sz-1,sz)
        sage: len(L)
        1

    AUTHORS:
    - Edinah K. Gnang
    """
    if n == 1:
        return [A]
    else:
        gu = []
        for i in range(1,n,2):
            for j in range(1,n-i,2):
                gu=gu+[B.elementwise_product(Prod(g1,g2,g3)).expand() for g1 in Tetrahedralizations(A,B,i,sz) for g2 in Tetrahedralizations(A,B,j,sz) for g3 in Tetrahedralizations(A,B,n-(i+j),sz)]
        return gu

def RandomTriangulation(A,Ha,n,sz):
    """
    Outpts a list of second order hypermatrices each of which have a single nonzero symbolic entry which
    describes a triangulation of a regular polygon on n vertices. The input matrix is meant to be 
    upper-triangular matrices.

     EXAMPLES:

    ::

        sage: sz=3
        sage: A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,'one')-HM(2,sz,'kronecker'))
        sage: for i0 in range(1,sz):
        ....:   for i1 in range(i0):
        ....:       A[i0,i1]=0
        sage: L=RandomTriangulation(A,A,sz-1,sz)
        

    AUTHORS:
    - Edinah K. Gnang
    """
    if n == 1:
        return [A]
    else:
        gu = []
        j = RollLD([Ca(i)*Ca(n-i) for i in range(1,n+1)])
        return [Ha.elementwise_product(Prod(g1,g2)).expand() for g1 in RandomTriangulation(A,Ha,j,sz) for g2 in RandomTriangulation(A,Ha,n-j,sz)]

def SecondOrderDFT(m,n):
    """
    outputs second order uncorrelated pair of second order
    hypermatrices classically associated with the Discrete
    Fourier Transform.
    

    EXAMPLES:
 
    ::

        sage: [Ha, Hb]=SecondOrderDFT(2,2)
        sage: Ha
        [[1, 1], [1, -1]]
        sage: Hb
        [[1, 1], [1, -1]]
        sage: Prod(Ha,Hb).simplify()
        [[2, 0], [0, 2]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the hypermatrices
    Ha=HM(n,m,[exp( I*2*pi*u*t/m) for t in range(m) for u in range(n)])
    Hb=HM(m,n,[exp(-I*2*pi*t*v/m) for v in range(n) for t in range(m)])
    return [Ha, Hb]

def SecondOrderDFT2(n):
    """
    outputs second order uncorrelated pair of second order
    hypermatrices classically associated with the Discrete
    Fourier Transform.
    

    EXAMPLES:
 
    ::

        sage: [Ha, Hb]=SecondOrderDFT2(2)
        sage: Prod(Ha,Hb).printHM()
        [:, :]=
        [[2] [0]]
        [[0] [2]]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if n==2:
        # Initialization of the hypermatrices
        Ha=HM(n,n,[Matrix(SR,1,1,exp(I*2*pi*u*t/n)) for t in range(n) for u in range(n)])
        Hb=HM(n,n,[Matrix(SR,1,1,exp(I*2*pi*u*t/n)) for t in range(n) for u in range(n)])
    elif n>2:
        # Initialization of the hypermatrices
        Ha=HM(n,n,[Matrix(SR,[[cos(2*pi*u*t/n),-sin(2*pi*u*t/n)],[ sin(2*pi*u*t/n),cos(2*pi*u*t/n)]]) for t in range(n) for u in range(n)])
        Hb=HM(n,n,[Matrix(SR,[[cos(2*pi*u*t/n), sin(2*pi*u*t/n)],[-sin(2*pi*u*t/n),cos(2*pi*u*t/n)]]) for t in range(n) for u in range(n)])
    return [Ha, Hb]

def ThirdOrderDFT(m,n):
    """
    outputs third order uncorrelated tuple of third order
    hypermatrices generalizing the classical Discrete
    Fourier Transform matrix. The input m is associated
    with the order of the root of unity and the input n
    correspond to the size of the matrix.
    

    EXAMPLES:
 
    ::

        sage: [Ha, Hb, Hc]=ThirdOrderDFT(3,2)
        sage: Ha
        [[[1, 1], [1, 1/2*I*sqrt(3) - 1/2], [1, -1/2*I*sqrt(3) - 1/2]], [[1, 1], [1/2*I*sqrt(3) - 1/2, 1], [-1/2*I*sqrt(3) - 1/2, 1]]]
        sage: Hb
        [[[1, 1, 1], [1, 1/2*I*sqrt(3) - 1/2, -1/2*I*sqrt(3) - 1/2]], [[1, 1/2*I*sqrt(3) - 1/2, -1/2*I*sqrt(3) - 1/2], [1, 1, 1]]]
        sage: Hc
        [[[1, 1], [1, 1]], [[1, 1/2*I*sqrt(3) - 1/2], [1/2*I*sqrt(3) - 1/2, 1]], [[1, -1/2*I*sqrt(3) - 1/2], [-1/2*I*sqrt(3) - 1/2, 1]]]
        sage: Prod(Ha,Hb,Hc).simplify_full()
        [[[3, 0], [0, 0]], [[0, 0], [0, 3]]]
        sage: [Ha, Hb, Hc]=ThirdOrderDFT(5,5)
        sage: Prod(Ha,Hb,Hc).simplify_full()
        [[[5, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 5, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 5, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 5]]]
        sage: Prod(Ha,Ha.transpose(2),Ha.transpose()).simplify_full().printHM()
        [[[5, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 5, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 5, 0], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 5]]]    

 
    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the hypermatrices
    Ha=HM(n, m, n, [exp(I*2*pi*t*(u-w)^2/m) for w in range(n) for t in range(m) for u in range(n)])
    Hb=HM(n, n, m, [exp(I*2*pi*t*(u-v)^2/m) for t in range(m) for v in range(n) for u in range(n)])
    Hc=HM(m, n, n, [exp(I*2*pi*t*(v-w)^2/m) for w in range(n) for v in range(n) for t in range(m)])
    return [Ha, Hb, Hc]

def ThirdOrderDFT2(n):
    """
    outputs third order uncorrelated tuple of third order
    hypermatrices generalizing the classical Discrete
    Fourier Transform matrix. The input m is associated
    with the order of the root of unity and the input n
    correspond to the size of the matrix.
    

    EXAMPLES:
 
    ::

        sage: [Ha, Hb, Hc]=ThirdOrderDFT2(5)
        sage: Prod(Ha,Hb,Hc).expand().list()
        [
        [5 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 5], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [5 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 5], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [5 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 5], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [5 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 5], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]  [0 0]
        [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0], [0 0],
        <BLANKLINE>
        [0 0]  [0 0]  [0 0]  [0 0]  [5 0]
        [0 0], [0 0], [0 0], [0 0], [0 5]
        ]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the hypermatrices
    Ha=HM(n,n,n,[Matrix(SR,[[cos(2*pi*t*(u-w)^2/n), -sin(2*pi*t*(u-w)^2/n)], [sin(2*pi*t*(u-w)^2/n), cos(2*pi*t*(u-w)^2/n)]]) for w in range(n) for t in range(n) for u in range(n)])
    Hb=HM(n,n,n,[Matrix(SR,[[cos(2*pi*t*(u-v)^2/n), -sin(2*pi*t*(u-v)^2/n)], [sin(2*pi*t*(u-v)^2/n), cos(2*pi*t*(u-v)^2/n)]]) for t in range(n) for v in range(n) for u in range(n)])
    Hc=HM(n,n,n,[Matrix(SR,[[cos(2*pi*t*(v-w)^2/n), -sin(2*pi*t*(v-w)^2/n)], [sin(2*pi*t*(v-w)^2/n), cos(2*pi*t*(v-w)^2/n)]]) for w in range(n) for v in range(n) for t in range(n)])
    return [Ha, Hb, Hc]

def ThirdOrdercharpoly(A, c):
    """
    Outpts the solution associated with the linear dependence of powers.

     EXAMPLES:

    ::

        sage: x0,x1,x2,x3,x4,x5,x6,x7,x8=var('x0,x1,x2,x3,x4,x5,x6,x7,x8')
        sage: A=HM([[[1, 1], [-1, 2]], [[-1, 4], [1, 17]]])
        sage: [Sln, s]=ThirdOrdercharpoly(A,'A')
        sage: Tp=eval(s)
        sage: Sln
        [x0 == 186641252224723742786128720548/302131816499269505043899*x8,
         x1 == -16334511509638140306907278508/302131816499269505043899*x8,
         x2 == -39916709921235256189474933621/302131816499269505043899*x8,
         x3 == 444869993198324697111572893/302131816499269505043899*x8,
         x4 == -241741381030800897895387320/302131816499269505043899*x8,
         x5 == -122250819499746431538540833/302131816499269505043899*x8,
         x6 == 120487356897906588291809840/302131816499269505043899*x8,
         x7 == 139067504458363202088911118/302131816499269505043899*x8]
        sage: Tp.subs(dict([(s.lhs(),s.rhs()) for s in Sln]))
        [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of powers
    L=[]; Ls=[]; i=0
    while len(L) < 1+prod(A.dimensions()):
        L=L+HypermatrixCayleyHamiltonList(A, 2*i+1)
        Ls=Ls+HypermatrixCayleyHamiltonStringList(2*i+1, c)
        i=i+1
    # Initialization of the boolean variables which assert the status of the search.
    Fnd=False
    n=1+prod(A.dimensions())
    while (not Fnd) and n>1:
        # Initializing the index variables
        Indx = Set(range(len(L))).subsets(n)
        # Looping through all the subset of the appropriate size.
        for index in Indx:
            M=Matrix(SR, [L[i] for i in index]).transpose()
            #print 'Indexing set =', index
            if M.rank()==n-1:
                Fnd=True
                break
        # Initialization the result
        if M.rank()==n-1:
            b=Matrix(SR, M.nrows(), 1, HM(M.nrows(), 1, 'zero').list())
            x=Matrix(SR, M.ncols(), 1, [var('x'+str(i)) for i in range(M.ncols())])
            return [linear_solver(M, b, x, x) ," + ".join([str(x[i,0])+'*'+Ls[index[i]] for i in range(M.ncols())])]
        n=n-1
    if Fnd==False:
        return []
 
def llsa(Ha):
    """
    Outputs the rank 1 Logarithmic Least Square Approximation of 
    the input Hypermatrix Ha. The function uses the multiplicative
    least square solver to ensure that there always exist a solution.

    EXAMPLES:
 
    ::

        sage: [[Sln, U, V], MulSln]=llsa(Prod(HM(2,1,'a'), HM(1,2,'b')))
        sage: Hu = U.subs(dict([(s.lhs(),s.rhs()) for s in Sln[:3]]))
        sage: Hv = V.subs(dict([(s.lhs(),s.rhs()) for s in Sln[:3]]))
        sage: Hr = Prod(Hu,Hv)
        sage: Matrix(2,2,[Hr[i,j].subs(k0=0,k1=0,k2=0,k3=0,k4=0,k5=0,k6=0,k7=0).canonicalize_radical() for i in range(2) for j in range(2)])
        [a00*b00 a00*b01]
        [a10*b00 a10*b01]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the dimension list
    dm = Ha.dimensions()
    # Initialization of the list of Hypermatrices
    L=[]
    for i in range(Ha.order()):
        dmt=copy(dm); dmt[Integer(mod(i+1, Ha.order()))]=1
        #L.append(HM(apply(HypermatrixGenerate, dmt+['x'+str(i)+'y'])))
        L.append(HM(HypermatrixGenerate(*(dmt+['x'+str(i)+'y']))))
    # Initializing the constraints
    #Lh=apply(GeneralHypermatrixLogProduct, L).list(); Rh=Ha.list()
    Lh=GeneralHypermatrixLogProduct(*L).list(); Rh=Ha.list()
    CnstrLst=[Lh[j]==Rh[j] for j in range(prod(Ha.dimensions()))]
    # Initializing the list of variables
    VrbLst=[]
    for i in range(len(L)):
        VrbLst=VrbLst+L[i].list()
    # Formatting the constraints
    [Atmp, btmp]=ConstraintFormatorII(CnstrLst, VrbLst)
    # Initializing the least square constraints
    A=Atmp.transpose()*Atmp; b=multiplicative_matrix_product(Atmp.transpose(),btmp)
    # Solving the least square equations
    Mx=Matrix(SR,A.ncols(),1,VrbLst)
    Sln=multiplicative_least_square_linear_solver(A.transpose()*A, multiplicative_matrix_product(A.transpose(),b), Mx, Mx)
    return [[Sln]+L, multiplicative_gauss_jordan_eliminationII(A.transpose()*A, multiplicative_matrix_product(A.transpose(),b))] 

def LogarithmicRankOneApproximation(Ha):
    """
    Outputs the logarithmic BM-rank one approximationassociated with
    the input Hypermatrix Ha

    EXAMPLES:
 
    ::

        sage: [L0,L1]=LogarithmicRankOneApproximation(Prod(HM(2,1,'a'), HM(1,2,'b')))
        sage: Hu=(L0[1]).copy().subs(dict([(s.lhs(),s.rhs()) for s in L0[0]]))
        sage: Hv=(L0[2]).copy().subs(dict([(s.lhs(),s.rhs()) for s in L0[0]]))
        sage: Prod(Hu,Hv).subs(dict([(var('k'+str(s)),0) for s in range(8)])).canonicalize_radical()
        [[a00*b00, a00*b01], [a10*b00, a10*b01]]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the dimension list
    dm = Ha.dimensions()
    # Initialization of the list of Hypermatrices
    L=[]
    for i in range(Ha.order()):
        dmt=copy(dm); dmt[Integer(mod(i+1, Ha.order()))]=1
        #L.append(HM(apply(HypermatrixGenerate, dmt+['x'+str(i)+'y'])))
        L.append(HM(HypermatrixGenerate(*(dmt+['x'+str(i)+'y']))))
    # Initializing the constraints
    #Lh=apply(GeneralHypermatrixLogProduct, L).list(); Rh=Ha.list()
    Lh=GeneralHypermatrixLogProduct(*L).list(); Rh=Ha.list()
    CnstrLst=[Lh[j]==Rh[j] for j in range(prod(Ha.dimensions()))]
    # Initializing the list of variables
    VrbLst=[]
    for i in range(len(L)):
        VrbLst=VrbLst+L[i].list()
    # Formatting the constraints
    [A, b]=ConstraintFormatorII(CnstrLst, VrbLst)
    # Solving the least square equations
    Mx=Matrix(SR,A.ncols(),1,VrbLst)
    #Sln=multiplicative_linear_solver(A, b, Mx, Mx)
    Sln=multiplicative_least_square_linear_solver(A.transpose()*A, multiplicative_matrix_product(A.transpose(),b), Mx, Mx)
    #return [[Sln]+L, multiplicative_gauss_jordan_eliminationII(A,b)] 
    return [[Sln]+L, multiplicative_gauss_jordan_eliminationII(A.transpose()*A, multiplicative_matrix_product(A.transpose(),b))] 

def UncorrelatedSideLength2Triple(c1,c2,c3):
    """
    Generates a symbolic parametrization of an uncorrelated hypermatrix
    triplet Each having side length equal to 2. The inputs are three
    characters to used in the symbolic parametrization of the hyperma
    trix entries.

    EXAMPLES:

    ::

        sage: [Sln1, Sln2, Sln3]=UncorrelatedSideLength2Triple('a','b','c')
        sage: Ha=HM(2,2,2,'a').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hb=HM(2,2,2,'b').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hc=HM(2,2,2,'c').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hd=Prod(Ha,Hb,Hc).simplify_full(); Hd
        [[[-(a010*b001*c000*c011*c101*c110 - a010*b001*c001*c010*c100*c111)/(c001*c010*c111), 0], [0, 0]], [[0, 0], [0, -(a111*b111*c000*c011*c101*c110 - a111*b111*c001*c010*c100*c111)/(c001*c010*c100)]]]
        sage: Ah=Ha.copy(); Bh=Hb.copy(); Ch=Hc.copy()
        sage: Ch[0,0,0]=Ch[0,0,0]/Hd[0,0,0]; Ch[1,0,0]=Ch[1,0,0]/Hd[0,0,0]
        sage: Ch[0,1,1]=Ch[0,1,1]/Hd[1,1,1]; Ch[1,1,1]=Ch[1,1,1]/Hd[1,1,1]
        sage: Prod(Ah,Bh,Ch).simplify_full()
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]
        sage: Ha=HM(2,2,2,'a').subs(dict([(s.lhs(),s.rhs()) for s in Sln2]))
        sage: Hb=HM(2,2,2,'b').subs(dict([(s.lhs(),s.rhs()) for s in Sln2]))
        sage: Hc=HM(2,2,2,'c').subs(dict([(s.lhs(),s.rhs()) for s in Sln2]))
        sage: Hd=Prod(Ha,Hb,Hc).simplify_full(); Hd
        [[[-(a010*b001*c000*c011*c101*c110 - a010*b001*c001*c010*c100*c111)/(c001*c010*c111), 0], [0, 0]], [[0, 0], [0, -(a111*b111*c000*c011*c101*c110 - a111*b111*c001*c010*c100*c111)/(c001*c010*c100)]]]
        sage: Ah=Ha.copy(); Bh=Hb.copy(); Ch=Hc.copy()
        sage: Ch[0,0,0]=Ch[0,0,0]/Hd[0,0,0]; Ch[1,0,0]=Ch[1,0,0]/Hd[0,0,0]
        sage: Ch[0,1,1]=Ch[0,1,1]/Hd[1,1,1]; Ch[1,1,1]=Ch[1,1,1]/Hd[1,1,1]
        sage: Prod(Ah,Bh,Ch).simplify_full()
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]
        sage: Ha=HM(2,2,2,'a').subs(dict([(s.lhs(),s.rhs()) for s in Sln3]))
        sage: Hb=HM(2,2,2,'b').subs(dict([(s.lhs(),s.rhs()) for s in Sln3]))
        sage: Hc=HM(2,2,2,'c').subs(dict([(s.lhs(),s.rhs()) for s in Sln3]))
        sage: Hd=Prod(Ha,Hb,Hc).simplify_full(); Hd
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the hypermatrices.
    Ha=HM(2,2,2,c1); Hb=HM(2,2,2,c2); Hc=HM(2,2,2,c3)
    # Initialization fo the list of variables.
    VrbLst=Ha.list()+Hb.list()+Hc.list()
    # Initialization of the first list of constraints.
    CnstrLst1=[Ha[i,0,k]+Hb[i,j,0]+Hc[0,j,k]-Ha[i,1,k]-Hb[i,j,1]-Hc[1,j,k]==-1 for i in range(2) for j in range(2) for k in range(2) if (i!=j or j!=k or i!=k)]
    # Initialization of the second list of constraints.
    CnstrLst2=[Ha[i,1,k]+Hb[i,j,1]+Hc[1,j,k]-Ha[i,0,k]-Hb[i,j,0]-Hc[0,j,k]==-1 for i in range(2) for j in range(2) for k in range(2) if (i!=j or j!=k or i!=k)]
    # Formating the first set of constraints.
    [A1,b1]=ConstraintFormatorII(CnstrLst1, VrbLst)
    Mx1=Matrix(SR,A1.ncols(),1,VrbLst); Sln1=multiplicative_linear_solver(A1, b1, Mx1, Mx1)
    # Formating the second set of constraints.
    [A2,b2]=ConstraintFormatorII(CnstrLst2, VrbLst)
    Mx2=Matrix(SR,A2.ncols(),1,VrbLst); Sln2=multiplicative_linear_solver(A2, b2, Mx2, Mx2)
    # Initializing the product
    Htmp=Prod(Ha,Hb,Hc)
    # Initializing the Kroenker delta
    Kdlt=HM(3,2,'kronecker')
    CnstrLst3=[Htmp[i,j,k]==Kdlt[i,j,k] for i in range(2) for j in range(2) for k in range(2)]
    # Formating the last list of constraints.
    [A3, b3]=ConstraintFormatorII(CnstrLst3, Hc.list())
    Mx3=Matrix(SR,A3.ncols(),1,Hc.list()); Sln3=linear_solver(A3, b3, Mx3, Mx3)
    return [Sln1, Sln2, Sln3]

def GeneralHypermatrixTransform(Hl, X):
    """
    Implements the general hypermatrix Transform

    EXAMPLES:

    ::

        sage: sz=2; t=var('t'); Q=HM(sz,sz,[cos(t),sin(t),-sin(t), cos(t)])
        sage: Y=GeneralHypermatrixTransform([Q.transpose(),Q], HM(2,1,var_list('x',sz))); Y.canonicalize_radical()
        [[-x0*cos(t) + x1*sin(t)], [x1*cos(t) + x0*sin(t)]]
        sage: GeneralHypermatrixTransform([Q.transpose(),Q], Y).canonicalize_radical()
        [[(cos(t)^2 + sin(t)^2)*x0], [(cos(t)^2 + sin(t)^2)*x1]]
        sage: sz=2; A=HM(2,2,'a')
        sage: GeneralHypermatrixTransform([A.transpose(),A], HM(2,1,var_list('x',sz))).canonicalize_radical()
        [[a00*x0 + a01*x1], [a10*x0 + a11*x1]]
        sage: sz=2; P0=HM(sz,1,var_list('x',sz)); A=HM(sz,sz,'a'); B=i2x2(A)
        sage: P1=GeneralHypermatrixTransform([A,B],P0).canonicalize_radical()
        sage: sum(f^2 for f in P1.list()).canonicalize_radical()
        x0^2 + x1^2


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order and the size
    od = Hl[0].order(); sz = Hl[0].n(0)
    # Constrained Orthogonalization procedure.
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    Dlt=sum(DltL)
    # Loop initializing the hypermartrix enrtries
    Ly=[]
    for t in range(sz):
        #Ly.append((apply(ProdB,[X.transpose(i) for i in range(od-1,-1,-1)]+[apply(ProdB,[H for H in Hl]+[DltL[t]])])).list()[0]^(1/od))
        Ly.append((ProdB(*([X.transpose(i) for i in range(od-1,-1,-1)]+[ ProdB(*([H for H in Hl]+[DltL[t]])) ]))).list()[0]^(1/od))
    return HM(*([sz]+[1 for i in range(od-1)]+[Ly])) 

def weighted_hypermatrix_minor(A):
    """
    Outputs a list of second order minor hypermatrices
    which add up to the original hypermatrices.

    EXAMPLES:
 
    ::

        sage: L=weighted_hypermatrix_minor(HM(3,3,'a')); L
        [[[0, 0, 0], [0, 1/2*a11, a12], [0, a21, 1/2*a22]],
         [[1/2*a00, 0, a02], [0, 0, 0], [a20, 0, 1/2*a22]],
         [[1/2*a00, a01, 0], [a10, 1/2*a11, 0], [0, 0, 0]]]
        sage: sum(L)
        [[a00, a01, a02], [a10, a11, a12], [a20, a21, a22]]

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Checking that the matrix is square
    if A.is_cubical() and A.order()==2 and A.n(0)>2:
        # Initialization of the size parameter
        sz=A.n(0)
        # Initialization of the Kronecker delta hypermatrices
        Id=HM(2,sz,'kronecker')
        # Initialization of the list
        L=[HM(sz,1,[Id[i,t] for i in range(sz)]) for t in range(sz)]
        # Initialization of the list of matrices
        MtrL=[]
        for t in range(sz):
            MtrL.append((sz-2)^(-1)*(Prod(sum([L[i] for i in range(sz) if i!=t]),sum([L[i] for i in range(sz) if i!=t]).transpose())-sum([Prod(L[i],L[i].transpose()) for i in range(sz) if i!=t]))+(sz-1)^(-1)*sum([Prod(L[i],L[i].transpose()) for i in range(sz) if i!=t]))
        return [A.elementwise_product(MtrL[i]) for i in range(sz)]
    elif A.is_cubical() and A.order()==3 and A.n(0)>3:
        # Initialization of the size parameter
        sz=A.n(0)
        # Initialization of the list
        L=[]
        for t in range(sz):
            # Initialization of a temporary HM
            Tp=HM(sz,sz,sz,'zero')
            for i in range(sz):
                for j in range(sz):
                    for k in range(sz):
                        if i!=t and j!=t and k!=t:
                            if i==j and j==k:
                                Tp[i,j,k]=A[i,j,k]/(sz-1)
                            if (i==j and j!=k) or (i==k and i!=j) or (j==k and i!=k):
                                Tp[i,j,k]=A[i,j,k]/(sz-2)
                            elif i!=j and i!=k and j!=k:
                                Tp[i,j,k]=A[i,j,k]/(sz-3)
            L.append(Tp.copy())
        return L
    else:
        raise ValueError("The input hypermpatrix must be cubic and order 3  and lower.")

def SecondOrderCharpolyI(A, U, mu, nu):
    """
    Outputs second order hypermatrix characterisitic polynomial.
    Or generator of the first spectral elimination ideal.
    The inputs are matrix A for which we want to compute
    the spectral decompostion. The matrices U and V which are
    associated with the e-vectors and the diagonal matrices
    mu, nu.

    EXAMPLES:
 
    ::

        sage: Ha=HM(2,2,'a'); Hu=HM(2,2,'u'); Hd0=HM(2,2,diagonal_matrix(HM(2,'x').list()).list()); Hd1=HM(2,2,diagonal_matrix(HM(2,'y').list()).list())
        sage: SecondOrderCharpolyI(Ha, Hu, Hd0, Hd1)[0].printHM()
        [:, :]=
        [u00*x0*y0*(1/u00 - u01*u10/(u00^2*(u01*u10/u00 - u11))) + u01*u10*x1*y1/(u00*(u01*u10/u00 - u11))                                     u01*x0*y0/(u01*u10/u00 - u11) - u01*x1*y1/(u01*u10/u00 - u11)]
        [u10*x0*y0*(1/u00 - u01*u10/(u00^2*(u01*u10/u00 - u11))) + u10*u11*x1*y1/(u00*(u01*u10/u00 - u11))                           u01*u10*x0*y0/(u00*(u01*u10/u00 - u11)) - u11*x1*y1/(u01*u10/u00 - u11)] 
        sage: x,y=var('x,y')
        sage: Ha=HM(2,2,'a'); Hu=HM(2,2,'u'); Hd0=HM(2,2,diagonal_matrix([x,x]).list()); Hd1=HM(2,2,diagonal_matrix([y,y]).list())
        sage: (SecondOrderCharpolyI(Ha, Hu, Hd0, Hd1)[1]).factor()
        x^2*y^2 - a00*x*y - a11*x*y - a01*a10 + a00*a11

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Checking that the matrix is square and that mu and nu are diagonal matrices
    if A.is_cubical() and A.order()==2 and (mu.elementwise_exponent(2)-Prod(mu.transpose(),mu)).is_zero() and (nu.elementwise_exponent(2)-Prod(nu.transpose(),nu)).is_zero():
        # Initialization of the hypermatrix V
        V=U.inverse().transpose()
        return [Prod(Prod(U,mu),Prod(V,nu).transpose()), (A-Prod(Prod(U,mu),Prod(V,nu).transpose())).det()]
    else:
        raise ValueError("Not supported for the input hypermatrices.")

def SecondOrderCharpolyII(A, U, Dg):
    """
    Outputs second order hypermatrix characterisitic polynomial.
    Or generator of the first spectral elimination ideal.
    The inputs are matrix A for which we want to compute
    the spectral decompostion. The matrices U and V which are
    associated with the e-vectors and the diagonal matrices
    mu, nu.

    EXAMPLES:
 
    ::

        sage: A=HM(2,2,'a'); U=HM(2,2,'u'); Dg=HM(2,2,diagonal_matrix(HM(2,'x').list()).list())
        sage: SecondOrderCharpolyII(A, U, Dg)[2].simplify_rational().numerator().factor()
        (a10*u00^2 - a00*u00*u10 + a11*u00*u10 - a01*u10^2)*(a10*u01^2 - a00*u01*u11 + a11*u01*u11 - a01*u11^2)*(a01*a10 - a00*a11)
        sage: SecondOrderCharpolyII(A, U, Dg)[2].simplify_rational().denominator().factor()
        (a10*u00*u01 - a00*u01*u10 + a11*u00*u11 - a01*u10*u11)*(a10*u00*u01 + a11*u01*u10 - a00*u00*u11 - a01*u10*u11)

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Checking that the matrix is square and that mu and nu are diagonal matrices
    if A.is_cubical() and A.order() == 2 and (Dg.elementwise_exponent(2)-Prod(Dg.transpose(),Dg)).is_zero():
        # Initialization of the hypermatrix V
        V=U.inverse().transpose()
        # Initialization of the Kronecker delta list
        L=GeneralHypermatrixKroneckerDeltaL(2,A.n(0))
        # Initializing the equations
        Eq=[(A-ProdB(U,Prod(Dg,V.transpose()),L[i])).det()==0 for i in range(A.n(0))]
        # Initializing the list of equations
        Sln=solve(Eq, [Dg[i,i] for i in range(Dg.n(0))])[0]
        return [(A-ProdB(U,Prod(Dg,V.transpose()),L[i])).det() for i in range(A.n(0))]+[(A-Prod(U,Prod(Dg,V.transpose()))).det().subs(Sln)]
    else:
        raise ValueError("Not supported for the input hypermatrices.")

def GeneralUncorrelatedComposition(Lu, La, Lf): 
    """
    Implements the generic composition procedure to be used for the spectral
    decomposition procedure. The hypermatrix inputs are three lists.


    EXAMPLES:

    ::

        sage: Lu=[HM(2,2,'u'), HM(2,2,'v')]
        sage: Sln=GeneralUncorrelatedComposition(Lu, [HM(2,2,'a'),HM(2,2,'a').inverse()], [HM(2,2,'f'),HM(2,2,'f').inverse()])
        sage: U=HM(2,2,'u').subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: V=HM(2,2,'v').subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Prod(U,V)[1,0].is_zero()
        True
        sage: Prod(U,V)[0,1].is_zero()
        True
        sage: Hl1=[HM(2,2,'a'),HM(2,2,'b')]; Xl1=[HM(2,2,'s'),HM(2,2,'t')]
        sage: Hl2=[HM(2,2,'f'),HM(2,2,'g')]; Xl2=[HM(2,2,'x'),HM(2,2,'y')]
        sage: Sln1=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl1,Xl1)
        sage: Sln2=GeneralHypermatrixConstrainedUncorrelatedTuples(Hl2,Xl2)
        sage: La=[Hx.subs(dict([(s.lhs(),s.rhs()) for s in Sln1 if s.lhs()!=1])) for Hx in Xl1]
        sage: Tmp1=HM(2,2,'one')
        sage: Tmp1[0,0]=1/Prod(La[0],La[1])[0,0];Tmp1[0,1]=1/Prod(La[0],La[1])[0,0]
        sage: Tmp1[1,0]=1/Prod(La[0],La[1])[1,1];Tmp1[1,1]=1/Prod(La[0],La[1])[1,1]
        sage: Lf=[Hx.subs(dict([(s.lhs(),s.rhs()) for s in Sln2 if s.lhs()!=1])) for Hx in Xl2]
        sage: Tmp2=HM(2,2,'one')
        sage: Tmp2[0,0]=1/Prod(Lf[0],Lf[1])[0,0];Tmp2[0,1]=1/Prod(Lf[0],Lf[1])[0,0]
        sage: Tmp2[1,0]=1/Prod(Lf[0],Lf[1])[1,1];Tmp2[1,1]=1/Prod(Lf[0],Lf[1])[1,1]
        sage: Lu=[HM(2,2,'u'), HM(2,2,'v')]
        sage: Sln=GeneralUncorrelatedComposition(Lu, [La[0].elementwise_product(Tmp1),La[1]], [Lf[0].elementwise_product(Tmp2),Lf[1]])
        sage: Prod(U,V)[1,0].is_zero()
        True
        sage: Prod(U,V)[0,1].is_zero()
        True
        sage: Lu=[HM(2,2,2,'u'), HM(2,2,2,'v'), HM(2,2,2,'w')]
        sage: # Initialization of the first uncorrelated tuple
        sage: [Sln1, Sln2, Sln3]=UncorrelatedSideLength2Triple('a','b','c')
        sage: Ha=HM(2,2,2,'a').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hb=HM(2,2,2,'b').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hc=HM(2,2,2,'c').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hd=Prod(Ha,Hb,Hc).simplify()
        sage: Ah=Ha.copy(); Bh=Hb.copy(); Ch=Hc.copy()
        sage: Ch[0,0,0]=Ch[0,0,0]/Hd[0,0,0]; Ch[1,0,0]=Ch[1,0,0]/Hd[0,0,0]
        sage: Ch[0,1,1]=Ch[0,1,1]/Hd[1,1,1]; Ch[1,1,1]=Ch[1,1,1]/Hd[1,1,1]
        sage: La=[Ah, Bh, Ch]
        sage: # Initialization of the second uncorrelated tuple
        sage: [Tln1, Tln2, Tln3]=UncorrelatedSideLength2Triple('f','g','h')
        sage: Hf=HM(2,2,2,'f').subs(dict([(s.lhs(),s.rhs()) for s in Tln1]))
        sage: Hg=HM(2,2,2,'g').subs(dict([(s.lhs(),s.rhs()) for s in Tln1]))
        sage: Hh=HM(2,2,2,'h').subs(dict([(s.lhs(),s.rhs()) for s in Tln1]))
        sage: He=Prod(Hf,Hg,Hh).simplify()
        sage: Fh=Hf.copy(); Gh=Hg.copy(); Hh=Hh.copy()
        sage: Hh[0,0,0]=Hh[0,0,0]/He[0,0,0]; Hh[1,0,0]=Hh[1,0,0]/He[0,0,0]
        sage: Hh[0,1,1]=Hh[0,1,1]/He[1,1,1]; Hh[1,1,1]=Hh[1,1,1]/He[1,1,1]
        sage: Lf=[Fh, Gh, Hh]
        sage: # Performing the composition
        sage: Sln=GeneralUncorrelatedComposition(Lu, La, Lf)
        sage: Hu=HM(2,2,2,'u').subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Hv=HM(2,2,2,'v').subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Hw=HM(2,2,2,'w').subs(dict([(s.lhs(),s.rhs()) for s in Sln if s.lhs()!=1]))
        sage: Hx=Prod(Hu,Hv,Hw).simplify()
        sage: Uh=Hu.copy(); Vh=Hv.copy(); Wh=Hw.copy()
        sage: Wh[0,0,0]=Wh[0,0,0]/Hx[0,0,0]; Wh[1,0,0]=Wh[1,0,0]/Hx[0,0,0]
        sage: Wh[0,1,1]=Wh[0,1,1]/Hx[1,1,1]; Wh[1,1,1]=Wh[1,1,1]/Hx[1,1,1]
        sage: Prod(Uh,Vh,Wh).simplify_full()
        [[[1, 0], [0, 0]], [[0, 0], [0, 1]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the order paramter
    od=Lu[0].order()
    # Initializing the size parameter
    sz=Lu[0].n(0)
    # Initializing the list of hypermatrices
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # We seek to solve for Hu,Hv,Hw for input hypermatrices Ha,Hb,Hc, He,Hf,Hg
    L1=[]; L2=[]
    for i in range(sz): 
        #L1=L1+apply(ProdB,[Hu for Hu in Lu]+[DltL[i]]).list()
        L1=L1+ProdB(*([Hu for Hu in Lu]+[DltL[i]])).list()
        #L2=L2+apply(ProdB,[Ha for Ha in La]+[apply(ProdB,[Hf for Hf in Lf]+[DltL[i]])]).list()
        L2=L2+ProdB(*([Ha for Ha in La]+[ProdB(*([Hf for Hf in Lf]+[DltL[i]]))])).list()
    # Initialization of the equation
    EqL=[L1[i]==L2[i] for i in range(len(L1))]
    LstX=[]
    for x in Lu:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    # Formating the constraints
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # returning the solutions to the system obtained via Gauss-Jordan elimination
    return multiplicative_linear_solver(A, b, v, v)

def ThirdOrdeCharpolyI(A, Mu, Mv, Mw):
    """
    Outputs the third order hypermatrix characterisitic polynomial.
    Can alternatively generator of the first spectral elimination ideal.
    Assumes that the hypermatrix U, V, W arises from a parametrization
    of uncorrelated tuples but checks that the the inputs hypermatrices
    Du, Dv, Dw are diagonal hypremartices.


    EXAMPLES:
 
    ::

        sage: Mu=HM(2,2,'f','sym'); Mv=HM(2,2,'g','sym'); Mw=HM(2,2,'h','sym')
        sage: ThirdOrdeCharpolyI(HM(2,2,2,'a'), Mu, Mv, Mw)
        (f10^2*g10^2*h10^2 - a111)*a001*a010*a100 - (f00^2*g00^2*h00^2 - a000)*a011*a101*a110
 

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Checking that the matrix is square and that mu and nu are diagonal matrices
    if A.is_cubical() and A.order() == 3 and A.n(0)==2:
        # Initializing the hypermatrix B
        B=HM(A.n(0),A.n(1),A.n(2),'zero')
        for i in range(A.n(0)):
            for j in range(A.n(1)):
                for k in range(A.n(2)):
                    if i==j and j==k:
                        B[i,j,k]=A[i,j,k]-(Mu[0,i]*Mv[0,i]*Mw[0,i])^2
                    else:
                        B[i,j,k]=A[i,j,k]
        return B.det()
    else:
        raise ValueError("Not supported for the input hypermatrices.")

def ThirdOrdeCharpolyII(A, U, V, W, Du, Dv, Dw):
    """
    Outputs the third order hypermatrix characterisitic polynomial.
    Can alternatively generator of the first spectral elimination ideal.
    Assumes that the hypermatrix U, V, W arises from a parametrization
    of uncorrelated tuples but checks that the the inputs hypermatrices
    Du, Dv, Dw are diagonal hypremartices.


    EXAMPLES:
 
    ::

        sage: Du=HM(Matrix(2,2,HM(2,2,'f','sym').listHM())); Dv=HM(Matrix(2,2,HM(2,2,'g','sym').listHM())); Dw=HM(Matrix(2,2,HM(2,2,'h','sym').listHM()))
        sage: [Sln1, Sln2, Sln3]=UncorrelatedSideLength2Triple('u','v','w')
        sage: Hu=HM(2,2,2,'u').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hv=HM(2,2,2,'v').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hw=HM(2,2,2,'w').subs(dict([(s.lhs(),s.rhs()) for s in Sln1]))
        sage: Hd=Prod(Hu,Hv,Hw).simplify_full()
        sage: Uh=Hu.copy(); Vh=Hv.copy(); Wh=Hw.copy()
        sage: Wh[0,0,0]=Wh[0,0,0]/Hd[0,0,0]; Wh[1,0,0]=Wh[1,0,0]/Hd[0,0,0]
        sage: Wh[0,1,1]=Wh[0,1,1]/Hd[1,1,1]; Wh[1,1,1]=Wh[1,1,1]/Hd[1,1,1]
        sage: ThirdOrdeCharpolyII(HM(2,2,2,'a'), Uh, Vh, Wh, Du, Dv, Dw)[0]
        -(f10^2*g10^2*h10^2*u111*v111*w000*w011*w101*w110/(u111*v111*w000*w011*w101*w110 - u111*v111*w001*w010*w100*w111) - a111)*(f00*f10*g00*g10*h00^2*u110*v101*w001*w010*w100*w111/(u010*v001*w000*w011*w101*w110 - u010*v001*w001*w010*w100*w111) - a100)*(f00*f10*g00^2*h00*h10*u011*v001*w101 + a001)*(f00^2*g00*g10*h00*h10*u010*v011*w110 + a010) + (f00^2*g00^2*h00^2*u010*v001*w000*w011*w101*w110/(u010*v001*w000*w011*w101*w110 - u010*v001*w001*w010*w100*w111) - a000)*(f00*f10*g00*g10*h10^2*u011*v011*w001*w010*w100*w111/(u111*v111*w000*w011*w101*w110 - u111*v111*w001*w010*w100*w111) - a011)*(f10^2*g00*g10*h00*h10*u111*v101*w101 + a101)*(f00*f10*g10^2*h00*h10*u110*v111*w110 + a110)


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Checking that the matrix is square and that mu and nu are diagonal matrices
    if A.order()==3 and A.n(0)==2 and (Prod(Du.transpose(),Du.transpose(2),Du)-Du.elementwise_exponent(3)).is_zero() and (Prod(Dv.transpose(),Dv.transpose(2),Dv)-Dv.elementwise_exponent(3)).is_zero() and (Prod(Dw.transpose(),Dw.transpose(2),Dw)-Dw.elementwise_exponent(3)).is_zero():
        DltL=GeneralHypermatrixKroneckerDeltaL(A.order(),A.n(0))
        return [(A-ProdB(Prod(U,Du,Du.transpose()), Prod(Dv,V,Dv.transpose(2)), Prod(Dw.transpose(),Dw.transpose(2),W), DltL[t])).det() for t in range(2)]
    else:
        raise ValueError("Not supported for the input hypermatrices.") 

def Additive_Determinant_Matrix(f, g, t):
    """
    Outputs a symbolic second order hypermatrix whose determinant is the sum of
    the two polynomials.

    EXAMPLES:

    ::

        sage: x=var('x'); f=x^2+sum(HM(2,'a').list()[i]*x^i for i in range(2)); g=x^3+sum(HM(3,'b').list()[i]*x^i for i in range(3))
        sage: Ha=Additive_Determinant_Matrix(f, g, x)
        sage: (Ha.refII()[2,2].ref()[2,2]).canonicalize_radical() 
        ((b2 + 1)*x^2 + x^3 + (a1 + b1)*x + a0 + b0)/(a1*x + x^2 + a0)
        sage: (Ha.refII()[1,1].ref()[1,1]).canonicalize_radical()
        a1*x + x^2 + a0
        sage: Hb=Ha.copy()
        sage: for k in range(Hb.n(0)):
        ....:     Hb=BlockSweep(Hb,k)
        ....:
        sage: Hb[0,0][0,0].canonicalize_radical()
        -(a1*x + x^2 + a0)/((b2 + 1)*x^2 + x^3 + (a1 + b1)*x + a0 + b0)
        sage: (Ha*Hb).simplify_full()
        [[[[-1]], [[0, 0]], [[0, 0, 0]]], [[[0], [0]], [[-1, 0], [0, -1]], [[0, 0, 0], [0, 0, 0]]], [[[0], [0], [0]], [[0, 0], [0, 0], [0, 0]], [[-1, 0, 0], [0, -1, 0], [0, 0, -1]]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz0=f.degree(t); sz1=g.degree(t)
    # Initialization of the companion matrices
    A=CompanionHM(f,t)-t*HM(2,sz0,'kronecker')
    B=CompanionHM(g,t)-t*HM(2,sz1,'kronecker')
    Tp=HM(sz1,sz0,'zero');Tp[0,sz0-1]=1
    # Initialization of the first row
    M00=HM(1,1,'one'); M01=HM(1,sz0,'zero'); M02=HM(1,sz1,[B[0,j] for j in range(B.n(1))])
    # Performing the row substitution
    for j in range(B.n(1)):
        B[0,j]=HM(2,sz1,'kronecker')[sz1-1,j]
    # Initialization of the  second row
    M10=HM(sz0,1,[HM(2,sz0,'kronecker')[i,0] for i in range(sz0)]); M11=A; M12=HM(sz0,sz1,'zero')
    # Initialization of the last row
    M20=HM(sz1,1,'zero'); M21=Tp.copy(); M22=B
    # Initialization of the hypermatrix
    return HM([[M00,M01,M02],[M10,M11,M12],[M20,M21,M22]])

def GeneralHypermatrixRankOnePartition(B, Hl, Xl):
    """
    Returns the constraints associated with linearizations of the rank one decomposition
    constraints.The polynomial returned come from zero rows. The function takes as inputs
    a hypermatrix and two lists. The input Xl is the list of hypermatrices associated with
    the variables. The input Hl is the list of hypermatrix associated with the decompositions.
    The first list element of Hl is the Hypermatrix to be deocomposed the other elements 
    correspond to the parameters of the decomposition. 

    EXAMPLES:

    ::

        sage: B=HM(2,2,'b'); Hl=[HM(2,2,'c')]; Xl=[HM(2,2,'x'), HM(2,2,'y')] 
        sage: Sln=GeneralHypermatrixRankOnePartition(B, Hl, Xl); Sln
        [-(b01 - c01)*(b10 - c10) + (b00 - c00)*(b11 - c11),
         -(b01 + c01)*(b10 + c10) + (b00 + c00)*(b11 + c11)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the primitive root of unity
    w=exp(I*2*pi/Xl[0].n(1))
    # Initializing the order
    od=Xl[0].order()
    # Initialization the Kronecker slice selectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od, Xl[0].n(1))
    # Loop initializing the hypermartrix enrtry lists associaed with constraints 
    Lx=[]; Lh=[]
    for t in range(Xl[0].n(1)):
        #Lx=Lx+apply(ProdB,[X for X in Xl]+[DltL[t]]).list()
        Lx=Lx+ProdB(*([X for X in Xl]+[DltL[t]])).list()
        Lh=Lh+((1/Xl[0].n(1))*sum([B]+[Hl[j]*w^(t*(j+1)) for j in rg(len(Hl))])).list()
    # Initialization of the equation
    EqL=[Lx[i]==Lh[i] for i in rg(len(Lx))]
    # Formating the constraints
    LstX=[]
    for x in Xl:
        LstX=LstX+x.list()
    if len(Set(LstX).list())==len(LstX):
        VrbL=LstX
    else:
        VrbL=Set(LstX).list()
    [A,b]=multiplicativeConstraintFormator(EqL, VrbL)
    # Initialization of the vector of variables
    v=Matrix(SR, A.ncols(), 1, VrbL)
    # computing the solutions to the system obtained via Gauss-Jordan elimination
    Sln=multiplicative_linear_solver(A, b, v, v)
    # returning the polynomial conditions eliminating the variables
    return [f.rhs().numerator()-f.rhs().denominator() for f in Sln if f.lhs()==1]

def Form2TotallySymmetricHypermatrix(f, od, Vrbls):
    """
    Procedure for extracting a Hypermatrix from a multivariate
    homogeneous from the the order corresponds to the degree
    of the homogeneous form and the side length is determined
     by the number of variables

    EXAMPLES:

    ::

        sage: sz=2; od=2; X=HM(sz,sz,var_list('x',sz^2)); f=X.det()
        sage: f
        -x1*x2 + x0*x3
        sage: H=Form2TotallySymmetricHypermatrix(f, 2, X.list()); H.printHM()
        [:, :]=
        [   0    0    0  1/2]
        [   0    0 -1/2    0]
        [   0 -1/2    0    0]
        [ 1/2    0    0    0]
        sage: (HM(sz^2,1,X.list()).transpose()*H*HM(sz^2,1,X.list()))[0,0] # Checking the  bilinear form
        -x1*x2 + x0*x3
        


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list 
    l=[len(Vrbls) for i in range(od)]
    # Initialization of the hypermatrix 
    inpts=l+['zero']; Rh=HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry=[Integer(mod(i,l[0]))]
        sm=Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm=sm+prod(l[0:k+1])*entry[len(entry)-1]
        Rh[tuple(entry)]=f.diff([Vrbls[v] for v in entry])/factorial(od)
    return Rh

def Form2Hypermatrix(f, Vrbls):
    """
    Procedure for extracting a side length sz Hypermatrix from
    a non homogeneous multivariate from. The order input is od
    the side length is sz. This is inpired by the theory of 
    system of linear equations in terms of side length two 
    hypermatrices. The list Vrbls stores all the variables.
    In the underlying form each variables is used to construct
    a vector of powers of the variable.


    EXAMPLES:

    ::

        sage: sz=2; od=2; A=HM(sz,sz,'a'); B=HM(sz,sz,'b'); X=var_list('x',od)
        sage: Hv0=HM(sz, 1, [X[0]^0, X[0]^1]); Hv1=HM(sz, 1, [X[1]^0, X[1]^1])
        sage: f=ProdB(Hv0.transpose(),Hv1,A)[0,0]; f
        a11*x0*x1 + a10*x0 + a01*x1 + a00
        sage: Form2Hypermatrix(f, X).printHM()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: g=ProdB(Hv0.transpose(),Hv1,B)[0,0]; g
        b11*x0*x1 + b10*x0 + b01*x1 + b00
        sage: Form2Hypermatrix(g, X).printHM()
        [:, :]=
        [b00 b01]
        [b10 b11]
        sage: sz=2; od=3; A=HM(sz, sz, sz,'a'); X=var_list('x',od)
        sage: Hv0=HM(sz, 1, 1, [1,X[0]]); Hv1=HM(sz, 1, 1, [1,X[1]]); Hv2=HM(sz, 1, 1, [1,X[2]])
        sage: f=ProdB(Hv0.transpose(2), Hv1.transpose(), Hv2, A)[0,0,0]; f
        a111*x0*x1*x2 + a110*x0*x1 + a101*x0*x2 + a011*x1*x2 + a100*x0 + a010*x1 + a001*x2 + a000
        sage: Form2Hypermatrix(f, X).printHM()
        [:, :, 0]=
        [a000 a010]
        [a100 a110]
        <BLANKLINE> 
        [:, :, 1]=
        [a001 a011]
        [a101 a111]
        sage: sz=3; od=2; d=2; A=HM(sz,sz,'a'); X=var_list('x',od)
        sage: Hv0=HM(sz,1,[X[0]^i for i in range(d+1)]); Hv1=HM(sz,1,[X[1]^j for j in range(d+1)])
        sage: f=ProdB(Hv0.transpose(),Hv1,A)[0,0]; f
        a22*x0^2*x1^2 + a21*x0^2*x1 + a12*x0*x1^2 + a20*x0^2 + a11*x0*x1 + a02*x1^2 + a10*x0 + a01*x1 + a00
        sage: Form2Hypermatrix(f, X).printHM()
        [:, :]=
        [a00 a01 a02]
        [a10 a11 a12]
        [a20 a21 a22]
        sage: sz=3; od=3; d=3; A=HM(sz,sz,sz,'a'); X=var_list('x',od)
        sage: Hv0=HM(sz,1,1,[X[0]^i for i in range(d+1)]); Hv1=HM(sz,1,1,[X[1]^j for j in range(d+1)]); Hv2=HM(sz,1,1,[X[2]^j for j in range(d+1)])
        sage: f=ProdB(Hv0.transpose(2), Hv1.transpose(), Hv2, A)[0,0,0]; f
        a222*x0^2*x1^2*x2^2 + a221*x0^2*x1^2*x2 + a212*x0^2*x1*x2^2 + a122*x0*x1^2*x2^2 + a220*x0^2*x1^2 + a211*x0^2*x1*x2 + a121*x0*x1^2*x2 + a202*x0^2*x2^2 + a112*x0*x1*x2^2 + a022*x1^2*x2^2 + a210*x0^2*x1 + a120*x0*x1^2 + a201*x0^2*x2 + a111*x0*x1*x2 + a021*x1^2*x2 + a102*x0*x2^2 + a012*x1*x2^2 + a200*x0^2 + a110*x0*x1 + a020*x1^2 + a101*x0*x2 + a011*x1*x2 + a002*x2^2 + a100*x0 + a010*x1 + a001*x2 + a000
        sage: Form2Hypermatrix(f, X).printHM()
        [:, :, 0]=
        [a000 a010 a020]
        [a100 a110 a120]
        [a200 a210 a220]
        <BLANKLINE> 
        [:, :, 1]=
        [a001 a011 a021]
        [a101 a111 a121]
        [a201 a211 a221]
        <BLANKLINE> 
        [:, :, 2]=
        [a002 a012 a022]
        [a102 a112 a122]
        [a202 a212 a222]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the size and order parameters
    od=len(Vrbls); sz=1+max([f.degree(v) for v in Vrbls])
    # Initialization of the list 
    l=[sz for i in range(od)]
    # Initialization of the hypermatrix 
    inpts=l+['zero']; Rh=HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry=[Integer(mod(i,l[0]))]
        sm=Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm=sm+prod(l[0:k+1])*entry[len(entry)-1]
        Tmplst=[]
        for z in range(len(entry)):
            Tmplst=Tmplst+[Vrbls[z],entry[z]]
        #print [factorial(Tmplst[b]) for b in range(1,len(Tmplst),2)]
        Rh[tuple(entry)]=f.diff(*Tmplst).subs([v==0 for v in Vrbls])/prod(factorial(Tmplst[b]) for b in range(1,len(Tmplst),2))
    return Rh

def Form2HypermatrixII(f, od, Vrbls, c):
    """
    Procedure for extracting a Hypermatrix from a multivariate
    homogeneous multilinear from the order corresponds to
    the degree of the homogeneous form and the side length is
    determined by the number of variables. The input c is 
    character or a string

    EXAMPLES:

    ::

        sage: sz=2; od=2; X=HM(sz,sz,var_list('x',sz^2)); f=X.det()
        sage: H=Form2HypermatrixII(f, 2, X.list(), 'a')[0]; H.printHM()
        [:, :]=
        [         0          0          0  a03 + 1/2]
        [         0          0  a12 - 1/2          0]
        [         0 -a12 - 1/2          0          0]
        [-a03 + 1/2          0          0          0]
        sage: Form2HypermatrixII(f, 2, X.list(), 'a')[1]
        [a03, a12]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the list of variables to be returned
    Lv=[]
    # Initialization of the list 
    l=[len(Vrbls) for i in range(od)]
    # Initialization of the hypermatrix 
    inpts=l+['zero']; Rh=HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry=[Integer(mod(i,l[0]))]
        sm=Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm=sm+prod(l[0:k+1])*entry[len(entry)-1]
        cpt=f.diff([Vrbls[v] for v in entry])
        if cpt == 0:
            Rh[tuple(entry)]=SR(0)
        elif Set(entry).cardinality()<len(entry):
            Rh[tuple(entry)]=f.diff([Vrbls[v] for v in entry])/factorial(od)  
        else:
            indxL=copy(entry); indxL.sort(); lex=Permutation_lex(get_tuple_permutation(indxL,entry))
            Rh[tuple(entry)]=f.diff([Vrbls[v] for v in entry])/factorial(od)+exp(Integer(2)*pi*sqrt(-Integer(1))*lex/factorial(od))*var(c+str(indxL).replace(', ','').replace(']','').replace('[',''))
            # Updating the list of variables
            if not (var(c+str(indxL).replace(', ','').replace(']','').replace('[','')) in Lv):
                Lv.append(var(c+str(indxL).replace(', ','').replace(']','').replace('[','')))
    return [Rh, Lv]

def diagonal_coef_gaussian_eliminationHM(Cf1, Vx, Cf2, rs):
    """
    Outputs the row echelon form of the input coefficient third order hypermatrices 
    and the corresponding right hand side. This implementation assumes that the
    inputs are third order hypermatrices whose entries are themselves diagonal
    second order hypermatrices. All entries of Cf1 are matrices of the size 
    m x m and all entries of Cf2 are matrices of the size n x n (this is not 
    checked). Consequently the entries of Vx and rs are all m x n matrices.
    This implementation avoids division and would work on other inputs so
    long as the entries of the coefficien matrices commutes among themeselve.


    EXAMPLES:
    ::

       
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag'); A11=HM(2,HM(2,'d').list(),'diag')
        sage: B00=HM(2,HM(2,'e').list(),'diag'); B01=HM(2,HM(2,'f').list(),'diag'); B10=HM(2,HM(2,'g').list(),'diag'); B11=HM(2,HM(2,'h').list(),'diag')
        sage: Cf1=HM([[[A00, A10], [A01, A11]]]); Cf1.dimensions() # Initialization of the left coefficient matrix
        [1, 2, 2]
        sage: Cf2=HM([[[B00, B01]], [[B10, B11]]]); Cf2.dimensions() # Initialization of the right coefficient matrix
        [2, 1, 2]
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n')]]])
        sage: [A, X, B, C]=diagonal_coef_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0  0  0]
        [ 0 a1  0  0]
        [ 0  0 a0  0]
        [ 0  0  0 a1]
        sage: A[0,1,0].printHM()
        [:, :]=
        [b0  0  0  0]
        [ 0 b1  0  0]
        [ 0  0 b0  0]
        [ 0  0  0 b1]
        sage: A[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,1,1].printHM()
        [:, :]=
        [-b0*c0      0      0      0]
        [     0 -b1*c1      0      0]
        [     0      0  a0*d0      0]
        [     0      0      0  a1*d1]
        sage: B[0,0,0].printHM()
        [:, :]=
        [e0  0  0  0]
        [ 0 e1  0  0]
        [ 0  0 e0  0]
        [ 0  0  0 e1]
        sage: B[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,0].printHM()
        [:, :]=
        [g0  0  0  0]
        [ 0 g1  0  0]
        [ 0  0 g0  0]
        [ 0  0  0 g1]
        sage: B[1,0,1].printHM()
        [:, :]=
        [f0*g0     0     0     0]
        [    0 f1*g1     0     0]
        [    0     0 e0*h0     0]
        [    0     0     0 e1*h1]
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, A10, A20], [A01, A11, A21]]])
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, B01, B02]], [[B10, B11, B12]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=diagonal_coef_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0  0  0  0  0  0  0]
        [ 0 a1  0  0  0  0  0  0]
        [ 0  0 a0  0  0  0  0  0]
        [ 0  0  0 a1  0  0  0  0]
        [ 0  0  0  0 a0  0  0  0]
        [ 0  0  0  0  0 a1  0  0]
        [ 0  0  0  0  0  0 a0  0]
        [ 0  0  0  0  0  0  0 a1]
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, HM(2,2,'zero'), HM(2,2,'zero')], [A01, A11, HM(2,2,'zero')]]])
        sage: Cf1
        [[[[[a0, 0], [0, a1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[b0, 0], [0, b1]], [[d0, 0], [0, d1]], [[0, 0], [0, 0]]]]]
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, HM(2,2,'zero'), HM(2,2,'zero')]], [[B10, B11, HM(2,2,'zero')]]])
        sage: Cf2
        [[[[[g0, 0], [0, g1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]]], [[[[j0, 0], [0, j1]], [[k0, 0], [0, k1]], [[0, 0], [0, 0]]]]]
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=diagonal_coef_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A
        [[[[[a0, 0], [0, a1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[b0, 0], [0, b1]], [[d0, 0], [0, d1]], [[0, 0], [0, 0]]]]]
        sage: B
        [[[[[g0, 0], [0, g1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]]], [[[[j0, 0], [0, j1]], [[k0, 0], [0, k1]], [[0, 0], [0, 0]]]]]

 
    AUTHORS:
    - Edinah K. Gnang
    - To Do:
    """
    if Cf1.n(1)==Vx.n(2) and Vx.n(2)==Cf2.n(0) and Cf1.n(2)==Cf2.n(2) and 1==Vx.n(0) and Vx.n(0)==Vx.n(1):
        # Initialization of the variable index
        vindx=0
        # Initializing copies of the input hypermatrices.
        A=Cf1.copy(); X=Vx.copy(); B=Cf2.copy(); C=rs.copy()
        # Initialization of the row and column index
        i=0; j=0
        while i < A.n(2) and j < A.n(1):
            while (HM(1,1,A.n(2)-i,[A[0,j,i0] for i0 in range(i,A.n(2))]).is_zero() and j < A.n(1)-1) or (HM(1,1,B.n(0)-i,[B[j,0,i0] for i0 in range(i,B.n(0))]).is_zero() and j < B.n(0)-1):
                # Incrementing the column index
                j=j+1
            if (HM(1,A.n(1),A.n(2)-i,[A[0,j0,i0] for i0 in range(i,A.n(2)) for j0 in range(A.n(1))]).is_zero()==False) and (HM(B.n(0),1,B.n(2)-i,[B[j0,0,i0] for i0 in range(i,B.n(2)) for j0 in range(B.n(0))]).is_zero()==False) and j < A.n(1):
                while A[0,j,i].is_zero() or B[j,0,i].is_zero():
                    # Initialization of the matrices
                    Ta=HM(A.n(2)-i,A.n(1),[A[0,j0,i0] for j0 in range(A.n(1)) for i0 in range(i,A.n(2))])
                    Tb=HM(B.n(2)-i,B.n(0),[B[j0,0,i0] for j0 in range(B.n(0)) for i0 in range(i,B.n(2))])
                    Tc=HM(C.n(2)-i,1,[C[0,0,i0] for i0 in range(i,C.n(2))])
                    # Inflating the entries of the identity matrix
                    idta=HM(2, A[0,0,0].n(0),'kronecker')
                    Ida=HM(2, Ta.n(0), 'kronecker')
                    idtb=HM(2, B[0,0,0].n(0),'kronecker')
                    Idb=HM(2, Tb.n(0), 'kronecker')
                    for u in range(Ta.n(0)):
                        for v in range(Ta.n(1)):
                            Ida[u,v]=idta*Ida[u,v]
                    for u in range(Tb.n(0)):
                        for v in range(Tb.n(1)):
                            Idb[u,v]=idtb*Idb[u,v]
                    # Initialization of the cyclic shift permutation matrix
                    Pa=sum([HM(Ta.n(0),1,[Ida[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Ida[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                    Pb=sum([HM(Tb.n(0),1,[Idb[i0,k] for i0 in range(Tb.n(0))])*HM(1,Tb.n(0),[Idb[Integer(mod(k+1,Tb.n(0))),j0] for j0 in range(Tb.n(0))]) for k in range(Tb.n(0))])
                    # Performing the shift
                    Ta=Pa*Ta; Tb=Pb*Tb; Tc=Pa*Tc
                    for i0 in range(Ta.n(0)):
                        for j0 in range(Ta.n(1)):
                            A[0,j0,i+i0]=Ta[i0,j0]
                    for i0 in range(Ta.n(0)):
                        for j0 in range(Ta.n(1)):
                            B[j0,0,i+i0]=Tb[i0,j0]
                    for i0 in range(b.n(0)):
                        C[0,0,i+i0]=Tc[i0,0]
                # Main part
                if (A.n(2)-i-1>0) and not ((HM(1,1,A.n(2)-i-1,[A[0,j,i0] for i0 in range(i+1,A.n(2))]).is_zero() and j <= A.n(1)-1) and (HM(1,1,B.n(2)-i-1,[B[j,0,i0] for i0 in range(i+1,B.n(2))]).is_zero() and j <= B.n(0)-1)):
                    # Performing the row operations.
                    cf1a = A[0,j,i]; cf1b = B[j,0,i]
                    # Backing up the variable prior to the inflation
                    Xold=X.copy()
                    # Updating the variables
                    for t in range(X.n(2)):
                        X[0,0,t]=HM(2,2,'kronecker').tensor_product(X[0,0,t])
                    # Updating the right hand side
                    for r in range(i+1,A.n(2)):
                        # Taking care of the zero row
                        if (HM(1,A.n(1),1,[A[0,j0,r] for j0 in range(A.n(1))]).is_zero()) or (HM(B.n(0),1,1,[B[j0,0,r] for j0 in range(B.n(0))]).is_zero()):
                            r=r+1
                        else:
                            # Initialization of the coefficient
                            cf2a=A[0,j,r]; cf2b=B[j,0,r]
                            # Updating the right hand side.
                            n0=C[0,0,0].n(0); n1=C[0,0,0].n(1)
                            U=HM(n0,n1,[var('z'+str(vindx+t)) for t in range(n0*n1)])
                            # Incrementing the free variable index
                            vindx=(n0*n1)+vindx
                            C[0,0,r]=(U-cf2a*C[0,0,i]*cf2b).block_sum(cf1a*C[0,0,r]*cf1b-U)
                            # Updating the constraints
                            for j0 in range(A.n(1)):
                                if (-cf2a*A[0,j0,i]*Xold[0,0,j0]*B[j0,0,i]*cf2b + cf1a*A[0,j0,r]*Xold[0,0,j0]*B[j0,0,r]*cf1b).is_zero():
                                    A[0,j0,r]=HM(2,2,'zero').tensor_product(A[0,j0,r])
                                    B[j0,0,r]=HM(2,2,'zero').tensor_product(B[j0,0,r])
                                else:
                                    A[0,j0,r]=(-cf2a*A[0,j0,i]).block_sum(cf1a*A[0,j0,r])
                                    B[j0,0,r]=( B[j0,0,i]*cf2b).block_sum(B[j0,0,r]*cf1b)
                    for r in range(i+1):
                        # Updating the other entries.
                        for j0 in range(A.n(1)):
                            A[0,j0,r]=HM(2,2,'kronecker').tensor_product(A[0,j0,r])
                        for j0 in range(B.n(0)):
                            B[j0,0,r]=HM(2,2,'kronecker').tensor_product(B[j0,0,r])
                        C[0,0,r]=HM(2,2,'kronecker').tensor_product(C[0,0,r])
            # Incrementing the row and column index
            i=i+1; j=j+1
        return [A, X, B, C]
    else:
        raise ValueError("Incorrect inputs")

def diagonal_coef_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs):
    """
    Outputs the reduced row echelon form of the input coefficient third order 
    hypermatrices and the corresponding right hand side. This implementation 
    assumes that the inputs are third order hypermatrices whose entries are 
    themselves diagonal second order hypermatrices (this is not checked).
    All entries of Cf1 are matrices of the size m x m and all entries of Cf2 
    are matrices of the size n x n. Consequently the entries of Vx and rs are 
    all m x n matrices. The implementation avoids division and consequently,
    does normalize the pivots to the units. The procedure would on other inputs so
    long as the entries of the coefficien matrices commutes among themeselve.


    EXAMPLES:
    ::

       
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag'); A11=HM(2,HM(2,'d').list(),'diag')
        sage: B00=HM(2,HM(2,'e').list(),'diag'); B01=HM(2,HM(2,'f').list(),'diag'); B10=HM(2,HM(2,'g').list(),'diag'); B11=HM(2,HM(2,'h').list(),'diag')
        sage: Cf1=HM([[[A00, A10], [A01, A11]]]); Cf1.dimensions() # Initialization of the left coefficient matrix
        [1, 2, 2] 
        sage: Cf2=HM([[[B00, B01]], [[B10, B11]]]); Cf2.dimensions() # Initialization of the right coefficient matrix
        [2, 1, 2]
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n')]]])
        sage: [A, X, B, C]=diagonal_coef_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [-a0*b0*c0         0         0         0]
        [        0 -a1*b1*c1         0         0]
        [        0         0   a0^2*d0         0]
        [        0         0         0   a1^2*d1]
        sage: A[0,1,0].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,1,1].printHM()
        [:, :]=
        [-b0*c0      0      0      0]
        [     0 -b1*c1      0      0]
        [     0      0  a0*d0      0]
        [     0      0      0  a1*d1]
        sage: B[0,0,0].printHM()
        [:, :]=
        [e0*f0*g0        0        0        0]
        [       0 e1*f1*g1        0        0]
        [       0        0  e0^2*h0        0]
        [       0        0        0  e1^2*h1]
        sage: B[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,0].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,1].printHM()
        [:, :]=
        [f0*g0     0     0     0]
        [    0 f1*g1     0     0]
        [    0     0 e0*h0     0]
        [    0     0     0 e1*h1]
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, HM(2,2,'zero'), HM(2,2,'zero')], [A01, A11, HM(2,2,'zero')]]])
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, HM(2,2,'zero'), HM(2,2,'zero')]], [[B10, B11, HM(2,2,'zero')]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=diagonal_coef_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A
        [[[[[a0*d0, 0], [0, a1*d1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[d0, 0], [0, d1]], [[0, 0], [0, 0]]]]]
        sage: C
        [[[[[d0*k0*m00 - b0*j0*n00, d0*k1*m01 - b0*j1*n01], [d1*k0*m10 - b1*j0*n10, d1*k1*m11 - b1*j1*n11]], [[n00, n01], [n10, n11]], [[p00, p01], [p10, p11]]]]]

 
    AUTHORS:
    - Edinah K. Gnang
    - To Do:
    """
    [A, X, B, C]=diagonal_coef_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
    # Initialization of the row and column index
    i=A.n(2)-1; j=0
    while i > 0 or j > 0:
        if HM(1,A.n(1),1,[A[0,j0,i] for j0 in range(A.n(1))]).is_zero() or HM(B.n(0),1,1,[B[j0,0,i] for j0 in range(B.n(0))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while A[0,j,i].is_zero() or B[j,0,i].is_zero():
                # Incrementing the column index
                j = j + 1
            # Performing row operations
            cf1a=A[0,j,i]; cf1b=B[j,0,i]
            for r in range(i-1,-1,-1):
                cf2a=A[0,j,r]; cf2b=B[j,0,r]
                # Updating the right hand side
                C[0,0,r]=-cf2a*C[0,0,i]*cf2b + cf1a*C[0,0,r]*cf1b
                # Updating the coefficients
                for j0 in range(A.n(1)):
                    A[0,j0,r]=-cf2a*A[0,j0,i] + cf1a*A[0,j0,r]
                    B[j0,0,r]=-B[j0,0,i]*cf2b + B[j0,0,r]*cf1b
            i=i-1; j=0
    return [A, X, B, C]

def general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs):
    """
    Outputs the row echelon form of the input coefficient third order hypermatrices 
    and the corresponding right hand side. This implementation assumes that the
    inputs are third order hypermatrices whose entries are themselves second order
    hypermatrices (square matrices to be precise). All entries of Cf1 are matrices
    of the size m x m and all entries of Cf2 are matrices of the size n x n.
    Consequently the entries of Vx and rs are all m x n matrices.


    EXAMPLES:
    ::

       
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag'); A11=HM(2,HM(2,'d').list(),'diag')
        sage: B00=HM(2,HM(2,'e').list(),'diag'); B01=HM(2,HM(2,'f').list(),'diag'); B10=HM(2,HM(2,'g').list(),'diag'); B11=HM(2,HM(2,'h').list(),'diag')
        sage: Cf1=HM([[[A00, A10], [A01, A11]]]); Cf1.dimensions() # Initialization of the left coefficient matrix
        [1, 2, 2] 
        sage: Cf2=HM([[[B00, B01]], [[B10, B11]]]); Cf2.dimensions() # Initialization of the right coefficient matrix
        [2, 1, 2]
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n')]]])
        sage: [A, X, B, C]=general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0  0  0]
        [ 0 a1  0  0]
        [ 0  0 a0  0]
        [ 0  0  0 a1]
        sage: A[0,1,0].printHM()
        [:, :]=
        [b0  0  0  0]
        [ 0 b1  0  0]
        [ 0  0 b0  0]
        [ 0  0  0 b1]
        sage: A[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,1,1].printHM()
        [:, :]=
        [-b0*c0/a0         0         0         0]
        [        0 -b1*c1/a1         0         0]
        [        0         0        d0         0]
        [        0         0         0        d1]
        sage: B[0,0,0].printHM()
        [:, :]=
        [e0  0  0  0]
        [ 0 e1  0  0]
        [ 0  0 e0  0]
        [ 0  0  0 e1]
        sage: B[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,0].printHM()
        [:, :]=
        [g0  0  0  0]
        [ 0 g1  0  0]
        [ 0  0 g0  0]
        [ 0  0  0 g1]
        sage: B[1,0,1].printHM()
        [:, :]=
        [f0*g0/e0        0        0        0]
        [       0 f1*g1/e1        0        0]
        [       0        0       h0        0]
        [       0        0        0       h1] 
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, A10, A20], [A01, A11, A21]]])
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, B01, B02]], [[B10, B11, B12]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0  0  0  0  0  0  0]
        [ 0 a1  0  0  0  0  0  0]
        [ 0  0 a0  0  0  0  0  0]
        [ 0  0  0 a1  0  0  0  0]
        [ 0  0  0  0 a0  0  0  0]
        [ 0  0  0  0  0 a1  0  0]
        [ 0  0  0  0  0  0 a0  0]
        [ 0  0  0  0  0  0  0 a1]
        sage: A00=HM(2,2,'a'); A01=HM(2,2,'b'); A10=HM(2,2,'c')
        sage: A11=HM(2,2,'d'); A20=HM(2,2,'e'); A21=HM(2,2,'f')
        sage: Cf1=HM([[[A00, A10, A20], [A01, A11, A21]]])
        sage: B00=HM(2,2,'g'); B01=HM(2,2,'h'); B02=HM(2,2,'i')
        sage: B10=HM(2,2,'j'); B11=HM(2,2,'k'); B12=HM(2,2,'l')
        sage: Cf2=HM([[[B00, B01, B02]], [[B10, B11, B12]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a00 a01   0   0   0   0   0   0]
        [a10 a11   0   0   0   0   0   0]
        [  0   0 a00 a01   0   0   0   0]
        [  0   0 a10 a11   0   0   0   0]
        [  0   0   0   0 a00 a01   0   0]
        [  0   0   0   0 a10 a11   0   0]
        [  0   0   0   0   0   0 a00 a01]
        [  0   0   0   0   0   0 a10 a11]
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, HM(2,2,'zero'), HM(2,2,'zero')], [A01, A11, HM(2,2,'zero')]]])
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, HM(2,2,'zero'), HM(2,2,'zero')]], [[B10, B11, HM(2,2,'zero')]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0]
        [ 0 a1]

 
    AUTHORS:
    - Edinah K. Gnang
    - To Do:
    """
    if Cf1.n(1)==Vx.n(2) and Vx.n(2)==Cf2.n(0) and Cf1.n(2)==Cf2.n(2) and 1==Vx.n(0) and Vx.n(0)==Vx.n(1):
        # Initialization of the variable index
        vindx=0
        # Initializing copies of the input hypermatrices.
        A=Cf1.copy(); X=Vx.copy(); B=Cf2.copy(); C=rs.copy()
        # Initialization of the row and column index
        i=0; j=0
        while i < A.n(2) and j < A.n(1):
            while (HM(1,1,A.n(2)-i,[A[0,j,i0] for i0 in range(i,A.n(2))]).is_zero() and j < A.n(1)-1) or (HM(1,1,B.n(2)-i,[B[j,0,i0] for i0 in range(i,B.n(2))]).is_zero() and j < B.n(2)-1):
                # Incrementing the column index
                j=j+1
            if (HM(1,A.n(1),A.n(2)-i,[A[0,j0,i0] for i0 in range(i,A.n(2)) for j0 in range(A.n(1))]).is_zero()==False) and (HM(B.n(0),1,B.n(2)-i,[B[j0,0,i0] for i0 in range(i,B.n(2)) for j0 in range(B.n(0))]).is_zero()==False) and j < A.n(1):
                while A[0,j,i].is_zero() or B[j,0,i].is_zero():
                    # Initialization of the matrices
                    Ta=HM(A.n(2)-i,A.n(1),[A[0,j0,i0] for j0 in range(A.n(1)) for i0 in range(i,A.n(2))])
                    Tb=HM(B.n(2)-i,B.n(0),[B[j0,0,i0] for j0 in range(B.n(0)) for i0 in range(i,B.n(2))])
                    Tc=HM(C.n(2)-i,1,[C[0,0,i0] for i0 in range(i,C.n(2))])
                    # Inflating the entries of the identity matrix
                    idta=HM(2, A[0,0,0].n(0),'kronecker')
                    Ida=HM(2, Ta.n(0), 'kronecker')
                    idtb=HM(2, B[0,0,0].n(0),'kronecker')
                    Idb=HM(2, Tb.n(0), 'kronecker')
                    for u in range(Ta.n(0)):
                        for v in range(Ta.n(1)):
                            Ida[u,v]=idta*Ida[u,v]
                    for u in range(Tb.n(0)):
                        for v in range(Tb.n(1)):
                            Idb[u,v]=idtb*Idb[u,v]
                    # Initialization of the cyclic shift permutation matrix
                    Pa=sum([HM(Ta.n(0),1,[Ida[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Ida[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                    Pb=sum([HM(Tb.n(0),1,[Idb[i0,k] for i0 in range(Tb.n(0))])*HM(1,Tb.n(0),[Idb[Integer(mod(k+1,Tb.n(0))),j0] for j0 in range(Tb.n(0))]) for k in range(Tb.n(0))])
                    # Performing the shift
                    Ta=Pa*Ta; Tb=Pb*Tb; Tc=Pa*Tc
                    for i0 in range(Ta.n(0)):
                        for j0 in range(Ta.n(1)):
                            A[0,j0,i+i0]=Ta[i0,j0]
                    for i0 in range(Ta.n(0)):
                        for j0 in range(Ta.n(1)):
                            B[j0,0,i+i0]=Tb[i0,j0]
                    for i0 in range(b.n(0)):
                        C[0,0,i+i0]=Tc[i0,0]
                # Here we mean business
                if (A.n(2)-i-1> 0) and not ((HM(1,1,A.n(2)-i-1,[A[0,j,i0] for i0 in range(i+1,A.n(2))]).is_zero() and j <= A.n(1)-1) and (HM(1,1,B.n(2)-i-1,[B[j,0,i0] for i0 in range(i+1,B.n(2))]).is_zero() and j <= B.n(0)-1)):
                    # Performing the row operations.
                    cf1a = A[0,j,i]; cf1b = B[j,0,i]
                    # Backing up the variable prior to the inflation
                    Xold=X.copy()
                    # Updating the variables
                    for t in range(X.n(2)):
                        X[0,0,t]=HM(2,2,'kronecker').tensor_product(X[0,0,t])
                    # Updating the right hand side
                    for r in range(i+1,A.n(2)):
                        # Taking care of the zero row
                        if (HM(1,A.n(1),1,[A[0,j0,r] for j0 in range(A.n(1))]).is_zero()) or (HM(B.n(0),1,1,[B[j0,0,r] for j0 in range(B.n(0))]).is_zero()):
                            r=r+1
                        else:
                            # Initialization of the coefficient
                            cf2a=A[0,j,r]; cf2b=B[j,0,r]
                            # Updating the right hand side.
                            n0=C[0,0,0].n(0); n1=C[0,0,0].n(1)
                            U=HM(n0,n1,[var('z'+str(vindx+t)) for t in range(n0*n1)])
                            # Incrementing the free variable index
                            vindx=(n0*n1)+vindx
                            C[0,0,r]=(U-(cf2a*cf1a^(-1))*C[0,0,i]*(cf1b^(-1)*cf2b)).block_sum(C[0,0,r]-U)
                            # Updating the constraints
                            for j0 in range(A.n(1)):
                                if (-cf2a*A[0,j0,i]*Xold[0,0,j0]*B[j0,0,i]*cf2b + cf1a*A[0,j0,r]*Xold[0,0,j0]*B[j0,0,r]*cf1b).is_zero():
                                    A[0,j0,r]=HM(2,2,'zero').tensor_product(A[0,j0,r])
                                    B[j0,0,r]=HM(2,2,'zero').tensor_product(B[j0,0,r])
                                else:
                                    A[0,j0,r]=(-(cf2a*cf1a^(-1))*A[0,j0,i]).block_sum(A[0,j0,r])
                                    B[j0,0,r]=(B[j0,0,i]*(cf1b^(-1)*cf2b)).block_sum(B[j0,0,r])
                    for r in range(i+1):
                        # Updating the other entries.
                        for j0 in range(A.n(1)):
                            A[0,j0,r]=HM(2,2,'kronecker').tensor_product(A[0,j0,r])
                            B[j0,0,r]=HM(2,2,'kronecker').tensor_product(B[j0,0,r])
                        C[0,0,r]=HM(2,2,'kronecker').tensor_product(C[0,0,r])
            # Incrementing the row and column index
            i=i+1; j=j+1
        return [A, X, B, C]
    else:
        raise ValueError("Incorrect inputs")

def general_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs):
    """
    Outputs the reduced row echelon form of the input coefficient third order hypermatrices 
    and the corresponding right hand side. This implementation assumes that the
    inputs are third order hypermatrices whose entries are themselves second order
    hypermatrices (square matrices to be precise). All entries of Cf1 are matrices
    of the size m x m and all entries of Cf2 are matrices of the size n x n.
    Consequently the entries of Vx and rs are all m x n matrices.


    EXAMPLES:
    ::


        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag'); A11=HM(2,HM(2,'d').list(),'diag')
        sage: B00=HM(2,HM(2,'e').list(),'diag'); B01=HM(2,HM(2,'f').list(),'diag'); B10=HM(2,HM(2,'g').list(),'diag'); B11=HM(2,HM(2,'h').list(),'diag')
        sage: Cf1=HM([[[A00, A10], [A01, A11]]]); Cf1.dimensions() # Initialization of the left coefficient matrix
        [1, 2, 2] 
        sage: Cf2=HM([[[B00, B01]], [[B10, B11]]]); Cf2.dimensions() # Initialization of the right coefficient matrix
        [2, 1, 2]
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n')]]])
        sage: [A, X, B, C]=general_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A[0,0,0].printHM()
        [:, :]=
        [a0  0  0  0]
        [ 0 a1  0  0]
        [ 0  0 a0  0]
        [ 0  0  0 a1]
        sage: A[0,1,0].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: A[0,1,1].printHM()
        [:, :]=
        [-b0*c0/a0         0         0         0]
        [        0 -b1*c1/a1         0         0]
        [        0         0        d0         0]
        [        0         0         0        d1]
        sage: B[0,0,0].printHM()
        [:, :]=
        [e0  0  0  0]
        [ 0 e1  0  0]
        [ 0  0 e0  0]
        [ 0  0  0 e1]
        sage: B[0,0,1].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,0].printHM()
        [:, :]=
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]
        sage: B[1,0,1].printHM()
        [:, :]=
        [f0*g0/e0        0        0        0]
        [       0 f1*g1/e1        0        0]
        [       0        0       h0        0]
        [       0        0        0       h1]
        sage: A00=HM(2,HM(2,'a').list(),'diag'); A01=HM(2,HM(2,'b').list(),'diag'); A10=HM(2,HM(2,'c').list(),'diag')
        sage: A11=HM(2,HM(2,'d').list(),'diag'); A20=HM(2,HM(2,'e').list(),'diag'); A21=HM(2,HM(2,'f').list(),'diag')
        sage: Cf1=HM([[[A00, HM(2,2,'zero'), HM(2,2,'zero')], [A01, A11, HM(2,2,'zero')]]])
        sage: B00=HM(2,HM(2,'g').list(),'diag'); B01=HM(2,HM(2,'h').list(),'diag'); B02=HM(2,HM(2,'i').list(),'diag')
        sage: B10=HM(2,HM(2,'j').list(),'diag'); B11=HM(2,HM(2,'k').list(),'diag'); B12=HM(2,HM(2,'l').list(),'diag')
        sage: Cf2=HM([[[B00, HM(2,2,'zero'), HM(2,2,'zero')]], [[B10, B11, HM(2,2,'zero')]]]) 
        sage: Vx=HM([[[HM(2,2,'x'), HM(2,2,'y')]]])
        sage: rs=HM([[[HM(2,2,'m'), HM(2,2,'n'), HM(2,2,'p')]]])
        sage: [A, X, B, C]=general_gauss_jordan_eliminationHM(Cf1, Vx, Cf2, rs)
        sage: A
        [[[[[a0, 0], [0, a1]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[d0, 0], [0, d1]], [[0, 0], [0, 0]]]]]        
        sage: C
        [[[[[m00 - b0*j0*n00/(d0*k0), m01 - b0*j1*n01/(d0*k1)], [m10 - b1*j0*n10/(d1*k0), m11 - b1*j1*n11/(d1*k1)]], [[n00, n01], [n10, n11]], [[p00, p01], [p10, p11]]]]]

 
    AUTHORS:
    - Edinah K. Gnang
    - To Do:
    """
    [A, X, B, C]=general_gaussian_eliminationHM(Cf1, Vx, Cf2, rs)
    # Initialization of the row and column index
    i=A.n(2)-1; j=0
    while i > 0 or j > 0:
        if HM(1,A.n(1),1,[A[0,j0,i] for j0 in range(A.n(1))]).is_zero() or HM(B.n(0),1,1,[B[j0,0,i] for j0 in range(B.n(0))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while A[0,j,i].is_zero() or B[j,0,i].is_zero():
                # Incrementing the column index
                j = j + 1
            # Performing row operations
            cf1a=A[0,j,i]; cf1b=B[j,0,i]
            for r in range(i-1,-1,-1):
                cf2a=A[0,j,r]; cf2b=B[j,0,r]
                # Updating the right hand side
                C[0,0,r]=-(cf2a*cf1a^(-1))*C[0,0,i]*(cf1b^(-1)*cf2b) + C[0,0,r]
                # Updating the coefficients
                for j0 in range(A.n(1)):
                    A[0,j0,r]=-(cf2a*cf1a^(-1))*A[0,j0,i] + A[0,j0,r]
                for j0 in range(B.n(0)):
                    B[j0,0,r]=-B[j0,0,i]*(cf1b^(-1)*cf2b) + B[j0,0,r]
            i=i-1; j=0
    return [A, X, B, C]

def ThirdOrderDepthCyclicShift(A, s=1):
    """ 
    This function performs a cyclic shift to the order of
    the depth slices of an input third order hypermatrix A.

    EXAMPLES:
    ::

  
        sage: A = HM(3,3,3,'a'); ThirdOrderDepthCyclicShift(A).printHM()
        [:, :, 0]= 
        [a002 a012 a022]
        [a102 a112 a122]
        [a202 a212 a222]
        <BLANKLINE>
        [:, :, 1]=
        [a000 a010 a020]
        [a100 a110 a120]
        [a200 a210 a220]
        <BLANKLINE>
        [:, :, 2]=
        [a001 a011 a021]
        [a101 a111 a121]
        [a201 a211 a221]
        <BLANKLINE>


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the output hypermatrix to be filled
    #B = apply(HM, A.dimensions()+['zero'])
    B = HM(*(A.dimensions()+['zero']))
    for i in range(A.n(0)):
        for j in range(A.n(1)):
            for k in range(A.n(2)):
                B[i,j,k]=A[i,j,Integer(mod(k-s,A.n(2)))]
    return B

def hadamard_gaussian_eliminationHM(Cf, rs):
    """
    Outputs the row echelon form of the input second order hypermatrix and the right hand side.
    does not normalize the rows to ensure that the first non zero entry of non zero rows = 1
    This implementation tacitly assumes that the entries commute. As a result this implementation
    is NOT skew field friendly. Furthermore the implementation assumes that the inputs are
    second order hypermatrices whose entries are themselves second order hypermatrices.
 

    EXAMPLES:
 
    ::

        sage: Ha=HM(2,2,[HM(2,2,'a'), HM(2,2,'c'), HM(2,2,'b'), HM(2,2,'d')])
        sage: Hb=HM(2,1,[HM(2,2,'f'), HM(2,2,'g')])
        sage: [A,b]=hadamard_gaussian_eliminationHM(Ha,Hb)
        sage: A
        [[[[a00, a01], [a10, a11]], [[b00, b01], [b10, b11]]], [[[0, 0], [0, 0]], [[b00*c00 - a00*d00, b01*c01 - a01*d01], [b10*c10 - a10*d10, b11*c11 - a11*d11]]]]
        sage: b
        [[[[f00, f01], [f10, f11]]], [[[c00*f00 - a00*g00, c01*f01 - a01*g01], [c10*f10 - a10*g10, c11*f11 - a11*g11]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy(); b=rs.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Tb=HM(b.n(0)-i, b.n(1), [b[i0,j0] for j0 in range(b.n(1)) for i0 in range(i,b.n(0))])
                # Initializing the cyclic shift permutation matrix
                Id=HM(2, Ta.n(0), 'kronecker')
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; Tb=P*Tb
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
                for i0 in range(Tb.n(0)):
                    for j0 in range(Tb.n(1)):
                        b[i+i0,j0]=Tb[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    cf2=A[r,j]
                    for j0 in range(b.n(1)):
                        b[r,j0]=cf2.elementwise_product(b[i,j0])-cf1.elementwise_product(b[r,j0])
                    for j0 in range(A.n(1)):
                        A[r,j0]=cf2.elementwise_product(A[i,j0])-cf1.elementwise_product(A[r,j0])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return [A,b]

def hadamard_gauss_jordan_eliminationHM(Cf,rs):
    """
    Outputs the reduced row echelon form of the input matrix and the right hand side.
    This implementation assumes that the input entries commute and is therefore NOT
    skew field friendly. Furthermore the implementation assumes that the inputs are
    second order hypermatrices whose entries are themselves second order hypermatrices.


    EXAMPLES:
 
    ::

        sage: Ha=HM(2,2,[HM(2,2,'a'), HM(2,2,'c'), HM(2,2,'b'), HM(2,2,'d')])
        sage: Hb=HM(2,1,[HM(2,2,'f'), HM(2,2,'g')])
        sage: [A,b]=hadamard_gauss_jordan_eliminationHM(Ha,Hb)
        sage: A
        [[[[-(b00*c00 - a00*d00)*a00, -(b01*c01 - a01*d01)*a01], [-(b10*c10 - a10*d10)*a10, -(b11*c11 - a11*d11)*a11]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[b00*c00 - a00*d00, b01*c01 - a01*d01], [b10*c10 - a10*d10, b11*c11 - a11*d11]]]]
        sage: b
        [[[[(c00*f00 - a00*g00)*b00 - (b00*c00 - a00*d00)*f00, (c01*f01 - a01*g01)*b01 - (b01*c01 - a01*d01)*f01], [(c10*f10 - a10*g10)*b10 - (b10*c10 - a10*d10)*f10, (c11*f11 - a11*g11)*b11 - (b11*c11 - a11*d11)*f11]]], [[[c00*f00 - a00*g00, c01*f01 - a01*g01], [c10*f10 - a10*g10, c11*f11 - a11*g11]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    [A, b] = hadamard_gaussian_eliminationHM(Cf,rs)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            cf1=A[i,j]
            for r in range(i-1,-1,-1):
                #b[r,:] = -A[r,j]*b[i,:]+b[r,:]
                cf2=A[r,j]
                for j0 in range(b.n(1)):
                    b[r,j0]=cf2.elementwise_product(b[i,j0])-cf1.elementwise_product(b[r,j0])
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                for j0 in range(A.n(1)):
                    A[r,j0]=cf2.elementwise_product(A[i,j0])-cf1.elementwise_product(A[r,j0])
            i=i-1; j=0
    return [A,b]

def list_elementwise_product(L):
    """
    Procedure for computing Hypermatrix Hadamard products of list elementwise.

    EXAMPLES:

    ::

        sage: A=HM(2,2,'a'); B=HM(2,2,'b'); C=HM(2,2,'c')
        sage: list_elementwise_product([A,B,C]).printHM()
        [:, :]=
        [a00*b00*c00 a01*b01*c01]
        [a10*b10*c10 a11*b11*c11]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the hypermatrix
    Tmp=L[0]
    for h in L[1:]:
        Tmp=Tmp.elementwise_product(h)  
    return Tmp

def GeneralHypermatrixProduct_with_elementwise_product(*args):
    """
    Outputs a list of lists associated with the general
    Bhattacharya-Mesner product of the input hypermatrices
    whose entries are themselves hypermatrices of the same
    size. The BM product is performed as usual with the 
    exception that we perform elementwise product performing
    elementwise product of the entries


    EXAMPLES:

    ::

        sage: A=HM(2,2,[HM(2,2,'a'),HM(2,2,'c'),HM(2,2,'b'),HM(2,2,'d')])
        sage: B=HM(2,2,[HM(2,2,'e'),HM(2,2,'f'),HM(2,2,'g'),HM(2,2,'h')])
        sage: GeneralHypermatrixProduct_with_elementwise_product(A,B)[0,0].printHM()
        [:, :]=
        [a00*e00 + b00*f00 a01*e01 + b01*f01]
        [a10*e10 + b10*f10 a11*e11 + b11*f11]
        sage: GeneralHypermatrixProduct_with_elementwise_product(A,B)[0,1].printHM()
        [:, :]=
        [a00*g00 + b00*h00 a01*g01 + b01*h01]
        [a10*g10 + b10*h10 a11*g11 + b11*h11]
        sage: GeneralHypermatrixProduct_with_elementwise_product(A,B)[1,0].printHM()
        [:, :]=
        [c00*e00 + d00*f00 c01*e01 + d01*f01]
        [c10*e10 + d10*f10 c11*e11 + d11*f11]
        sage: GeneralHypermatrixProduct_with_elementwise_product(A,B)[1,1].printHM()
        [:, :]=
        [c00*g00 + d00*h00 c01*g01 + d01*h01]
        [c10*g10 + d10*h10 c11*g11 + d11*h11]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [(args[i]).n(i) for i in range(len(args))]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the assignement
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        # computing the Hypermatrix product
        if len(args)<2:
            raise ValueError("The number of operands must be >= 2")
        elif len(args) >= 2:
            Rh[tuple(entry)]=sum([list_elementwise_product([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+[t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+[args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+[args[len(args)-1][tuple([t]+entry[1:])]]) for t in range((args[0]).n(1))])
    return Rh

def hadamard_linear_solverHM(A,b,x,v):
    """
    Outputs the Reduced Row Echelon Form of the input matrix and the right hand side.
    where A denotes the input matrix, b denotes the right-hand side vector, x denotes
    the variable vector coming from the original system of equations, and v denotes 
    the free variable vector.

    EXAMPLES:
 
    ::

        sage: sz=2; Eq=[var('x'+str(i))+var('x'+str(sz+j))==var('a'+str(i)+str(j)) for i in range(sz) for j in range(sz)]
        sage: [A,b]=ConstraintFormatorHM(Eq,[var('x'+str(i)) for i in range(2*sz)])
        sage: Mx=HM(A.ncols(),1,[HM(1,1,[var('x'+str(i))]) for i in range(A.ncols())])
        sage: Mv=HM(A.ncols(),1,[HM(1,1,[var('t'+str(i))]) for i in range(A.ncols())])
        sage: Ha=HM(A.n(0),A.n(1),'zero'); Hb=HM(b.n(0),b.n(1),'zero')
        sage: for i in range(A.n(0)):
        ....:     Hb[i,0]=HM(1,1,[b[i,0]])
        ....:     for j in range(A.n(1)):
        ....:         Ha[i,j]=HM(1,1,[A[i,j]])
        ....:
        sage: Sln=hadamard_linear_solverHM(Ha,Hb,Mx,Mv); Sln
        [[[[x0]], [[a00 - a10 + a11 - t3]]],
         [[[x1]], [[a11 - t3]]],
         [[[x2]], [[a10 - a11 + t3]]],
         [[[0]], [[-a00 + a01 + a10 - a11]]]] 
        sage: A=HM(2,2,'a'); b=HM(2,1,HM(2,'b').list()); X=HM(2,1,HM(2,'x').list())
        sage: for i in range(2):
        ....:     b[i,0]=HM(1,1,[b[i,0]]); X[i,0]=HM(1,1,[X[i,0]])
        ....:     for j in range(2):
        ....:         A[i,j]=HM(1,1,[A[i,j]])
        ....:
        sage: Sln=hadamard_linear_solverHM(A,b,X,X); Sln
        [[[[-(a01*a10 - a00*a11)*a00*x0]],
          [[(a10*b0 - a00*b1)*a01 - (a01*a10 - a00*a11)*b0]]],
         [[[(a01*a10 - a00*a11)*x1]], [[a10*b0 - a00*b1]]]]

        
    AUTHORS:
    - Initial implementation by Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the reduced echelon form.
    [Ap,bp]=hadamard_gauss_jordan_eliminationHM(A,b)
    Id1=HM(2,Ap.n(0),'kronecker')
    for i in range(Id1.n(0)):
        for j in range(Id1.n(1)):
            Id1[i,j]=HM(2,Ap[0,0].n(0),'kronecker')*Id1[i,j]
    Id2=HM(2,Ap.n(1),'kronecker')
    for i in range(Id2.n(0)):
        for j in range(Id2.n(1)):
            Id2[i,j]=HM(2,Ap[0,0].n(1),'kronecker')*Id2[i,j]
    # Obtainin the list of pivot variables.
    Pm=HM(Ap.n(0),Ap.n(1),[HM(Ap[0,0].n(0),Ap[0,0].n(1),'zero') for cnt in range(Ap.n(0)*Ap.n(1))])
    for i in range(Ap.n(0)):
        if not HM(1,Ap.n(1),[Ap[i,u] for u in range(Ap.n(1))]).is_zero():
            for j in range(Ap.n(1)):
                #if Ap[i,j].is_unit():
                if not Ap[i,j].is_zero():
                    break
            #Pm=Pm+HM(Id1.n(0),1,[Id1[s,i] for s in range(Id1.n(0))])*HM(1,Id2.n(1),[Id2[j,t]*Ap[i,j] for t in range(Id2.n(1))])
            Pm[i,j]=Ap[i,j].copy()
    # Expressing the solutions
    tp1=GeneralHypermatrixProduct_with_elementwise_product(Pm,x)
    tp2=bp-GeneralHypermatrixProduct_with_elementwise_product((Ap-Pm),v)
    return [[tp1[i,0],tp2[i,0]] for i in range(tp1.n(0))]

def eulerian_eliminationHM(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=HM(sz,'x').list(); Ha=HM(sz,sz,'a'); Hb=HM(sz,1,HM(sz,'b').list())
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=eulerian_eliminationHM(CnstrLst, VrbLst)
        sage: Lf
        [a00*x0 + a01*x1 + a02*x2 - b0,
         a01*a10*x1 - a00*a11*x1 + a02*a10*x2 - a00*a12*x2 - a10*b0 + a00*b1,
         a00*a02*a11*a20*x2 - a00*a01*a12*a20*x2 - a00*a02*a10*a21*x2 + a00^2*a12*a21*x2 + a00*a01*a10*a22*x2 - a00^2*a11*a22*x2 - a00*a11*a20*b0 + a00*a10*a21*b0 + a00*a01*a20*b1 - a00^2*a21*b1 - a00*a01*a10*b2 + a00^2*a11*b2]
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 1 1]
        [0 1 1]
        [0 0 1]
        sage: sz=2; od=2 # Initialization of the size and parameters
        sage: A=HM(sz,sz,'a'); U=HM(sz,sz,'u'); V=HM(sz,sz,'v'); Dmu=HM(od,var_list('mu',sz),'diag'); Dnu=HM(od,var_list('nu',sz),'diag')
        sage: VrbLst=var_list('mu',sz)+var_list('nu',sz)+U.list()+V.list() # Initialization of the variables
        sage: CnstrLst=(A-U*Dmu*Dnu*V).list()+(HM(od,sz,'kronecker')-U*V).list()
        sage: degree_matrix(CnstrLst,VrbLst).printHM()
        [:, :]=
        [1 1 1 1 1 0 1 0 1 1 0 0]
        [1 1 1 1 0 1 0 1 1 1 0 0]
        [1 1 1 1 1 0 1 0 0 0 1 1]
        [1 1 1 1 0 1 0 1 0 0 1 1]
        [0 0 0 0 1 0 1 0 1 1 0 0]
        [0 0 0 0 0 1 0 1 1 1 0 0]
        [0 0 0 0 1 0 1 0 0 0 1 1]
        [0 0 0 0 0 1 0 1 0 0 1 1]
        sage: EqL=eulerian_eliminationHM(CnstrLst, VrbLst)
        sage: degree_matrix(EqL,VrbLst).printHM()
        [:, :]=
        [1 1 1 1 1 0 1 0 1 1 0 0]
        [0 1 1 1 1 1 1 1 1 1 0 0]
        [0 0 2 1 2 1 1 1 2 1 1 1]
        [0 0 0 0 1 0 1 0 1 1 0 0]
        [0 0 0 0 0 1 0 1 1 1 0 0]
        [0 0 0 0 0 0 1 0 1 1 1 1]
        [0 0 0 0 0 0 0 1 1 1 1 1]
        [0 0 0 0 0 0 0 0 0 0 0 0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the list of polynomials
    CnstrLst=copy(PolyLst)
    # Initializing the degree matrix.
    A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in rg(len(VrbLst))] for indx in rg(len(CnstrLst))])
    # Displaying the matrix on screen
    #A.printHM()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        #while HM(A.n(0)-i, 1, [A[i0,j] for i0 in rg(i,A.n(0))]).is_zero() and j < A.ncols()-1:
        while (A.slice([j],1).slice(rg(i,A.n(0)),0)).is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        #if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
        if A.slice(rg(A.n(1)),1).slice(rg(i,A.n(0)),0).is_zero()==False:
            while A[i,j].is_zero(): 
                #Ta=A[i:,:]
                #Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Ta=A.slice(rg(i,A.n(0)),0)
                # Initializing the cyclic shift permutation matrix
                #Id=identity_matrix(Ta.nrows())
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([Id[:,k]*Id[mod(k+1,Ta.nrows()),:] for k in range(Ta.nrows())])
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; CnstrLst=CnstrLst[:i]+(P*HM(len(CnstrLst[i:]), 1, CnstrLst[i:])).list()
                #A[i:,:]=Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            for r in rg(i+1,A.nrows()):
                # Taking care of the zero row
                #if HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))]).is_zero():
                if A.slice([r],0).is_zero():
                    r=r+1
                else:
                    if CnstrLst[r].degree(VrbLst[j])*CnstrLst[i].degree(VrbLst[j])!=0 and not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                        if not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                            CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                            #print('i=', i,'j=', j,' r=', r)
                            # Updating the degree matrix
                            A=degree_matrix(CnstrLst,VrbLst)
                            #A.printHM()
                        else:
                            CnstrLst[r]=SR(0)
                            # Updating the degree matrix
                            A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in rg(len(VrbLst))] for indx in rg(len(CnstrLst))])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return CnstrLst

def euler_sylvester_eliminationHM(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in reduced row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=HM(sz,'x').list(); Ha=HM(sz,sz,'a'); Hb=HM(sz,1,HM(sz,'b').list())
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=euler_sylvester_eliminationHM(CnstrLst, VrbLst)
        sage: degree_matrix(Lf, VrbLst)
        [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        sage: Lf
        [-a00^3*a01*a02^2*a10*a11^2*a20^2*x0 + a00^4*a02^2*a11^3*a20^2*x0 + 2*a00^3*a01^2*a02*a10*a11*a12*a20^2*x0 - 2*a00^4*a01*a02*a11^2*a12*a20^2*x0 - a00^3*a01^3*a10*a12^2*a20^2*x0 + a00^4*a01^2*a11*a12^2*a20^2*x0 + 2*a00^3*a01*a02^2*a10^2*a11*a20*a21*x0 - 2*a00^4*a02^2*a10*a11^2*a20*a21*x0 - 2*a00^3*a01^2*a02*a10^2*a12*a20*a21*x0 + 2*a00^5*a02*a11^2*a12*a20*a21*x0 + 2*a00^4*a01^2*a10*a12^2*a20*a21*x0 - 2*a00^5*a01*a11*a12^2*a20*a21*x0 - a00^3*a01*a02^2*a10^3*a21^2*x0 + a00^4*a02^2*a10^2*a11*a21^2*x0 + 2*a00^4*a01*a02*a10^2*a12*a21^2*x0 - 2*a00^5*a02*a10*a11*a12*a21^2*x0 - a00^5*a01*a10*a12^2*a21^2*x0 + a00^6*a11*a12^2*a21^2*x0 - 2*a00^3*a01^2*a02*a10^2*a11*a20*a22*x0 + 4*a00^4*a01*a02*a10*a11^2*a20*a22*x0 - 2*a00^5*a02*a11^3*a20*a22*x0 + 2*a00^3*a01^3*a10^2*a12*a20*a22*x0 - 4*a00^4*a01^2*a10*a11*a12*a20*a22*x0 + 2*a00^5*a01*a11^2*a12*a20*a22*x0 + 2*a00^3*a01^2*a02*a10^3*a21*a22*x0 - 4*a00^4*a01*a02*a10^2*a11*a21*a22*x0 + 2*a00^5*a02*a10*a11^2*a21*a22*x0 - 2*a00^4*a01^2*a10^2*a12*a21*a22*x0 + 4*a00^5*a01*a10*a11*a12*a21*a22*x0 - 2*a00^6*a11^2*a12*a21*a22*x0 - a00^3*a01^3*a10^3*a22^2*x0 + 3*a00^4*a01^2*a10^2*a11*a22^2*x0 - 3*a00^5*a01*a10*a11^2*a22^2*x0 + a00^6*a11^3*a22^2*x0 + a00^3*a01*a02*a10*a11*a12*a20*a21*b0 - a00^4*a02*a11^2*a12*a20*a21*b0 - a00^3*a01^2*a10*a12^2*a20*a21*b0 + a00^4*a01*a11*a12^2*a20*a21*b0 - a00^3*a01*a02*a10^2*a12*a21^2*b0 + a00^4*a02*a10*a11*a12*a21^2*b0 + a00^4*a01*a10*a12^2*a21^2*b0 - a00^5*a11*a12^2*a21^2*b0 - a00^3*a01*a02*a10*a11^2*a20*a22*b0 + a00^4*a02*a11^3*a20*a22*b0 + a00^3*a01^2*a10*a11*a12*a20*a22*b0 - a00^4*a01*a11^2*a12*a20*a22*b0 + a00^3*a01*a02*a10^2*a11*a21*a22*b0 - a00^4*a02*a10*a11^2*a21*a22*b0 + a00^3*a01^2*a10^2*a12*a21*a22*b0 - 3*a00^4*a01*a10*a11*a12*a21*a22*b0 + 2*a00^5*a11^2*a12*a21*a22*b0 - a00^3*a01^2*a10^2*a11*a22^2*b0 + 2*a00^4*a01*a10*a11^2*a22^2*b0 - a00^5*a11^3*a22^2*b0 - a00^3*a01*a02^2*a10*a11*a20*a21*b1 + a00^4*a02^2*a11^2*a20*a21*b1 + a00^3*a01^2*a02*a10*a12*a20*a21*b1 - a00^4*a01*a02*a11*a12*a20*a21*b1 + a00^3*a01*a02^2*a10^2*a21^2*b1 - a00^4*a02^2*a10*a11*a21^2*b1 - a00^4*a01*a02*a10*a12*a21^2*b1 + a00^5*a02*a11*a12*a21^2*b1 + a00^3*a01^2*a02*a10*a11*a20*a22*b1 - a00^4*a01*a02*a11^2*a20*a22*b1 - a00^3*a01^3*a10*a12*a20*a22*b1 + a00^4*a01^2*a11*a12*a20*a22*b1 - 2*a00^3*a01^2*a02*a10^2*a21*a22*b1 + 3*a00^4*a01*a02*a10*a11*a21*a22*b1 - a00^5*a02*a11^2*a21*a22*b1 + a00^4*a01^2*a10*a12*a21*a22*b1 - a00^5*a01*a11*a12*a21*a22*b1 + a00^3*a01^3*a10^2*a22^2*b1 - 2*a00^4*a01^2*a10*a11*a22^2*b1 + a00^5*a01*a11^2*a22^2*b1 + a00^3*a01*a02^2*a10*a11^2*a20*b2 - a00^4*a02^2*a11^3*a20*b2 - 2*a00^3*a01^2*a02*a10*a11*a12*a20*b2 + 2*a00^4*a01*a02*a11^2*a12*a20*b2 + a00^3*a01^3*a10*a12^2*a20*b2 - a00^4*a01^2*a11*a12^2*a20*b2 - a00^3*a01*a02^2*a10^2*a11*a21*b2 + a00^4*a02^2*a10*a11^2*a21*b2 + a00^3*a01^2*a02*a10^2*a12*a21*b2 - a00^5*a02*a11^2*a12*a21*b2 - a00^4*a01^2*a10*a12^2*a21*b2 + a00^5*a01*a11*a12^2*a21*b2 + a00^3*a01^2*a02*a10^2*a11*a22*b2 - 2*a00^4*a01*a02*a10*a11^2*a22*b2 + a00^5*a02*a11^3*a22*b2 - a00^3*a01^3*a10^2*a12*a22*b2 + 2*a00^4*a01^2*a10*a11*a12*a22*b2 - a00^5*a01*a11^2*a12*a22*b2,
 -a00*a01*a02*a10*a11*a20*x1 + a00^2*a02*a11^2*a20*x1 + a00*a01^2*a10*a12*a20*x1 - a00^2*a01*a11*a12*a20*x1 + a00*a01*a02*a10^2*a21*x1 - a00^2*a02*a10*a11*a21*x1 - a00^2*a01*a10*a12*a21*x1 + a00^3*a11*a12*a21*x1 - a00*a01^2*a10^2*a22*x1 + 2*a00^2*a01*a10*a11*a22*x1 - a00^3*a11^2*a22*x1 - a00*a01*a10*a12*a20*b0 + a00^2*a11*a12*a20*b0 + a00*a01*a10^2*a22*b0 - a00^2*a10*a11*a22*b0 + a00*a01*a02*a10*a20*b1 - a00^2*a02*a11*a20*b1 - a00^2*a01*a10*a22*b1 + a00^3*a11*a22*b1 - a00*a01*a02*a10^2*b2 + a00^2*a02*a10*a11*b2 + a00^2*a01*a10*a12*b2 - a00^3*a11*a12*b2,
 a00*a02*a11*a20*x2 - a00*a01*a12*a20*x2 - a00*a02*a10*a21*x2 + a00^2*a12*a21*x2 + a00*a01*a10*a22*x2 - a00^2*a11*a22*x2 - a00*a11*a20*b0 + a00*a10*a21*b0 + a00*a01*a20*b1 - a00^2*a21*b1 - a00*a01*a10*b2 + a00^2*a11*b2]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(eulerian_eliminationHM(PolyLst, VrbLst))
    # Initializing the degree matrix.
    A=HM(len(CnstrLst), len(VrbLst), [SR(CnstrLst[i].degree(VrbLst[j])) for j in range(len(VrbLst)) for i in range(len(CnstrLst))])
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                    if not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                        CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                        A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
            i=i-1; j=0
    return CnstrLst

def eulerian_eliminationHMII(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation rids of extraneous zero solutions 
    This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=HM(sz,'x').list(); Ha=HM(sz,sz,'a'); Hb=HM(sz,1,HM(sz,'b').list())
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=eulerian_eliminationHMII(CnstrLst, VrbLst)
        sage: Lf
        [a00*x0 + a01*x1 + a02*x2 - b0,
 a01*a10*x1 - a00*a11*x1 + a02*a10*x2 - a00*a12*x2 - a10*b0 + a00*b1,
 a00*a02*a11*a20*x2 - a00*a01*a12*a20*x2 - a00*a02*a10*a21*x2 + a00^2*a12*a21*x2 + a00*a01*a10*a22*x2 - a00^2*a11*a22*x2 - a00*a11*a20*b0 + a00*a10*a21*b0 + a00*a01*a20*b1 - a00^2*a21*b1 - a00*a01*a10*b2 + a00^2*a11*b2]
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 1 1]
        [0 1 1]
        [0 0 1]
        sage: sz=2;X=var_list('x',sz);Y=var_list('y',sz);Z=var_list('z',sz)
        sage: EqL=(HM(sz,sz,sz,[X[i]*Y[j]*Z[k] for k in rg(sz) for j in rg(sz) for i in rg(sz)])-HM(sz,sz,sz,'a')).list()
        sage: Lf=eulerian_eliminationHMII(EqL,X+Y+Z)
        sage: degree_matrix(Lf,X+Y+Z).printHM()
        [:, :]=
        [1 0 1 0 1 0]
        [0 1 1 0 1 0]
        [0 0 1 1 0 0]
        [0 0 0 1 1 1]
        [0 0 0 0 0 0]
        [0 0 0 0 0 0]
        [0 0 0 0 0 0]
        [0 0 0 0 0 0]
        sage: Lf
        [x0*y0*z0 - a000,
         x1*y0*z0 - a100,
         a010*y0 - a000*y1,
         -(a001*z0 - a000*z1)*a000*y1,
         0,
         0,
         0,
         a010*a100 - a000*a110]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the list of polynomials
    CnstrLst=copy(PolyLst)
    # Initializing the degree matrix.
    A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in rg(len(VrbLst))] for indx in rg(len(CnstrLst))])
    # Displaying the matrix on screen
    #A.printHM()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        #while HM(A.n(0)-i, 1, [A[i0,j] for i0 in rg(i,A.n(0))]).is_zero() and j < A.ncols()-1:
        while (A.slice([j],1).slice(rg(i,A.n(0)),0)).is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        #if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
        if A.slice(rg(A.n(1)),1).slice(rg(i,A.n(0)),0).is_zero()==False:
            while A[i,j].is_zero(): 
                #Ta=A[i:,:]
                #Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                Ta=A.slice(rg(i,A.n(0)),0)
                # Initializing the cyclic shift permutation matrix
                #Id=identity_matrix(Ta.nrows())
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([Id[:,k]*Id[mod(k+1,Ta.nrows()),:] for k in range(Ta.nrows())])
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; CnstrLst=CnstrLst[:i]+(P*HM(len(CnstrLst[i:]), 1, CnstrLst[i:])).list()
                #A[i:,:]=Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            for r in rg(i+1,A.nrows()):
                # Taking care of the zero row
                #if HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))]).is_zero():
                if A.slice([r],0).is_zero():
                    r=r+1
                else:
                    if CnstrLst[r].degree(VrbLst[j])*CnstrLst[i].degree(VrbLst[j])!=0 and not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                        if not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                            # Getting rid of zero solutions
                            tmp_cnstr=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                            if r < min(len(VrbLst),len(CnstrLst)):
                                for rt in rg(r,min(len(VrbLst),len(CnstrLst))):
                                    while tmp_cnstr.subs(VrbLst[rt]==0).is_zero():
                                        tmp_cnstr=expand(tmp_cnstr/VrbLst[rt])
                                CnstrLst[r]=tmp_cnstr
                            else:
                                CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                            #print('i=', i,'j=', j,' r=', r)
                            # Updating the degree matrix
                            A=degree_matrix(CnstrLst,VrbLst)
                            #A.printHM()
                        else:
                            CnstrLst[r]=SR(0)
                            # Updating the degree matrix
                            A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in rg(len(VrbLst))] for indx in rg(len(CnstrLst))])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return CnstrLst

def euler_sylvester_eliminationHMII(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in reduced row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation rids us of extraneous zero roots
    This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=HM(sz,'x').list(); Ha=HM(sz,sz,'a'); Hb=HM(sz,1,HM(sz,'b').list())
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=euler_sylvester_eliminationHMII(CnstrLst, VrbLst)
        sage: Lf
        [-a00^3*a01*a02^2*a10*a11^2*a20^2*x0 + a00^4*a02^2*a11^3*a20^2*x0 + 2*a00^3*a01^2*a02*a10*a11*a12*a20^2*x0 - 2*a00^4*a01*a02*a11^2*a12*a20^2*x0 - a00^3*a01^3*a10*a12^2*a20^2*x0 + a00^4*a01^2*a11*a12^2*a20^2*x0 + 2*a00^3*a01*a02^2*a10^2*a11*a20*a21*x0 - 2*a00^4*a02^2*a10*a11^2*a20*a21*x0 - 2*a00^3*a01^2*a02*a10^2*a12*a20*a21*x0 + 2*a00^5*a02*a11^2*a12*a20*a21*x0 + 2*a00^4*a01^2*a10*a12^2*a20*a21*x0 - 2*a00^5*a01*a11*a12^2*a20*a21*x0 - a00^3*a01*a02^2*a10^3*a21^2*x0 + a00^4*a02^2*a10^2*a11*a21^2*x0 + 2*a00^4*a01*a02*a10^2*a12*a21^2*x0 - 2*a00^5*a02*a10*a11*a12*a21^2*x0 - a00^5*a01*a10*a12^2*a21^2*x0 + a00^6*a11*a12^2*a21^2*x0 - 2*a00^3*a01^2*a02*a10^2*a11*a20*a22*x0 + 4*a00^4*a01*a02*a10*a11^2*a20*a22*x0 - 2*a00^5*a02*a11^3*a20*a22*x0 + 2*a00^3*a01^3*a10^2*a12*a20*a22*x0 - 4*a00^4*a01^2*a10*a11*a12*a20*a22*x0 + 2*a00^5*a01*a11^2*a12*a20*a22*x0 + 2*a00^3*a01^2*a02*a10^3*a21*a22*x0 - 4*a00^4*a01*a02*a10^2*a11*a21*a22*x0 + 2*a00^5*a02*a10*a11^2*a21*a22*x0 - 2*a00^4*a01^2*a10^2*a12*a21*a22*x0 + 4*a00^5*a01*a10*a11*a12*a21*a22*x0 - 2*a00^6*a11^2*a12*a21*a22*x0 - a00^3*a01^3*a10^3*a22^2*x0 + 3*a00^4*a01^2*a10^2*a11*a22^2*x0 - 3*a00^5*a01*a10*a11^2*a22^2*x0 + a00^6*a11^3*a22^2*x0 + a00^3*a01*a02*a10*a11*a12*a20*a21*b0 - a00^4*a02*a11^2*a12*a20*a21*b0 - a00^3*a01^2*a10*a12^2*a20*a21*b0 + a00^4*a01*a11*a12^2*a20*a21*b0 - a00^3*a01*a02*a10^2*a12*a21^2*b0 + a00^4*a02*a10*a11*a12*a21^2*b0 + a00^4*a01*a10*a12^2*a21^2*b0 - a00^5*a11*a12^2*a21^2*b0 - a00^3*a01*a02*a10*a11^2*a20*a22*b0 + a00^4*a02*a11^3*a20*a22*b0 + a00^3*a01^2*a10*a11*a12*a20*a22*b0 - a00^4*a01*a11^2*a12*a20*a22*b0 + a00^3*a01*a02*a10^2*a11*a21*a22*b0 - a00^4*a02*a10*a11^2*a21*a22*b0 + a00^3*a01^2*a10^2*a12*a21*a22*b0 - 3*a00^4*a01*a10*a11*a12*a21*a22*b0 + 2*a00^5*a11^2*a12*a21*a22*b0 - a00^3*a01^2*a10^2*a11*a22^2*b0 + 2*a00^4*a01*a10*a11^2*a22^2*b0 - a00^5*a11^3*a22^2*b0 - a00^3*a01*a02^2*a10*a11*a20*a21*b1 + a00^4*a02^2*a11^2*a20*a21*b1 + a00^3*a01^2*a02*a10*a12*a20*a21*b1 - a00^4*a01*a02*a11*a12*a20*a21*b1 + a00^3*a01*a02^2*a10^2*a21^2*b1 - a00^4*a02^2*a10*a11*a21^2*b1 - a00^4*a01*a02*a10*a12*a21^2*b1 + a00^5*a02*a11*a12*a21^2*b1 + a00^3*a01^2*a02*a10*a11*a20*a22*b1 - a00^4*a01*a02*a11^2*a20*a22*b1 - a00^3*a01^3*a10*a12*a20*a22*b1 + a00^4*a01^2*a11*a12*a20*a22*b1 - 2*a00^3*a01^2*a02*a10^2*a21*a22*b1 + 3*a00^4*a01*a02*a10*a11*a21*a22*b1 - a00^5*a02*a11^2*a21*a22*b1 + a00^4*a01^2*a10*a12*a21*a22*b1 - a00^5*a01*a11*a12*a21*a22*b1 + a00^3*a01^3*a10^2*a22^2*b1 - 2*a00^4*a01^2*a10*a11*a22^2*b1 + a00^5*a01*a11^2*a22^2*b1 + a00^3*a01*a02^2*a10*a11^2*a20*b2 - a00^4*a02^2*a11^3*a20*b2 - 2*a00^3*a01^2*a02*a10*a11*a12*a20*b2 + 2*a00^4*a01*a02*a11^2*a12*a20*b2 + a00^3*a01^3*a10*a12^2*a20*b2 - a00^4*a01^2*a11*a12^2*a20*b2 - a00^3*a01*a02^2*a10^2*a11*a21*b2 + a00^4*a02^2*a10*a11^2*a21*b2 + a00^3*a01^2*a02*a10^2*a12*a21*b2 - a00^5*a02*a11^2*a12*a21*b2 - a00^4*a01^2*a10*a12^2*a21*b2 + a00^5*a01*a11*a12^2*a21*b2 + a00^3*a01^2*a02*a10^2*a11*a22*b2 - 2*a00^4*a01*a02*a10*a11^2*a22*b2 + a00^5*a02*a11^3*a22*b2 - a00^3*a01^3*a10^2*a12*a22*b2 + 2*a00^4*a01^2*a10*a11*a12*a22*b2 - a00^5*a01*a11^2*a12*a22*b2,
 -a00*a01*a02*a10*a11*a20*x1 + a00^2*a02*a11^2*a20*x1 + a00*a01^2*a10*a12*a20*x1 - a00^2*a01*a11*a12*a20*x1 + a00*a01*a02*a10^2*a21*x1 - a00^2*a02*a10*a11*a21*x1 - a00^2*a01*a10*a12*a21*x1 + a00^3*a11*a12*a21*x1 - a00*a01^2*a10^2*a22*x1 + 2*a00^2*a01*a10*a11*a22*x1 - a00^3*a11^2*a22*x1 - a00*a01*a10*a12*a20*b0 + a00^2*a11*a12*a20*b0 + a00*a01*a10^2*a22*b0 - a00^2*a10*a11*a22*b0 + a00*a01*a02*a10*a20*b1 - a00^2*a02*a11*a20*b1 - a00^2*a01*a10*a22*b1 + a00^3*a11*a22*b1 - a00*a01*a02*a10^2*b2 + a00^2*a02*a10*a11*b2 + a00^2*a01*a10*a12*b2 - a00^3*a11*a12*b2,
 ((a22*x2 - b2)*a00 - (a02*x2 - b0)*a20)*(a01*a10 - a00*a11) - ((a12*x2 - b1)*a00 - (a02*x2 - b0)*a10)*(a01*a20 - a00*a21)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(eulerian_eliminationHMII(PolyLst, VrbLst))
    # Initializing the degree matrix.
    A=HM(len(CnstrLst), len(VrbLst), [SR(CnstrLst[i].degree(VrbLst[j])) for j in range(len(VrbLst)) for i in range(len(CnstrLst))])
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                    if not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                        #CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                        tmp_cnstr=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                        if r < min(len(VrbLst),len(CnstrLst)):
                            while tmp_cnstr.subs(VrbLst[r]==0).is_zero():
                                tmp_cnstr=expand(tmp_cnstr/VrbLst[r])
                            CnstrLst[r]=tmp_cnstr
                        else:
                            CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().expand()
                        A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
            i=i-1; j=0
    return CnstrLst

def eulerian_elimination_reductionHM(PolyLst, VrbLst, Rlts):
    """
    Outputs list of contraints whose degree matrix is in row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.
    The polynomial expressions obtained are reduced modulo the single variable
    variables relations inputed in Rlts. The input list of polynomials must
    be given in their expanded form


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=var_list('x',sz); f=sum(var_list('a',sz)[k]*x^(k-1) for k in rg(1,sz))
        sage: Rlts=[prod(VrbLst[i]-j for j in rg(sz-1)) for i in rg(sz)]
        sage: CnstrLst=Rlts[:sz-1]+[sum(f.subs(x==VrbLst[k]) for k in rg(sz))]
        sage: Lf=eulerian_elimination_reductionHM(CnstrLst, VrbLst, Rlts)
        sage: Lf
        [(x0 - 1)*x0,
         (x1 - 1)*x1,
         48*(135*a1^4*a2^14*x2 + 270*a1^3*a2^15*x2 + 201*a1^2*a2^16*x2 + 66*a1*a2^17*x2 + 8*a2^18*x2 + 81*a1^5*a2^13 + 135*a1^4*a2^14 + 81*a1^3*a2^15 + 21*a1^2*a2^16 + 2*a1*a2^17)*(6*a1*a2^11*x2 + 3*a2^12*x2 + 9*a1^2*a2^10 + 6*a1*a2^11 + a2^12)*(a2^3*x2 + 3*a1*a2^2 + a2^3)*a2^3]
        sage: degree_matrix(Lf, VrbLst).printHM()
        [:, :]=
        [2 0 0]
        [0 2 0]
        [0 0 3]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(PolyLst)
    # Initializing the degree matrix.
    A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
    #A.printHM()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        #while (A[i:,j]).is_zero() and j < A.ncols()-1:
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        #if (A[i:,:].is_zero())==False:
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                #Ta=A[i:,:]
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=identity_matrix(Ta.nrows())
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([Id[:,k]*Id[mod(k+1,Ta.nrows()),:] for k in range(Ta.nrows())])
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; CnstrLst=CnstrLst[:i]+(P*HM(len(CnstrLst[i:]), 1, CnstrLst[i:])).list()
                #A[i:,:]=Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j])) > 0 and not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                        #if not SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                        Cf=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j])
                        rs=HM(Cf.n(0),1,'zero')
                        #print prod(gaussian_elimination_ReductionHM(Cf, rs, VrbLst, Rlts)[0][z,z] for z in range(Cf.n(0)))
                        if not prod(gaussian_elimination_ReductionHM(Cf, rs, VrbLst, Rlts)[0][z,z] for z in range(Cf.n(0))).is_zero():
                            #CnstrLst[r]=SylvesterHM(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                            CnstrLst[r]=prod(gaussian_elimination_ReductionHM(Cf, rs, VrbLst, Rlts)[0][z,z] for z in range(Cf.n(0)))
                            #print 'i=', i,'j=', j,' r=', r
                            #print 'CnstrLst=', CnstrLst
                            A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return CnstrLst

def degree_matrix(EqL, VrbL):
    """
    Outputs the degree matrix associated with the in input system 
    relative to the input list of variables.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbL=HM(sz,'x').list(); Ha=HM(sz,sz,'a'); Hb=HM(sz,1,HM(sz,'b').list())
        sage: EqL=(Ha*HM(sz,1,VrbL)-Hb).list()
        sage: Ha=degree_matrix(EqL, VrbL)
        sage: Ha.printHM()
        [:, :]=
        [1 1 1]
        [1 1 1]
        [1 1 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of matrix
    Ha=HM(len(EqL), len(VrbL), 'zero')
    for i in rg(len(EqL)):
        for j in rg(len(VrbL)):
            if SR(EqL[i]).subs([v==0 for v in VrbL])==SR(EqL[i]):
                Ha[i,j]=0
            else:
                Ha[i,j]=EqL[i].degree((VrbL)[j])
    return Ha

def charpoly2x2(A,v):
    """
    Outputs the Characteristic polynomial of the input 2x2 matrix A
    in the input variable v.


    EXAMPLES:
 
    ::

        sage: x0=var('x0'); sz=Integer(2); M=HM(sz,sz,'m'); CP=charpoly2x2(M,x0); CP
        -m01*m10 + m00*m11 - (m00 + m11)*x0 + x0^2
        sage: M.substituteHMinto(CP, x0).expand().p()
        [:, :]=
        [0 0]
        [0 0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return v^2-A.trace()*v+Deter(A)

def i2x2(A):
    """
    Outputs the symbolic inverse of a 2x2 matrix.


    EXAMPLES:
 
    ::

        sage: i2x2(HM(2,2,'a')).printHM()
        [:, :]=
        [-a11/(a01*a10 - a00*a11)  a01/(a01*a10 - a00*a11)]
        [ a10/(a01*a10 - a00*a11) -a00/(a01*a10 - a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return HM([\
[ A[1,1]/(A[0,0]*A[1,1]-A[0,1]*A[1,0]), -A[0,1]/(A[0,0]*A[1,1]-A[0,1]*A[1,0])],\
[-A[1,0]/(A[0,0]*A[1,1]-A[0,1]*A[1,0]),  A[0,0]/(A[0,0]*A[1,1]-A[0,1]*A[1,0])]])

def inxn(A):
    """
    Outputs the symbolic inverse of a nxn matrix.
    Using the logarithmic gradient.


    EXAMPLES:
 
    ::

        sage: inxn(HM(2,2,'a')).printHM()
        [:, :]=
        [-a11/(a01*a10 - a00*a11)  a01/(a01*a10 - a00*a11)]
        [ a10/(a01*a10 - a00*a11) -a00/(a01*a10 - a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the computation of the determinant
    sz=A.n(0); X=HM(sz,sz,'x'); G=Deter(X); Xi=HM(sz, sz, [diff(ln(G),X[j,i]) for j in rg(sz) for i in rg(sz)])
    return Xi.subs([X[i,j]==A[i,j] for j in rg(sz) for i in rg(sz)])

def adjoint(A):
    """
    Outputs the symbolic adjoint of a nxn matrix.
    Using the gradient.


    EXAMPLES:
 
    ::

        sage: adjoint(HM(2,2,'a')).printHM()
        [:, :]=
        [-a11  a01]
        [ a10 -a00]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the computation of the determinant
    sz=A.n(0); X=HM(sz,sz,'x'); G=Deter(X); Xi=HM(sz, sz, [diff(G,X[j,i]) for j in rg(sz) for i in rg(sz)])
    return Xi.subs([X[i,j]==A[i,j] for j in rg(sz) for i in rg(sz)])

def j2x2(A):
    """
    Outputs the symbolic jnverse of a 2x2 matrix. In otther words expresses the permanent based construction


    EXAMPLES:
 
    ::

        sage: j2x2(HM(2,2,'a')).printHM()
        [:, :]=
        [a11/(a01*a10 + a00*a11) a01/(a01*a10 + a00*a11)]
        [a10/(a01*a10 + a00*a11) a00/(a01*a10 + a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return HM([\
[A[1,1]/(A[0,0]*A[1,1]+A[0,1]*A[1,0]), A[0,1]/(A[0,0]*A[1,1]+A[0,1]*A[1,0])],\
[A[1,0]/(A[0,0]*A[1,1]+A[0,1]*A[1,0]), A[0,0]/(A[0,0]*A[1,1]+A[0,1]*A[1,0])]])

def jnxn(A):
    """
    Outputs the symbolic jnverse of a nxn matrix.
    Using the logarithmic gradient. Computes the permanent gradiant analog of the inverse


    EXAMPLES:
 
    ::

        sage: jnxn(HM(2,2,'a')).printHM()
        [:, :]=
        [a11/(a01*a10 + a00*a11) a01/(a01*a10 + a00*a11)]
        [a10/(a01*a10 + a00*a11) a00/(a01*a10 + a00*a11)]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the computation of the determinant
    sz=A.n(0); X=HM(sz,sz,'x'); G=PerII(X); Xi=HM(sz, sz, [diff(ln(G),X[j,i]) for j in rg(sz) for i in rg(sz)])
    return Xi.subs([X[i,j]==A[i,j] for j in rg(sz) for i in rg(sz)])

def bdjoint(A):
    """
    Outputs the symbolic adjoint of a nxn matrix.
    Using the gradient.


    EXAMPLES:
 
    ::

        sage: bdjoint(HM(2,2,'a')).printHM()
        [:, :]=
        [a11  a01]
        [a10  a00]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the computation of the determinant
    sz=A.n(0); X=HM(sz,sz,'x'); G=Per(X); Xi=HM(sz, sz, [diff(G,X[j,i]) for j in rg(sz) for i in rg(sz)])
    return Xi.subs([X[i,j]==A[i,j] for j in rg(sz) for i in rg(sz)])

def LeftRightDiagonalDependence3x3x3(A):
    """
    Outputs the a pair of solutions to the left right diagonal dependence problem.


    EXAMPLES:
 
    ::

        sage: A=HM([[[0,1,1],[6,-5,-1],[1,0,19]],[[1,2,3],[3,-2,-2],[1,1,0]],[[-6,0,2],[1,-3,-1],[-3,2,1]]])
        sage: [[Xfa,Yfa], [Xfb,Yfb]]=LeftRightDiagonalDependence3x3x3(A)
        sage: sz=3; sum(HM(sz,sz,[Xfa[i,t]*A[i,j,t]*Yfa[t,j] for j in range(sz) for i in range(sz)]) for t in range(sz)).canonicalize_radical()
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        sage: sz=3; sum(HM(sz,sz,[Xfb[i,t]*A[i,j,t]*Yfb[t,j] for j in range(sz) for i in range(sz)]) for t in range(sz)).canonicalize_radical()
        [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        sage: (HM(2,Xfa.matrix()[:,2].list(),'diag')*HM(2,Yfa.matrix()[2,:].list(),'diag')).det().is_zero() # Testing the first slice 
        False
        sage: (HM(2,Xfb.matrix()[:,2].list(),'diag')*HM(2,Yfb.matrix()[2,:].list(),'diag')).det().is_zero() # Testing the first slice 
        False


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    sz=A.nrows()
    # Initialization of the variable associated with the diagonal dependence.
    X=HM(sz,sz,'x'); Y=HM(sz,sz,'y')
    # Initializing the permutations
    P=Permutations(range(sz))
    # Initialization of constraints
    Eq=[sum(Permutation([p[indx]+1 for indx in range(len(p))]).signature()*\
    prod([X[i,p[i]]*A[i,k,p[i]] for i in range(sz)]) for p in P)==0 for k in range(sz)]
    # Formating the constraints using the first column of X as variables
    [F,g]=ConstraintFormatorHM(Eq, X.list()[-sz:])
    # Obtatining the determinant of the matrix F
    dtF=F.det()
    # Obtaining the parametrization by solving in the variable X[sz-1, sz-2].
    v=X[sz-1, sz-2]
    a0=dtF.subs(v==0)
    a1=diff(dtF, v, 1).subs(v==0)/factorial(1)
    a2=diff(dtF, v, 2).subs(v==0)/factorial(2)
    # Initialization of the solution of the quadratic equation
    Sln1=[\
    v == -1/2*( a1 + sqrt(a1^2 - 4*a0*a2) )/a2,\
    v == -1/2*( a1 - sqrt(a1^2 - 4*a0*a2) )/a2]
    # Performing the substitution
    Fa=F.subs(Sln1[0]).matrix()
    Sln2a=[X[i,sz-1]==-(X[sz-1,sz-1]*i2x2(Fa[:sz-1,:sz-1]).matrix()*Fa[:sz-1,sz-1])[i,0] for i in range(sz-1)]+Sln1[:1]
    Fb=F.subs(Sln1[1]).matrix()
    Sln2b=[X[i,sz-1]==-(X[sz-1,sz-1]*i2x2(Fb[:sz-1,:sz-1]).matrix()*Fb[:sz-1,sz-1])[i,0] for i in range(sz-1)]+Sln1[1:]
    # Initialization of the list of Mks 
    Xfa=X.subs(Sln2a)
    Lma=[HM(sz,sz,[Xfa[i,j]*A[i,k,j] for j in range(sz) for i in range(sz)]) for k in range(sz)]
    Xfb=X.subs(Sln2b)
    Lmb=[HM(sz,sz,[Xfb[i,j]*A[i,k,j] for j in range(sz) for i in range(sz)]) for k in range(sz)]
    # Initialization of solutions in Y
    Sln3a=[Y[j,k]==\
    -(Y[sz-1,k]*i2x2((Lma[k].matrix())[:sz-1,:sz-1]).matrix()*(Lma[k].matrix())[:sz-1,sz-1])[j,0] for j in range(sz-1) for k in range(sz)]
    Sln3b=[Y[j,k]==\
    -(Y[sz-1,k]*i2x2((Lmb[k].matrix())[:sz-1,:sz-1]).matrix()*(Lmb[k].matrix())[:sz-1,sz-1])[j,0] for j in range(sz-1) for k in range(sz)]
    Yfa=Y.subs(Sln3a)
    # Final verification
    #Rsa=sum(HM(sz,sz,[Xfa[i,t]*A[i,j,t]*Yfa[t,j] for j in range(sz) for i in range(sz)]) for t in range(sz)).canonicalize_radical()
    Yfb=Y.subs(Sln3b)
    # Final verification
    #Rsb=sum(HM(sz,sz,[Xfb[i,t]*A[i,j,t]*Yfb[t,j] for j in range(sz) for i in range(sz)]) for t in range(sz)).canonicalize_radical()
    return [[Xfa,Yfa], [Xfb,Yfb]]

def Reduced3x3x3CanonicalFactorization(A, Xfa, Yfa, indx):
    """
    Outputs the a pair of solutions to the left right diagonal dependence problem.


    EXAMPLES:
 
    ::

        sage: A=HM([[[0,1,1],[6,-5,-1],[1,0,19]],[[1,2,3],[3,-2,-2],[1,1,0]],[[-6,0,2],[1,-3,-1],[-3,2,1]]])
        sage: [[Xfa, Yfa], [Xfb,Yfb]]=LeftRightDiagonalDependence3x3x3(A)
        sage: (HM(2,Xfa.matrix()[:,2].list(),'diag')*HM(2,Yfa.matrix()[2,:].list(),'diag')).det().is_zero() # Testing the first slice 
        False
        sage: [Uf, Vf, Wf]=Reduced3x3x3CanonicalFactorization(A, Xfa, Yfa, 2)
        sage: Prod(Uf,Vf,Wf).canonicalize_radical() # Checking the factorization
        [[[0, 1, 1], [6, -5, -1], [1, 0, 19]], [[1, 2, 3], [3, -2, -2], [1, 1, 0]], [[-6, 0, 2], [1, -3, -1], [-3, 2, 1]]] 
        sage: Prod(Uf,Vf,Wf).canonicalize_radical()==A
        True


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the size and order parameters
    sz=3; od=3 
    # Checking that the last column of X and the last row of Y have no zero entries
    #print "(HM(2, Xfa.matrix()[:,2].list(),'diag')*HM(2, Yfa.matrix()[2,:].list(),'diag')).det().is_zero() is ",\
    #(HM(2, Xfa.matrix()[:,2].list(),'diag')*HM(2, Yfa.matrix()[2,:].list(),'diag')).det().is_zero()
    if (HM(2, Xfa.matrix()[:,2].list(),'diag')*HM(2, Yfa.matrix()[2,:].list(),'diag')).det().is_zero():
        raise ValueError("The input index has zero entries")
    else:
        # A convenien way to Initialize of the identity pairs
        J1=Prod(HM(sz,sz,sz,'one'), HM(sz,sz,sz,'one'), HM(od,sz,'kronecker')); U=J1.copy()
        J2=Prod(HM(od,sz,'kronecker'), HM(sz,sz,sz,'one'), HM(sz,sz,sz,'one')); W=J2.copy()
        # Initialization of the hypermatrix
        Ha=A.copy()
        # Updating the last slice Hypermatrix
        for i in range(sz):
            for j in range(sz):
                Ha[i,j,indx]=0
        # Initialization of the left weight coefficient
        XXfa=Xfa.copy()
        for i in range(sz):
            for j in range(sz):
                if j!=indx:
                    XXfa[i,j]=-Xfa[i,j]/Xfa[i,indx]
        for i in range(sz):
            XXfa[i,indx]=1
        # Initialization of the right weight coefficient
        YYfa=Yfa.copy()
        for i in range(sz):
            for j in range(sz):
                if i!=indx:
                    YYfa[i,j]=Yfa[i,j]/Yfa[indx,j]
        for j in range(sz):
            YYfa[indx,j]=1
        # Updating the slices of U
        for i in range(sz):
            for t in range(sz):
                for k in range(sz):
                    if t!=indx:
                        U[i,t,k]=XXfa[i,t]*J1[i,indx,k]+J1[i,t,k]
        # Updating the slices of W
        for j in range(sz):
            for t in range(sz-1):
                for k in range(sz):
                    if t!=indx:
                        W[t,j,k]=J2[t,j,k]+J2[indx,j,k]*YYfa[t,j]
        # Printing the difference
        #print '\n'
        #(A-Prod(U,Ha,W)).canonicalize_radical().printHM()
        # Obtaining the finall output
        Uf=HM(sz,sz-1,sz,[U[i,j,k] for k in range(sz) for j in range(sz-1) for i in range(sz)])
        Vf=HM(sz,sz,sz-1,[A[i,j,k] for k in range(sz-1) for j in range(sz) for i in range(sz)])
        Wf=HM(sz-1,sz,sz,[W[i,j,k] for k in range(sz) for j in range(sz) for i in range(sz-1)])
        #print '\n'
        #(A-Prod(Uf,Vf,Wf)).canonicalize_radical().printHM()
        return [Uf, Vf, Wf]

def Remnant(p, q, vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the corresponding remnant with the
    modular arithmetic method.
 

    EXAMPLES:

    ::

        sage: x, a0, a1, a2, b0, b1, b2=var('x, a0, a1, a2, b0, b1, b2')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: factor(Remnant(p, q, x).det())
        (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Updating the firt input polynomial to make it monic in vrbl
    p=p/(p.diff(vrbl,Integer(p.degree(vrbl))).subs(vrbl==0)/factorial(Integer(p.degree(vrbl))))
    #print 'p=',p
    # Initialization of the list
    L=[]; f=expand(q)
    #print 'Initial f=',f
    for d in range(Integer(f.degree(vrbl)-p.degree(vrbl)),-1,-1):
        f=expand(fast_reduce(f,[vrbl^(d+p.degree(vrbl))],[vrbl^(d+p.degree(vrbl))-expand(p*vrbl^d)]))
        #print '    f=',f
    L.append(f)
    while len(L) < p.degree(vrbl):
        # Initialization of the update of q
        #f=expand(q*L[len(L)-1])
        f=expand(vrbl*L[len(L)-1])
        for d in range(f.degree(vrbl)-p.degree(vrbl),-1,-1):
            f=expand(fast_reduce(f,[vrbl^(d+p.degree(vrbl))],[vrbl^(d+p.degree(vrbl))-expand(p*vrbl^d)]))
        L.append(f)
    # Initialisation of the matrix
    return HM(p.degree(vrbl), p.degree(vrbl),[diff(L[i],vrbl,j).subs(vrbl==0)/factorial(j) for j in range(p.degree(vrbl)) for i in range(len(L))])

def RemnantII(p, q, vrbl):
    """
    Takes as input two polynomials and a variable
    and outputs the corresponding remnant with the
    modular arithmetic method.
 

    EXAMPLES:

    ::

        sage: x, a0, a1, a2, b0, b1, b2=var('x, a0, a1, a2, b0, b1, b2')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: factor(RemnantII(p, q, x).det())
        (a0 + a1 - b0 - b1)*(a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Updating the firt input polynomial to make it monic in vrbl
    p=p/(p.diff(vrbl,Integer(p.degree(vrbl))).subs(vrbl==0)/factorial(Integer(p.degree(vrbl))))
    #print 'p=',p
    # Initialization of the list
    L=[]; f=expand(q)
    #print 'Initial f=',f
    for d in range(Integer(f.degree(vrbl)-p.degree(vrbl)),-1,-1):
        f=expand(fast_reduce(f,[vrbl^(d+p.degree(vrbl))],[vrbl^(d+p.degree(vrbl))-expand(p*vrbl^d)]))
        #print '    f=',f
    L.append(f)
    while len(L) < p.degree(vrbl):
        # Initialization of the update of q
        f=expand(q*L[len(L)-1])
        for d in range(f.degree(vrbl)-p.degree(vrbl),-1,-1):
            f=expand(fast_reduce(f,[vrbl^(d+p.degree(vrbl))],[vrbl^(d+p.degree(vrbl))-expand(p*vrbl^d)]))
        L.append(f)
    # Initialisation of the matrix
    return HM(p.degree(vrbl), p.degree(vrbl),[diff(L[i],vrbl,j).subs(vrbl==0)/factorial(j) for j in range(p.degree(vrbl)) for i in range(len(L))]) 

def modular_eliminationHM(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=var_list('x',sz); Ha=Vandermonde(range(1,sz+1)); Hb=HM(sz,1,var_list('b',sz))
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=modular_eliminationHM(CnstrLst, VrbLst); Lf
        [-b0 + x0 + x1 + x2, -b0 + b1 - x1 - 2*x2, -2/3*b0 + b1 - 1/3*b2 + 2/3*x2]
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 1 1]
        [0 1 1]
        [0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(PolyLst)
    # Initializing the degree matrix.
    A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
    #A.printHM()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        #while (A[i:,j]).is_zero() and j < A.ncols()-1:
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        #if (A[i:,:].is_zero())==False:
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                #Ta=A[i:,:]
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=identity_matrix(Ta.nrows())
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([Id[:,k]*Id[mod(k+1,Ta.nrows()),:] for k in range(Ta.nrows())])
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; CnstrLst=(P*HM(len(CnstrLst), 1, CnstrLst)).list()
                #A[i:,:]=Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                        if not Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                            CnstrLst[r]=Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                            #print 'i=', i,'j=', j,' r=', r
                            #print 'CnstrLst=', CnstrLst
                            A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return CnstrLst

def complete_modular_eliminationHM(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in reduced row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: x, a0, a1, a2, b0, b1, b2=var('x, a0, a1, a2, b0, b1, b2')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: [f.factor() for f in complete_modular_eliminationHM([p,q],[x])]
        [(a0 - x)*(a1 - x), (a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)]
        sage: sz=3; VrbLst=var_list('x',sz); Ha=Vandermonde(range(1,sz+1)); Hb=HM(sz,1,var_list('b',sz))
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=complete_modular_eliminationHM(CnstrLst, VrbLst)
        sage: Lf
        [-b0 + 5/6*b1 - 1/6*b2 + 1/3*x0,
         -b0 + 4/3*b1 - 1/3*b2 - 1/3*x1,
         -2/3*b0 + b1 - 1/3*b2 + 2/3*x2]        
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 0 0]
        [0 1 0]
        [0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(modular_eliminationHM(PolyLst, VrbLst))
    # Initializing the degree matrix.
    A=HM(len(CnstrLst), len(VrbLst), [SR(CnstrLst[i].degree(VrbLst[j])) for j in range(len(VrbLst)) for i in range(len(CnstrLst))])
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                    if not Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                        CnstrLst[r]=Remnant(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                        A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
            i=i-1; j=0
    return CnstrLst

def modular_eliminationHMII(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: sz=3; VrbLst=var_list('x',sz); Ha=Vandermonde(range(1,sz+1)); Hb=HM(sz,1,var_list('b',sz))
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=modular_eliminationHMII(CnstrLst, VrbLst); Lf
        [-b0 + x0 + x1 + x2, -b0 + b1 - x1 - 2*x2, -2/3*b0 + b1 - 1/3*b2 + 2/3*x2]
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 1 1]
        [0 1 1]
        [0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(PolyLst)
    # Initializing the degree matrix.
    A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
    #A.printHM()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        #while (A[i:,j]).is_zero() and j < A.ncols()-1:
        while HM(A.n(0)-i, 1, [A[i0,j] for i0 in range(i,A.n(0))]).is_zero() and j < A.ncols()-1:
            # Incrementing the column index
            j=j+1
        #if (A[i:,:].is_zero())==False:
        if HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))]).is_zero()==False:
            while A[i,j].is_zero(): 
                #Ta=A[i:,:]
                Ta=HM(A.n(0)-i, A.n(1), [A[i0,j0] for j0 in range(A.n(1)) for i0 in range(i,A.n(0))])
                # Initializing the cyclic shift permutation matrix
                #Id=identity_matrix(Ta.nrows())
                Id=HM(2, Ta.n(0), 'kronecker')
                #P=sum([Id[:,k]*Id[mod(k+1,Ta.nrows()),:] for k in range(Ta.nrows())])
                P=sum([HM(Ta.n(0),1,[Id[i0,k] for i0 in range(Ta.n(0))])*HM(1,Ta.n(0),[Id[Integer(mod(k+1,Ta.n(0))),j0] for j0 in range(Ta.n(0))]) for k in range(Ta.n(0))])
                Ta=P*Ta; CnstrLst=(P*HM(len(CnstrLst), 1, CnstrLst)).list()
                #A[i:,:]=Ta
                for i0 in range(Ta.n(0)):
                    for j0 in range(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            cf1=A[i,j]
            for r in range(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1, A.n(1), [A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                        if not RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                            CnstrLst[r]=RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                            #print 'i=', i,'j=', j,' r=', r
                            #print 'CnstrLst=', CnstrLst
                            A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return CnstrLst

def complete_modular_eliminationHMII(PolyLst, VrbLst):
    """
    Outputs list of contraints whose degree matrix is in reduced row echelon form.
    The general problem of determining the existence of solutions to a
    system of polynomial equations having at most finitely many solutions
    is NP hard. This implementation should therefore be used with caution.


    EXAMPLES:
 
    ::

        sage: x, a0, a1, a2, b0, b1, b2=var('x, a0, a1, a2, b0, b1, b2')
        sage: p=(x-a0)*(x-a1); q=(x-b0)*(x-b1)
        sage: [f.factor() for f in complete_modular_eliminationHMII([p,q],[x])]
        [(a0 - x)*(a1 - x),
         -(a0 + a1 - b0 - b1)*(a0 - b0)*(a0 - b1)*(a1 - b0)*(a1 - b1)]
        sage: sz=3; VrbLst=var_list('x',sz); Ha=Vandermonde(range(1,sz+1)); Hb=HM(sz,1,var_list('b',sz))
        sage: CnstrLst=(Ha*HM(sz,1,VrbLst)-Hb).list()
        sage: Lf=complete_modular_eliminationHMII(CnstrLst, VrbLst)
        sage: Lf
        [-b0 + 5/6*b1 - 1/6*b2 + 1/3*x0,
         -b0 + 4/3*b1 - 1/3*b2 - 1/3*x1,
         -2/3*b0 + b1 - 1/3*b2 + 2/3*x2]        
        sage: degree_matrix(Lf, var_list('x',sz)).printHM()
        [:, :]=
        [1 0 0]
        [0 1 0]
        [0 0 1]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    CnstrLst=copy(modular_eliminationHMII(PolyLst, VrbLst))
    # Initializing the degree matrix.
    A=HM(len(CnstrLst), len(VrbLst), [SR(CnstrLst[i].degree(VrbLst[j])) for j in range(len(VrbLst)) for i in range(len(CnstrLst))])
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        if HM(1,A.n(1),[A[i,j0] for j0 in range(A.n(1))]).is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in range(i-1,-1,-1):
                if (CnstrLst[r].degree(VrbLst[j]))*(CnstrLst[i].degree(VrbLst[j]))>0 and not RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).is_empty():
                    if not RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).det().is_zero():
                        CnstrLst[r]=RemnantII(CnstrLst[r], CnstrLst[i], VrbLst[j]).det()
                        A=HM([[SR(CnstrLst[indx].degree(VrbLst[jndx])) for jndx in range(len(VrbLst))] for indx in range(len(CnstrLst))])
            i=i-1; j=0
    return CnstrLst

def outerdeterminant(A, B):
    """
    Computes symbolically the outer-product expansions of the determinant
    using the sum over permutation formula. The inputs should be second 
    order hypermatrices.

    EXAMPLES:

    ::

        sage: sz=2; outerdeterminant(HM(sz,sz,'a'), HM(sz,sz,'b')).printHM()
        [:, :]= 
        [-a01*a10*b01*b10 + a00*a11*b01*b10 -a01*a10*b01*b11 + a00*a11*b01*b11]
        [ a01*a10*b00*b10 - a00*a11*b00*b10  a01*a10*b00*b11 - a00*a11*b00*b11]
        sage: outerdeterminant(HM(2,2,'a'), HM(2,2,'b')).trace().factor()
        -(a01*a10 - a00*a11)*(b01*b10 - b00*b11)


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the permutations
    P = Permutations(range(A.nrows()))
    return sum([Permutation([p[i]+1 for i in range(len(p))]).signature()*prod([\
HM(A.nrows(),1,[A[i,p[k]] for i in range(A.nrows())])*\
HM(1,B.ncols(),[B[k,j] for j in range(B.ncols())]) for k in range(A.nrows())]) for p in P])

def CC2RR_inflate(A):
    """ 
    Outputs the inflated matrix obtained by replacing
    complex entries of A by their canonical 2x2 
    real matrix representations.


    EXAMPLES:

    ::  

        sage: A = HM([[-2*I + 3, -2], [5*I - 1, -I + 2]]); CC2RR_inflate(A).printHM()
        [:, :]=
        [ 3  2 -2  0]
        [-2  3  0 -2]
        [-1 -5  2  1]
        [ 5 -1 -1  2]


    AUTHORS:
    - Edinah K. Gnang
    """
    if A.order()==2:
        # Initialization of the matrix
        B=HM(2*A.n(0), 2*A.n(1), 'zero') # Conversion from complex to real
        for i in range(A.n(0)):
            for j in range(A.n(1)):
                Tmp=HM(A.n(0), A.n(1), 'zero'); Tmp[i,j]=1
                B=B+Tmp.tensor_product(HM([[A[i,j].real(),-A[i,j].imag()],[A[i,j].imag(),A[i,j].real()]]))
        return B
    else:
        raise ValueError("Expected a second order hypermatrix")
        
def RR2CC_deflate(Q):
    """ 
    Outputs the deflated matrix obtained by replacing
    the canonical 2x2 real matrix representations by
    complex numbers.


    EXAMPLES:

    ::  

        sage: A = HM([[3, 2, -2, 0], [-2, 3, 0, -2], [-1, -5, 2, 1], [5, -1, -1, 2]]); RR2CC_deflate(A).printHM()
        [:, :]=
        [-2*I + 3       -2]
        [ 5*I - 1   -I + 2]


    AUTHORS:
    - Edinah K. Gnang
    """
    if Q.order()==2:
        # Initialization of the matrix
        U=HM(Q.n(0)/2, Q.n(1)/2, 'zero') # Conversion from complex to real
        for i in range(0, Q.n(0), 2):
            for j in range(0, Q.n(1), 2):
                Tmp=HM(Q.n(0), Q.n(1), 'zero'); Tmp[i,j]=1
                U[i/2, j/2] = Q[i, j]+I*Q[i+1, j]
        return U
    else:
        raise ValueError("Expected a second order hypermatrix")
 
def quaternion_2x2_CC_rep(VrbL): 
    """ 
    Outputs the canonical 2x2 complex matrix 
    representation of quaternions using the input 
    variables. The input VrbL is a list of pairs 
    associated with real part and imaginary part
    of the input complex numbers 


    EXAMPLES:

    ::  

        sage: VrbLx=var_list('x',2); VrbLy=var_list('y',2)
        sage: quaternion_2x2_CC_rep([(VrbLx[i], VrbLy[i]) for i in range(2)]).printHM()
        [:, :]=
        [ x1 + I*y1  x0 + I*y0]
        [-x0 + I*y0  x1 - I*y1]


    AUTHORS:
    - Edinah K. Gnang
    """ 
    return HM(2,2,[VrbL[1][0]+I*VrbL[1][1], -VrbL[0][0]+I*VrbL[0][1],  VrbL[0][0]+I*VrbL[0][1], VrbL[1][0]-I*VrbL[1][1]])

def quaternion_2x2_unit_abs_CC(VrbL): 
    """ 
    Out puts the canonical 2x2 matrix representation
    using the input variables. Assumes that the 
    2 variables in VrbL are associated with complex
    numbers lying on the unit circle


    EXAMPLES:

    ::  

        sage: VrbL=var_list('x',2); quaternion_2x2_unit_abs_CC(VrbL).printHM()
        [:, :]=
        [   x1    x0]
        [-1/x0  1/x1]

    AUTHORS:
    - Edinah K. Gnang
    """ 
    return HM(2,2,[VrbL[1],-1/VrbL[0],  VrbL[0],1/VrbL[1]])

def rg(*args): 
    """ 
    Adapts the range function to our purposes.
    This function makes sure to return a list of
    integers and not object of type int.


    EXAMPLES:

    ::  

        sage: rg(0,10,2)
        [0, 2, 4, 6, 8]


    AUTHORS:
    - Edinah K. Gnang
    """ 
    return [Integer(i) for i in range(*args)]

def imod(a,d): 
    """ 
    returns the residue class mod the input integer d
    of the input integer a.
    

    EXAMPLES:

    ::  

        sage: imod(5,2)
        1


    AUTHORS:
    - Edinah K. Gnang
    """ 
    return Integer(mod(a,d))

def multivariate_leading_term(f, Xv, Pp):
    """
    Takes as input a polynomial in the variables
    specified in the list Xv and outputs the 
    leading term of the input polynomial.
    The last input is the list of primes
    assigned to each variable to determine
    the monomial ordering
 

    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f = 5*Xv[0]*Xv[1]^3*Xv[2]^2 + 4*Xv[1] + 2*Xv[1]*Xv[2]^7 + 5
        sage: multivariate_leading_term(f, Xv, Pp)
        2*x1*x2^7
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    # Expression used for specifying the type of the operation.
    cst = 2
    add = var('x0') + var('x1')
    mul = var('x0') * var('x1')
    xpo = var('x0') ^ var('x1')
    if f.operator() == add.operator():
        # Collecting the terms
        L=f.operands()
        # Collecting the terms striped from their coefficients
        L_strpd = list()
        for i in rg(len(L)):
            if L[i].arguments() != ():
                if (L[i].operator()==mul.operator() or (L[i]).operator()==xpo.operator()):
                    cst_fctr = 1
                    lst_i = L[i].operands()
                    for j in rg(len(lst_i)):
                        if lst_i[j].arguments()==():
                            cst_fctr = lst_i[j]
                    L_strpd.append((expand(L[i]/cst_fctr), i))
                elif L[i] in Xv:
                    L_strpd.append((L[i], i))
        # Storing the integer and the index associated with the term
        tmp_value = L_strpd[0][0].subs([Xv[i]==Pp[i] for i in rg(sz)])
        idx = L_strpd[0][1]
        for k in rg(len(L_strpd)):
            if L_strpd[k][0].subs([Xv[i]==Pp[i] for i in rg(sz)]) > tmp_value:
                tmp_value = L_strpd[k][0].subs([Xv[i]==Pp[i] for i in rg(sz)])
                idx = L_strpd[k][1]
        return L[idx]
    elif f.operator() == mul.operator():
        return f
    elif f.operator() == xpo.operator():
        return f 
    else :
        return f

def multivariate_division(f, List, Xv, Pp):
    """
    Takes as input a polynomial f the list of 
    polynomials and performs the multivariable
    division algorithm and the list of variables
    used. The last input is a list of primes which
    determines the monomial ordering.
    The functions outputs a list. The last entry of
    list being the remainder and the rest are quotients
    identified in order with the divisor list.
 

    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f = 5*Xv[0]*Xv[1]^3*Xv[2]^2 + 4*Xv[1] + 2*Xv[1]*Xv[2]^7 + 5
        sage: List = [Xv[0]^2+5*Xv[1]^3+2, Xv[1]^3*Xv[0]^2+5*Xv[0]+1]
        sage: multivariate_division(f, List, Xv, Pp)
        [x0*x2^2, 0, 2*x1*x2^7 - x0^3*x2^2 - 2*x0*x2^2 + 4*x1 + 5]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    # Initializing the output List
    L = []
    for j in rg(len(List)+1):
        L.append(0)
    # Initializing the Polynomial
    p = f
    while not p.is_zero():
        i = 0
        division_occured = False
        while (i in rg(len(List))) and (not division_occured):
            if List[i] == 0:
                i = i+1
            else:
                # Getting the Leading term of fi
                Lt_fi = multivariate_leading_term(List[i], Xv, Pp)
                # Getting the leading Monomial of fi
                Lm_fi = Lt_fi/Lt_fi.subs([Xv[j]==1 for j in rg(sz)])
                # Getting the Leading term of p
                Lt_p = multivariate_leading_term(p, Xv, Pp)
                # Getting the leading Monomial of p
                Lm_p = Lt_p/Lt_p.subs([Xv[j]==1 for j in rg(sz)])
                m_p  = Lm_p.subs([Xv[j]==Pp[j] for j in rg(sz)])
                m_fi = Lm_fi.subs([Xv[j]==Pp[j] for j in rg(sz)])
                if gcd(m_p, m_fi) == m_fi or gcd(m_p, m_fi) == -m_fi:
                    L[i] = expand(L[i] + Lt_p/Lt_fi)
                    p = expand(p - List[i] * Lt_p/Lt_fi)
                    division_occured = True
                else :
                    i = i+1
        if division_occured == False:
            L[len(List)] = L[len(List)] + multivariate_leading_term(p, Xv, Pp)
            p = p - multivariate_leading_term(p, Xv, Pp)
    return L

def multivariate_monomial_lcm(t1, t2, Xv, Pp):
    """
    Takes as input two terms t1 and t2 and
    returns a the least common multiple monomial.
    the function does not check the inputs.
    The last imput is a list of prime which
    determines the monomial ordering. 


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: multivariate_monomial_lcm(Xv[0]*Xv[1]^2*Xv[2], Xv[0]*Xv[2]^2, Xv, Pp)
        x0*x1^2*x2^2


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    # Initialization of the Prime variable dictionary datastructure
    PpXv = dict([(Pp[i],Xv[i]) for i in rg(sz)])
    # These 2 lines of code get rid of the coefficient of the leading terms
    m1 = t1/t1.subs([Xv[j]==1 for j in rg(sz)])
    m2 = t2/t2.subs([Xv[j]==1 for j in rg(sz)])
    # The following computes the lcm value associated with the monomial we seek
    monomial_lcm_value = lcm(m1.subs([Xv[i]==Pp[i] for i in rg(sz)]), m2.subs([Xv[i]==Pp[i] for i in rg(sz)]))
    # The next section of line of codes recovers the 
    # monomial in question from the computed lcm integer.
    prime_factors = factor(Integer(monomial_lcm_value))
    factor_list = list(prime_factors)
    # Initialization of the monomial
    m = 1
    for i in rg(len(factor_list)):
        tmp_list = list(factor_list[i])
        m = m * PpXv[tmp_list[0]]^Integer(tmp_list[1])
    return m

def multivariate_S_polynomials(List, Xv, Pp):
    """
    Takes as input a list of polynomials
    returns the list of substracted polynomials.
    The last input is a list of primes which
    determines the monomial ordering.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: multivariate_S_polynomials([Xv[0]*Xv[1]^2*Xv[2]+Xv[1]*Xv[2]+1, Xv[0]*Xv[2]^2+1], Xv, Pp)
        [x1*x2^2 - x1^2 + x2]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    L = []
    for i in rg(len(List)-1):
        for j in rg(i+1,len(List)):
            Lt_fi = multivariate_leading_term(List[i], Xv, Pp)
            Lt_fj = multivariate_leading_term(List[j], Xv, Pp)
            monomial_lcm = multivariate_monomial_lcm(Lt_fi,Lt_fj, Xv, Pp)
            Sij = expand(List[i]*(monomial_lcm/Lt_fi) - List[j]*(monomial_lcm/Lt_fj))
            L.append(Sij)
    return L

def multivariate_reduce_polynomial(f, Xv, Pp):
    """
    Takes as input a polynomial f and removes any redundant monomial
    common factors between the terms of f. The reduction refers to 
    the reduced grobner bases. The last input is a list of primes
    which determines the prime induce monomial ordering.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: multivariate_reduce_polynomial(Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2], Xv, Pp)
        x2^2 - x1 + x2


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    # Initialization of the Prime variable dictionary datastructure
    PpXv = dict([(Pp[i],Xv[i]) for i in rg(sz)])
    # Checks to see if there is a constant term 
    # in which case no reduction is needed
    if not f.subs([Xv[j]==0 for j in rg(sz)]).is_zero():
        return f
    elif f == 0:
        return f
    else:
        L = list(f.iterator())
        # The next piece of code determines i
        # if the expression is a monomial
        prd = 1
        for j in rg(len(L)):
            prd = prd*L[j]
        if prd == f:
            return 1
        elif (len(L) == 2) and (L[0]^L[1] == f):
            return f
        for i in rg(len(L)):
            # The next line of code gets rid of 
            # the coefficients in the list
            L[i] = L[i]/(L[i].subs([Xv[j]==1 for j in rg(sz)]))
            L[i] = Integer(L[i].subs([Xv[j]==Pp[j] for j in rg(sz)]))
        # Computing the greatest common divisior
        cmn_fctr = gcd(L)
        if cmn_fctr == 1 :
            return f
        else :
            # The next section of line of codes recover the monomial
            # in question from the computed gcd integer.
            prime_factors = factor(cmn_fctr)
            factor_list = list(prime_factors)
            m = 1
            for i in rg(len(factor_list)):
                tmp_list = list(factor_list[i])
                m = m * PpXv[tmp_list[0]]^Integer(tmp_list[1])
            g = expand(f/m)
            return g

def prime_induced_grobner_basis(Idl, Xv, Pp):
    """
    Takes as input a polynomial f and removes any redundant monomial
    common factors between the terms of f. The reduction referes to 
    the reduced grobner bases. The last input is a list of primes 
    which determines the variable ordering.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: Idl=[expand((Xv[0]+2*Xv[1])*(2*Xv[2]))-6, Xv[2]^2-Xv[2], Xv[1]^2-Xv[1], Xv[0]^2-Xv[0]] 
        sage: prime_induced_grobner_basis(Idl, Xv, Pp)[0]
        2*x0*x2 + 4*x1*x2 - 6


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(Xv)
    # Initialization step 
    I_curr = list()
    for i in rg(len(Idl)):
        I_curr.append(Idl[i])
    l_old = 0; l_new = len(I_curr)
    # Boolean variable tracking contradictions
    finished = False
    while l_old != l_new and finished == False:
        # Computes the single pass of the substraction polynomials
        S  = multivariate_S_polynomials(I_curr, Xv, Pp)
        #print('\n\n The subtraction polynomials yield')
        for i in rg(len(S)):
            S[i] = multivariate_reduce_polynomial(S[i], Xv, Pp)
            #print('S[',i,']= ',S[i])
        # The instruction bellow is the lazy way of getting rid of the duplicates.
        St = Set(S)
        S = list(St)
        # Recording the size of the Ideal generator set before the division
        l_old = len(I_curr)
        for i in rg(len(S)):
            tmp_list = multivariate_division(S[i], I_curr, Xv, Pp)
            if tmp_list[len(tmp_list)-1]!=0:
                I_curr.append(tmp_list[len(tmp_list)-1])
        # Printing the result of the first pass of the Buchberger algorithm.
        #print('\n\n The Current generator for the Ideal is given by')
        for i in rg(len(I_curr)):
            #print I_curr[i]
            if I_curr[i] == I_curr[i].subs([Xv[j]==0 for j in rg(sz)]) and not I_curr[i].subs([Xv[j]==0 for j in rg(sz)]).is_zero():
                finished = True
        # Recording the size of the generator set after the division
        l_new = len(I_curr)
    return I_curr

def generate_general_linear_constraints(sz,l):
    """
    Creates a sage file which intializes a general linear 
    system of sz constraints in l variables.

    EXAMPLES:

    ::

        sage: generate_general_linear_constraints(3,2)
        sage: load('general_linear_system_3_2.sage')
        [:, :, 0]=
        [a00*x0*b00 + a01*x1*b10]
        <BLANKLINE>
        [:, :, 1]=
        [a10*x0*b01 + a11*x1*b11]
        <BLANKLINE>
        [:, :, 2]=
        [a20*x0*b02 + a21*x1*b12]
        sage: from subprocess import call
        sage: call("rm general_linear_system_3_2.sage", shell=True)
        0
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the hypermatrices.
    Al=HM(sz,l,'a').list(); Bl=HM(l,sz,'b').list(); Xl=var_list('x',l)
    # Creating the file name string.
    filename='general_linear_system_'+str(sz)+'_'+str(l)+'.sage'
    # Opening the file
    f=open(filename,'w')
    #f.write('# Loading the Hypermatrix Package\n')
    #f.write("load('./Hypermatrix_Algebra_tst.sage')\n\n")
    f.write('# Initializing the number of constraints and the number of variableas\n')
    f.write('sz='+str(sz)+'; l='+str(l)+'\n\n')
    f.write('# Initialization of the variables\n')
    f.write("Lx=var_list('x',l)\n")
    f.write("La=HM(sz,l,'a').list()\n")
    f.write("Lb=HM(l,sz,'b').list()\n\n")
    f.write('# Initializing the free variables\n')
    f.write('F=FreeAlgebra(QQ,len(La+Lx+Lb),La+Lx+Lb)\n')
    f.write('F.<'+str(Al+Xl+Bl)[1:len(str(Al+Xl+Bl))-1]+'>=FreeAlgebra(QQ,len(La+Lx+Lb))\n\n')
    f.write('# Initialization of the hypermatrices with symbolic variable entries which do not commute\n')
    f.write('# associated with the map\n')
    f.write('Ha=HM(1,l,sz,HM(sz,l,'+str(Al)+').transpose().list())\n')
    f.write('Hx=HM(1,1,l,'+str(Xl)+')\n')
    f.write('Hb=HM(l,1,sz,'+str(Bl)+')\n\n')
    f.write('# Initialization of the product\n')
    f.write('Hr=Prod(Ha,Hx,Hb)\n')
    f.write('Hr.printHM()\n')
    # Closing the file
    f.close()

def GeneralHypermatrixSlicer(A, Rg, indx):
    """
    Outputs slices specified by index list L.
    the last string input is either row or col
    and determines the slices to be collected
    into a hypermatrix in the specified order
    by the input list Rg.


    EXAMPLES:
 
    ::

        sage: sz=3; A=HM(sz,sz,'a')
        sage: GeneralHypermatrixSlicer(A, [0], 'row').printHM()
        [:, :]=
        [a00 a01 a02]
        sage: GeneralHypermatrixSlicer(A, [1], 'col').printHM()
        [:, :]=
        [a01]
        [a11]
        [a21]
        sage: GeneralHypermatrixSlicer(A, [1,0], 'col').printHM()
        [:, :]=
        [a01 a00]
        [a11 a10]
        [a21 a20]
        sage: GeneralHypermatrixSlicer(A, [1,0], 'row').printHM()
        [:, :]=
        [a10 a11 a12]
        [a00 a01 a02]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the desired permutation
    if sorted(Rg) == rg(len(Rg)):
        Pmt=Rg
    else:
        Pmt = get_permutation(sorted(Rg),Rg)
    # Initialization of a number for the test
    nb=2
    if type(indx) == type(nb):
        if indx < A.order() :
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        entry[indx] = Rg[Pmt[Rg.index(entry[indx])]]
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        else:
            raise ValueError("The index must be smaller then the order of the Hypermatrix")
    elif type(indx) == type('tst'):
        if indx == 'row':
            indx=0
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in rg(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        entry[indx] = Rg[Pmt[Rg.index(entry[indx])]]
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'col':
            indx=1
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        entry[indx] = Rg[Pmt[Rg.index(entry[indx])]]
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'dpt':
            indx=2
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        entry[indx] = Rg[Pmt[Rg.index(entry[indx])]]
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'tme':
            indx=3
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        entry[indx] = Rg[Pmt[Rg.index(entry[indx])]]
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        else:
            raise ValueError("The string must be one of the following 4 choices row, col, dpt or tme")
    else:
        raise ValueError("The index must be a string or an integer")

def GeneralHypermatrixSlicerII(A, Rg, indx):
    """
    Outputs slices specified by index list L.
    the last string input is either row or col
    and determines the slices to be collected
    into a hypermatrix. The difference with
    the implementation above is that slice
    are placed in increasing order independently
    of the specification in the input list Rg


    EXAMPLES:
 
    ::

        sage: sz=3; A=HM(sz,sz,'a')
        sage: GeneralHypermatrixSlicerII(A, [0], 'row').printHM()
        [:, :]=
        [a00 a01 a02]
        sage: GeneralHypermatrixSlicerII(A, [1], 'col').printHM()
        [:, :]=
        [a01]
        [a11]
        [a21]
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of a number for the test
    nb=2
    if type(indx) == type(nb):
        if indx < A.order() :
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        else:
            raise ValueError("The index must be smaller then the order of the Hypermatrix")
    elif type(indx) == type('tst'):
        if indx == 'row':
            indx=0
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'col':
            indx=1
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'dpt':
            indx=2
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        elif indx == 'tme':
            indx=3
            if len(Rg) <= A.n(indx):
                # Initialization of the hypermatrix which stores the result
                dms=A.dimensions(); dms[indx]=len(Rg); 
                # Initializing the list of entries
                Lst=[]
                # Initialization of the list specifying the dimensions of the output
                l = [A.n(i) for i in range(A.order())]
                # Main loop performing the transposition of the entries
                for i in range(prod(l)):
                    # Turning the index i into an hypermatrix array location using the decimal encoding trick
                    entry = [Integer(mod(i,l[0]))]
                    sm = Integer(mod(i,l[0]))
                    for k in range(len(l)-1):
                        entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                        sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
                    if entry[indx] in Rg:
                        Lst.append(A[tuple(entry)])
                #return apply(HM,dms+[Lst])
                return HM(*(dms+[Lst]))
            else:
                raise ValueError("The range must be smaller then corresponding index range")
        else:
            raise ValueError("The string must be one of the following 4 choices row, col, dpt or tme")
    else:
        raise ValueError("The index must be a string or an integer")

def KroneckerResultant(L, vrbl, VrbLp, VrbLq):
    """
    Takes as input a list of polynomials, a variable,
    two lists of dummy variables to be used in the linear
    combinations of constraints and outputs the corresponding
    Kronecker resultant list of polynomials.


    EXAMPLES:

    ::

        sage: sz=2;La=var_list('a',sz); Lb=var_list('b',sz); Lc=var_list('c',sz)
        sage: p=expand(prod(x-La[i] for i in rg(sz)))
        sage: q=expand(prod(x-La[i] for i in rg(floor(sz/2)))*prod(x-Lb[1] for i in rg(floor(sz/2))))
        sage: h=expand(prod((x-Lc[i]) for i in rg(sz)))
        sage: L=[p, q, h]
        sage: len(Set([factor(v) for v in KroneckerResultant(L, x, var_list('u',len(L)), var_list('v',len(L)))]).list())
        10        
        sage: X=var_list('x',4); L=[X[1] + X[2] + X[3] - 5, 7*X[1]*X[2] + 4*X[3] - 2*X[2] - 8, 10*X[2]+5*X[1]*X[2]-2*X[2]*X[3]+1]
        sage: len(Set([factor(v) for v in KroneckerResultant(L, X[1], var_list('u',len(L)), var_list('v',len(L)))]).list())
        6 


    AUTHORS:
    - Edinah K. Gnang, Jonathan Earl
    """
    # Initialization of the symbolic linear combination
    p=expand(sum(L[i]*VrbLp[i] for i in rg(len(L)))); q=expand(sum(L[i]*VrbLq[i] for i in rg(len(L))))
    # Initialization of the determinant
    f=expand(SylvesterHM(p, q, vrbl).det())
    # Initialization of the list of monomial
    Lm=[mn/mn.subs([v==1 for v in VrbLp+VrbLq]) for mn in f.operands()]
    return [f.coefficient(mn) for mn in Lm]

def KroneckerResultantII(L, vrbl, VrbLp, VrbLq):
    """
    Takes as input a list of polynomials, a variable,
    two lists of dummy variables to be used in the linear
    combinations of constraints and outputs the corresponding
    Kronecker resultant list of polynomials.


    EXAMPLES:

    ::

        sage: sz=2;La=var_list('a',sz); Lb=var_list('b',sz); Lc=var_list('c',sz)
        sage: p=expand(prod(x-La[i] for i in rg(sz)))
        sage: q=expand(prod(x-La[i] for i in rg(floor(sz/2)))*prod(x-Lb[1] for i in rg(floor(sz/2))))
        sage: h=expand(prod((x-Lc[i]) for i in rg(sz)))
        sage: L=[p, q, h]
        sage: len(Set([factor(v) for v in KroneckerResultant(L, x, var_list('u',len(L)), var_list('v',len(L)))]).list())
        10


    AUTHORS:
    - Jonathan Earl
    """
    lenL = len(L)
    var1, var2 = str(VrbLp[0])[0], str(VrbLq[0])[0]
    M = SylvesterHM(sum(VrbLp[i]*L[i] for i in range(lenL)), sum(VrbLq[i]*L[i] for i in range(lenL)), vrbl).matrix()
    f = expand(M.det())
    appender = {}
    for i in f.operands():
        parts = str(i).replace('-'+var1, '-1*'+var1).replace('-'+var2, '-1*'+var2).split('*')
        myKey = '*'.join([j for j in parts if j.startswith(var1) or j.startswith(var2)])
        myVal = '*'.join([j for j in parts if j not in myKey])
        myVal = 1 if not bool(myVal) else SR(myVal)
        appender[myKey] = appender.get(myKey, 0) + myVal
    return appender.values()

def kroneckerian_elimination(L, VrbL):
    """
    Takes as input a list of polynomials and a list of variable
    and outputs the corresponding resultant. Performs the Kroneckerian
    elimination algorithm

    EXAMPLES:

    ::

        sage: sz=3; VrbL=var_list('x',sz); L=(Vandermonde(rg(1,1+sz))*HM(sz,1,VrbL)-HM(sz,1,rg(sz))).list()
        sage: degree_matrix(L,VrbL)
        [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
        sage: len(kroneckerian_elimination(L, VrbL))
        3
        sage: sz=2; VrbL=var_list('x',sz); A=HM(sz,sz,'a'); b=HM(sz,1,var_list('b',sz))
        sage: L=(A*HM(sz,1,VrbL)-b).list()
        sage: kroneckerian_elimination(L, VrbL)
        [[a00*x0 + a01*x1 - b0, a10*x0 + a11*x1 - b1],
         [-a01*a10*x1 + a00*a11*x1 + a10*b0 - a00*b1,
          a01*a10*x1 - a00*a11*x1 - a10*b0 + a00*b1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the resulting list
    RsL=[L]
    # Initialization of the loop eliminating all the variables
    for i in rg(len(VrbL)-1):
        RsL.append(Set(KroneckerResultant(RsL[len(RsL)-1], VrbL[i], var_list('u',len(RsL[len(RsL)-1])), var_list('v',len(RsL[len(RsL)-1])))).list()) 
    return RsL

def GeneralHypermatrixSubstituteInMatrix(A,vrbl,M):
    """
    Outputs a hypermatrix whose polynomial entries
    have been substited in the input matrix for the
    input variable.


    EXAMPLES:

    ::

        sage: x=var('x'); Ha=HM(2,1,[x+1,x^2+1])
        sage: Y=var_list('y',2); rM=GeneralHypermatrixSubstituteInMatrix(Ha,x,HM(2,2,[Y[0],0,0,Y[1]]))
        sage: rM[0,0].printHM()
        [:, :]=
        [y0 + 1      0]
        [     0 y1 + 1]
        sage: rM[1,0].printHM()
        [:, :]=
        [y0^2 + 1        0]
        [       0 y1^2 + 1]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the computations of the entries
    for i in range(prod(l)):
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if A[tuple(entry)].is_zero():
            Rh[tuple(entry)] = 0
        else:
            Rh[tuple(entry)] = substituteHM(A[tuple(entry)],vrbl,M).expand()
    return Rh

def naught_eliminationHM(Cf):
    """
    Outputs the row echelon form of a multiplicative linear constraints where the RHS is zero.
    This implementation assumes that there is not division. This assumption incurs no loss of 
    generality at all since we can collect the denominators to make up a new multiplicative 
    system. Solve it independently and check whether they have non overlapping solutions.
    The corresponding problem is striking by its combinatorial flavor.
    

    EXAMPLES:
 
    ::

        sage: A = naught_eliminationHM(HM(2,2,'a'))
        sage: A.printHM()
        [:, :]=
        [a00 a01]
        [  0   0]
        sage: Ta=HM(2,2,'a') # Initialization of the coefficient matrix.
        sage: Ha=HM(2,2,[Ta[0,0]*HM(2,2,'kronecker'), Ta[1,0]*HM(2,2,'kronecker'), Ta[0,1]*HM(2,2,'kronecker'), Ta[1,1]*HM(2,2,'kronecker')])
        sage: A=naught_eliminationHM(Ha) # performing the gaussian elimination where entries are hypermatrices.
        sage: A
        [[[[a00, 0], [0, a00]], [[a01, 0], [0, a01]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]
        sage: sz=2; A=HM(sz,sz,'a'); B=HM(sz,sz,'b')
        sage: A00=HM([[A[0,0],-B[0,0]],[B[0,0],A[0,0]]]); A01=HM([[A[0,1],-B[0,1]],[B[0,1],A[0,1]]])
        sage: A10=HM([[A[1,0],-B[1,0]],[B[1,0],A[1,0]]]); A11=HM([[A[1,1],-B[1,1]],[B[1,1],A[1,1]]])
        sage: M=naught_eliminationHM(HM([[A00,A01],[A10,A11]]))
        sage: M
        [[[[a00, -b00], [b00, a00]], [[a01, -b01], [b01, a01]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initializing a copy of the input second order hypermatrices.
    A=Cf.copy()
    # Initialization of the row and column index
    i=0; j=0
    while i < A.n(0) and j < A.n(1):
        while A.slice(rg(i,A.n(0)),'row').slice([j],'col').is_zero() and j < A.n(1)-1:
            # Incrementing the column index
            j=j+1
        if A.slice(rg(i,A.n(0)),'row').is_zero()==False:
            while A[i,j].is_zero(): 
                Ta=A.slice(rg(i,A.n(0)),'row')
                # Initializing the cyclic shift permutation matrix
                P=HM(2, rg(1,Ta.n(0))+[0],'perm')
                Ta=P*Ta
                for i0 in rg(Ta.n(0)):
                    for j0 in rg(Ta.n(1)):
                        A[i+i0,j0]=Ta[i0,j0]
            # Performing the row operations.
            for r in rg(i+1,A.nrows()):
                # Taking care of the zero row
                if HM(1,A.n(1),[A[r,j0] for j0 in range(A.n(1))]).is_zero():
                    r=r+1
                else:
                    # Initialization of the coefficient
                    if A[r,j].is_zero() == False:
                        for j0 in rg(A.n(1)):
                            A[r,j0]=0*A[r,j0]
        # Incrementing the row and column index.
        i=i+1; j=j+1
    return A

def naught_reduced_eliminationHM(Cf):
    """
    Outputs the reduced row echelon form associated with the naught elimination.
    This implementation assumes that the input entries commute. 


    EXAMPLES:
 
    ::

        sage: RefA = naught_reduced_eliminationHM(HM(2,2,'a'))
        sage: RefA.printHM()
        [:, :]=
        [a00 a01]
        [  0   0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    A=naught_eliminationHM(Cf)
    # Initialization of the row and column index
    i=A.nrows()-1; j=0
    while i>0 or j>0:
        #if (A[i,:]).is_zero():
        #if HM(1,A.n(1),[A[i,j0] for j0 in rg(A.n(1))]).is_zero():
        if A.slice([i],'row').is_zero():
            # decrementing the row index and initializing the column index
            i=i-1; j=0
        else :
            while (A[i,j]).is_zero():
                # Incrementing the column index
                j = j + 1
            # performing row operations
            for r in rg(i-1,-1,-1):
                #A[r,:] = -A[r,j]*A[i,:]+A[r,:]
                Tra=HM(1, A.n(1), 'zero')
                for j0 in rg(A.n(1)):
                    if j0 == j:
                        Tra[0,j0]=-A[r,j0]*A[i,j0]+A[r,j0]
                    else:
                        Tra[0,j0]=A[r,j0]
                for j0 in rg(A.n(1)):
                    A[r,j0]=Tra[0,j0]
            i=i-1; j=0
    return A

def naught_solver(EqL, La, Lf):
    """
    Formats the constraints performs and solves the multiplicatively linear constraints
    where the right hand side equals zero. This function outputs the solutions. The input
    EqL corresponds to a list of constraints. The input Lv corresponds to the list of 
    variables appearing in the constraints. The input Lf corresponds to the list of free
    varaibles each taken in correspondence with the entries of Lv. This implementation 
    tacitly assumes that the  the input constraints are indeed multiplicatively linear.
    This implementation performs all permutations of the variables and all permutations
    of the equations.


    EXAMPLES:
 
    ::

        sage: sz=2; len(naught_solver([var('x'+str(i))*var('x'+str(sz+j)) for i in range(sz) for j in range(sz)], var_list('x', 2*sz), var_list('t', 2*sz)))
        2


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the permutations
    P=Permutations(len(La)); Q=Permutations(len(EqL))
    # Initialization of the list which stores the solutions
    Sln=[]
    for jtr in Q:
        itr=[jtr[i]-1 for i in rg(len(EqL))]
        # Performing a cyclic permutation of the constraints
        Eq=[EqL[itr[i]] for i in rg(len(EqL))]
        # Obtaining the variables in the first equations
        [TmpHa,hb]=multiplicativeConstraintFormatorIIHM(Eq[:1],La)
        La1=(TmpHa*HM(len(La),1,La))[0,0].operands()
        La2=Set(La).difference(Set(La1)).list()
        for p in P:
            q=[p[i]-1 for i in rg(len(La))]
            # Updating the ordering of the variables
            tLa=[La[q[i]] for i in rg(len(La))]
            # Formatting the constraints to obtain the coefficient matrix
            [Ha, hb]=multiplicativeConstraintFormatorIIHM(Eq, tLa)
            # Performing the Gaussian elimination procedure
            tA=naught_reduced_eliminationHM(Ha)
            # Identifying the non zero rows of the matrix
            r=1
            while HM(tA.n(0),tA.n(1),'zero').fill_with(tA.slice(rg(r),'row'),[0,0]) != tA:
                r=r+1
            # Taking only the nonzero rows
            Ca=tA.slice(rg(r),'row')
            # Initialization of the vector
            #vA=HM(len(tLa),1,tLa)
            # Obtaining the resulting constraints
            #qE=(vA^Ca).list(); print 'Eq =', Eq,'qE =', qE, 'tLa =', tLa
            # Obtaining a solution to the system
            Mx=HM(Ca.n(1),1,tLa); Mv=HM(Ca.n(1),1,Lf) # Initialization of the pivot and free variables
            tmpSln=multiplicative_linear_solverHM(Ca,HM(Ca.n(0),1,'zero'),Mx,Mv)
            if (Set(tmpSln).list() in Sln) == False:
                Sln.append(Set(tmpSln).list())
    # Initializing the list of lengths
    Ll=[len(s) for s in Sln]; mn=min(Ll)
    return [s for s in Sln if len(s)==mn]
 
def SecondOrderIndexRotation(Ha, T):
    """
    The function perform the rotation of angle T for the indices.
    Ha is input second order hypermatrices. The rotation is performed
    clockwise by multiples of 2*pi/4.
    [i,j] -> [(i-floor(sz/2))*cos(T)+(-j+floor(sz/2))*sin(T)+floor(sz/2), (i-floor(sz/2))*sin(T)-(-j+floor(sz/2))*cos(T)+floor(sz/2)] if sz is odd
    [i,j] -> [(i-(sz-1)/2)*cos(T)+(-j+(sz-1)/2)*sin(T)+(sz-1)/2, (i-(sz-1)/2)*sin(T)-(-j+(sz-1)/2)*cos(T)+(sz-1)/2] if sz is even


    EXAMPLES:

    ::

        sage: sz=5; Ha=HM(sz,sz,'a') # Initialization of the input Hypermatrix
        sage: (Ha.tumble()-SecondOrderIndexRotation(Ha, 2*pi/4)).is_zero()
        True
        sage: sz=6; Ha=HM(sz,sz,'a') # Initialization of the input Hypermatrix
        sage: (Ha.tumble()-SecondOrderIndexRotation(Ha, 2*pi/4)).is_zero()
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    if Ha.is_cubical() and Integer(mod(Ha.n(0),2)) == 1:
        # Initialization of the matrix
        sz=Ha.n(0); B=HM(sz,sz,'zero')
        for i in rg(sz):
            for j in rg(sz):
                B[i,j]=Ha[(i-floor(sz/2))*cos(T)+(-j+floor(sz/2))*sin(T)+floor(sz/2), (i-floor(sz/2))*sin(T)-(-j+floor(sz/2))*cos(T)+floor(sz/2)]
        return B
    elif Ha.is_cubical() and Integer(mod(Ha.n(0),2)) == 0:
        # Initialization of the matrix
        sz=Ha.n(0); B=HM(sz,sz,'zero')
        for i in rg(sz):
            for j in rg(sz):
                B[i,j]=Ha[(i-(sz-1)/2)*cos(T)+(-j+(sz-1)/2)*sin(T)+(sz-1)/2, (i-(sz-1)/2)*sin(T)-(-j+(sz-1)/2)*cos(T)+(sz-1)/2]
        return B
    else:
        raise ValueError("The input matrices must be square.")

def ThirdOrderIndexRotation(A, Langle):
    """
    The function takes a 3rd order hypermatrix and performs
    an index rotation around the axis specified in the Row,
    Column and Depth order specified by the input list angles.
    This implement only handles cubic hypermatrices. In case
    the hypermatrix is not cubic zeropadd to a cubic hypermatrix.

    EXAMPLES:
 
    ::

        sage: sz=2; A=HM(sz, sz, sz, 'a')
        sage: Langle=[2*pi/4, 0, 0]
        sage: ThirdOrderIndexRotation(A, Langle).printHM()
        [:, :, 0]=
        [a100 a110]
        [a101 a111]
        <BLANKLINE>
        [:, :, 1]=
        [a000 a010]
        [a001 a011]
        <BLANKLINE>


    AUTHORS:
    - Fan Tian and Edinah K. Gnang
    - To Do: Implement the arbitrary order version
    """
    if A.is_cubical():
        sz=A.n(0)
        # Initializing the output
        B=A.copy()
        # First performs a rotation around the Row ( or x ) axis performs a rotation of the column slices
        # Second performs a rotation around the Column ( or y ) axis performs a rotation of the  row slices
        # Third performs a rotation around the Depth ( or z ) axis performs a rotation of the depth slices
        axes = [1, 0, 2]
        for i in rg(len(axes)):
            axis = axes[i]
            for j in rg(sz):
                M=HM(sz, sz, B.slice([j], axis).list()).index_rotation(Langle[i])
                for u in rg(sz):
                    for v in rg(sz):
                        # Performing the index rotation relative to the row axis
                        if axis == 1:
                            B[u,j,v]=M[u,v]
                        # Performing the index rotation relative to the col axis
                        elif axis == 0:
                            B[j,u,v]=M[u,v]
                        # Performing the index rotation relative to the dpt axis
                        elif axis == 2:
                            B[u,v,j]=M[u,v]
        return B
    else:
        raise ValueError("Expected a cubic hypermatrix")

def SelectThirdOrderIndexRotation(A, Langle, EntryList):
    """
    The function takes a 3rd order hypermatrix and performs
    an index rotation  of the select indices specified by the 
    EntryList input around the axis specified in the Row,
    Column and Depth order specified by the input list angles.
    This implement only handles cubic hypermatrices. In case
    the hypermatrix is not cubic zeropadd to a cubic hypermatrix.


    EXAMPLES:
 
    ::

        sage: sz=2; A=HM(sz, sz, sz, 'a')
        sage: Langle=[2*pi/4, 0, 0]
        sage: SelectThirdOrderIndexRotation(A, Langle, rg(sz)).printHM()
        [:, :, 0]=
        [a100 a110]
        [a101 a111]
        <BLANKLINE>
        [:, :, 1]=
        [a000 a010]
        [a001 a011]
        <BLANKLINE>
        sage: sz=4; A=HM(sz, sz, sz, 'a')
        sage: Langle=[2*pi/4, 0, 0]
        sage: SelectThirdOrderIndexRotation(A, Langle, [0,1]).printHM()
        [:, :, 0]=
        [a100 a110 a020 a030]
        [a101 a111 a120 a130]
        [a200 a210 a220 a230]
        [a300 a310 a320 a330]
        <BLANKLINE>
        [:, :, 1]=
        [a000 a010 a021 a031]
        [a001 a011 a121 a131]
        [a201 a211 a221 a231]
        [a301 a311 a321 a331]
        <BLANKLINE>
        [:, :, 2]=
        [a002 a012 a022 a032]
        [a102 a112 a122 a132]
        [a202 a212 a222 a232]
        [a302 a312 a322 a332]
        <BLANKLINE>
        [:, :, 3]=
        [a003 a013 a023 a033]
        [a103 a113 a123 a133]
        [a203 a213 a223 a233]
        [a303 a313 a323 a333]
        <BLANKLINE>


    AUTHORS:
    - Edinah K. Gnang and Fan Tian 
    - To Do: Implement the arbitrary order version
    """
    if A.is_cubical():
        # Sorting the EntryList
        EntryList.sort()
        sz=A.n(0); TmpB=HM(len(EntryList),len(EntryList),len(EntryList),[A[i,j,k] for k in EntryList for j in EntryList for i in EntryList]).index_rotation(Langle)
        B=A.copy()
        for i in rg(len(EntryList)):
            for j in rg(len(EntryList)):
                for k in rg(len(EntryList)):
                    B[EntryList[i], EntryList[j], EntryList[k]]=TmpB[i,j,k]
        return B
    else:
        raise ValueError("Expected a cubic hypermatrix and the entry list must be smaller then the side length.")

def ThirdOrderSliceIndexRotation(A, Langle, Lslice):
    """
    The function takes a 3rd order hypermatrix and performs
    an index rotation around the axis specified in the Row,
    Column and Depth order specified by the input list angles.
    The operation is performed only to the slices which specified
    in the input Lslice.
    This implement only handles cubic hypermatrices. In case
    the hypermatrix is not cubic zeropadd to a cubic hypermatrix.

    EXAMPLES:
 
    ::

        sage: sz=2; A=HM(sz, sz, sz, 'a')
        sage: Langle=[0, 0, 2*pi/4]; Lslice=[0]
        sage: ThirdOrderSliceIndexRotation(A, Langle, Lslice).printHM()
        [:, :, 0]=
        [a100 a000]
        [a110 a010]
        <BLANKLINE>
        [:, :, 1]=
        [a001 a011]
        [a101 a111]
        <BLANKLINE>


    AUTHORS:
    - Fan Tian and Edinah K. Gnang
    - To Do: Implement the arbitrary order version
    """
    if A.is_cubical():
        sz=A.n(0)
        # Initializing the output
        B=A.copy()
        # First performs a rotation around the Row ( or x ) axis performs a rotation of the column slices
        # Second performs a rotation around the Column ( or y ) axis performs a rotation of the  row slices
        # Third performs a rotation around the Depth ( or z ) axis performs a rotation of the depth slices
        axes = [1, 0, 2]
        for i in rg(len(axes)):
            axis = axes[i]
            for j in Lslice:
                M=HM(sz, sz, B.slice([j], axis).list()).index_rotation(Langle[i])
                for u in rg(sz):
                    for v in rg(sz):
                        # Performing the index rotation relative to the row axis
                        if axis == 1:
                            B[u,j,v]=M[u,v]
                        # Performing the index rotation relative to the col axis
                        elif axis == 0:
                            B[j,u,v]=M[u,v]
                        # Performing the index rotation relative to the dpt axis
                        elif axis == 2:
                            B[u,v,j]=M[u,v]
        return B
    else:
        raise ValueError("Expected a cubic hypermatrix")

def SelectSecondOrderIndexRotation(Ha, T, EntryList):
    """
    The function perform the rotation of angle T for the 
    selected indices specified by the EntryList input.
    Ha is input second order hypermatrices.


    EXAMPLES:

    ::

        sage: sz=5; Ha=HM(sz,sz,'a') # Initialization of the input Hypermatrix
        sage: (Ha.tumble()-SelectSecondOrderIndexRotation(Ha, 2*pi/4, rg(sz))).is_zero()
        True
        sage: sz=6; Ha=HM(sz,sz,'a') # Initialization of the input Hypermatrix
        sage: (Ha.tumble()-SelectSecondOrderIndexRotation(Ha, 2*pi/4, rg(sz))).is_zero()
        True
        sage: sz=5; Ha=HM(sz,sz,'a')
        sage: (Ha-SelectSecondOrderIndexRotation(Ha, 2*pi/4, [0,1])).printHM()
        [:, :]=
        [ a00 - a10 -a00 + a01          0          0          0]
        [ a10 - a11 -a01 + a11          0          0          0]
        [         0          0          0          0          0]
        [         0          0          0          0          0]
        [         0          0          0          0          0]


    AUTHORS:
    - Edinah K. Gnang
    """
    if Ha.is_cubical() and len(EntryList) <= Ha.n(0):
        # Sorting the EntryList
        EntryList.sort()
        # Initialization of the matrix
        sz=Ha.n(0); TmpB=HM(len(EntryList),len(EntryList),[Ha[i,j] for j in EntryList for i in EntryList]).index_rotation(T)
        B=Ha.copy()
        for i in rg(len(EntryList)):
            for j in rg(len(EntryList)):
                B[EntryList[i], EntryList[j]]=TmpB[i,j]
        return B
    else:
        raise ValueError("The input matrices must be square and the entry list must be smaller then the side length.")

def SecondOrderIndexMap(A):
    """
    The function perform a very special index map to the the the indices.
    A is input second order hypermatrix. The product of the sum across
    non-zero entries of yields a listing of all possible orrientations
    of gracefully labeled graphs. If B is the output for A=HM(sz,sz,'a')
    then prod(sum(B[i,j] for j in rg(sz) if j>=i) for i in rg(sz)) lists
    all 2^(sz-1)*factorial(sz) orrientations of grapcefully labeled graphs 


    EXAMPLES:

    ::

        sage: sz=5; Ha=HM(sz, sz, 'a') # Initialization of the input Hypermatrix
        sage: SecondOrderIndexMap(Ha).p()
        [:, :]=
        [      a00       a11       a22       a33       a44]
        [        0 a01 + a10 a12 + a21 a23 + a32 a34 + a43]
        [        0         0 a02 + a20 a13 + a31 a24 + a42]
        [        0         0         0 a03 + a30 a14 + a41]
        [        0         0         0         0 a04 + a40]
        sage: sz=Integer(4); A=HM(sz,sz,'a'); B=SecondOrderIndexMap(A)
        sage: F=prod(sum(B[i,j] for j in rg(sz) if j>=i) for i in rg(sz)); F # list of orrientations of graceful graphs 
        (a00 + a11 + a22 + a33)*(a01 + a10 + a12 + a21 + a23 + a32)*(a02 + a13 + a20 + a31)*(a03 + a30)
        sage: sz=Integer(4); od=Integer(2); X=var_list('x',sz); A=HM(sz,sz,'a'); Dx=HM(od, X,'diag'); B=SecondOrderIndexMap(Dx*A)
        sage: F=diff(prod(sum(B[i,j] for j in rg(sz) if j>=i) for i in rg(sz)),X); expand(F) # list of graceful functional digraphs 
        a00*a10*a20*a30 + a01*a11*a20*a30 + a00*a12*a20*a30 + a02*a11*a21*a30 + a00*a13*a21*a30 + a02*a10*a22*a30 + a02*a12*a22*a30 + a01*a13*a22*a30 + a02*a11*a23*a30 + a00*a13*a23*a30 + a03*a11*a21*a31 + a03*a10*a22*a31 + a03*a12*a22*a31 + a03*a11*a23*a31 + a03*a11*a20*a32 + a03*a13*a22*a32 + a03*a10*a20*a33 + a03*a12*a20*a33 + a03*a13*a21*a33 + a03*a13*a23*a33


    AUTHORS:
    - Edinah K. Gnang
    """
    if A.is_cubical():
        # Initialization of the matrix
        sz=A.n(0); B=HM(sz,sz,'zero')
        for i in rg(sz):
            for j in rg(i+1):
                if i == A.n(0)-1: 
                    B[i,j]=A[i-j,A.n(1)-1-j]
                else:
                    B[i,j]=A[i-j,A.n(1)-1-j]+A[A.n(1)-1-j,i-j]
        return B.index_rotation(2*(2*pi/4))
    else:
        raise ValueError("The input matrices must be square.")

def SecondOrderIndexMapII(A):
    """
    The function perform a very special index map to the the the indices.
    Ha is input second order hypermatrices and is assumed to be ?-diagonal


    EXAMPLES:

    ::

        sage: sz=Integer(4); Ha=HM(sz, sz, 'a') # Initialization of the input Hypermatrix
        sage: SecondOrderIndexMapII(Ha).printHM()
        [:, :]=
        [    a00     a11     a22     a33]
        [      0 a01*a10 a12*a21 a23*a32]
        [      0       0 a02*a20 a13*a31]
        [      0       0       0 a03*a30]
        sage: sz=Integer(4); A=HM(sz,sz,'a'); B=SecondOrderIndexMapII(A); B.p()
        sage: F=prod(sum(B[i,j] for j in rg(sz) if j>=i) for i in rg(sz)); F
        (a01*a10 + a12*a21 + a23*a32)*(a02*a20 + a13*a31)*(a00 + a11 + a22 + a33)*a03*a30


    AUTHORS:
    - Edinah K. Gnang
    """
    if A.is_cubical():
        # Initialization of the matrix
        sz=A.n(0); B=HM(sz,sz,'zero')
        for i in rg(sz):
            for j in rg(i+1):
                if i == A.n(0)-1: 
                    B[i,j]=A[i-j,A.n(1)-1-j]
                else:
                    B[i,j]=A[i-j,A.n(1)-1-j]*A[A.n(1)-1-j,i-j]
        return B.index_rotation(2*(2*pi/4))
    else:
        raise ValueError("The input matrices must be square.")

def SecondOrderIndexInvolution(A):
    """
    The function perform a very special index involution to the the the indices.
    Ha is input second order hypermatrices and must be a square matrix


    EXAMPLES:

    ::

        sage: sz=Integer(5); A=HM(sz, sz, 'a') # Initialization of the input Hypermatrix
        sage: SecondOrderIndexInvolution(A).p()
        [:, :]=
        [a44 a43 a42 a41 a40]
        [a34 a33 a32 a31 a30]
        [a24 a23 a22 a21 a20]
        [a14 a13 a12 a11 a10]
        [a04 a03 a02 a01 a00]


    AUTHORS:
    - Edinah K. Gnang
    """
    if A.is_cubical():
        # Initialization of the matrix
        sz=A.n(0); B=HM(sz,sz,'zero')
        for i in rg(sz):
            for j in rg(sz):
                B[i,j]=A[sz-1-i,sz-1-j]
        return B
    else:
        raise ValueError("The input matrices must be square.")

def SecondOrderBetaSlicing(A,T):
    """
    The function takes as in put a matrix A as well as a tuple description
    of an undirected loop beta-labeled graph and outputs a square matrix of the same size
    as A whose columns are the Beta slices of A. The function checks that the second input
    is beta labeled.


    EXAMPLES:

    ::

        sage: sz=Integer(4); A=HM(2*sz-1, 2*sz-1, 'a') # Initialization of the input Hypermatrix
        sage: T=[(0,0)]+[(i,0) for i in rg(1,sz)]+[(0,i) for i in rg(1,sz)] # Initialization of the tuples
        sage: SecondOrderBetaSlicing(A,T).p()
        [:, :]=
        [a00 a11 a22 a33 a44 a55 a66]
        [a10 a21 a32 a43 a54 a65 a06]
        [a20 a31 a42 a53 a64 a05 a16]
        [a30 a41 a52 a63 a04 a15 a26]
        [a01 a12 a23 a34 a45 a56 a60]
        [a02 a13 a24 a35 a46 a50 a61]
        [a03 a14 a25 a36 a40 a51 a62]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,4),(1,3),(2,2),(3,2),(4,1),(4,0),(3,1),(2,3),(1,4)]
        sage: SecondOrderBetaSlicing(A,T).p()
        [:, :]=
        [a04 a15 a26 a30 a41 a52 a63]
        [a13 a24 a35 a46 a50 a61 a02]
        [a22 a33 a44 a55 a66 a00 a11]
        [a32 a43 a54 a65 a06 a10 a21]
        [a41 a52 a63 a04 a15 a26 a30]
        [a40 a51 a62 a03 a14 a25 a36]
        [a31 a42 a53 a64 a05 a16 a20]
        [a23 a34 a45 a56 a60 a01 a12]
        [a14 a25 a36 a40 a51 a62 a03]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,3),(1,3),(2,3),(3,3),(4,0),(3,0),(3,1),(3,2),(0,4)]
        sage: SecondOrderBetaSlicing(A,T).p()
        [:, :]=
        [a03 a14 a25 a36 a40 a51 a62]
        [a13 a24 a35 a46 a50 a61 a02]
        [a23 a34 a45 a56 a60 a01 a12]
        [a33 a44 a55 a66 a00 a11 a22]
        [a40 a51 a62 a03 a14 a25 a36]
        [a30 a41 a52 a63 a04 a15 a26]
        [a31 a42 a53 a64 a05 a16 a20]
        [a32 a43 a54 a65 a06 a10 a21]
        [a04 a15 a26 a30 a41 a52 a63]
        sage: sz=Integer(5); od=Integer(2); A=HM(sz, sz, 'a'); X=var_list('x', sz); Ha=HM(sz,sz,'zero') # Setup for obtaining beta-labled functional digraphs
        sage: for u in rg(sz):
        ....:     for v in rg(sz):
        ....:         Ha[u,v]=A[u,v]*X[abs(v-u)] # Filling up the matrix
        ....:
        sage: F=expand(diff(prod(sum(Ha[i, j] for j in rg(sz)) for i in rg(sz)),X)) # Initialization of the listing
        sage: Lt=[]
        sage: for mnm in F.operands():
        ....:     Lt.append(Monomial2Tuple(mnm, A.list(), sz)+[(t[1], t[0]) for t in Monomial2Tuple(mnm, A.list(), sz) if t[0]!=t[1]])
        ....:
        sage: Lt[:5]
        [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (0, 1), (0, 2), (0, 3), (0, 4)],
         [(0, 1), (1, 1), (2, 0), (3, 0), (4, 0), (1, 0), (0, 2), (0, 3), (0, 4)],
         [(0, 0), (1, 2), (2, 0), (3, 0), (4, 0), (2, 1), (0, 2), (0, 3), (0, 4)],
         [(0, 2), (1, 1), (2, 1), (3, 0), (4, 0), (2, 0), (1, 2), (0, 3), (0, 4)],
         [(0, 0), (1, 3), (2, 1), (3, 0), (4, 0), (3, 1), (1, 2), (0, 3), (0, 4)]]
        sage: V=Vandermonde(var_list('x',2*sz-1))
        sage: for T in Lt[:2]:
        ....:     SecondOrderBetaSlicing(V,T).p(); print('\n')
        ....:
        [:, :]=
        [   1   x1 x2^2 x3^3 x4^4 x5^5 x6^6 x7^7 x8^8]
        [  x0 x1^2 x2^3 x3^4 x4^5 x5^6 x6^7 x7^8    1]
        [x0^2 x1^3 x2^4 x3^5 x4^6 x5^7 x6^8    1   x8]
        [x0^3 x1^4 x2^5 x3^6 x4^7 x5^8    1   x7 x8^2]
        [x0^4 x1^5 x2^6 x3^7 x4^8    1   x6 x7^2 x8^3]
        [   1   x2 x3^2 x4^3 x5^4 x6^5 x7^6 x8^7 x0^8]
        [   1   x3 x4^2 x5^3 x6^4 x7^5 x8^6 x0^7 x1^8]
        [   1   x4 x5^2 x6^3 x7^4 x8^5 x0^6 x1^7 x2^8]
        [   1   x5 x6^2 x7^3 x8^4 x0^5 x1^6 x2^7 x3^8]

        [:, :]=
        [   1   x2 x3^2 x4^3 x5^4 x6^5 x7^6 x8^7 x0^8]
        [  x1 x2^2 x3^3 x4^4 x5^5 x6^6 x7^7 x8^8    1]
        [x0^2 x1^3 x2^4 x3^5 x4^6 x5^7 x6^8    1   x8]
        [x0^3 x1^4 x2^5 x3^6 x4^7 x5^8    1   x7 x8^2]
        [x0^4 x1^5 x2^6 x3^7 x4^8    1   x6 x7^2 x8^3]
        [  x0 x1^2 x2^3 x3^4 x4^5 x5^6 x6^7 x7^8    1]
        [   1   x3 x4^2 x5^3 x6^4 x7^5 x8^6 x0^7 x1^8]
        [   1   x4 x5^2 x6^3 x7^4 x8^5 x0^6 x1^7 x2^8]
        [   1   x5 x6^2 x7^3 x8^4 x0^5 x1^6 x2^7 x3^8]        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the number of vertices in the template graph
    sz=Integer((A.n(0)+1)/2)
    if A.is_cubical() and Set(rg(sz))==Set([abs(t[1]-t[0]) for t in T]) and Tuple_to_AdjacencyII(T,2*sz-1).is_symmetric():
        return HM([[A[Integer(mod(t[0]+k,2*sz-1)),Integer(mod(t[1]+k,2*sz-1))] for t in T] for k in rg(2*sz-1)]).t()
    else:
        raise ValueError("The input matrices must be square and the second input beta labeled")

def SecondOrderRhoSlicing(A,T):
    """
    The function takes as input a square matrix A with an odd number of rows  as well as
    a tuple description of an undirected loop rho-labeled graph and outputs a square matrix
    of the same size as A whose columns are the rho slices of A. The function checks that 
    the second input is beta labeled.


    EXAMPLES:

    ::

        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a') # Initialization of the input Hypermatrix
        sage: T=[(i,sz-1) for i in rg(sz-1)]+[(sz-1,i) for i in rg(sz-1)]+[(sz-1, sz-1)] # Initialization of the tuples associated with a rho-labeling
        sage: SecondOrderRhoSlicing(A,T).p()
        [:, :]=
        [a00 a01 a02 a03 a04 a54 a64 a74 a84]
        [a05 a11 a12 a13 a14 a15 a65 a75 a85]
        [a06 a16 a22 a23 a24 a25 a26 a76 a86]
        [a07 a17 a27 a33 a34 a35 a36 a37 a87]
        [a08 a18 a28 a38 a44 a45 a46 a47 a48]
        [a50 a10 a20 a30 a40 a55 a56 a57 a58]
        [a60 a61 a21 a31 a41 a51 a66 a67 a68]
        [a70 a71 a72 a32 a42 a52 a62 a77 a78]
        [a80 a81 a82 a83 a43 a53 a63 a73 a88]
        sage: sz=Integer(4); A=HM(2*sz-1, 2*sz-1, 'a') # Initialization of the input Hypermatrix
        sage: T=[(0,0)]+[(i,0) for i in rg(1,sz)]+[(0,i) for i in rg(1,sz)] # Initialization of the tuples
        sage: SecondOrderRhoSlicing(A,T).p()
        [:, :]=
        [a00 a15 a25 a35 a45 a05 a06 a07 a08]
        [a10 a11 a26 a36 a46 a56 a16 a17 a18]
        [a20 a21 a22 a37 a47 a57 a67 a27 a28]
        [a30 a31 a32 a33 a48 a58 a68 a78 a38]
        [a40 a41 a42 a43 a44 a50 a60 a70 a80]
        [a01 a51 a52 a53 a54 a55 a61 a71 a81]
        [a02 a12 a62 a63 a64 a65 a66 a72 a82]
        [a03 a13 a23 a73 a74 a75 a76 a77 a83]
        [a04 a14 a24 a34 a84 a85 a86 a87 a88]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,4),(1,3),(2,2),(3,2),(4,1),(4,0),(3,1),(2,3),(1,4)]
        sage: SecondOrderRhoSlicing(A,T).p()
        [:, :]=
        [a00 a02 a04 a25 a45 a64 a84 a06 a08]
        [a10 a11 a13 a15 a36 a56 a75 a05 a17]
        [a28 a21 a22 a24 a26 a47 a67 a86 a16]
        [a27 a30 a32 a33 a35 a37 a58 a78 a07]
        [a18 a38 a41 a43 a44 a46 a48 a60 a80]
        [a01 a20 a40 a52 a54 a55 a57 a50 a71]
        [a82 a12 a31 a51 a63 a65 a66 a68 a61]
        [a72 a03 a23 a42 a62 a74 a76 a77 a70]
        [a81 a83 a14 a34 a53 a73 a85 a87 a88]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,3),(1,3),(2,3),(3,3),(4,0),(3,0),(3,1),(3,2),(0,4)]
        sage: SecondOrderRhoSlicing(A,T).p()
        [:, :]=
        [a00 a01 a02 a03 a15 a54 a64 a74 a05]
        [a16 a11 a12 a13 a14 a26 a65 a75 a85]
        [a06 a27 a22 a23 a24 a25 a37 a76 a86]
        [a07 a17 a38 a33 a34 a35 a36 a48 a87]
        [a08 a18 a28 a40 a44 a45 a46 a47 a50]
        [a61 a10 a20 a30 a51 a55 a56 a57 a58]
        [a60 a72 a21 a31 a41 a62 a66 a67 a68]
        [a70 a71 a83 a32 a42 a52 a73 a77 a78]
        [a80 a81 a82 a04 a43 a53 a63 a84 a88]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the number of vertices in the template graph
    sz=Integer((A.n(0)+1)/2)
    if A.is_cubical() and Set(rg(sz))==Set([min(abs(t[1]-t[0]),2*sz-1-abs(t[1]-t[0])) for t in T]) and Tuple_to_AdjacencyII(T,2*sz-1).is_symmetric():
        # Initialization of the matrix
        Ha=HM(2*sz-1, 2*sz-1, 'zero')
        # Identifying the column index
        for i in rg(len(T)):
            if T[i][0] == T[i][1]:
                # Assigning the index
                indx=T[i][0]
        # Initialization of the list of free indices
        fL0=rg(2*sz-1); fL1=rg(2*sz-1)
        for i in rg(len(T)):
            if T[i][1] == indx:
                for k in rg(2*sz-1):
                    Ha[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=A[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]
                fL0.remove(i); fL1.remove(T[i][0])
        # Initialization of the dictionary
        DctIndx=dict([(fL0[i],fL1[i]) for i in rg(len(fL0))])
        for k in rg(2*sz-1):
            for i in rg(len(T)):
                if i in fL0:
                    Ha[Integer(mod(DctIndx[i]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=A[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(T[i][1]+k,2*sz-1))]
        return Ha 
    else:
        raise ValueError("The input matrices must be square and the second input beta labeled")

def SecondOrderRhoSlicingII(A,T):
    """
    The function takes as input a matrix A as well as a tuple description
    of an undirected loop rho-labeled graph and outputs a square matrix of the same size
    as A whose columns are the rho slices of A associated with a bipartite decomposition.
    The function checks that the second input is beta labeled.


    EXAMPLES:

    ::

        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a') # Initialization of the input Hypermatrix
        sage: T=[(0,5),(1,1),(2,1),(3,0),(5,3),(5,0),(1,2),(0,3),(3,5)] # Initialization of the tuples associated with a rho-labeling
        sage: SecondOrderRhoSlicingII(A,T).p()
        [:, :]=
        [ b09 b014 b415 b214 b414 b013 b117 b015 b017]
        [ b19 b110 b115 b516 b315 b515 b114  b29 b116]
        [b217 b210 b211 b216 b617 b416 b616 b215 b310]
        [b411  b39 b311 b312 b317  b79 b517 b717 b316]
        [b417 b512 b410 b412 b413  b49 b810  b69  b89]
        [b010  b59 b613 b511 b513 b514 b510 b011 b710]
        [b811 b111 b610 b714 b612 b614 b615 b611 b112]
        [b213 b012 b212 b711 b815 b713 b715 b716 b712]
        [b813 b314 b113 b313 b812 b016 b814 b816 b817]
        sage: sz=Integer(4); A=HM(2*sz-1, 2*sz-1, 'a') # Initialization of the input Hypermatrix
        sage: T=[(0,0)]+[(i,0) for i in rg(1,sz)]+[(0,i) for i in rg(1,sz)] # Initialization of the tuples
        sage: SecondOrderRhoSlicingII(A,T).p()
        [:, :]=
        [ b07 b111 b211 b311 b011 b012 b013]
        [ b17  b18 b212 b312 b412 b112 b113]
        [ b27  b28  b29 b313 b413 b513 b213]
        [ b37  b38  b39 b310  b47  b57  b67]
        [ b08  b48  b49 b410 b411  b58  b68]
        [ b09  b19  b59 b510 b511 b512  b69]
        [b010 b110 b210 b610 b611 b612 b613]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,4),(1,3),(2,2),(3,2),(4,1),(4,0),(3,1),(2,3),(1,4)]
        sage: SecondOrderRhoSlicingII(A,T).p()
        [:, :]=
        [ b09 b011 b013 b214 b414 b613 b813 b015 b017]
        [ b19 b110 b112 b114 b315 b515 b714 b014 b116]
        [b217 b210 b211 b213 b215 b416 b616 b815 b115]
        [b216  b39 b311 b312 b314 b316 b517 b717 b016]
        [b117 b317 b410 b412 b413 b415 b417  b69  b89]
        [b010  b29  b49 b511 b513 b514 b516  b59 b710]
        [b811 b111 b310 b510 b612 b614 b615 b617 b610]
        [b711 b012 b212 b411 b611 b713 b715 b716  b79]
        [b810 b812 b113 b313 b512 b712 b814 b816 b817]
        sage: sz=Integer(5); A=HM(2*sz-1, 2*sz-1, 'a'); T=[(0,3),(1,3),(2,3),(3,3),(4,0),(3,0),(3,1),(3,2),(0,4)]
        sage: SecondOrderRhoSlicingII(A,T).p()
        [:, :]=
        [ b09 b010 b011 b012 b114 b513 b613 b713 b014]
        [b115 b110 b111 b112 b113 b215 b614 b714 b814]
        [b015 b216 b211 b212 b213 b214 b316 b715 b815]
        [b016 b116 b317 b312 b313 b314 b315 b417 b816]
        [b017 b117 b217  b49 b413 b414 b415 b416  b59]
        [b610  b19  b29  b39 b510 b514 b515 b516 b517]
        [ b69 b711 b210 b310 b410 b611 b615 b616 b617]
        [ b79 b710 b812 b311 b411 b511 b712 b716 b717]
        [ b89 b810 b811 b013 b412 b512 b612 b813 b817]
        sage: sz=Integer(5); od=Integer(2); A=HM(sz, sz, 'a'); X=var_list('x', sz); Ha=HM(sz,sz,'zero') # Setup for obtaining beta-labled functional digraphs
        sage: for u in rg(sz):
        ....:     for v in rg(sz):
        ....:         Ha[u,v]=A[u,v]*X[abs(v-u)] # Filling up the matrix
        ....:
        sage: F=expand(diff(prod(sum(Ha[i, j] for j in rg(sz)) for i in rg(sz)),X)) # Initialization of the listing
        sage: Lt=[]
        sage: for mnm in F.operands():
        ....:     Lt.append(Monomial2Tuple(mnm, A.list(), sz)+[(t[1], t[0]) for t in Monomial2Tuple(mnm, A.list(), sz) if t[0]!=t[1]])
        ....:
        sage: Lt[:5]
        [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (0, 1), (0, 2), (0, 3), (0, 4)],
         [(0, 1), (1, 1), (2, 0), (3, 0), (4, 0), (1, 0), (0, 2), (0, 3), (0, 4)],
         [(0, 0), (1, 2), (2, 0), (3, 0), (4, 0), (2, 1), (0, 2), (0, 3), (0, 4)],
         [(0, 2), (1, 1), (2, 1), (3, 0), (4, 0), (2, 0), (1, 2), (0, 3), (0, 4)],
         [(0, 0), (1, 3), (2, 1), (3, 0), (4, 0), (3, 1), (1, 2), (0, 3), (0, 4)]]
        sage: Ma=HM(2*sz-1, 2*sz-1, 'a')
        sage: for T in Lt[:2]:
        ....:     SecondOrderRhoSlicingII(Ma,T).p(); print('\n')
        ....:
        [:, :]=
        [ b09 b114 b214 b314 b414 b014 b015 b016 b017]
        [ b19 b110 b215 b315 b415 b515 b115 b116 b117]
        [ b29 b210 b211 b316 b416 b516 b616 b216 b217]
        [ b39 b310 b311 b312 b417 b517 b617 b717 b317]
        [ b49 b410 b411 b412 b413  b59  b69  b79  b89]
        [b010 b510 b511 b512 b513 b514 b610 b710 b810]
        [b011 b111 b611 b612 b613 b614 b615 b711 b811]
        [b012 b112 b212 b712 b713 b714 b715 b716 b812]
        [b013 b113 b213 b313 b813 b814 b815 b816 b817]

        [:, :]=
        [ b09 b010 b114 b214 b314 b513 b014 b015 b016]
        [b117 b110 b111 b215 b315 b415 b614 b115 b116]
        [b217  b29 b211 b212 b316 b416 b516 b715 b216]
        [b317  b39 b310 b312 b313 b417 b517 b617 b816]
        [b017  b49 b410 b411 b413 b414  b59  b69  b79]
        [b810  b19 b510 b511 b512 b514 b515 b610 b710]
        [b811 b011 b210 b611 b612 b613 b615 b616 b711]
        [b812 b012 b112 b311 b712 b713 b714 b716 b717]
        [ b89 b013 b113 b213 b412 b813 b814 b815 b817]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the number of vertices in the template graph
    sz=Integer((A.n(0)+1)/2)
    # Initialization of the symbolic matrix
    if A.is_cubical() and Set(rg(sz))==Set([min(abs(t[1]-t[0]),2*sz-1-abs(t[1]-t[0])) for t in T]) and Tuple_to_AdjacencyII(T,2*sz-1).is_symmetric():
        #return HM([[Hb[Integer(mod(t[0]+k,2*sz-1)),(2*sz-1)+Integer(mod(t[1]+k,2*sz-1))] for t in T] for k in rg(2*sz-1)]).t()
        # Initialization of the matrix
        Hb=HM((2*sz-1), (2*sz-1),'b'); B=HM(2*(2*sz-1), 2*(2*sz-1),'b')
        # Identifying the column index
        for i in rg(len(T)):
            if T[i][0] == T[i][1]:
                # Assigning the index
                indx=T[i][0]
        # Initialization of the list of free indices
        fL0=rg(2*sz-1); fL1=rg(2*sz-1)
        for i in rg(len(T)):
            if T[i][1] == indx:
                for k in rg(2*sz-1):
                    Hb[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=B[Integer(mod(T[i][0]+k,2*sz-1)),(2*sz-1)+Integer(mod(indx+k,2*sz-1))]
                fL0.remove(i); fL1.remove(T[i][0])
        # Initialization of the dictionary
        DctIndx=dict([(fL0[i],fL1[i]) for i in rg(len(fL0))])
        for k in rg(2*sz-1):
            for i in rg(len(T)):
                if i in fL0:
                    Hb[Integer(mod(DctIndx[i]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=B[Integer(mod(T[i][0]+k,2*sz-1)),(2*sz-1)+Integer(mod(T[i][1]+k,2*sz-1))]
        return Hb
    else:
        raise ValueError("The input matrices must be square and the second input beta labeled")

def SecondOrderPseudoRhoSlicing(A,Tp):
    """
    The function takes as in put a square matrix A with an even number of vertices as well as
    a tuple description of an undirected loop pseudo rho-labeled graph and outputs a square 
    matrix of the same size as A whose columns are the rho slices of A. The function checks 
    that the second input is beta labeled. The extra two directed edges which make up the
    additional undirected edges should be appended at the end of the tuple


    EXAMPLES:

    ::

        sage: sz=Integer(5); A=HM(2*sz,2*sz,'a') # Initialization of the input Hypermatrix
        sage: T=[(0,0)]+[(i,0) for i in rg(1,sz)]+[(0,i) for i in rg(1,sz)]+[(2*sz-1,1), (1,2*sz-1)] # Initialization of the tuples associated with a rho-labeling
        sage: SecondOrderPseudoRhoSlicing(A,T).p()
        [:, :]=
        [a00 a15 a25 a35 a45 a05 a06 a07 a08 a19]
        [a10 a11 a26 a36 a46 a56 a16 a17 a18 a29]
        [a20 a21 a22 a37 a47 a57 a67 a27 a28 a39]
        [a30 a31 a32 a33 a48 a58 a68 a78 a38 a49]
        [a40 a41 a42 a43 a44 a50 a60 a70 a80 a59]
        [a01 a51 a52 a53 a54 a55 a61 a71 a81 a69]
        [a02 a12 a62 a63 a64 a65 a66 a72 a82 a79]
        [a03 a13 a23 a73 a74 a75 a76 a77 a83 a89]
        [a04 a14 a24 a34 a84 a85 a86 a87 a88 a09]
        [a91 a92 a93 a94 a95 a96 a97 a98 a90 a99]
        sage: sz=Integer(5); A=HM(2*sz,2*sz,'a'); T=[(0,4),(1,3),(2,2),(3,2),(4,1),(4,0),(3,1),(2,3),(1,4)]+[(2*sz-1,0),(0,2*sz-1)]
        sage: SecondOrderPseudoRhoSlicing(A,T).p()
        [:, :]=
        [a00 a02 a04 a25 a45 a64 a84 a06 a08 a79]
        [a10 a11 a13 a15 a36 a56 a75 a05 a17 a89]
        [a28 a21 a22 a24 a26 a47 a67 a86 a16 a09]
        [a27 a30 a32 a33 a35 a37 a58 a78 a07 a19]
        [a18 a38 a41 a43 a44 a46 a48 a60 a80 a29]
        [a01 a20 a40 a52 a54 a55 a57 a50 a71 a39]
        [a82 a12 a31 a51 a63 a65 a66 a68 a61 a49]
        [a72 a03 a23 a42 a62 a74 a76 a77 a70 a59]
        [a81 a83 a14 a34 a53 a73 a85 a87 a88 a69]
        [a97 a98 a90 a91 a92 a93 a94 a95 a96 a99]
        sage: sz=Integer(5); A=HM(2*sz, 2*sz, 'a'); T=[(0,3),(1,3),(2,3),(3,3),(4,0),(3,0),(3,1),(3,2),(0,4)]+[(2*sz-1,0),(0,2*sz-1)]
        sage: SecondOrderPseudoRhoSlicing(A,T).p()
        [:, :]=
        [a00 a01 a02 a03 a15 a54 a64 a74 a05 a69]
        [a16 a11 a12 a13 a14 a26 a65 a75 a85 a79]
        [a06 a27 a22 a23 a24 a25 a37 a76 a86 a89]
        [a07 a17 a38 a33 a34 a35 a36 a48 a87 a09]
        [a08 a18 a28 a40 a44 a45 a46 a47 a50 a19]
        [a61 a10 a20 a30 a51 a55 a56 a57 a58 a29]
        [a60 a72 a21 a31 a41 a62 a66 a67 a68 a39]
        [a70 a71 a83 a32 a42 a52 a73 a77 a78 a49]
        [a80 a81 a82 a04 a43 a53 a63 a84 a88 a59]
        [a96 a97 a98 a90 a91 a92 a93 a94 a95 a99]


    AUTHORS:
    - Edinah K. Gnang
    """
    T=Tp[:Integer(len(Tp)-2)]
    # Initialization of the number of vertices in the template graph
    sz=Integer((len(T)+1)/2)
    # Initialization 
    if A.is_cubical() and Set(rg(sz))==Set([min(abs(t[1]-t[0]),2*sz-1-abs(t[1]-t[0])) for t in T]) and Tuple_to_AdjacencyII(T,2*sz-1).is_symmetric():
        # Initialization of the matrix
        Ha=HM(2*sz-1, 2*sz-1, 'zero')
        # Identifying the column index
        for i in rg(len(T)):
            if T[i][0] == T[i][1]:
                # Assigning the index
                indx=T[i][0]
        # Initialization of the list of free indices
        fL0=rg(2*sz-1); fL1=rg(2*sz-1)
        for i in rg(len(T)):
            if T[i][1] == indx:
                for k in rg(2*sz-1):
                    Ha[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=A[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]
                fL0.remove(i); fL1.remove(T[i][0])
        # Initialization of the dictionary
        DctIndx=dict([(fL0[i],fL1[i]) for i in rg(len(fL0))])
        for k in rg(2*sz-1):
            for i in rg(len(T)):
                if i in fL0:
                    Ha[Integer(mod(DctIndx[i]+k,2*sz-1)),Integer(mod(indx+k,2*sz-1))]=A[Integer(mod(T[i][0]+k,2*sz-1)),Integer(mod(T[i][1]+k,2*sz-1))]
        Ah=HM(2*sz, 2*sz, 'zero'); Ah=Ah.fill_with(Ha,[0,0]); Ah[2*sz-1,2*sz-1]=A[2*sz-1,2*sz-1]
        for i in rg(2*sz-1):
            Ah[Integer(mod(indx+i,2*sz-1)),2*sz-1]=A[Integer(mod(Tp[len(Tp)-2][1]+i,2*sz-1)),Tp[len(Tp)-2][0]]
            Ah[2*sz-1,Integer(mod(indx+i,2*sz-1))]=A[Tp[len(Tp)-2][0],Integer(mod(Tp[len(Tp)-2][1]+i,2*sz-1))]
        return Ah 
    else:
        raise ValueError("The input matrices must be square and the second input beta labeled")

def BetaLabelCaterpillarTuple(T):
    """
    Outputs the graceful labeling of the input Caterpillar tree T.
    The implementation assumes that the input caterpillar tree arise
    in the format that Random Caterpillar function output in the sense
    the maximum in pre-image is where the next star in the caterpillar
    is attached to. This is simplifying assumption for the inplementation
    of the spring bloom algorithm. 


    EXAMPLES:

    ::

        sage: sz=Integer(15); T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 6), (8, 7), (9, 7), (10, 7), (11, 7), (12, 7), (13, 7), (14, 7)]
        sage: BetaLabelCaterpillarTuple(T)
        [(0, 14), (1, 14), (2, 14), (3, 14), (4, 14), (5, 14), (6, 14), (7, 13), (8, 13), (9, 13), (10, 13), (11, 13), (12, 13), (13, 13), (14, 7)]
       

    AUTHORS:
    - Edinah K. Gnang
    """
    sz=Integer(len(T))
    # Changing the list of tuples into a list of list for mutability
    Tp=[[T[i][0],T[i][1]] for i in rg(sz)]
    # Identifying non zero vertices which will be labeled
    # zero throughout the run of the spring bloom procedure.
    # This implementation makes use of the special structure
    # of the caterpillar trees generated by the RandomCaterpillarTuple
    Lv=[0]; u=Integer(0)
    while u < sz-1:
        # Appending the next vertex to the list
        Lv.append(max(tpl_pre_image_set(T,u)))
        # Updating the vertex to the next one
        u=max(tpl_pre_image_set(T,u))
    #print('Lv = ', Lv)
    # The main part of the Spring Bloom procedure.
    for i in rg(len(Lv)):
        # Specifying what to do at the very first center
        if i==Integer(0):
            indx=Lv[i+1]+Integer(1)
            Tp=TupleComplementaryLabelII(Tp[:indx])+Tp[indx:]
            for j in rg(indx,len(Tp)):
                # Accounting for the label change for the next center in the rest of the caterpillar
                if Tp[j][1]==Lv[i+1]:
                    Tp[j][1]=Integer(0)
        elif (i>0 and Lv[i]<Integer(sz-1)):
            indx=Lv[i+1]+Integer(1)
            Tp=TupleComplementaryLabelII(Tp[:indx])+Tp[indx:]
            for j in rg(indx,len(Tp)):
                # Accounting for the label change for the next center in the rest of the caterpillar
                if Tp[j][1]==Lv[i+1]:
                    Tp[j][1]=Integer(0) 
        elif (i>0 and Lv[i]==Integer(sz-1)):
            Tp=TupleComplementaryLabelII(Tp)
    return [(Tp[i][0], Tp[i][1]) for i in rg(len(Tp))]

def BetaLabelCaterpillarTupleII(T):
    """
    Outputs the graceful labeling of the input Caterpillar tree T.
    The implementation assumes that the input caterpillar tree arise
    in the format that Random Caterpillar function output in the sense
    the maximum in pre-image is where the next star in the caterpillar
    is attached to. This is simplifying assumption for the inplementation
    of the spring bloom algorithm. The difference with the implementation
    above is that we add the back edges for non-loop edges. To be used i
    SecondOrderBetaslicing function 


    EXAMPLES:

    ::

        sage: sz=Integer(15); T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 6), (8, 7), (9, 7), (10, 7), (11, 7), (12, 7), (13, 7), (14, 7)]
        sage: BetaLabelCaterpillarTupleII(T)
        [(0, 7), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 0), (9, 0), (10, 0), (11, 0), (12, 0), (13, 0), (14, 0), (7, 0), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (0, 8), (0, 9), (0, 10), (0, 11), (0, 12), (0, 13), (0, 14)]
       

    AUTHORS:
    - Edinah K. Gnang
    """
    sz=Integer(len(T))
    # Changing the list of tuples into a list of list for mutability
    Tp=[[T[i][0],T[i][1]] for i in rg(sz)]
    # Identifying non zero vertices which will be labeled
    # zero throughout the run of the spring bloom procedure.
    # This implementation makes use of the special structure
    # of the caterpillar trees generated by the RandomCaterpillarTuple
    Lv=[0]; u=Integer(0)
    while u < sz-1:
        # Appending the next vertex to the list
        Lv.append(max(tpl_pre_image_set(T,u)))
        # Updating the vertex to the next one
        u=max(tpl_pre_image_set(T,u))
    #print('Lv = ', Lv)
    # The main part of the Spring Bloom procedure.
    for i in rg(len(Lv)):
        # Specifying what to do at the very first center
        if i==Integer(0):
            indx=Lv[i+1]+Integer(1)
            Tp=TupleComplementaryLabelII(Tp[:indx])+Tp[indx:]
            for j in rg(indx,len(Tp)):
                # Accounting for the label change for the next center in the rest of the caterpillar
                if Tp[j][1]==Lv[i+1]:
                    Tp[j][1]=Integer(0)
        elif (i>0 and Lv[i]<Integer(sz-1)):
            indx=Lv[i+1]+Integer(1)
            Tp=TupleComplementaryLabelII(Tp[:indx])+Tp[indx:]
            for j in rg(indx,len(Tp)):
                # Accounting for the label change for the next center in the rest of the caterpillar
                if Tp[j][1]==Lv[i+1]:
                    Tp[j][1]=Integer(0) 
        elif (i>0 and Lv[i]==Integer(sz-1)):
            Tp=TupleComplementaryLabelII(Tp)
    Tt=[(Tp[i][0], Tp[i][1]) for i in rg(len(Tp))]
    return Tt+[(Tt[i][1], Tt[i][0]) for i in rg(len(Tt)) if Tt[i][1]!=Tt[i][0]]

def CaterpillarLabelHistogram(T):
    """
    Starts with graceful labeling of the input Caterpillar tree, T
    generated by the spring bloom algorithm in BetaLabelCaterpillarTuple function. 
    For each c in Z_n, shift every vertex label by c. Create histogram of 
    resulting edge label frequencies.
    Outputs list of all shifted labelings of graceful input graph
    and list of histograms in monomial form (product of variables x_i, where power
    of x_i denotes frequency of edge label i). 


    EXAMPLES: 

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]
        sage: CaterpillarLabelHistogram(T)[0]
        [[(0, 3), (1, 3), (2, 3), (3, 3), (4, 0), (5, 0)],
         [(1, 4), (2, 4), (3, 4), (4, 4), (5, 1), (0, 1)],
         [(2, 5), (3, 5), (4, 5), (5, 5), (0, 2), (1, 2)],
         [(3, 0), (4, 0), (5, 0), (0, 0), (1, 3), (2, 3)],
         [(4, 1), (5, 1), (0, 1), (1, 1), (2, 4), (3, 4)],
         [(5, 2), (0, 2), (1, 2), (2, 2), (3, 5), (4, 5)]]
        sage: CaterpillarLabelHistogram(T)[1]
        [x0*x1*x2*x3*x4*x5,
         x0*x1^2*x2*x3*x4,
         x0*x1^2*x2^2*x3,
         x0*x1*x2*x3*x4*x5,
         x0*x1^2*x2*x3*x4,
         x0*x1^2*x2^2*x3]
        sage: U = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 4), (6, 4), (7, 6), (8, 7)]
        sage: CaterpillarLabelHistogram(U)[0]
        [[(0, 7), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 1), (7, 1), (8, 0)],
         [(1, 8), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 2), (8, 2), (0, 1)],
         [(2, 0), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7), (8, 3), (0, 3), (1, 2)],
         [(3, 1), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (0, 4), (1, 4), (2, 3)],
         [(4, 2), (5, 0), (6, 0), (7, 0), (8, 0), (0, 0), (1, 5), (2, 5), (3, 4)],
         [(5, 3), (6, 1), (7, 1), (8, 1), (0, 1), (1, 1), (2, 6), (3, 6), (4, 5)],
         [(6, 4), (7, 2), (8, 2), (0, 2), (1, 2), (2, 2), (3, 7), (4, 7), (5, 6)],
         [(7, 5), (8, 3), (0, 3), (1, 3), (2, 3), (3, 3), (4, 8), (5, 8), (6, 7)],
         [(8, 6), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4), (5, 0), (6, 0), (7, 8)]]
        sage: CaterpillarLabelHistogram(U)[1]
        [x0*x1*x2*x3*x4*x5*x6*x7*x8,
         x0*x1^2*x2*x3*x4*x5*x6*x7,
         x0*x1^2*x2^2*x3^2*x4*x5,
         x0*x1^2*x2^2*x3^2*x4^2,
         x0*x1*x2*x3*x4*x5*x6*x7*x8,
         x0*x1^2*x2*x3*x4*x5*x6*x7,
         x0*x1^2*x2^2*x3*x4*x5*x6,
         x0*x1^2*x2^2*x3^2*x4*x5,
         x0*x1^2*x2^2*x3*x4*x5*x6]


    AUTHORS:
    - Kailee Lin
    """
    sz=Integer(len(T))
    # get graceful labeling (from spring bloom algorithm) of caterpillar
    BLT = BetaLabelCaterpillarTuple(T)
    # initialize list of histograms
    Lhist = []
    # initialize list of variables (one for each label)
    X = var_list('x',sz)
    # initialize list of shifted labelings
    LabelList = []
    # iterate over shifting labels by each integer in Z_n (where n=sz)
    for c in rg(sz):
        # create list of tuples for shifted labeling of graph
        BLTc = []
        for i in rg(sz):
            BLTc.append((Integer(mod(BLT[i][0]+c, sz)), Integer(mod(BLT[i][1]+c, sz))))
        # add labelings to LabelList
        LabelList.append(BLTc)
        # create monomial (histogram) for shifted labeling of graph
        Ledge = [abs(BLTc[i][0]-BLTc[i][1]) for i in rg(sz)]
        cHist = prod((X[i]) for i in Ledge)
        # add to Lhist
        Lhist.append(cHist)
    return [LabelList, Lhist]

def SecondOrderBetaInterlacers(A,T):
    """
    The function takes as in put a matrix A as well as a tuple description
    of an undirected loop beta-labeled graph and outputs a square matrix of the same size
    as A whose columns are the Beta slices of A. The function checks that the second input
    is beta labeled.


    EXAMPLES:

    ::

        sage: sz=Integer(4); A=HM(sz, sz, 'a') # Initialization of the input Hypermatrix
        sage: T=[(0,0)]+[(i,0) for i in rg(1,sz)]+[(0,i) for i in rg(1,sz)] # Initialization of the tuples
        sage: SecondOrderBetaInterlacers(A,T)
        [[[-a00, 0, 0, 0], [0, a11, a12, a13], [0, a21, a22, a23], [0, a31, a32, a33]],
         [[a00, 0, a02, a03], [0, -a11, 0, 0], [a20, 0, a22, a23], [a30, 0, a32, a33]],
         [[a00, a01, 0, a03], [a10, a11, 0, a13], [0, 0, -a22, 0], [a30, a31, 0, a33]],
         [[a00, a01, a02, 0], [a10, a11, a12, 0], [a20, a21, a22, 0], [0, 0, 0, -a33]]]
        sage: sz=Integer(5); A=HM(sz, sz, 'a'); T=[(0,4),(1,3),(2,2),(3,2),(4,1),(4,0),(3,1),(2,3),(1,4)]; SecondOrderBetaInterlacers(A,T)
        [[[a00, a01, a02, a03, 0], [a10, a11, a12, 0, 0], [a20, a21, -a22, 0, a24], [a30, 0, 0, a33, a34], [0, 0, a42, a43, a44]],
         [[a00, 0, 0, a03, a04], [0, a11, a12, a13, a14], [0, a21, a22, a23, 0], [a30, a31, a32, -a33, 0], [a40, a41, 0, 0, a44]],
         [[a00, a01, a02, 0, 0], [a10, a11, 0, 0, a14], [a20, 0, a22, a23, a24], [0, 0, a32, a33, a34], [0, a41, a42, a43, -a44]],
         [[-a00, 0, a02, a03, a04], [0, a11, a12, a13, 0], [a20, a21, a22, 0, 0], [a30, a31, 0, a33, a34], [a40, 0, 0, a43, a44]],
         [[a00, a01, 0, 0, a04], [a10, -a11, 0, a13, a14], [0, 0, a22, a23, a24], [0, a31, a32, a33, 0], [a40, a41, a42, 0, a44]]]
        sage: sz=Integer(5); A=HM(sz, sz, 'a'); T=[(0,3),(1,3),(2,3),(3,3),(4,0),(3,0),(3,1),(3,2),(0,4)]; SecondOrderBetaInterlacers(A,T)
        [[[a00, a01, a02, 0, 0], [a10, a11, a12, 0, a14], [a20, a21, a22, 0, a24], [0, 0, 0, -a33, a34], [0, a41, a42, a43, a44]],
         [[a00, 0, a02, a03, a04], [0, a11, a12, a13, 0], [a20, a21, a22, a23, 0], [a30, a31, a32, a33, 0], [a40, 0, 0, 0, -a44]],
         [[-a00, a01, 0, 0, 0], [a10, a11, 0, a13, a14], [0, 0, a22, a23, a24], [0, a31, a32, a33, a34], [0, a41, a42, a43, a44]],
         [[a00, 0, a02, a03, a04], [0, -a11, a12, 0, 0], [a20, a21, a22, 0, a24], [a30, 0, 0, a33, a34], [a40, 0, a42, a43, a44]],
         [[a00, a01, 0, a03, a04], [a10, a11, 0, a13, a14], [0, 0, -a22, a23, 0], [a30, a31, a32, a33, 0], [a40, a41, 0, 0, a44]]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Checking that the Tuple describes a gracefully labeled graph
    if Set(rg(sz)) == Set([abs(t[1]-t[0]) for t in T]) and Tuple_to_AdjacencyII(T,sz).is_symmetric():
        # Initialization of the list which stores the output
        La=[]
        for i in rg(sz):
            # Initialization of a copy of the input hypermatrix
            Ha=A.copy()
            # Looping through the entries specified by the tuple list
            for t in T:
                # Nagating the the loop edge entry
                if t[0]==t[1]:
                    Ha[Integer(mod(t[0]+i,sz)),Integer(mod(t[1]+i,sz))]=-Ha[Integer(mod(t[0]+i,sz)),Integer(mod(t[1]+i,sz))]
                else:
                    # Zeroing out the non noop edges
                    Ha[Integer(mod(t[0]+i,sz)),Integer(mod(t[1]+i,sz))]=0
            La.append(Ha)
        return La
    else:
        raise ValueError("The input tuple the second input beta labeled")

def geometric_mean(L):
    """
    The function computes the geometric mean
    of the input list L.


    EXAMPLES:

    ::

        sage: sz0=2; sz1=3; Ha=HM(sz0, sz1, 'a')
        sage: geometric_mean(Ha.list())
        (a00*a01*a02*a10*a11*a12)^(1/6)


    AUTHORS:
    - Edinah K. Gnang, Jeanine S. Gnang
    """
    # Initialization of the construct variable
    z=var('z')
    # Initialization of the size determined by the length of the list
    sz=len(L)
    # Return the geometric mean viewed as an inner-product of sorts
    return GProd([HM(1,sz,L), HM(sz,1,'one')], prod, [z])[0,0]^(1/sz)

def geometric_meanII(L):
    """
    The function computes the geometric mean
    of the input list L. To be used for numerical
    computation


    EXAMPLES:

    ::

        sage: X=[0.03658233053840871, 0.022693452948493835, 0.09667167574741581, 0.1354454280082533, 0.02906998361722122, 0.09068172967913375, 0.18808247869583106, 0.06596997458401005, 0.043486280252139436, 0.6087259605232003, 0.14746917844106938, 0.0024856908759630526, 0.11116106918595019, 0.02867537872396155, 0.15283808208604527]
        sage: geometric_meanII(X)
        0.0653181757705423


    AUTHORS:
    - Edinah K. Gnang, Jeanine S. Gnang
    """
    return prod(L)^(1.0/len(L))

def arithmetic_mean(L):
    """
    The function computes the arithmetic mean
    of the input list L.


    EXAMPLES:

    ::

        sage: sz0=2; sz1=3; Ha=HM(sz0, sz1, 'a')
        sage: arithmetic_mean(Ha.list())
        1/6*a00 + 1/6*a01 + 1/6*a02 + 1/6*a10 + 1/6*a11 + 1/6*a12


    AUTHORS:
    - Edinah K. Gnang, Jeanine S. Gnang
    """
    # Initialization of the construct variable
    z=var('z')
    # Initialization of the size determined by the length of the list
    sz=len(L)
    # Return the arithmetic mean viewed as an inner-product of sorts
    return GProd([HM(1,sz,L), HM(sz,1,'one')], sum, [z])[0,0]*(1/sz)

def arithmetic_meanII(L):
    """
    The function computes the arithmetic mean
    of the input list L. To be used for numerical
    computation


    EXAMPLES:

    ::

        sage: X=[0.03658233053840871, 0.022693452948493835, 0.09667167574741581, 0.1354454280082533, 0.02906998361722122, 0.09068172967913375, 0.18808247869583106, 0.06596997458401005, 0.043486280252139436, 0.6087259605232003, 0.14746917844106938, 0.0024856908759630526, 0.11116106918595019, 0.02867537872396155, 0.15283808208604527]
        sage: arithmetic_mean(X)
        0.117335912927140


    AUTHORS:
    - Edinah K. Gnang, Jeanine S. Gnang
    """
    return sum(L)*(1.0/len(L))

def GeneratePartition(sz):
    """
    Creates Partition to be used for computing the permanent.
    This function follows a maple implementation suggested
    Harry Crane


    EXAMPLES:
    ::


        sage: GeneratePartition(3)
        [[1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 2, 2], [1, 2, 3]]
        


    AUTHORS:
    - Edinah K. Gnang, Harry Crane
    """
    N = [[1]]
    if sz > 1:
        for i in rg(1,sz):
            M = N
            r = len(M)
            N = []
            for j in rg(r):
                mx = max(M[j])
                for k in rg(1,mx+2):
                    N = N + [M[j]+[k]]
    return N

def Partition2HM(part):
    """
    Converts a partition into matrices. This function follows a maple implementation suggested
    Harry Crane


    EXAMPLES:
    ::


        sage: Partition2HM([1, 2, 1]).printHM()
        [:, :]=
        [1 0 1]
        [0 1 0]
        [1 0 1]


    AUTHORS:
    - Edinah K. Gnang, Harry Crane
    """
    M = max(part); N = len(part)
    B = HM(N,N,'zero')
    for i in rg(1,M+1):
        d = HM(N,1,'zero')
        for j in rg(N):
            if part[j] == i:
                d[j,0] = 1
        B = B + d*d.transpose()
    return B

def SetIntersection(L):
    """
    Outputs the intersection of the input list of Sets.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: SetIntersection([Set([1,2,3]),Set([1,2])])
        {1, 2}

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    St=L[0]
    for i in rg(1,len(L)):
        St=St.intersection(L[i])
    return St

def SetUnion(L):
    """
    Outputs the union of the input list of Sets.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: SetUnion([Set([1,2,3]),Set([1,2])])
        {1, 2, 3}

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    St=L[0]
    for i in rg(1,len(L)):
        St=St.union(L[i])
    return St

def DirectSum(L):
    """
    Outputs the direct sum of the input list of Hypermatrices.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: DirectSum([HM(2,2,'a'), HM(2,2,'b')]).printHM()
        [:, :]=
        [a00 a01   0   0]
        [a10 a11   0   0]
        [  0   0 b00 b01]
        [  0   0 b10 b11]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    TmpH=L[0]
    for i in rg(1,len(L)):
        TmpH=TmpH.block_sum(L[i])
    return TmpH

def TensorProduct(L):
    """
    Outputs the tensor product of the input list of Hypermatrices.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: TensorProduct([HM(2,2,'a'), HM(2,2,'b')]).printHM()
        [:, :]=
        [a00*b00 a00*b01 a01*b00 a01*b01]
        [a00*b10 a00*b11 a01*b10 a01*b11]
        [a10*b00 a10*b01 a11*b00 a11*b01]
        [a10*b10 a10*b11 a11*b10 a11*b11]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    TmpH=L[0]
    for i in rg(1,len(L)):
        TmpH=TmpH.tensor_product(L[i])
    return TmpH

def Exp(L):
    """
    Outputs the exponentiation of the input list of two elements.
    The function checks that the list has only two elements
    When used with GProdIII it can only handle second order constructs


    EXAMPLES:
 
    ::


        sage: Exp(var_list('a',2))
        a0^a1


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(L) == 2:
        return L[0]^L[1]
    else:
        raise ValueError("Expected list of two elements")

def BaseExp(L):
    """
    Outputs the base exponentiation of the input list
    This implementation check the validity of the inputs
    When used with GProdIII it can only handle second order constructs


    EXAMPLES:
 
    ::


        sage: Exp(var_list('a',2))
        a0^a1


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(L) == 2:
        return L[1]^L[0]
    else:
        raise ValueError("Expected list of two elements")

def ExpN(L, dgts=50):
    """
    Outputs the exponentiation of the input list of two elements
    The function checks that the list has only two elements


    EXAMPLES:
 
    ::


        sage: ExpN([2.000000, 3.000000])
        8.0000000000000


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(L) == 2:
        return ComplexField(dgts)(exp(L[1]*ln(L[0])))
    else:
        raise ValueError("Expected list of two elements")

def BaseExpN(L,dgts=50):
    """
    Outputs the base exponentiation of the input list
    This implementation check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: BaseExpN([2.000000, 3.000000])
        9.0000000000000


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    if len(L) == 2:
        return ComplexField(dgts)(exp(L[0]*ln(L[1])))
    else:
        raise ValueError("Expected list of two elements")

def And(L):
    """
    Outputs the conjunction of the input list of boolean values.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: And([True, False])
        False

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    St=L[0]
    for i in rg(1,len(L)):
        St = St and L[i]
    return St

def Or(L):
    """
    Outputs the disjunction of the input list of boolean values.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: Or([False, True])
        True

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    St=L[0]
    for i in rg(1,len(L)):
        St = St or L[i]
    return St

def MinSum(L):
    """
    Outputs the minimum between the sum of entries of the input
    list L and the unit integer 1.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: MinSum([2,3])
        1
        sage: MinSum([2, -3, 1])
        0

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return min(1, sum(L))

def identity(L):
    """
    Outputs the input L without any changes.
    This implementation does not check the validity of the inputs


    EXAMPLES:
 
    ::


        sage: identity([2,3])
        [2, 3]
        sage: identity((2, -3, 1))
        (2, -3, 1)

    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    return list(L)

def is_Tree(A):
    """
    Returns an boolean value determining if the input unweighted
    adjacency matrix is associated with a tree. The implementation
    is based on a implementation of the matrix tree theorem.


    EXAMPLES:
    ::
        sage: is_Tree(Matrix([[0, 1, 0], [1, 0, 1], [0, 1, 0]]))
        True

    AUTHORS:
    - Edinah K. Gnang
    """
    if 1==((diagonal_matrix((A*ones_matrix(A.nrows(),1)).list())-A)[0:A.nrows()-1,0:A.ncols()-1]).det():
        return True
    else:
        return False

def Tuple2DiGraph(T,sz):
    """
    The method returns a directed graph object associated with 
    with the tuple list description of the directed graph

    EXAMPLES:

    ::

        sage: Tuple2DiGraph([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)],5).degree_sequence()
        [4, 2, 2, 1, 1]
        sage: A=HM(3,3,'a'); f=A[0,0]*A[0,1]*A[0,2]*A[1,0]*A[1,2]*A[2,0]*A[2,1]*A[2,2]
        sage: Tuple2DiGraph(Monomial2Tuple(f, A.list(), 3),3).degree_sequence()
        [6, 6, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the identity matrix
    Id=HM(2,sz,'kronecker')
    return DiGraph(sum([Id.slice([t[0]],'col')*Id.slice([t[1]],'row') for t in T]).matrix())

def Monomial2DiGraph(mnm, L, sz):
    """
    The method returns a directed graph object associated with 
    with the monomial edge list description of the directed graph.
    The input mnm is the monomial. The input L list the variables
    The input sz corresponds to the number of vertices.

    EXAMPLES:

    ::

        sage: sz=3; A=HM(sz,sz,'a'); f=A[0,0]*A[0,1]*A[0,2]*A[1,0]*A[1,2]*A[2,0]*A[2,1]*A[2,2]
        sage: Monomial2DiGraph(f, A.list(), sz).degree_sequence()
        [6, 6, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the identity matrix
    return Tuple2DiGraph(Monomial2Tuple(mnm, L, sz), sz)

def TupleFunctionList(sz):
    """
    Returns a list of edge tuple desctiption for all 
    functional directed graphs on sz vertices.
    In other words the function lists members of (Z_sz)^Z_sz


    EXAMPLES:
    ::
        sage: TupleFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 0), (2, 0)],
         [(0, 2), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 2), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 0), (2, 1)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 2), (2, 1)],
         [(0, 2), (1, 2), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in rg(sz)]; Lf=[]
    # Main loop performing the collecting the functions.
    for i in rg(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in rg(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Appending the function to the list
        Lf.append([(i,f[i]) for i in rg(sz)])
    return Lf

def Zn2Zn(sz):
    """
    Returns a list of edge tuple desctiption for all 
    functional directed graphs on sz vertices.
    In other words the function lists members of (Z_sz)^Z_sz.
    This implementation is identical to the function above it
    is just has a shorter name


    EXAMPLES:
    ::
        sage: Zn2Zn(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 0), (2, 0)],
         [(0, 2), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 2), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 0), (2, 1)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 2), (2, 1)],
         [(0, 2), (1, 2), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in rg(sz)]; Lf=[]
    # Main loop performing the collecting the functions.
    for i in rg(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in rg(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Appending the function to the list
        Lf.append([(i,f[i]) for i in rg(sz)])
    return Lf

def TupleFunctionListII(sz0, sz1):
    """
    Returns a list of edge tuple desctiption for all 
    functions in (Z_sz1)^Z_sz0.


    EXAMPLES:
    ::
        sage: TupleFunctionListII(3,3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 0), (2, 0)],
         [(0, 2), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 2), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 0), (2, 1)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 2), (2, 1)],
         [(0, 2), (1, 2), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    if sz0 > 0 and sz1 > 0:
        return [[(i,l[i]) for i in rg(sz0)] for l in List_of_Integers([sz1 for i in rg(sz0)])]
    else:
        raise ValueError("Expected input sizes to be an integer >=1")

def TupleFunctionListIII(L0, L1):
    """
    Returns a list of edge tuple desctiption for all 
    functions in (L1)^L0.


    EXAMPLES:
    ::
        sage: TupleFunctionListIII([0, 1, 2],[0, 1, 2])
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 0), (2, 0)],
         [(0, 2), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 2), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 0), (2, 1)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 2), (2, 1)],
         [(0, 2), (1, 2), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    sz0=len(L0); sz1=len(L1)
    if len(L1) == 1:
        return [[(i,L1[0]) for i in L0]]
    elif max(L0+L1) > 0:
        return [[(L0[i],L1[l[i]]) for i in rg(sz0)] for l in List_of_Integers([sz1 for i in rg(sz0)])]
    else:
        raise ValueError("Expected input sizes to be an integer >=1")

def injectiveTupleFunctionList(L0, L1):
    """
    Returns a list of edge tuple desctiption for all 
    functional directed graphs on a domain list L0 and the
    codomain list L1 of graphs which are injective.


    EXAMPLES:
    ::
        sage: injectiveTupleFunctionList([0,1],[0,1])
        [[(0, 0), (1, 1)],
         [(0, 1), (1, 0)]]
 

    AUTHORS:

    - Edinah K. Gnang
    """
    # Checking whether or not injective fucntions are at all possible
    if len(L0)>len(L1):
        return []
    else:
        # Initialization sets
        S1=Set(L1)
        # Initialization of the list of permutations
        SnL=PermutationFunctionList(len(L0))
        # Initialization of the result
        rsLt=[]
        # Updating the list of functions
        for st in S1.subsets(len(L0)):
            l1=st.list()
            rsLt=rsLt+[[(L0[i], l1[T[i][1]]) for i in rg(len(L0))] for T in SnL]
        return rsLt

def RepresentativeTupleFunctionList(sz):
    """
    Returns a list of edge tuple desctiption for all 
    functional directed graphs. Outputing one per
    isomorphism class the graph isomorphism routine
    is doing the heavy lifting here.


    EXAMPLES:
    ::
        sage: RepresentativeTupleFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 2), (1, 1), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 0), (1, 1), (2, 2)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    L=TupleFunctionList(sz)
    # Initialization of the list storing the equivalence class of trees.
    cL=[ L[0] ]
    # Loop perfomring the isomorphism binning.
    for tp in L:
        nwT=True
        for i in range(len(cL)):
            if Tuple2DiGraph(tp,sz).is_isomorphic(Tuple2DiGraph(cL[i],sz)):
                nwT=False
                break
        if nwT==True:
            cL.append(tp)
    return cL

def PermutationFunctionList(sz):
    """
    Returns a list of edge tuple descriptions associated 
    with permutations.


    EXAMPLES:
    ::
        sage: PermutationFunctionList(3)
        [[(0, 0), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 2), (1, 1), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of permutations of elements from 1 to (n-1).
    P=Permutations(sz)
    return [[(i,Integer(p[i]-1)) for i in rg(sz)] for p in P]

def AlternatingGroupFunctionList(sz):
    """
    Returns a list of edge tuple descriptions associated 
    with permutations.


    EXAMPLES:
    ::
        sage: AlternatingGroupFunctionList(3)
        [[(0, 0), (1, 1), (2, 2)], [(0, 1), (1, 2), (2, 0)], [(0, 2), (1, 0), (2, 1)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of permutations of elements from 1 to (n-1).
    P=Permutations(sz)
    return [[(i,Integer(p[i]-Integer(1))) for i in rg(sz)] for p in P if signf([(i,Integer(p[i]-1)) for i in rg(sz)])>Integer(0)]

def RepresentativePermutationFunctionList(sz):
    """
    Returns a list of edge tuple descriptions associated 
    with permutations.


    EXAMPLES:
    ::
        sage: RepresentativePermutationFunctionList(3)
        [[(0, 0), (1, 1), (2, 2)], [(0, 0), (1, 2), (2, 1)], [(0, 1), (1, 2), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    L=PermutationFunctionList(sz)
    # Initialization of the list storing the equivalence class of trees.
    cL=[ L[0] ]
    # Loop perfomring the isomorphism binning.
    for tp in L:
        nwT=True
        for i in range(len(cL)):
            if Tuple2DiGraph(tp,sz).is_isomorphic(Tuple2DiGraph(cL[i],sz)):
                nwT=False
                break
        if nwT==True:
            cL.append(tp)
    return cL

def GracefulFunctionList(sz):
    """
    Returns a list of edge tuple descriptions associated 
    with functions which admit a graceful labeling.
    This implementation works while the number of vertices
    is less then 11 because of the indexing symbolic issue.


    EXAMPLES:
    ::
        sage: sz=Integer(2); GracefulFunctionList(sz)
        [[(0, 0), (1, 0)], [(0, 1), (1,1)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the symbolic matrix
    A=HM(sz,sz,'a')
    # Initialization of the label variables
    X=var_list('x',sz)
    # Initialization of the list of permutations
    SnL=PermutationFunctionList(sz)
    # Initialization of the listing polynomial
    F0=expand(diff(sum(prod(sum(A[i,j]*X[abs(T[j][1]-T[i][1])] for j in rg(sz)) for i in rg(sz)) for T in SnL),X))
    # Initialization of the list of terms
    Ltrm0=[trm/trm.subs([v==1 for v in A.list()]) for trm in F0.operands()]
    return [Monomial2Tuple(mnm/mnm.subs([v==1 for v in A.list()]), A.list(),sz) for mnm in Ltrm0]

def RhoLabelableNonGracefulFunctionList(sz):
    """
    Returns a list of edge tuple descriptions associated 
    with functions which admit a rho labeling but no graceful labeling.
    This implementation works while the number of vertices
    is less then 11 because of the indexing symbolic issue.
    This implementation is very slow


    EXAMPLES:
    ::
        sage: sz=Integer(5); Lrho=RhoLabelableNonGracefulFunctionList(sz); Lrho
        [[(0, 2), (1, 0), (2, 1), (3, 4), (4, 4)],
         [(0, 4), (1, 1), (2, 1), (3, 0), (4, 3)],
         [(0, 2), (1, 4), (2, 3), (3, 0), (4, 4)],
         [(0, 3), (1, 0), (2, 4), (3, 1), (4, 4)],
         [(0, 1), (1, 1), (2, 4), (3, 2), (4, 3)],
         [(0, 3), (1, 2), (2, 2), (3, 4), (4, 0)],
         [(0, 2), (1, 1), (2, 4), (3, 1), (4, 0)],
         [(0, 0), (1, 0), (2, 3), (3, 4), (4, 2)],
         [(0, 1), (1, 3), (2, 2), (3, 0), (4, 2)],
         [(0, 3), (1, 1), (2, 0), (3, 2), (4, 1)],
         [(0, 4), (1, 2), (2, 3), (3, 1), (4, 4)],
         [(0, 2), (1, 1), (2, 3), (3, 0), (4, 1)],
         [(0, 0), (1, 4), (2, 1), (3, 0), (4, 2)],
         [(0, 0), (1, 0), (2, 4), (3, 2), (4, 3)],
         [(0, 4), (1, 0), (2, 2), (3, 2), (4, 1)],
         [(0, 1), (1, 2), (2, 0), (3, 4), (4, 4)],
         [(0, 1), (1, 4), (2, 3), (3, 3), (4, 0)],
         [(0, 4), (1, 0), (2, 3), (3, 3), (4, 1)],
         [(0, 4), (1, 2), (2, 2), (3, 0), (4, 3)],
         [(0, 0), (1, 3), (2, 0), (3, 4), (4, 1)],
         [(0, 0), (1, 4), (2, 0), (3, 1), (4, 3)],
         [(0, 3), (1, 4), (2, 0), (3, 2), (4, 4)],
         [(0, 3), (1, 0), (2, 2), (3, 1), (4, 2)],
         [(0, 1), (1, 3), (2, 4), (3, 0), (4, 4)],
         [(0, 2), (1, 3), (2, 4), (3, 3), (4, 0)],
         [(0, 0), (1, 2), (2, 4), (3, 0), (4, 1)],
         [(0, 2), (1, 4), (2, 2), (3, 1), (4, 3)],
         [(0, 2), (1, 3), (2, 2), (3, 4), (4, 1)],
         [(0, 3), (1, 1), (2, 1), (3, 4), (4, 0)],
         [(0, 0), (1, 2), (2, 3), (3, 1), (4, 0)],
         [(0, 1), (1, 4), (2, 2), (3, 2), (4, 0)],
         [(0, 4), (1, 3), (2, 1), (3, 2), (4, 4)],
         [(0, 1), (1, 1), (2, 3), (3, 4), (4, 2)],
         [(0, 3), (1, 4), (2, 1), (3, 3), (4, 2)],
         [(0, 1), (1, 2), (2, 0), (3, 3), (4, 3)],
         [(0, 3), (1, 2), (2, 4), (3, 3), (4, 1)],
         [(0, 4), (1, 1), (2, 0), (3, 1), (4, 2)],
         [(0, 0), (1, 3), (2, 1), (3, 2), (4, 0)],
         [(0, 2), (1, 0), (2, 1), (3, 3), (4, 3)],
         [(0, 4), (1, 3), (2, 0), (3, 3), (4, 2)]]
        sage: Tg=Lrho[0]; print("Induced edge labels: ",Set([min(abs(t[1]-t[0]),2*sz-1-abs(t[1]-t[0])) for t in Tg])) # Rho Labelings
        Induced edge labels:  {0, 1, 2}
        sage: A=HM(2*sz-1,2*sz-1,'a'); X=var_list('x',sz); Lf=injectiveTupleFunctionList(rg(sz), rg(2*sz-1))
        sage: F=sum(prod(A[T[i][1],T[Tg[i][1]][1]]*X[min(abs(T[Tg[i][1]][1]-T[i][1]),2*sz-1-abs(T[Tg[i][1]][1]-T[i][1]))] for i in rg(sz)) for T in Lf); Fl=diff(F,X)
        sage: rL=[Monomial2Tuple(mnm/mnm.subs([v==1 for v in A.list()]), A.list(),2*sz-1) for mnm in Fl.operands()]; rL[:5]
        [[(0, 3), (1, 1), (2, 1), (3, 5), (5, 0)],
         [(0, 3), (1, 2), (2, 2), (3, 5), (5, 0)],
         [(0, 0), (1, 2), (2, 4), (4, 1), (5, 0)],
         [(0, 0), (1, 3), (3, 4), (4, 1), (5, 0)],
         [(0, 0), (1, 4), (2, 1), (4, 2), (5, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(5)
    # Initialization of the symbolic matrix
    A=HM(2*sz-1,2*sz-1,'a')
    # Initialization of the label variables
    X=var_list('x',sz)
    # Initialization of the list of permutations
    SnL=PermutationFunctionList(sz)
    # Initialization of the listing polynomial
    F0=expand(diff(sum(prod(sum(A[i,j]*X[abs(T[j][1]-T[i][1])] for j in rg(sz)) for i in rg(sz)) for T in SnL),X))
    # Initialization of the list of terms
    Ltrm0=[trm/trm.subs([v==1 for v in A.list()]) for trm in F0.operands()]
    # Initialization of the corresponding set of terms
    St0=Set(Ltrm0)
    # Initialization of the list of functions
    Lf=injectiveTupleFunctionList(rg(sz), rg(2*sz-1))
    # Initialization of the listing polynomial
    F1=expand(diff(sum(prod(sum(A[i,j]*X[min(abs(T[j][1]-T[i][1]),2*sz-1-abs(T[j][1]-T[i][1]))] for j in rg(sz)) for i in rg(sz)) for T in Lf),X))
    # Initialization of the list of terms
    Ltrm1=[trm/trm.subs([v==1 for v in A.list()]) for trm in F1.operands()]
    # Initialization of the corresponding set of terms
    St1=Set(Ltrm1)
    # Computing the set difference
    dSt=St1.difference(St0)
    # Initialization of list of tuple descriptions
    return [Monomial2Tuple(trm, A.list(), 2*sz-1) for trm in dSt]

def TranspositionPermutation(pl, sz):
    """
    Returns a tuple list description of the transposition
    specified by the first input pl which list of lenght 2
    indicating the element to be transposed. The second
    input is an integer which indicate the length of the
    output list.


    EXAMPLES:
    ::
        sage: sz=3; TranspositionPermutation([0,1],sz)
        [(0, 1), (1, 0), (2, 2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the tuple list
    T=[(i,i) for i in rg(sz)]
    T[pl[0]]=(pl[0], pl[1]); T[pl[1]]=(pl[1], pl[0])
    return T

def is_permutation(T):
    """
    Dertermines whether or not the input tuple describes a permutation


    EXAMPLES:

    ::


        sage: is_permutation([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)])
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the adjacency matrix
    sz=len(T); A=HM(sz,sz,'zero')
    for t in T:
        A[t[0],t[1]]=1
    if (A*HM(sz,1,'one')-HM(sz,1,'one')).is_zero() and (A.transpose()*HM(sz,1,'one')-HM(sz,1,'one')).is_zero():
        return True
    else:
        return False

def RandomPermutationTuple(sz):
    """
    Outputs a random permutation i.e. a spanning union of
    disjoint directed cycles described in tuple notation
    chosen uniformly at random


    EXAMPLES:

    ::

        sage: RandomPermutationTuple(1)
        [(0, 0)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the Tuple and the list which
    # will store values that were already used
    L=rg(sz); T=[]
    for i in rg(sz):
        T.append((i, L[randint(0,len(L)-1)]))
        L.remove(T[len(T)-1][1])
    return T

def RandomDerangementTuple(sz):
    """
    Outputs a derangement described in tuple notation
    chosen uniformly at random


    EXAMPLES:

    ::

        sage: RandomDerangementTuple(2)
        [(0, 1), (1, 0)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the randomly chosen permutation
    T = RandomPermutationTuple(sz)
    while prod(T[i][1]-T[i][0] for i in rg(sz)).is_zero():
        T = RandomPermutationTuple(sz) 
    return T

def is_functional_tree(T):
    """
    Dertermines whether or not the input tuple describes a permutation


    EXAMPLES:

    ::


        sage: is_functional_tree([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)])
        False
        sage: is_functional_tree([(0, 3), (1, 3), (2, 3), (3, 3)])
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the adjacency matrix
    sz=len(T); A=HM(sz,sz,'zero')
    for t in T:
        A[t[0],t[1]]=1
    if 1==sum(A[i,i]*((HM(2,(A*HM(sz,1,'one')).list(),'diag')-A).slice([j for j in rg(sz) if j!=i],'row').slice([k for k in rg(sz) if k!=i],'col')).det() for i in rg(sz)):
        return True
    else:
        return False

def RootedTupleTreeFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with trees.

    EXAMPLES:
    ::
        sage: RootedTupleTreeFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]
        sage: sz=3; X=var_list('x',sz+1); Y=var_list('y',sz+1); Z=var_list('z',sz+1); Ta=HM(sz+1,sz+1,'a'); A=HM(sz+1,sz+1,'zero'); DgA=[Ta[i,i] for i in rg(sz+1)]
        sage: for i in rg(sz+1):
        ....:     for j in rg(sz+1):
        ....:         A[i,j]=Ta[i,j]*X[abs(j-i)]*prod(Y[u] for u in rg(min(i,j), max(i,j)))*prod(Z[u] for u in rg(1+min(i,j), 1+max(i,j)))
        ....:
        sage: sum(prod(A[t[0],t[1]] for t in tp) for tp in RootedTupleTreeFunctionList(sz))
        a00*a10*a20*x0*x1*x2*y0^2*y1*z1^2*z2 + a01*a11*a20*x0*x1*x2*y0^2*y1*z1^2*z2 + a02*a10*a22*x0*x1*x2*y0^2*y1*z1^2*z2 + a00*a12*a20*x0*x1*x2*y0*y1^2*z1*z2^2 + a02*a11*a21*x0*x1*x2*y0*y1^2*z1*z2^2 + a02*a12*a22*x0*x1*x2*y0*y1^2*z1*z2^2 + a00*a10*a21*x0*x1^2*y0*y1*z1*z2 + a01*a11*a21*x0*x1^2*y0*y1*z1*z2 + a01*a12*a22*x0*x1^2*y0*y1*z1*z2
        sage: sz=5; X=HM(sz,1,var_list('x',sz)); Y=HM(1,sz,var_list('y',sz)); A=X*Y # Quick demonstration of Cayley's Theorem
        sage: factor(sum(prod(A[t[0],t[1]] for t in tp) for tp in RootedTupleTreeFunctionList(sz)))
        (y0^2 + y1^2 + y2^2 + y3^2 + y4^2)*x0*x1*x2*x3*x4*(y0 + y1 + y2 + y3 + y4)^3
        sage: sz=5; A=HM(sz,sz,'a'); F=sum(prod(A[t[0],t[1]] for t in tp) for tp in RootedTupleTreeFunctionList(sz))


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Initialization of the adjacency martrix of the functional graph
        A = sum([Id[:,j]*Id[f[j],:] for j in range(sz)])
        # Initialization of the directed Laplacian
        lA= diagonal_matrix((A*ones_matrix(A.nrows(),1)).list())-A
        # Initialization of the list of sumbratrices
        Lmtr=[Matrix(ZZ,sz-1,sz-1,[lA[u,v] for u in range(sz) for v in range(sz) if u!=t if v!=t]) for t in range(sz)]
        # Testing treeness
        if sum(A[t,t]*Lmtr[t].det() for t in range(sz)) == 1:
            # Appending the function to the list
            Lf.append([(i, f[i]) for i in range(sz)])
    return Lf

def UniqueFixedPointTupleFunctionList(sz):
    """
    Returns tuple descriptions of functions having a unique fixed point
    the implementation uses symbolic listings.

    EXAMPLES:
    ::
        sage: sz=Integer(4); UniqueFixedPointTupleFunctionList(sz)
        [[(0, 1), (1, 0), (2, 0), (3, 3)],
         [(0, 2), (1, 0), (2, 0), (3, 3)],
         [(0, 3), (1, 0), (2, 0), (3, 3)],
         [(0, 1), (1, 2), (2, 0), (3, 3)],
         [(0, 2), (1, 2), (2, 0), (3, 3)],
         [(0, 3), (1, 2), (2, 0), (3, 3)],
         [(0, 1), (1, 3), (2, 0), (3, 3)],
         [(0, 2), (1, 3), (2, 0), (3, 3)],
         [(0, 3), (1, 3), (2, 0), (3, 3)],
         [(0, 1), (1, 0), (2, 1), (3, 3)],
         [(0, 2), (1, 0), (2, 1), (3, 3)],
         [(0, 3), (1, 0), (2, 1), (3, 3)],
         [(0, 1), (1, 2), (2, 1), (3, 3)],
         [(0, 2), (1, 2), (2, 1), (3, 3)],
         [(0, 3), (1, 2), (2, 1), (3, 3)],
         [(0, 1), (1, 3), (2, 1), (3, 3)],
         [(0, 2), (1, 3), (2, 1), (3, 3)],
         [(0, 3), (1, 3), (2, 1), (3, 3)],
         [(0, 1), (1, 0), (2, 3), (3, 3)],
         [(0, 2), (1, 0), (2, 3), (3, 3)],
         [(0, 3), (1, 0), (2, 3), (3, 3)],
         [(0, 1), (1, 2), (2, 3), (3, 3)],
         [(0, 2), (1, 2), (2, 3), (3, 3)],
         [(0, 3), (1, 2), (2, 3), (3, 3)],
         [(0, 1), (1, 3), (2, 3), (3, 3)],
         [(0, 2), (1, 3), (2, 3), (3, 3)],
         [(0, 3), (1, 3), (2, 3), (3, 3)]]        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the symbolic matrices
    A=HM(sz,sz,var_list('z',sz^2))
    # Initializing the listing
    F=expand(A[sz-1,sz-1]*prod(sum(A[i,j] for j in rg(sz) if j!=i) for i in rg(sz-1)))
    # Converting monomials into tuples
    return [Monomial2Tuple(mnm, A.list(), sz) for mnm in F.operands()]

def RepresentativeRootedTupleTreeFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with trees. The method returns only one
    per isomorphism equivalence class


    EXAMPLES:
    ::
        sage: RepresentativeRootedTupleTreeFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 0), (2, 1)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list
    L = DecreasingFunctionList(sz)
    # Initialization of the list storing the equivalence class of trees.
    cL=[ L[0] ]
    # Loop perfomring the isomorphism binning.
    for tp in L:
        nwT=True
        for i in range(len(cL)):
            if Tuple2DiGraph(tp,sz).is_isomorphic(Tuple2DiGraph(cL[i],sz)):
                nwT=False
                break
        if nwT==True:
            cL.append(tp)
    return cL

def RootedTupleInducedTreeFunctionList(sz, induced_edge_label_sequence):
    """
    Goes through all the functions and determines which ones
    are associated with a given edge labeled sequence sorted
    in non decreasing order

    EXAMPLES:
    ::
        sage: RootedTupleInducedTreeFunctionList(3, [0, 1, 2])
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]
        sage: sz=3; X=var_list('x',sz+1); Y=var_list('y',sz+1); Z=var_list('z',sz+1); Ta=HM(sz+1,sz+1,'a'); A=HM(sz+1,sz+1,'zero'); DgA=[Ta[i,i] for i in rg(sz+1)]
        sage: for i in rg(sz+1):
        ....:     for j in rg(sz+1):
        ....:         A[i,j]=Ta[i,j]*X[abs(j-i)]*prod(Y[u] for u in rg(min(i,j), max(i,j)))*prod(Z[u] for u in rg(1+min(i,j), 1+max(i,j)))
        ....:
        sage: sum(prod(A[t[0],t[1]] for t in tp) for tp in RootedTupleInducedTreeFunctionList(sz,[0,1,2]))
        a00*a10*a20*x0*x1*x2*y0^2*y1*z1^2*z2 + a01*a11*a20*x0*x1*x2*y0^2*y1*z1^2*z2 + a02*a10*a22*x0*x1*x2*y0^2*y1*z1^2*z2 + a00*a12*a20*x0*x1*x2*y0*y1^2*z1*z2^2 + a02*a11*a21*x0*x1*x2*y0*y1^2*z1*z2^2 + a02*a12*a22*x0*x1*x2*y0*y1^2*z1*z2^2


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Initialization of the adjacency martrix of the functional graph
        A = sum([Id[:,j]*Id[f[j],:] for j in range(sz)])
        # Initialization of the directed Laplacian
        lA= diagonal_matrix((A*ones_matrix(A.nrows(),1)).list())-A
        # Initialization of the list of sumbratrices
        Lmtr=[Matrix(ZZ,sz-1,sz-1,[lA[u,v] for u in range(sz) for v in range(sz) if u!=t if v!=t]) for t in range(sz)]
        # Testing treeness
        EdgLblSeq=[abs(f[i]-i) for i in range(sz)]; EdgLblSeq.sort()
        if sum(A[t,t]*Lmtr[t].det() for t in range(sz)) == 1 and  EdgLblSeq == induced_edge_label_sequence:
            # Appending the function to the list
            Lf.append([(i,f[i]) for i in range(sz)])
    return Lf

def NonDecreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with pointwise non decreasing functions.
    They capture the isomorphism class of all spanning union
    of functional trees.

    EXAMPLES:
    ::
        sage: NonDecreasingFunctionList(3)[0]
        [[(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]; Lg=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Testing whether the candidate fucntion is non decreasing 
        # Setting the boolean function
        Decreasing = True
        for i in rg(sz):
            if f[i] < i:
                Decreasing = False
                break
        # Appending the function to the list
        if Decreasing == True:
            Lf.append([(i, f[i]) for i in range(sz)])
        else:
            Lg.append([(i, f[i]) for i in range(sz)])
    return [Lf, Lg]

def DecreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with functions which are below the line y=x
    and never touch the line y=x for all x>0.
    The set forms a semigroup of the transformation monoid.

    EXAMPLES:
    ::
        sage: DecreasingFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 0), (2, 1)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    A=HM(sz,sz,'a')
    if sz == 1:
        return [(0, 0)]
    elif sz == 2:
        return [(0, 0), (1, 0)]
    elif sz > 2:
        return [Monomial2Tuple(mnm, A.list(), sz) for mnm in expand(A[0,0]*prod(sum(A[i,j] for j in rg(i)) for i in rg(1,sz))).operands()]
    else:
        raise ValueError("Expected the size to be an integer >=1")

def DecreasingFunctionListAdditivelyDistinct(sz):
    """
    Goes through all the functions pointwise decreasing functions
    and determines which ones have distinct unmodulated induced 
    additive edge labels.


    EXAMPLES:
    ::
        sage: DecreasingFunctionListAdditivelyDistinct(3)
        [[(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 0), (2, 1)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    A=HM(sz,sz,'a')
    # Initialization of the list
    L=DecreasingFunctionList(sz); rL=[]
    for T in L:
        if ((Tuple_to_Adjacency([(i,i) for i in rg(sz)])+Tuple_to_Adjacency(T))*HM(sz,1,rg(sz))).set().cardinality()==sz:
            rL.append(T)
    return rL

def NonIncreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with functions which never cross the y=x
    axis from bellow.
    They capture the isomorphism class of all spanning
    unions of functional trees.

    EXAMPLES:
    ::
        sage: NonIncreasingFunctionList(3)[0]
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]; Lg=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Testing whether the candidate fucntion is non decreasing 
        # Setting the boolean function
        Increasing = True
        for i in rg(sz):
            if f[i] > i:
                Increasing = False
                break
        # Appending the function to the list
        if Increasing == True:
            Lf.append([(i, f[i]) for i in range(sz)])
        else:
            Lg.append([(i, f[i]) for i in range(sz)])
    return [Lf, Lg]

def TupleComplementaryLabel(T):
    """
    Returns the tuple encoding of the involuted labeling
    This implementation does not assume that the tuple is rooted at 0.

    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)]
        sage: TupleComplementaryLabel(T)
        [(0, 4), (1, 4), (2, 0), (3, 2), (4, 4)]


    AUTHORS:
    - Edinah K. Gnang
    """
    sz=len(T)
    tp=[(sz-1-t[0], sz-1-t[1]) for t in T]
    tp.sort()
    return tp

def TupleComplementaryLabelII(T):
    """
    Returns the tuple encoding of the involuted labeling
    This implementation does not assume that the tuple is   
    rooted at 0. Differs from the implementation above in
    the fact that T is a list of list for mutability purposes.


    EXAMPLES:

    ::

        sage: T=[[0, 0], [1, 2], [2, 4], [3, 0], [4, 0]]
        sage: TupleComplementaryLabelII(T)
        [[0, 4], [1, 4], [2, 0], [3, 2], [4, 4]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size
    sz=Integer(len(T))
    tp=[[sz-1-t[0], sz-1-t[1]] for t in T]
    tp.sort()
    return tp

def IncreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with pointwise increasing functions.

    EXAMPLES:
    ::
        sage: IncreasingFunctionList(3)
        [[(0, 1), (1, 2), (2, 2)], [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    #A=HM(sz,sz,'a')
    A=HM(sz,sz,var_list('z',sz^2))
    if sz == 1:
        return [(0, 0)]
    elif sz == 2:
        return [(0, 1), (1, 1)]
    elif sz > 2:
        return [Monomial2Tuple(mnm, A.list(), sz) for mnm in expand(A[sz-1,sz-1]*prod(sum(A[sz-1-i,sz-1-j] for j in rg(i)) for i in rg(1,sz))).operands()]
    else:
        raise ValueError("Expected the size to be an integer >=1")

def RootedTupleTreeNonIncreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with trees and separates then according
    to whether or they are non increasing

    EXAMPLES:
    ::
        sage: RootedTupleTreeNonIncreasingFunctionList(3)[0]
        [[(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 0), (2, 1)]] 



    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]; Lg=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Initialization of the adjacency martrix of the functional graph
        A = sum([Id[:,j]*Id[f[j],:] for j in range(sz)])
        # Initialization of the dierected Laplacian
        lA= diagonal_matrix((A*ones_matrix(A.nrows(),1)).list())-A
        # Initialization of the list of sumbratrices
        Lmtr=[Matrix(ZZ,sz-1,sz-1,[lA[u,v] for u in range(sz) for v in range(sz) if u!=t if v!=t]) for t in range(sz)]
        # Testing treeness
        if sum(A[t,t]*Lmtr[t].det() for t in range(sz)) == 1:
            # Setting the boolean function
            Increasing = True
            for i in rg(sz):
                if f[i] > i:
                    Increasing = False
                    break
            # Appending the function to the list
            if Increasing == True:
                Lf.append([(i, f[i]) for i in range(sz)])
            else:
                Lg.append([(i, f[i]) for i in range(sz)])
    return [Lf, Lg]

def RootedTupleTreeNonDecreasingFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with non decreasing functional trees.

    EXAMPLES:
    ::
        sage: RootedTupleTreeNonDecreasingFunctionList(3)[0]
        [[(0, 1), (1, 2), (2, 2)], [(0, 2), (1, 2), (2, 2)]]



    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[sz for i in range(sz)]; Lf=[]; Lg=[]
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Initialization of the adjacency martrix of the functional graph
        A = sum([Id[:,j]*Id[f[j],:] for j in range(sz)])
        # Initialization of the dierected Laplacian
        lA= diagonal_matrix((A*ones_matrix(A.nrows(),1)).list())-A
        # Initialization of the list of sumbratrices
        Lmtr=[Matrix(ZZ,sz-1,sz-1,[lA[u,v] for u in range(sz) for v in range(sz) if u!=t if v!=t]) for t in range(sz)]
        # Testing treeness
        if sum(A[t,t]*Lmtr[t].det() for t in range(sz)) == 1:
            # Setting the boolean function
            Decreasing = True
            for i in rg(sz):
                if f[i] < i:
                    Decreasing = False
                    break
            # Appending the function to the list
            if Decreasing == True:
                Lf.append([(i, f[i]) for i in range(sz)])
            else:
                Lg.append([(i, f[i]) for i in range(sz)])
    return [Lf, Lg]

def RepresentativeTupleSpanningFunctionalTreeList(sz):
    """
    Returns a list of edge tuple desctiption for all 
    spanning unions of functional trees. Outputing one
    per isomorphism class the graph isomorphism routine
    is doing the heavy lifting here. The number of
    vertices size must be at least 2.


    EXAMPLES:
    ::
        sage: RepresentativeTupleSpanningFunctionalTreeList(4)
        [[(0, 0), (1, 0), (2, 0), (3, 0)],
         [(0, 0), (1, 1), (2, 0), (3, 0)],
         [(0, 0), (1, 0), (2, 1), (3, 0)],
         [(0, 0), (1, 1), (2, 1), (3, 0)],
         [(0, 0), (1, 1), (2, 2), (3, 0)],
         [(0, 0), (1, 0), (2, 1), (3, 1)],
         [(0, 0), (1, 0), (2, 2), (3, 1)],
         [(0, 0), (1, 0), (2, 1), (3, 2)],
         [(0, 0), (1, 1), (2, 2), (3, 3)]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    #A=HM(sz,sz,'a')
    A=HM(sz,sz,var_list('x',sz^2))
    L=[Monomial2Tuple(mnm, A.list(), sz) for mnm in expand(A[0,0]*prod(sum(A[i,j] for j in rg(i+1)) for i in rg(1,sz))).operands()]
    # Initialization of the list storing the equivalence class of trees.
    cL=[ L[0] ]
    # Loop perfomring the isomorphism binning.
    for tp in L:
        nwT=True
        for i in range(len(cL)):
            if Tuple2DiGraph(tp,sz).is_isomorphic(Tuple2DiGraph(cL[i],sz)):
                nwT=False
                break
        if nwT==True:
            cL.append(tp)
    return cL

def TupleSpanningFunctionalTreeList(sz):
    """
    Returns a list of edge tuple desctiption for all 
    spanning unions of functional trees. There are
    (sz+1)^(sz-1) of them. 


    EXAMPLES:
    ::
        sage: TupleSpanningFunctionalTreeList(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]] 


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    #A=HM(sz, sz, 'a')
    A=HM(sz, sz, var_list('z',sz^2))
    L =TupleFunctionList(sz)
    # Initialization of the list storing the equivalence class of trees.
    cL=[ ]
    cL0=RepresentativeTupleSpanningFunctionalTreeList(sz)
    # Loop perfomring the isomorphism binning.
    for tp in L:
        nwT=False
        for tq in cL0:
            if Tuple2DiGraph(tp,sz).is_isomorphic(Tuple2DiGraph(tq,sz)):
                nwT=True
                break
        if nwT==True:
            cL.append(tp)
    return cL

def TupleSpanningFunctionalTreeListII(sz):
    """
    Returns a list of edge tuple desctiption for all 
    spanning unions of functional trees. There are
    (sz+1)^(sz-1) of them. This implementation is based
    on the matrix tree theorem proof argument using
    functional trees on sz+1 vertices rooted at the
    vertex labeled sz. The listing of spanning unions
    of functional trees on sz vertices is obtained by
    contracting every subgraph described by the edge
    monomial A[i,sz]*A[sz,sz] into the self loop edge
    A[i,i] where i is in rg(sz). Works only for < 9
    vertices because for instance of the ambiguity
    inherent to a111 being confused as a_{1,11} or 
    a_{11,1}


    EXAMPLES:
    ::
        sage: TupleSpanningFunctionalTreeListII(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]] 


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the lists
    A=HM(sz+1, sz+1, 'a'); As=HM(sz, sz, 'a')
    # Initialization of the directed Laplacian
    LpmA=HM(2,(A*HM(sz+1,1,'one')).list(),'diag')-A
    # Initialization of the symbolic listing
    tmpF=expand(Deter(LpmA.slice(rg(sz),'row').slice(rg(sz),'col')))
    F=fast_reduce(tmpF, [A[i,sz] for i in rg(sz)], [A[i,i] for i in rg(sz)])
    return [Monomial2Tuple(mnm, As.list(), sz) for mnm in F.operands()]

def List_of_Integers(l):
    """
    The function takes as input a list l of positive integers > 0.
    The function outputs the list of distinct integer list of lenght
    len(l) where the list entry indexed by i ranges from 0 inclusively
    to l[i] excluded.


    EXAMPLES:
    ::
        sage: List_of_Integers([2,2,2])
        [[0, 0, 0],
         [1, 0, 0],
         [0, 1, 0],
         [1, 1, 0],
         [0, 0, 1],
         [1, 0, 1],
         [0, 1, 1],
         [1, 1, 1]]
        sage: List_of_Integers([1,2,3])
        [[0, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1], [0, 0, 2], [0, 1, 2]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list which will be returned 
    L=[]
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        L.append(entry)
    return L

def TreeFunctionList(n):
    """
    Goes through all the functions and determines which ones
    are associated with trees. One of think of thes trees as
    rooted at 0.

    EXAMPLES:
    ::
        sage: TreeFunctionList(4)
        [[0, 0, 0],
        [2, 0, 0],
        [3, 0, 0],
        [0, 1, 0],
        [3, 1, 0],
        [0, 3, 0],
        [2, 3, 0],
        [3, 3, 0],
        [0, 0, 1],
        [2, 0, 1],
        [0, 1, 1],
        [0, 3, 1],
        [0, 0, 2],
        [2, 0, 2],
        [3, 0, 2],
        [0, 1, 2]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the lists
    l=[n for i in range(n-1)]; Lf=[]
    # Initialization of the identity matrix
    Id=identity_matrix(n)
    # Main loop performing the collecting the functions.
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        f=entry
        # Appending the function to the list
        if is_Tree(sum([Id[:,j]*Id[f[j-1],:]+Id[:,f[j-1]]*Id[j,:] for j in range(1,n)])):
            Lf.append(f)
    return Lf

def Tuple2DiGraphII(T,sz):
    """
    The method returns a directed graph object associated with 
    with the tuple list description of the directed graph

    EXAMPLES:

    ::

        sage: Tuple2DiGraph([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)],5).degree_sequence()
        [4, 2, 2, 1, 1]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    return DiGraph(sum([Id[:,t[0]]*Id[t[1],:] for t in T]))

def mPer(A,tq):
    """
    Computes symbolically the partial modified permanent by summing only over
    representatives of the coeset.


    EXAMPLES:

    ::

        sage: sz=4; tp=[(0, 0), (1, 2), (2, 0), (3, 0)]
        sage: A=HM(sz,sz,'a').elementwise_product(HM(sz,sz,[x^(sz^abs(j-i)) for j in rg(sz) for i in rg(sz)]))
        sage: mPer(A,tp).coefficient(x^((sz^sz-1)/(sz-1)))
        a00*a12*a20*a30 + a02*a12*a22*a30 + a03*a11*a21*a31 + a03*a13*a21*a33
        sage: sz=4; mPer(HM(sz,sz,'a'), [(i,0) for i in rg(sz)])
        a00*a10*a20*a30 + a01*a11*a21*a31 + a02*a12*a22*a32 + a03*a13*a23*a33
       

    AUTHORS:
    - Edinah K. Gnang
    """
    sz=A.n(0)
    tp=[(1+tq[i][0], 1+tq[i][1]) for i in rg(len(tq))]
    # Initializing the permutations
    P = Permutations(sz); S=SymmetricGroup(sz)
    # Initializing the graph
    grph=Tuple2DiGraph(tp, sz+1)
    # Initializing the automorphism group
    AutGrp=grph.automorphism_group()
    # Initializing representatives of Left coset as strings
    Lcstr=[CstL[0].cycle_string() for CstL in S.cosets(AutGrp)]
    # Loop enumerating the number of graceful labelings
    fctr=0
    # Initialization of the function
    f=0
    for p in P:
        if p.cycle_string() in Lcstr:
            # Initializing the inverse
            pinv=p.inverse()
            # fixing the permutations index
            q =[p[i]-1 for i in rg(sz)]
            qi=[pinv[i]-1 for i in rg(sz)]
            f=f+prod([A[j, q[tp[qi[j]][1]-1]] for j in range(sz)])
    return f

def Monomial2Tuple(mnm, VrbL, sz):
    """
    Outputs the tuple edge list description of the input monomial mnm.
    The variables are obtain by listing the entries of a hypermatrix.
    directed graph case.


    EXAMPLES:
 
    ::

        sage: sz=4; A=HM(sz,sz,'a'); Tp=Monomial2Tuple(prod(A[0,i] for i in rg(sz)), A.list(), sz)
        sage: Tp
        [(0, 0), (0, 1), (0, 2), (0, 3)]
        


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Getting rid of the coefficient
    f=mnm/(mnm.subs([v==1 for v in VrbL]))
    # Initialization of the dictionary
    EdgeDct=dict([(VrbL[j*sz+i],(i,j)) for j in rg(sz) for i in rg(sz)])
    if f in VrbL:
        return [EdgeDct[f]] 
    else:
        Tp=[EdgeDct[g] for g in f.operands()]; Tp.sort()
    return Tp

def Monomial2TupleII(mnm, VrbL):
    """
    Outputs the tuple edge list description of the input monomial mnm.
    The output of the function is taken to be the exponent of the variables.
    The current implementation does not check that the input is a monomial.


    EXAMPLES:
 
    ::

        sage: sz=Integer(3); X=var_list('x',sz); F=expand(prod(X[j]-X[i] for j in rg(sz) for i in rg(sz) if i<j))
        sage: L=[Monomial2TupleII(mnm, X) for mnm in F.operands()]; L
        [[(0, 2), (1, 1), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Getting rid of the coefficient
    trm=mnm/(mnm.subs([v==1 for v in VrbL]))
    return [(i, trm.degree(VrbL[i])) for i in rg(len(VrbL))]

def Monomial2Adjacency(mnm, VrbL, sz):
    """
    Outputs the adjacency matrix description of the input monomial mnm.
    The variables are obtain by listing the entries of a hypermatrix.
    This implementation handles directed graph case. The input needs
    not be multilinear. The implementation does not check that the input
    is a monomial


    EXAMPLES:
 
    ::

        sage: sz=4; A=HM(sz,sz,'a'); AT=Monomial2Adjacency(prod(A[0,i] for i in rg(sz)), A.list(), sz)
        sage: AT.p()
        [1 1 1 1]
        [0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the adjacency matrix
    AdjMtr=HM(sz,sz,'zero') 
    # Getting rid of the coefficient of the monomial
    f=mnm/(mnm.subs([v==1 for v in VrbL]))
    # Initialization of the dictionary
    EdgeDct=dict([(VrbL[j*sz+i],(i,j)) for j in rg(sz) for i in rg(sz)])
    # Cheking the support via differentiation
    for i in rg(sz):
        for j in rg(sz):
            if not f.diff(VrbL[j*sz+i]).is_zero():
                AdjMtr[i,j]=1
    return AdjMtr

def Monomial2AdjacencyII(mnm, VrbL, sz):
    """
    Outputs the symbolic adjacency matrix of the input monomial mnm.
    The variables are obtain by listing the entries of a hypermatrix.
    Handles directed graph case. The input monomial need not be multilinear


    EXAMPLES:
 
    ::

        sage: sz=4; A=HM(sz,sz,'a'); AT=Monomial2AdjacencyII(prod(A[0,i] for i in rg(sz)), A.list(), sz)
        sage: AT.p()
        [a00 a01 a02 a03]
        [  0   0   0   0]
        [  0   0   0   0]
        [  0   0   0   0]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of the adjacency matrix
    AdjMtr=HM(sz,sz,'zero') 
    # Getting rid of the coefficient of the monomial
    f=mnm/(mnm.subs([v==1 for v in VrbL]))
    # Cheking the support via differentiation
    for i in rg(sz):
        for j in rg(sz):
            if not f.diff(VrbL[j*sz+i]).is_zero():
                AdjMtr[i,j]=VrbL[j*sz+i]
    return AdjMtr

def RootedTupleClassTreeFunctionList(tp):
    """
    Computes determines the set all functional
    trees with the same skeleton unalbeled tree.


    EXAMPLES:

    ::

        sage: sz=3; RootedTupleClassTreeFunctionList([(0, 0)]+[(i, i-1) for i in rg(1,sz)])
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 1), (1, 1), (2, 0)],
         [(0, 0), (1, 2), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 2), (1, 1), (2, 1)],
         [(0, 2), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]] 
       
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(tp)
    # Initialization of a symbolic matrix
    A=HM(sz,sz,'a')
    # Computing the sum over modified permanents
    F=sum(mPer(A,T) for T in [switch_sink(tp,i) for i in rg(sz)])
    # converting term to tuple description of functional directed trees
    return [Monomial2Tuple(mnm, A.list(), sz) for mnm in F.operands()]

def BasicLagrangeInterpolation(L, x):
    """
    Implements the basic lagrange interpolation.
    The functions take as input a list of tuples
    and outputs a polynomial in the variable x


    EXAMPLES:
    ::


        sage: x=var('x'); BasicLagrangeInterpolation([(0,0), (1,1), (2,2), (3,3)], x)
        1/2*(x - 1)*(x - 2)*x - (x - 1)*(x - 3)*x + 1/2*(x - 2)*(x - 3)*x


    AUTHORS:
    - Edinah K. Gnang
    """
    # L is a list of tuples
    # Initialized the lenght of the list
    n = len(L)
    # Initialization of the function
    f = 0
    # Code for building the parts 
    for idx in range(len(L)):
        fk = 1
        for j in [i for i in range(len(L)) if i != idx]:
            fk = fk*((x-L[j][0])/(L[idx][0]-L[j][0]))
        f = f + L[idx][1]*fk
    return f

def bli(L, v=x):
    """
    Implements the basic lagrange interpolation.
    The functions take as input a list of tuples
    and outputs a polynomial in the input variable v


    EXAMPLES:
    ::


        sage: x=var('x'); bli([(0,0), (1,1), (2,2), (3,3)], x)
        1/2*(x - 1)*(x - 2)*x - (x - 1)*(x - 3)*x + 1/2*(x - 2)*(x - 3)*x


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the function
    F = SR(0)
    # Code for building the parts 
    for idx in rg(len(L)):
        fk = SR(1)
        for j in [i for i in rg(len(L)) if i != idx]:
            fk = fk*((v-L[j][0])/(L[idx][0]-L[j][0]))
        F = F + L[idx][1]*fk
    return F

def LagrangeBasis(T, X, sz1):
    """
    Returns the Lagrange basis element associated
    with lagrange interpolation indexed by a function.
    The input T is a tuple description of the function
    associated with the basis element. The domain of the
    function described by T is Z_sz0 and the codomain is
    Z_sz1.


    EXAMPLES:
    ::


        sage: sz0=Integer(2); sz1=Integer(3); X=var_list('x', sz0)
        sage: T=[(i,0) for i in rg(sz0)]; Lt=LagrangeBasis(T, X, sz1); Lt
        1/4*(x0 - 1)*(x0 - 2)*(x1 - 1)*(x1 - 2)


    AUTHORS:
    - Edinah K. Gnang
    """
    return prod(prod((X[k]-jk)/(T[k][1]-jk) for jk in rg(sz1) if jk != T[k][1]) for k in rg(len(X)))

def LagrangeInterpolationZn(F, X):
    """
    Implements the basic lagrange interpolation
    over Zn where the input F is a multivariate
    polynomial in the entries of the list of 
    variable X.


    EXAMPLES:
    ::


        sage: sz=Integer(2); X=var_list('x', sz); F=X[0]^5*X[1]^7 - 3*X[0]^2*X[1] + 7
        sage: G=LagrangeInterpolationZn(F, X); expand(G)
        -2*x0*x1 + 7


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(X))
    # Initialization of the list of Tuple
    Lt=TupleFunctionList(sz)
    #return sum(F.subs([X[i]==T[i][1] for i in rg(sz)])*prod(prod((X[k]-jk)/(T[k][1]-jk) for jk in rg(sz) if jk != T[k][1]) for k in rg(sz)) for T in Lt)
    return sum(F.subs([X[i]==T[i][1] for i in rg(sz)])*LagrangeBasis(T, X, sz) for T in Lt)

def LagrangeInterpolationZd(F, X, d):
    """
    Implements the basic lagrange interpolation
    over Zd where the input F is a multivariate
    polynomial in the entries of the list of 
    variable X.


    EXAMPLES:
    ::


        sage: sz=Integer(2); X=var_list('x', sz); F=X[0]^5*X[1]^7 - 3*X[0]^2*X[1] + 7
        sage: d=Integer(2); G=LagrangeInterpolationZd(F, X, d); expand(G)
        -2*x0*x1 + 7


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(X))
    # Initialization of the list of Tuple
    Lt=TupleFunctionListII(len(X), d)
    return sum(F.subs([X[i]==T[i][1] for i in rg(sz)])*LagrangeBasis(T, X, d) for T in Lt)

def Strip_Coefficients(F, v):
    """
    Extracts the list of coefficients of the
    input polynomial F in the variable v
    the implementation assumes that the input polynomial
    F is presented in it's expanded form.


    EXAMPLES:
    ::


        sage: x=var('x'); F=BasicLagrangeInterpolation([(0,0), (1,1), (2,2), (3,3)], x); F
        1/2*(x - 1)*(x - 2)*x - (x - 1)*(x - 3)*x + 1/2*(x - 2)*(x - 3)*x
        sage: Strip_Coefficients(expand(F), x)
        [0, 1]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializtion of the degree in the input variable this is the only part which
    # requires an expanded form.
    dg=Integer(F.degree(v))
    return [diff(F,v,i).subs(v==0)/factorial(i) for i in rg(dg+1)]

def composition(f, x, k, sz):
    """
    This function performs the composition of the function f in the 
    variable x with itself k times. The implementation assumes that
    f is the functions defined by a functional directed graph on sz
    vertices in order to ensure that the function has degree at most
    sz-1 


    EXAMPLES:
    ::


        sage: f=1/2*(x - 1)*(x - 2)*x - (x - 1)*(x - 3)*x + 1/2*(x - 2)*(x - 3)*x
        sage: composition(f, x, 1, 4)
        1/2*(x - 1)*(x - 2)*x - (x - 1)*(x - 3)*x + 1/2*(x - 2)*(x - 3)*x
        sage: sz=4; tq=[(0, 1), (1, 2), (2, 3), (3, 3)]
        sage: f=BasicLagrangeInterpolation(tq,var('z'))
        sage: tq == [(i, f.subs(z==i)) for i in rg(sz)]
        True
        sage: L=[composition(f, var('z'), i, sz) for i in rg(sz)]; L
        [z,
         -1/6*(z - 1)*(z - 2)*(z - 3) + 1/2*(z - 1)*(z - 2)*z - 3/2*(z - 1)*(z - 3)*z + (z - 2)*(z - 3)*z,
         -1/3*(z - 1)*(z - 2)*(z - 3) + 1/2*(z - 1)*(z - 2)*z - 3/2*(z - 1)*(z - 3)*z + 3/2*(z - 2)*(z - 3)*z,
         -1/2*(z - 1)*(z - 2)*(z - 3) + 1/2*(z - 1)*(z - 2)*z - 3/2*(z - 1)*(z - 3)*z + 3/2*(z - 2)*(z - 3)*z]
        sage: [[(i, g.subs(var('z')==i)) for i in rg(sz)] for g in [composition(f, var('z'), i, sz) for i in rg(sz)]]
        [[(0, 0), (1, 1), (2, 2), (3, 3)],
         [(0, 1), (1, 2), (2, 3), (3, 3)],
         [(0, 2), (1, 3), (2, 3), (3, 3)],
         [(0, 3), (1, 3), (2, 3), (3, 3)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if k==0:
        return x
    elif k==1:
        return f
    elif k > 1:
        # Initialization of the function
        g=f
        for t in rg(k-1):
            # Initialization of the function
            TmpF=0
            # Code for building the parts 
            for idx in range(sz):
                fk=1
                for j in [i for i in rg(sz) if i != idx]:
                    fk=fk*(x-j)/(idx-j)
                TmpF=TmpF + g.subs(x==f).subs(x==idx)*fk
            g=TmpF
        return g

def compose_with(f, g, sz, vrbl):
    """
    This function performs the composition of the function f in the 
    variable x with itself k times. The implementation assumes that
    f is the functions defined by a functional directed graph on sz
    vertices in order to ensure that the function has degree at most
    sz-1 


    EXAMPLES:
    ::


        sage: f0=BasicLagrangeInterpolation([(0,1), (1,2), (2,0)],x); f1=BasicLagrangeInterpolation([(0,2), (1,0), (2,1)],x); f2=x
        sage: f3=0; f4=BasicLagrangeInterpolation([(0,0), (1,2), (2,1)],x)
        sage: expand(compose_with(f0, f1, 3, x))
        x
        sage: compose_with(f4, f4, 3, x) - composition(f4, x, 2, 3)
        0


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the function
    TmpF=0
    # Code for building the parts 
    for idx in range(sz):
        fk=1
        for j in [i for i in rg(sz) if i != idx]:
            fk=fk*(vrbl-j)/(idx-j)
        TmpF=TmpF + f.subs(vrbl==g).subs(vrbl==idx)*fk
    g=TmpF
    return g

def compose_tuple(T0, T1):
    """
    This function performs the composition of the input tuple functions.


    EXAMPLES:
    ::


        sage: T0=[(0,1), (1,2), (2,0)]; T1=[(0,2), (1,0), (2,1)]
        sage: compose_tuple(T0, T1)
        [(0, 0), (1, 1), (2, 2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    if len(T0) != len(T1):
        raise ValueError("Expected tuples of the same size.")
    else:
        return [(i, T0[T1[i][1]][1]) for i in rg(len(T0))]

def compose_tuple_list(L):
    """
    This function performs the composition of the input tuple function list.
    This implementation assume that the input list  of tuples describes 
    composable functions.

    EXAMPLES:
    ::


        sage: T0=[(0,1), (1,2), (2,0)]; T1=[(0,2), (1,0), (2,1)]; L=[T0, T1]
        sage: compose_tuple_list(L)
        [(0, 0), (1, 1), (2, 2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    T=L[0]
    for i in rg(1,len(L)):
        T=compose_tuple(T,L[i])
    return T

def compose_tuple_power(T, pwr):
    """
    This function performs the composition of the input tuple functions.
    The function also return fractional iterates computed rather naively.


    EXAMPLES:
    ::


        sage: T=[(0, 1), (1, 2), (2, 0)]
        sage: compose_tuple_power(T, 0)
        [(0, 0), (1, 1), (2, 2)]
        sage: sz=3; L = compose_tuple_power([(Integer(i),Integer(0)) for i in rg(sz)], Integer(1)/Integer(2)); L
        [[(0, 0), (1, 0), (2, 0)], [(0, 0), (1, 2), (2, 0)], [(0, 0), (1, 0), (2, 1)]]
        sage: sz=3; L = compose_tuple_power([(Integer(i),Integer(0)) for i in rg(sz)], Integer(3)/Integer(2)); L
        [(0, 0), (1, 0), (2, 0)]


    AUTHORS:
    - Edinah K. Gnang
    """
    if pwr.is_integer() and pwr == 0:
        return [(i, i) for i in rg(len(T))]
    elif pwr.is_integer() and pwr == Integer(1):
        return T
    elif pwr.is_integer() and pwr > Integer(1):
        Tp=T.copy()
        for i in rg(1,pwr):
            Tp=compose_tuple(Tp,T)
        return Tp
    elif pwr.is_integer() and pwr == -Integer(1):
        return invert_tuple(T)
    elif pwr.is_integer() and pwr < -Integer(1):
        return compose_tuple_power(invert_tuple(T), -pwr)
    elif not pwr.is_integer() and pwr.is_rational(): 
        # Initialization of the numerator and denominator
        num=pwr.numerator(); dnm=pwr.denominator()
        TmpL=[]
        for Tp in TupleFunctionList(len(T)):
            if compose_tuple_power(Tp, dnm) == T:
                TmpL.append(Tp)
        # Initialization of the final output
        rsLt=[]
        for Tq in TmpL:
            # Computing the iterate
            Tqq=compose_tuple_power(Tq, num)
            if not Tqq in rsLt:
                rsLt.append(Tqq)
        if len(rsLt) == 1:
            return rsLt[0]
        else:
            return rsLt
    else:
        raise ValueError("Expected a rational number input")

def invert_tuple(T):
    """
    This function computes the composition inverse of 
    the input tuple.


    EXAMPLES:
    ::


        sage: sz=3; T0=[(0, 1), (1, 2), (2, 0)]; T1=invert_tuple(T0)
        sage: compose_tuple(T0, T1)
        [(0, 0), (1, 1), (2, 2)]
        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of a tuple description for f
    TpL=[(T[i][1], i) for i in rg(len(T))]; TpL.sort()
    if [t[0] for t in TpL] == rg(len(TpL)):
        return TpL
    else:
        raise ValueError("The input function must be invertible")

def is_invertible(T):
    """
    Determines whether or not the input tuple describes
    an invertible function


    EXAMPLES:
    ::


        sage: sz=3; T=[(0, 1), (1, 2), (2, 0)]; is_invertible(T)
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    if Tuple_to_Adjacency(T).det() == 0:
        return False
    else:
        return True

def compose_tuple_pow(T, k):
    """
    This function performs the composition of the input tuple.
    The implementation assumes that T is a functional directed graph.


    EXAMPLES:
    ::


        sage: T=[(0, 1), (1, 2), (2, 3), (3, 3)]; L=[compose_tuple_pow(T, i) for i in rg(len(T))]; L
        [[(0, 0), (1, 1), (2, 2), (3, 3)],
         [(0, 1), (1, 2), (2, 3), (3, 3)],
         [(0, 2), (1, 3), (2, 3), (3, 3)],
         [(0, 3), (1, 3), (2, 3), (3, 3)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    if k==0:
        return [(i, i) for i in rg(len(T))]
    elif k==1:
        return T
    elif k > 1:
        # Initialization of the function
        f=BasicLagrangeInterpolation(T, x)
        g=f
        for t in rg(k-1):
            # Initialization of the function
            TmpF=0
            # Code for building the parts 
            for idx in range(len(T)):
                fk=1
                for j in [i for i in rg(len(T)) if i != idx]:
                    fk=fk*(x-j)/(idx-j)
                TmpF=TmpF + g.subs(x==f).subs(x==idx)*fk
            g=TmpF
        return [(i, g.subs(x==i)) for i in rg(len(T))]

def local_iterate_tuple(T, Lv):
    """
    This function iterates the input function described by a tuple list 
    locally on the subset of the domain Lv specified as a list. This
    implementation is motivated by the generalization of the composition
    lemma. This implementation assume that the input list of tuples describes 
    is valid and the input list Lv is also valid.

    EXAMPLES:
    ::


        sage: T=[(0,1), (1,2), (2,2)]; Lv=rg(2)
        sage: local_iterate_tuple(T,Lv)
        [(0, 2), (1, 2), (2, 2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    rT=[]
    for i in rg(len(T)):
        if T[i][0] in Lv:
            rT.append((T[i][0],T[T[i][1]][1]))
        else:
            rT.append(T[i])
    return rT

def composition_inverse(f, sz, vrbl):
    """
    This function computes the composition inverse of f.
    The implementation test whether f is invertible.


    EXAMPLES:
    ::


        sage: sz=3; f0=BasicLagrangeInterpolation([(0,1), (1,2), (2,0)], x)
        sage: f1=composition_inverse(f0, sz, x)
        sage: expand(compose_with(f0, f1, sz, x))
        x


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of a tuple description for f
    TpL=[(f.subs(vrbl==i), i) for i in rg(sz)]; TpL.sort()
    if [t[0] for t in TpL] == rg(sz):
        g = BasicLagrangeInterpolation(TpL, vrbl) 
    else:
        raise ValueError("The input function must be invertible")
    return g

def find_sink(tp):
    """
    Finds the sink (also called root of a functional tree).


    EXAMPLES:

    ::


        sage: find_sink([(0, 0), (1, 3), (2, 1), (3, 0), (4, 0)])
        0
        

    AUTHORS:
    - Edinah K. Gnang
    """
    T=[(tp[i][0],tp[i][1]) for i in tpl_image_set(tp)]
    for i in rg(len(tp)):
        T=[(tp[i][0],tp[i][1]) for i in tpl_image_set(T)]
    return T[0][0]

def FindTreeTupleComponentsII(T):
    """
    Returns a tuple list each of which corresponds to a pair
    made up of a vertex and the associated sink vertex.
    This implementation assume the input is a tree.


    EXAMPLES:

    ::


        sage: FindTreeTupleComponentsII([(0, 0), (1, 2), (2, 4), (3, 7), (4, 4), (5, 0), (6, 0), (7, 0)])
        [(0, 0), (1, 4), (2, 4), (3, 0), (4, 4), (5, 0), (6, 0), (7, 0)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Classifying the vertices
    C=[(find_sink(T),find_sink(T))]
    Rg=rg(len(T)); Rg.remove(find_sink(T))
    for j in Rg:
        i=j; cnt=0
        while T[i][1] != T[i][0] and cnt <= len(T)+1:
            i=T[i][1]; cnt=cnt+1
        if T[i][1] == T[i][0]:
            C.append((j,T[i][0]))
        else:
            raise ValueError("Expected a tree")
    C.sort()
    return C

def switch_sink(Tn, alpha):
    """
    Switches the sink from of the input functional tree to alpha.


    EXAMPLES:

    ::


        sage: switch_sink([(0, 0), (1, 3), (2, 1), (3, 0), (4, 0)], 1)
        [(0, 3), (1, 1), (2, 1), (3, 1), (4, 0)]



    AUTHORS:
    - Edinah K. Gnang
    """
    a = find_sink(Tn)
    if a == alpha:
        return Tn
    else:
        # The new sink will be alpha instead of a
        Tp=[]
        # Obtaining the spine made up of the path from alpha to a
        Snk=[]; i=alpha; Tp.append((alpha, alpha))
        while Tn[i][0] != a and Tn[i][1] != a:
            Tp.append((Tn[i][1], Tn[i][0])); Snk.append(Tn[i][0])
            i=Tn[i][1]
            #print 'Tp=',Tp
        Tp.append((Tn[i][1], Tn[i][0])); Snk.append(Tn[i][0])
        Snk.append(Tn[i][1])
        #print 'Snk=',Snk
        # Partioning the vertices of Tn by components
        C=FindTreeTupleComponentsII(Tn)
        #print 'C=',C
        # Initialization of the list of vertices in the partition a
        Sa=Set([C[i][0] for i in range(len(Tn)) if C[i][1]==a])
        #print 'Sa=',Sa
        # Correcting the orrientation of the remaining edges
        while Set(Snk) != Sa:
            for i in Sa:
                if (Tn[i][0] in Snk) and (Tn[i][1] not in Snk):
                    Tp.append((Tn[i][1], Tn[i][0])); Snk.append(Tn[i][1])
                elif (Tn[i][0] not in Snk) and (Tn[i][1] in Snk):
                    Tp.append((Tn[i][0], Tn[i][1])); Snk.append(Tn[i][0])
        # Sorting the list
        Tp.sort()
        return Tp

def switch_sinkII(Tn, alpha):
    """
    Switches the sink from of the input functional tree to alpha.
    Assumes that the input is a functional tree rooted as zero
    Used in the harmonious labeling paper

    EXAMPLES:

    ::


        sage: switch_sinkII([(0, 0), (1, 3), (2, 1), (3, 0), (4, 0)], 1)
        [(0, 0), (1, 3), (2, 0), (3, 0), (4, 1)]



    AUTHORS:
    - Edinah K. Gnang, Michael P. Williams
    """
    # Initialization of the size parameter
    sz=len(Tn)
    # Initialization of the transpositions function in tuple descriptions
    Tp=[(0, alpha)]
    for i in rg(1,sz):
        if i == alpha:
           Tp.append((alpha, 0))
        else:
           Tp.append((i,i))
    return compose_tuple(compose_tuple(Tp,switch_sink(Tn,alpha)),Tp)

def pre_image_set(tp, L):
    """
    returns the list of vertex pre-images of the input vertex set.
    The input graphs is assumes to have no isolated vertices.

    EXAMPLES:

    ::

        sage: pre_image_set([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)], [0])
        [0, 3, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    return Set([t[0] for t in tp if t[1] in L]).list()

def tpl_pre_image_set(tp, i):
    """
    returns the list of vertex pre-images of the input vertex.
    The input graphs is assumes to have no isolated vertices.

    EXAMPLES:

    ::

        sage: tpl_pre_image_set([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)], 0)
        [0, 3, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    return Set([t[0] for t in tp if t[1]==i]).list()

def tpl_image_set(tp):
    """
    returns the list of vertex image of the domain of the input
    function associated with the list of tuples.
    The input graphs is assumes to have no isolated vertices.


    EXAMPLES:

    ::

        sage: tpl_image_set([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)])
        [0, 2, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing and sorting the list
    L=Set([t[1] for t in tp]).list(); L.sort()
    return L

def tpl_image_setII(tp,Ld):
    """
    returns the list of vertex image of the subset of the domain described by the 
    list Ld of the input function associated with the list of tuples.
    The input graphs is assumes to have no isolated vertices.


    EXAMPLES:

    ::

        sage: tpl_image_setII([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)], rg(4))
        [0, 2, 4]
        sage: tpl_image_setII([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)], rg(1,3))
        [2, 4]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing and sorting the list
    L=Set([tp[i][1] for i in Ld]).list(); L.sort()
    return L

def tpl_pre_image_set_function(tp):
    """
    returns the list of vertex pre-images of every vertex
    the vertices being sorted in increasing order.
    The input graphs is assumes to have no isolated vertices.


    EXAMPLES:

    ::

        sage: tpl_pre_image_set_function([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)])
        [[0, 3, 4], [], [1], [], [2]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    return [tpl_pre_image_set(tp, i) for i in rg(len(tp))]

def tpl_pre_image_set_functionII(tp):
    """
    returns the list of vertex pre-images of every vertex
    the vertices being sorted in increasing order.
    The input graphs is assumes to have no isolated vertices.
    The difference with the previous function is that loop edges
    are removed


    EXAMPLES:

    ::

        sage: tpl_pre_image_set_functionII([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)])
        [[3, 4], [], [1], [], [2]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    return [[v for v in tpl_pre_image_set(tp, i) if v != i] for i in rg(len(tp))]

def tpl_leaf_set(tp):
    """
    returns the list of leaf vertex set of the functional directed graph
    function associated with the list of tuples.


    EXAMPLES:

    ::

        sage: tpl_leaf_set([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)])
        [1, 3]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing and sorting the list
    L0=Set([t[1] for t in tp]).list(); L0.sort()
    L1=[tp[i][0] for i in rg(len(tp)) if not tp[i][0] in L0]; L1.sort()
    return L1

def generate_sorted_hist(Tf, X):
    """
    returns the list of monomoial describing the sorted histogram of proper colorings
    for the input functional digraph having a unique fixed point. The code was written
    in connection with Stanley's conjecture.


    EXAMPLES:

    ::

        sage: sz=Integer(3); Tf=[(0,0)]+[(i,i-1) for i in rg(1,sz)]; X=var_list('x',sz)
        sage: generate_sorted_hist(Tf, X)
        [x0^2*x1, x0*x1*x2]
        sage: sz=5; Tf=[(0,0)]+[(i,i+1) for i in rg(1,sz-1)]+[(sz-1,1)]; X=var_list('x',sz)
        sage: generate_sorted_hist(Tf, X)
        [x0^3*x1^2, x0^2*x1^2*x2, x0^3*x1*x2, x0^2*x1*x2*x3, x0*x1*x2*x3*x4]


    AUTHORS:
    - Edinah K. Gnang; Kailee Lin
    """
    # Initializing the size parameter
    sz=Integer(len(Tf))
    # Testing that Tf has a unique fixed point
    if len([(i,Tf[i][1]) for i in rg(sz) if i==Tf[i][1]])==1:
        # Initialization of the fixed point
        rt=[i for i in rg(sz) if i==Tf[i][1]][0]
        # Initialize the list Z_n^Z_n
        Lg=TupleFunctionList(sz)
        # Initializing the histogram
        Lhst=[]
        # Main loop filling Lhst
        for Tg in Lg:
            if prod((compose_tuple(Tg,Tf)[i][1]-Tg[i][1]) for i in rg(sz) if i!=rt) !=0:
                # Initializin the list of exponents and sorting it
                tmpL=[len(pre_image_set(Tg,[i])) for i in rg(sz)]; tmpL.sort()
                # Test to check that tmpL is new
                if not prod(X[sz-1-i]^tmpL[i] for i in rg(sz)) in Lhst:
                    # Update the list of histogram
                    Lhst.append(prod(X[sz-1-i]^tmpL[i] for i in rg(sz)))
        # returning the result
        return Lhst
    else: 
        raise ValueError("Expected a functional digraph with a unique fixed point.")

def generate_sorted_histII(Tf, X):
    """
    returns the list of monomoial describing the sorted histogram of proper colorings
    for the input functional digraph having a unique fixed point. The code was written
    in connection with Stanley's conjecture.


    EXAMPLES:

    ::

        sage: sz=Integer(3); Tf=[(0,0)]+[(i,i-1) for i in rg(1,sz)]; X=var_list('x', sz)
        sage: generate_sorted_histII(Tf, X)
        [x0*x1, x0^2]
        sage: sz=Integer(5); Tf=[(0,0)]+[(i,i+1) for i in rg(1,sz-1)]+[(sz-1,1)]; X=var_list('x', sz)
        sage: generate_sorted_histII(Tf, X)
        [x0^2*x1*x2, x0^2*x1^2, x0*x1*x2*x3]


    AUTHORS:
    - Edinah K. Gnang; Kailee Lin
    """
    # Initializing the size parameter
    sz=Integer(len(Tf))
    # Initialization of Adjacency matrix
    Af=Tuple_to_Adjacency(Tf); Aid=Tuple_to_Adjacency([(i,i) for i in rg(sz)])
    # Initialization of the signed incidence matrices
    A=(Af-Aid)
    # Testing that Tf has a unique fixed point
    if len([(i,Tf[i][1]) for i in rg(sz) if i==Tf[i][1]])==1:
        # Initialization of the fixed point
        rt=[i for i in rg(sz) if i==Tf[i][1]][0]
        # Initilizing a list of variables for the histogram
        X=var_list('x', sz)
        # Initialize the list Z_n^Z_n
        Lg=TupleFunctionList(sz)
        # Initializing the histogram
        Lhst=[]
        # Main loop filling Lhst
        for Tg in Lg:
            if prod(A[i,Tg[i][1]] for i in rg(sz) if i!=rt)!=0:
                # Initializing the list of exponents and sorting it
                tmpL=[len([v for v in tpl_pre_image_set(Tg,u) if v!=rt]) for u in rg(sz)]; tmpL.sort()
                # Test to check that tmpL is new
                if not prod(X[sz-1-i]^tmpL[i] for i in rg(sz)) in Lhst:
                    # Update the list of histogram
                    Lhst.append(prod(X[sz-1-i]^tmpL[i] for i in rg(sz)))
        # returning the result
        return Lhst
    else: 
        raise ValueError("Expected a functional digraph with a unique fixed point.")

def tpl_pre_image_cardinality_map(T, Codomain):
    """
    returns the tuple list description of the induced map whose
    domain is the Codomain specified as a list of integers the 
    input tuple description of the input function.


    EXAMPLES:

    ::

        sage: tpl_pre_image_cardinality_map([(0, 0), (1, 2), (2, 4), (3, 0), (4, 0)], rg(5))
        [(0, 3), (1, 0), (2, 1), (3, 0), (4, 1)]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    Tp=[(Codomain[i], len(tpl_pre_image_set(T,Codomain[i]))) for i in rg(len(Codomain))]; Tp.sort()
    return Tp

def tuple_order(T):
    """
    Given a tuple description of a function the present function
    determines the LCM of the cycle lengths which appear in the graph
    The implementation uses the adjacency matrix of the functional
    directed graph.


    EXAMPLES:

    ::

        sage: sz=Integer(4); T=[(i, Integer(mod(i+1,sz))) for i in rg(sz)]; tuple_order(T)
        4
        sage: sz=Integer(6); T=[(0, 0), (1, 2), (2, 1), (3, 4), (4, 5), (5, 3)]; tuple_order(T)
        6
        sage: sz=Integer(8); T=[(0, 1), (1, 0)]+[(2, 3), (3, 4), (4, 2)]+[(i, i-1) for i in rg(5, sz)]; tuple_order(T)
        6


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(T))
    # Initializing the symbolic edge weights
    A=HM(sz,sz,'a')
    # Initialization of the adjacency matrix
    At=A.elementwise_product(Tuple_to_Adjacency(T))
    # Initialization of the polynomial which computes the cycle lengths
    F=Modulo(sum((At^k).trace() for k in rg(1,sz+1)), A.list(), [v^2 for v in A.list()])[1]
    #print("F = ", F)
    add = var('x0') + var('x1'); mul = var('x0') * var('x1')
    if F.operator() == add.operator():
        Lt=[Monomial2Tuple(mnm, A.list(), sz) for mnm in F.operands()] 
        #print('Lt = ', Lt)
    elif F.operator() == mul.operator():
       Lt=[Monomial2Tuple(F, A.list(), sz)] 
    return LCM([len(l) for l in Lt])

def gcomp(tp, tq):
    """
    Performs the absolute difference composition of functions
    the inputs to the function are two tuple lists of the same
    size. The current version does not check that the list are
    in fact of the same size.


    EXAMPLES:

    ::

        sage: tp=[(0,1), (1,2), (2,3), (3,0)]; tq=[(0,0), (1,0), (2,0), (3,0)]
        sage: gcomp(tp, tq)
        [(0, 1), (1, 2), (2, 3), (3, 0)]
       

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(tq); tr=[(i,i) for i in rg(sz)]
    # Updating the composition
    for i in rg(sz):
        tr[abs(tq[i][1]-tq[i][0])] = (abs(tq[i][0]-tq[i][1]), tp[abs(tq[i][0]-tq[i][1])][1])
    return tr

def functionaldigraphincidenceHM(T):
    """
    Returns the transpose of the conventional incidence matrix associated with the input
    tree specified by a list of tuples associated with the function. 


    EXAMPLES:

    ::

        sage: functionaldigraphincidenceHM([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)])
        [[0, 0, 0, 0, 0], [1, -1, 0, 0, 0], [1, 0, -1, 0, 0], [1, 0, 0, -1, 0], [1, 0, 0, 0, -1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return Tuple_to_Adjacency(T)-HM(2,len(T),'kronecker')

def functionaldigraphunsignedincidenceHM(T):
    """
    Returns the transpose of the unsigned incidence matrix associated with the input
    tree specified by a list of tuples associated with the function. 


    EXAMPLES:

    ::

        sage: functionaldigraphunsignedincidenceHM([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)])
        [[2, 0, 0, 0, 0], [1, 1, 0, 0, 0], [1, 0, 1, 0, 0], [1, 0, 0, 1, 0], [1, 0, 0, 0, 1]]


    AUTHORS:
    - Edinah K. Gnang
    """
    return Tuple_to_Adjacency(T)+HM(2,len(T),'kronecker')

def EuclidsGCD(a, b):
    """

    This function implements Euclid's GCD algorithm.
    The function checks that the inputs are non-zero
    integers and returns as output the matrix which
    describes all the iterations of the algorithm.


    EXAMPLES:
    ::


        sage: G=EuclidsGCD(89, 55); G.printHM()
        [:, :]=
        [89 55  1 34]
        [55 34  1 21]
        [34 21  1 13]
        [21 13  1  8]
        [13  8  1  5]
        [ 8  5  1  3]
        [ 5  3  1  2]
        [ 3  2  1  1]
        [ 2  1  2  0]


    AUTHORS:
    - Edinah K. Gnang
    """
    if type(a)==type(Integer(1)) and type(b)==type(Integer(1)) and a*b !=0:
        # Initialization of the matrix Data Structure.
        G = HM(1, 4, 'zero')
        # Initialization of the initial conditions
        G[0, 0] = a; G[0, 1] = b
        G[0, 3] = Integer(mod(G[0, 0], G[0, 1]))
        G[0, 2] = (G[0, 0] - G[0, 3])/G[0, 1]
        # Initialization of the index
        indx = 0
        while G[indx, 3] != 0:
            # Updating the size of G
            G=G.zero_pad([G.n(0)+1, G.n(1)])
            # Incrementing the index
            indx=indx+1
            G[indx, 0] = G[indx-1, 1]; G[indx, 1] = G[indx-1, 3]
            G[indx, 3] = Integer(mod(G[indx, 0], G[indx, 1]))
            G[indx, 2] = (G[indx, 0] - G[indx, 3])/G[indx, 1]
        return G
    else:
        raise ValueError("Expected non zero integer inputs.")

def IntegerBezout(a, b):
    """

    This function uses Euclid's GCD algorithm to devise the
    Bezouts identity Z-linear combination which yields the GCD.
    Cramers identity is also used here. The function checks
    that the inputs are non-zero integers and returns as output
    the matrix which describes all the iterations of the algorithm.


    EXAMPLES:
    ::


        sage: a=189; b=55; [G, M, s, t]=IntegerBezout(a, b); G.p()
        [:, :]=
        [189  55   3  24]
        [ 55  24   2   7]
        [ 24   7   3   3]
        [  7   3   2   1]
        [  3   1   3   0]
        sage: s*a+t*b
        1


    AUTHORS:
    - Edinah K. Gnang
    """
    if type(a)==type(Integer(1)) and type(b)==type(Integer(1)) and a*b !=0:
        # Initialization of the matrix Data Structure.
        G = HM(1, 4, 'zero')
        # Initialization of the initial conditions
        G[0, 0] = a; G[0, 1] = b
        G[0, 3] = Integer(mod(G[0, 0], G[0, 1]))
        G[0, 2] = (G[0, 0] - G[0, 3])/G[0, 1]
        # Initialization of the index
        indx = 0
        while G[indx, 3] != 0:
            # Updating the size of G
            G=G.zero_pad([G.n(0)+1, G.n(1)])
            # Incrementing the index
            indx=indx+1
            G[indx, 0] = G[indx-1, 1]; G[indx, 1] = G[indx-1, 3]
            G[indx, 3] = Integer(mod(G[indx, 0], G[indx, 1]))
            G[indx, 2] = (G[indx, 0] - G[indx, 3])/G[indx, 1]
        # Filling up the matrix
        M=HM(G.n(0)-1,G.n(0)-1,'zero')
        # Initialization of the first two rows of the matrix
        M[0,0]=1; M[1,0]=G[1,2]; M[1,1]=1
        # Loop Filling up the rest of the matrix
        for i in rg(2,G.n(0)-1):
            # Filling up the i-th row
            M[i,i-2]=Integer(1); M[i,i-1]=-G[i,2]; M[i,i]=-Integer(1)
        # Computing Bezout's coefficients
        s=M.slice(rg(1,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()
        t=-G[0,2]*M.slice(rg(1,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()-\
        M.slice([0]+rg(2,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()
        return [G, M, -s, -t]
    else:
        raise ValueError("Expected non zero integer inputs.")

def Modulo(f, VrbL, Rlts):
    """
    Outputs the quotient and the remainder of the simultaneous
    Euclidean division. The algorithm takes as input
    a multivariate polynomial f in the variables in the
    input list VrbL and a list of monic univariate polynomial
    which correspond to the relations we are moding by.
    All polynomials must be inputed in expanded form otherwise
    the output is incorrect. This implementation does not work
    for the univariate case


    EXAMPLES:

    ::
        
        sage: VrbL = var_list('x', 2); f = expand((VrbL[0]+VrbL[1])^10); Rlts = [VrbL[0]^2-5, VrbL[1]^3-7]; Modulo(f, VrbL, Rlts)[1]
        44100*x0*x1^2 + 35650*x0*x1 + 39150*x1^2 + 108430*x0 + 184093*x1 + 260375
        sage: sz=Integer(3); X=var_list('x',sz); P=expand(prod(prod(X[i]^(3+2*i) for i in rg(sz))-j for j in rg(sz)))
        sage: G0 = expand(Modulo(P, X, [expand(prod(X[i]-j for j in rg(sz))) for i in rg(sz)])[1]); G0
        4380205822152*x0^2*x1^2*x2^2 - 4380201691920*x0^2*x1^2*x2 - 4379939196912*x0^2*x1*x2^2 - 4363039572840*x0*x1^2*x2^2 + 4379935066848*x0^2*x1*x2 + 4363035457488*x0*x1^2*x2 + 4362773971728*x0*x1*x2^2 - 4362769856544*x0*x1*x2
        sage: Rlts = [expand((x1 - 1)*(x1 - 2)*x1), expand((x0 - 1)*(x0 - 2)*x0), expand((x2 - 1)*(x2 - 2)*x2)]
        sage: G1 = expand(Modulo(P, [x1,x0,x2], Rlts)[1]); G1
        4380205822152*x0^2*x1^2*x2^2 - 4380201691920*x0^2*x1^2*x2 - 4379939196912*x0^2*x1*x2^2 - 4363039572840*x0*x1^2*x2^2 + 4379935066848*x0^2*x1*x2 + 4363035457488*x0*x1^2*x2 + 4362773971728*x0*x1*x2^2 - 4362769856544*x0*x1*x2
        sage: G0-G1
        0
        sage: expand(sum(P.subs([X[i]==T[i][1] for i in rg(sz)])*prod(prod((X[i]-ji)/(T[i][1]-ji) for ji in rg(sz) if ji!=T[i][1]) for i in rg(sz)) for T in Lf))
        4380205822152*x0^2*x1^2*x2^2 - 4380201691920*x0^2*x1^2*x2 - 4379939196912*x0^2*x1*x2^2 - 4363039572840*x0*x1^2*x2^2 + 4379935066848*x0^2*x1*x2 + 4363035457488*x0*x1^2*x2 + 4362773971728*x0*x1*x2^2 - 4362769856544*x0*x1*x2
        sage: F0 = Modulo(P, X, [expand(prod(X[i]-j for j in rg(sz))) for i in rg(sz)])[0]; F0
        (x0^3 - 3*x0^2 + 2*x0)*x0^6*x1^15*x2^21 + 3*(x0^3 - 3*x0^2 + 2*x0)*x0^5*x1^15*x2^21 + 7*(x0^3 - 3*x0^2 + 2*x0)*x0^4*x1^15*x2^21 + (4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^18 + 3*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^17 + 7*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^16 + 15*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^15 + 31*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^14 + 63*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^13 + (255*x0^2*x2^21 - 254*x0*x2^21)*(x1^3 - 3*x1^2 + 2*x1)*x1^12 + 127*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^12 + 3*(255*x0^2*x2^21 - 254*x0*x2^21)*(x1^3 - 3*x1^2 + 2*x1)*x1^11 + 12*(88771421*x0^2*x1^2 - 88766010*x0^2*x1 - 88423410*x0*x1^2 + 88418020*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^11 + 7*(255*x0^2*x2^21 - 254*x0*x2^21)*(x1^3 - 3*x1^2 + 2*x1)*x1^10 + 2*(1067322123*x0^2*x1^2 - 1067257110*x0^2*x1 - 1063138566*x0*x1^2 + 1063073804*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^10 + 15*(255*x0^2*x2^21 - 254*x0*x2^21)*(x1^3 - 3*x1^2 + 2*x1)*x1^9 + 6*(712236439*x0^2*x1^2 - 712193070*x0^2*x1 - 709444926*x0*x1^2 + 709401724*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^9 + 31*(255*x0^2*x2^21 - 254*x0*x2^21)*(x1^3 - 3*x1^2 + 2*x1)*x1^8 + 2*(4275483705*x0^2*x1^2 - 4275223410*x0^2*x1 - 4258727202*x0*x1^2 + 4258467908*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^8 + 3*(5355*x0^2*x2^21 - 5334*x0*x2^21 - 31*x0^2*x2^14 + 30*x0*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^7 + 6*(2851010827*x0^2*x1^2 - 2850837270*x0^2*x1 - 2839837350*x0*x1^2 + 2839664460*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^7 + (32385*x0^2*x2^21 - 32258*x0*x2^21 - 279*x0^2*x2^14 + 270*x0*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^6 + 2*(17108130033*x0^2*x1^2 - 17107088610*x0^2*x1 - 17041081746*x0*x1^2 + 17040044324*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^6 + 3*(21675*x0^2*x2^21 - 21590*x0*x2^21 - 217*x0^2*x2^14 + 210*x0*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^5 + 762*(89811877*x0^2*x1^2 - 89806410*x0^2*x1 - 89459898*x0*x1^2 + 89454452*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^5 + (130305*x0^2*x2^21 - 129794*x0*x2^21 - 1395*x0^2*x2^14 + 1350*x0*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^4 + 12*(11406452565*x0^2*x1^2 - 11405758242*x0^2*x1 - 11361749992*x0*x1^2 + 11361058336*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^4 + 3*(5*x1^15*x2^21 - x1^10*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0^3 + 93*(2805*x0^2*x2^21 - 2794*x0*x2^21 - 31*x0^2*x2^14 + 30*x0*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^3 + 24*(11406624658*x0^2*x1^2 - 11405930328*x0^2*x1 - 11361921465*x0*x1^2 + 11361229802*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^3 + (31*x1^15*x2^21 - 9*x1^10*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0^2 + (521985*x0^2*x2^21 - 519938*x0*x2^21 - 5859*x0^2*x2^14 + 5670*x0*x2^14 + 6*x0^2*x2^7 - 4*x0*x2^7)*(x1^3 - 3*x1^2 + 2*x1)*x1^2 + 24*(22813421409*x0^2*x1^2 - 22812032742*x0^2*x1 - 22724014403*x0*x1^2 + 22722631070*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^2 + 21*(3*x1^15*x2^21 - x1^10*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0 + 3*(348075*x0^2*x2^21 - 346710*x0*x2^21 - 3937*x0^2*x2^14 + 3810*x0*x2^14 + 6*x0^2*x2^7 - 4*x0*x2^7)*(x1^3 - 3*x1^2 + 2*x1)*x1 + 24*(45627014911*x0^2*x1^2 - 45624237570*x0^2*x1 - 45448200279*x0*x1^2 + 45445433606*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2 + (127*x1^15*x2^21 - 45*x1^10*x2^14 + 2*x1^5*x2^7)*(x0^3 - 3*x0^2 + 2*x0) + (2088705*x0^2*x2^21 - 2080514*x0*x2^21 - 23715*x0^2*x2^14 + 22950*x0*x2^14 + 42*x0^2*x2^7 - 28*x0*x2^7)*(x1^3 - 3*x1^2 + 2*x1) + 24*(91254201915*x0^2*x1^2 - 91248647226*x0^2*x1 - 90896572031*x0*x1^2 + 90891038678*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)
        sage: F1 = Modulo(P, [x1,x0,x2], Rlts)[0]; F1
        (x1^3 - 3*x1^2 + 2*x1)*x0^9*x1^12*x2^21 + 3*(x1^3 - 3*x1^2 + 2*x1)*x0^9*x1^11*x2^21 + 7*(x1^3 - 3*x1^2 + 2*x1)*x0^9*x1^10*x2^21 + 15*(x1^3 - 3*x1^2 + 2*x1)*x0^9*x1^9*x2^21 + 31*(x1^3 - 3*x1^2 + 2*x1)*x0^9*x1^8*x2^21 + (4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^18 + 3*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^17 + 7*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^16 + 15*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^15 + 31*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^14 + 63*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^13 + 127*(4177665*x0^2*x1^2 - 4177410*x0^2*x1 - 4161282*x0*x1^2 + 4161028*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^12 + 12*(88771421*x0^2*x1^2 - 88766010*x0^2*x1 - 88423410*x0*x1^2 + 88418020*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^11 + 2*(1067322123*x0^2*x1^2 - 1067257110*x0^2*x1 - 1063138566*x0*x1^2 + 1063073804*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^10 + 6*(712236439*x0^2*x1^2 - 712193070*x0^2*x1 - 709444926*x0*x1^2 + 709401724*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^9 + 2*(4275483705*x0^2*x1^2 - 4275223410*x0^2*x1 - 4258727202*x0*x1^2 + 4258467908*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^8 + 3*(21*x0^9*x2^21 - x0^6*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^7 + 6*(2851010827*x0^2*x1^2 - 2850837270*x0^2*x1 - 2839837350*x0*x1^2 + 2839664460*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^7 + (16383*x1^2*x2^21 - 16382*x1*x2^21)*(x0^3 - 3*x0^2 + 2*x0)*x0^6 + (127*x0^9*x2^21 - 9*x0^6*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^6 + 2*(17108130033*x0^2*x1^2 - 17107088610*x0^2*x1 - 17041081746*x0*x1^2 + 17040044324*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^6 + 3*(16383*x1^2*x2^21 - 16382*x1*x2^21)*(x0^3 - 3*x0^2 + 2*x0)*x0^5 + 3*(85*x0^9*x2^21 - 7*x0^6*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^5 + 762*(89811877*x0^2*x1^2 - 89806410*x0^2*x1 - 89459898*x0*x1^2 + 89454452*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^5 + 7*(16383*x1^2*x2^21 - 16382*x1*x2^21)*(x0^3 - 3*x0^2 + 2*x0)*x0^4 + (511*x0^9*x2^21 - 45*x0^6*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^4 + 12*(11406452565*x0^2*x1^2 - 11405758242*x0^2*x1 - 11361749992*x0*x1^2 + 11361058336*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^4 + 3*(81915*x1^2*x2^21 - 81910*x1*x2^21 - 511*x1^2*x2^14 + 510*x1*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0^3 + 93*(11*x0^9*x2^21 - x0^6*x2^14)*(x1^3 - 3*x1^2 + 2*x1)*x1^3 + 24*(11406624658*x0^2*x1^2 - 11405930328*x0^2*x1 - 11361921465*x0*x1^2 + 11361229802*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^3 + (507873*x1^2*x2^21 - 507842*x1*x2^21 - 4599*x1^2*x2^14 + 4590*x1*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0^2 + (2047*x0^9*x2^21 - 189*x0^6*x2^14 + 2*x0^3*x2^7)*(x1^3 - 3*x1^2 + 2*x1)*x1^2 + 24*(22813421409*x0^2*x1^2 - 22812032742*x0^2*x1 - 22724014403*x0*x1^2 + 22722631070*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2^2 + 21*(49149*x1^2*x2^21 - 49146*x1*x2^21 - 511*x1^2*x2^14 + 510*x1*x2^14)*(x0^3 - 3*x0^2 + 2*x0)*x0 + 3*(1365*x0^9*x2^21 - 127*x0^6*x2^14 + 2*x0^3*x2^7)*(x1^3 - 3*x1^2 + 2*x1)*x1 + 24*(45627014911*x0^2*x1^2 - 45624237570*x0^2*x1 - 45448200279*x0*x1^2 + 45445433606*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)*x2 + (2080641*x1^2*x2^21 - 2080514*x1*x2^21 - 22995*x1^2*x2^14 + 22950*x1*x2^14 + 30*x1^2*x2^7 - 28*x1*x2^7)*(x0^3 - 3*x0^2 + 2*x0) + (8191*x0^9*x2^21 - 765*x0^6*x2^14 + 14*x0^3*x2^7)*(x1^3 - 3*x1^2 + 2*x1) + 24*(91254201915*x0^2*x1^2 - 91248647226*x0^2*x1 - 90896572031*x0*x1^2 + 90891038678*x0*x1)*(x2^3 - 3*x2^2 + 2*x2)


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the degree matrix
    Dm = degree_matrix(Rlts, VrbL)
    for i in rg(min(Dm.n(0), Dm.n(1))):
        for j in rg(min(Dm.n(0), Dm.n(1))):
            Dm[i,j]=0
    if Dm.is_zero():
        # Initialization of the quotient
        # and the initial remainder.
        q = 0; r = f
        for v in rg(len(VrbL)):
            for d in rg(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]), -1, -1):
                q = q + (VrbL[v]^d)*r.coefficient(VrbL[v]^(d+Rlts[v].degree(VrbL[v])))*Rlts[v]
                r = expand(fast_reduce(r, [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))], [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
        return [q, r]
    else:
        raise ValueError("Expected univariate algebraic relations.")

def ModuloII(f, VrbL, Rlts):
    """
    Outputs the remainder of the simultaneous
    Euclidean division. The algorithm takes as input
    a multivariate polynomial f in the variables in the
    input list VrbL and a list of monic univariate polynomial
    which correspond to the relations we are moding by.
    The imput polynomials must be presented in expanded form
    otherwise the output may be incorrect. This implementation
    does not work for the univariate case.


    EXAMPLES:

    ::
        
        sage: VrbL = var_list('x', 2); f = expand((VrbL[0]+VrbL[1])^10); Rlts = [VrbL[0]^2-5, VrbL[1]^3-7]
        sage: ModuloII(f, VrbL, Rlts)
        44100*x0*x1^2 + 35650*x0*x1 + 39150*x1^2 + 108430*x0 + 184093*x1 + 260375
        

    AUTHORS:
    - Edinah K. Gnang
    - To Do: Implment faster version
    """
    # Initialization of the degree matrix
    Dm = degree_matrix(Rlts, VrbL)
    # Updating only the diagonal entries to zero
    for i in rg(min(Dm.n(0), Dm.n(1))):
        for j in rg(min(Dm.n(0), Dm.n(1))):
            Dm[i,j]=0
    if Dm.is_zero():
        # Initialization of the initial remainder.
        r = f
        for v in rg(len(VrbL)):
            for d in rg(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]), -1, -1):
                r = expand(fast_reduce(r, [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))], [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
        return r
    else:
        raise ValueError("Expected univariate algebraic relations.")

def ModuloUnivarRelations(F, Xv, Rlts):
    """
    Outputs the sequence reduced polynomials for Euclidean division.
    The algorithm takes as input a multivariate polynomial F in the
    variables in the input list Xv and a list of monic univariate polynomial
    which correspond the same polynomial in different variables. All polynomials
    must be inputed in expanded form otherwise the output is incorrect.
    This implementation assumes that the input is a polynomial and not a single mononial
    term.

    EXAMPLES:

    ::
        
        sage: Xv=var_list('x',2); F = expand((Xv[0]+Xv[1])^10); Rlts = [Xv[0]^3-7, Xv[1]^3-7]; ModuloUnivarRelations(F, Xv, Rlts)
        [x0^10 + 10*x0^9*x1 + 45*x0^8*x1^2 + 120*x0^7*x1^3 + 210*x0^6*x1^4 + 252*x0^5*x1^5 + 210*x0^4*x1^6 + 120*x0^3*x1^7 + 45*x0^2*x1^8 + 10*x0*x1^9 + x1^10,
         x0^10 + x1^10 + 840*x0^7 + 840*x1^7 - (x0^3 - 7)^3*x0 - (x1^3 - 7)^3*x1 - 840*(x0^3 - 7)^2*x0 + 45*(x1^8 - (x1^3 - 7)^2*x1^2)*x0^2 - 840*(x1^3 - 7)^2*x1 + 45*(x0^8 - (x0^3 - 7)^2*x0^2)*x1^2 + 252*(x0^5 - (x0^3 - 7)*x0^2)*(x1^5 - (x1^3 - 7)*x1^2) + 210*(x1^6 - (x1^3 - 7)^2)*(x0^4 - (x0^3 - 7)*x0) + 210*(x0^6 - (x0^3 - 7)^2)*(x1^4 - (x1^3 - 7)*x1) + 10*(x1^9 - (x1^3 - 7)^3)*x0 + 10*(x0^9 - (x0^3 - 7)^3)*x1,
         21*x0^7 + 21*x1^7 + 11613*x0^4 + 7938*x0^2*x1^2 + 11613*x1^4 - 21*(x0^3 - 7)^2*x0 + 630*(x1^5 - (x1^3 - 7)*x1^2)*x0^2 - 21*(x1^3 - 7)^2*x1 + 630*(x0^5 - (x0^3 - 7)*x0^2)*x1^2 + 210*(x1^6 - (x1^3 - 7)^2)*x0 - 11613*(x0^3 - 7)*x0 + 210*(x0^6 - (x0^3 - 7)^2)*x1 - 11613*(x1^3 - 7)*x1 + 24353*x0 + 24353*x1,
         294*x0^4 + 16758*x0^2*x1^2 + 294*x1^4 - 294*(x0^3 - 7)*x0 - 294*(x1^3 - 7)*x1 + 114905*x0 + 114905*x1]
        sage: Xv=var_list('x',2); F=expand((Xv[0]+Xv[1])^5); Rlts=[Xv[i]*(Xv[i]-1) for i in rg(len(Xv))]; rmdL=ModuloUnivarRelations(F, Xv, Rlts); rmdL
        [x0^5 + 5*x0^4*x1 + 10*x0^3*x1^2 + 10*x0^2*x1^3 + 5*x0*x1^4 + x1^5,
         -(x0 - 1)^2*x0^3 + x0^5 - (x1 - 1)^2*x1^3 + x1^5 + 10*((x1 - 1)*x1^2 - x1^3)*((x0 - 1)*x0 - x0^2) + 10*((x0 - 1)*x0^2 - x0^3)*((x1 - 1)*x1 - x1^2) - 5*((x1 - 1)^2*x1^2 - x1^4)*x0 - 5*((x0 - 1)^2*x0^2 - x0^4)*x1,
         -2*(x0 - 1)^2*x0^2 + 2*x0^4 - 2*(x1 - 1)^2*x1^2 + 2*x1^4 + (x0 - 1)*x0^2 - x0^3 + (x1 - 1)*x1^2 - x1^3 - 10*((x1 - 1)*x1^2 - x1^3)*x0 - 5*((x1 - 1)*x1 - x1^2)*x0 - 10*((x0 - 1)*x0^2 - x0^3)*x1 - 5*((x0 - 1)*x0 - x0^2)*x1,
         -4*(x0 - 1)*x0^2 + 4*x0^3 - 4*(x1 - 1)*x1^2 + 4*x1^3 - 10*((x1 - 1)*x1 - x1^2)*x0 + 3*(x0 - 1)*x0 - 3*x0^2 - 10*((x0 - 1)*x0 - x0^2)*x1 + 10*x0*x1 + 3*(x1 - 1)*x1 - 3*x1^2,
         -4*(x0 - 1)*x0 + 4*x0^2 + 30*x0*x1 - 4*(x1 - 1)*x1 + 4*x1^2 - 3*x0 - 3*x1]
        sage: for i in rg(len(rmdL)): # Loop checking that the canonical reamainder is the same.
        ....:     print(expand(remainder_via_lagrange_interpolation(expand(rmdL[0]), rg(2), Xv)))
        ....:
        30*x0*x1 + x0 + x1
        30*x0*x1 + x0 + x1
        30*x0*x1 + x0 + x1
        30*x0*x1 + x0 + x1
        30*x0*x1 + x0 + x1


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the degree of the polynomial
    m=Rlts[0].degree(Xv[0])
    # Initialization of the list of coefficients
    Lc=[trm.subs([Xv[i]==1 for i in rg(len(Xv))]) for trm in F.operands()] #print('Lc=',Lc)
    # Initialization of the list of monomials
    Lt=[trm/trm.subs([Xv[i]==1 for i in rg(len(Xv))]) for trm in F.operands()] #print('Lt=',Lt)
    # Initialization of the tuple descriptions associated with the monomial support
    Lh=[[(i,SR(trm).degree(Xv[i])) for i in rg(len(Xv))] for trm in F.operands()] #print('Lh=',Lh)
    # Initialization of the first remainder
    rmd=F; rmdL=[F]
    while max([rmd.degree(Xv[i]) for i in rg(len(Xv))]) >= m:
        rmd=sum(Lc[t]*prod(Xv[i]^Lh[t][i][1] for i in rg(len(Xv)) if Lh[t][i][1]<m)*prod(Xv[i]^Lh[t][i][1]-Xv[i]^(Lh[t][i][1]-m*floor(Lh[t][i][1]/m))*(Rlts[i])^floor(Lh[t][i][1]/m) for i in rg(len(Xv)) if Lh[t][i][1]>=m) for t in rg(len(Lh)))
        rmdL.append(rmd)
        # Expanding the remainder obtained at the current iteration
        rmd=expand(rmd)
        # Obtaining the new list of coefficients
        Lc=[trm.subs([Xv[i]==1 for i in rg(len(Xv))]) for trm in rmd.operands()]
        # Obtaining the new list of terms
        Lt=[trm/trm.subs([Xv[i]==1 for i in rg(len(Xv))]) for trm in rmd.operands()]
        # Obtaining the new list of tuple descriptions associated with the monomial support
        Lh=[[(i, SR(trm).degree(Xv[i])) for i in rg(len(Xv))] for trm in rmd.operands()]
    return rmdL

def CanonicalModulo(f, VrbL, Rlts):
    """
    Outputs the quotient divisor part as well as the remainder of
    the simultaneous Euclidean division.
    This implementation accounts for the different orderings of the relations
    The algorithm takes as input a multivariate polynomial f in the variables in the
    input list VrbL and a list of monic univariate polynomial
    which correspond to the relations we are moding by.
    All polynomials must be inputed in expanded form otherwise
    the output is incorrect. It is tacitly assumed here that the relations are
    univariate polynomial in each of the variable. The benefit of this implementation
    is the fact that we can tell from the quotient divisor part whether the input polynomial
    is symmetric


    EXAMPLES:

    ::
        
        sage: VrbL = var_list('x', 2); f = expand((VrbL[0]+VrbL[1])^10); Rlts = [VrbL[0]^2-5, VrbL[1]^3-7]; CanonicalModulo(f, VrbL, Rlts)[0]
        (x0^2 - 5)*x0^8 + 10*(x0^2 - 5)*x0^7*x1 + 5*(x0^2 - 5)*(9*x1^2 + 1)*x0^6 + 45/2*(x1^3 - 7)*x0^2*x1^5 + 10*(x1^3 - 7)*x0*x1^6 + (x1^3 - 7)*x1^7 + 5*(12*x1^3 + 5*x1)*(x0^2 - 5)*x0^5 + 5*(x0^2 - 5)*x0^5*(5*x1 + 84) + 5/2*(42*x1^4 + 45*x1^2 + 5)*(x0^2 - 5)*x0^4 + 5/2*(x0^2 - 5)*(45*x1^2 + 294*x1 + 5)*x0^4 + 1/2*(120*x0^3 + 7)*(x1^3 - 7)*x1^4 + 1/2*(x1^3 - 7)*(600*x0 + 7)*x1^4 + 225/2*(x1^3 - 7)*x1^5 + (126*x1^5 + 300*x1^3 + 125*x1)*(x0^2 - 5)*x0^3 + (x0^2 - 5)*(882*x1^2 + 125*x1 + 2100)*x0^3 + 35*(3*x0^4 + x0)*(x1^3 - 7)*x1^3 + 35*(x1^3 - 7)*(x0 + 75)*x1^3 + 5/2*(42*x1^6 + 210*x1^4 + 225*x1^2 + 25)*(x0^2 - 5)*x0^2 + 5/2*(x0^2 - 5)*(225*x1^2 + 1470*x1 + 2083)*x0^2 + 63/2*(4*x0^5 + 5*x0^2)*(x1^3 - 7)*x1^2 + 1575/2*(x1^3 - 7)*(4*x0 + 1)*x1^2 + 5*(12*x1^7 + 126*x1^5 + 300*x1^3 + 125*x1)*(x0^2 - 5)*x0 + 5*(x0^2 - 5)*(882*x1^2 + 713*x1 + 2100)*x0 + 7/2*(30*x0^6 + 120*x0^3 + 7)*(x1^3 - 7)*x1 + 7/2*(x1^3 - 7)*(600*x0 + 3757)*x1 + 5*(12*x0^7 + 147*x0^4 + 49*x0)*(x1^3 - 7) + 5/2*(9*x1^8 + 210*x1^6 + 1050*x1^4 + 1125*x1^2 + 125)*(x0^2 - 5) + 5/2*(x0^2 - 5)*(1566*x1^2 + 7350*x1 + 10415) + 5*(x1^3 - 7)*(1549*x0 + 3675)
        sage: sz=Integer(2); X=var_list('x',sz); P=expand((X[1]-X[0])^4)
        sage: G0 = CanonicalModulo(P, X, [expand(prod(X[i]-j for j in rg(sz))) for i in rg(sz)])[0]; G0
        1/2*(x0^2 - x0)*x0^2 - 1/2*(x0^2 - x0)*x0*(4*x1 - 1) - 1/2*(x1^2 - x1)*(4*x0 - 1)*x1 - 2*(x0^2 - x0)*x0*x1 - 2*(x1^2 - x1)*x0*x1 + 1/2*(x1^2 - x1)*x1^2 + (x0^2 - x0)*(3*x1^2 - 2*x1) + (3*x0^2 - 2*x0)*(x1^2 - x1) + 1/2*(x1^2 - x1)*(2*x0 + 1) + 1/2*(x0^2 - x0)*(2*x1 + 1)
        sage: G1 = CanonicalModulo(P, [X[1], X[0]], [expand(prod(X[i]-j for j in rg(sz))) for i in [Integer(1),Integer(0)]])[0]; G1
        1/2*(x0^2 - x0)*x0^2 - 1/2*(x0^2 - x0)*x0*(4*x1 - 1) - 1/2*(x1^2 - x1)*(4*x0 - 1)*x1 - 2*(x0^2 - x0)*x0*x1 - 2*(x1^2 - x1)*x0*x1 + 1/2*(x1^2 - x1)*x1^2 + (x0^2 - x0)*(3*x1^2 - 2*x1) + (3*x0^2 - 2*x0)*(x1^2 - x1) + 1/2*(x1^2 - x1)*(2*x0 + 1) + 1/2*(x0^2 - x0)*(2*x1 + 1)
       


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the degree matrix
    Dm = degree_matrix(Rlts, VrbL)
    for i in rg(min(Dm.n(0), Dm.n(1))):
        for j in rg(min(Dm.n(0), Dm.n(1))):
            Dm[i,j]=0
    if Dm.is_zero():
        # Initialization of the quotient
        # and the initial remainder.
        q = 0; r = f
        for v in rg(len(VrbL)):
            for d in rg(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]), -1, -1):
                q = q + (VrbL[v]^d)*r.coefficient(VrbL[v]^(d+Rlts[v].degree(VrbL[v])))*Rlts[v]
                r = expand(fast_reduce(r, [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))], [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
    else:
        raise ValueError("Expected univariate algebraic relations.")
    # Initialization of the list of permutation
    Sn=PermutationFunctionList(len(VrbL))
    for T in Sn[1:]:
        # Initialization of the of the permutation of the variables
        VrbL=[VrbL[T[i][1]] for i in rg(len(VrbL))]; Rlts=[Rlts[T[i][1]] for i in rg(len(VrbL))]
        # Initialization of the quotient
        # and the initial remainder.
        tmp_q = 0; tmp_r = f
        for v in rg(len(VrbL)):
            for d in rg(f.degree(VrbL[v])-Rlts[v].degree(VrbL[v]), -1, -1):
                tmp_q = tmp_q + (VrbL[v]^d)*tmp_r.coefficient(VrbL[v]^(d+Rlts[v].degree(VrbL[v])))*Rlts[v]
                tmp_r = expand(fast_reduce(tmp_r, [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))], [VrbL[v]^(d+Rlts[v].degree(VrbL[v]))-expand(Rlts[v]*VrbL[v]^d)])) 
        # Updating the quotient
        q=q+tmp_q
    return [q/factorial(len(VrbL)), r]

def remainder_via_lagrange_interpolation(f, Lr, X):
    """
    Returns the canonical representative of the residue class
    f modulo Ld. The input f is an arbitrary multivariate polynomial
    in the variables stored in the list input X. Lr is is the list of distinct
    roots of the monic univariate polynomial associated with each variable.
    This implementation does not require the input polynomial to be in 
    factored form


    EXAMPLES:
    ::

        sage: sz=3; X=var_list('x',sz); f=expand(var('x0')^2*var('x1')+var('x2')^4); Lr=rg(sz)
        sage: expand(remainder_via_lagrange_interpolation(f, Lr, X))
        x0^2*x1 + 7*x2^2 - 6*x2
        sage: expand(remainder_via_lagrange_interpolation(f, rg(5), X))
        x2^4+x0^2*x1
        sage: sz=Integer(3); w=exp(2*pi*sqrt(-1)/3); X=var_list('x',sz); f=expand(var('x0')^2*var('x1')+var('x2')^4); Lr=[w^k for k in rg(sz)]
        sage: expand(remainder_via_lagrange_interpolation(f, Lr, X)).simplify_full()
        x0^2*x1+x2
        sage: sz=Integer(3); Xv=var_list('x',sz); T=[(0,0)]+[(i,i-1) for i in rg(1,sz)]; T # Initialization
        [(0, 0), (1, 0), (2, 1)]
        sage: vV=prod(Xv[j]-Xv[i] for i in rg(sz) for j in rg(sz) if i<j)
        sage: eV=prod((Xv[T[j][1]]-Xv[j])*(Xv[T[j][1]]^(2*sz-2)-Xv[j]^(2*sz-2))-(Xv[T[i][1]]-Xv[i])*(Xv[T[i][1]]^(2*sz-2)-Xv[i]^(2*sz-2)) for i in rg(sz) for j in rg(sz) if i<j)
        sage: F=vV*eV; w=exp(2*pi*I/(2*sz-1)); Lrh=[w^i for i in rg(2*sz-1)]; cF=remainder_via_lagrange_interpolation(f, Lr, X)

    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization the number of variables
    sz0=Integer(len(X)); sz1=Integer(len(Lr))
    return sum(f.subs([X[i] == Lr[t[i][1]] for i in rg(sz0)])*prod(prod((X[k]-jk)/(Lr[t[k][1]]-jk) for jk in Lr if jk !=Lr[t[k][1]]) for k in rg(sz0) ) for t in TupleFunctionListII(sz0, sz1))

def canonical_representative(f, Lr, X):
    """
    Returns the canonical representative of the residue class
    f modulo Ld. The input f is an arbitrary multivariate polynomial
    in the variables stored in the list input X. Lr is is the list of distinct
    roots of the monic univariate polynomial associated with each variable.
    This implementation does not require the input polunomial to be in 
    factored form. Easier to remember compared to the previous function name.


    EXAMPLES:
    ::

        sage: sz=3; X=var_list('x',sz); f=expand(var('x0')^2*var('x1')+var('x2')^4); Lr=rg(sz)
        sage: expand(canonical_representative(f, Lr, X))
        x0^2*x1 + 7*x2^2 - 6*x2


    AUTHORS:

    - Edinah K. Gnang
    """
    return remainder_via_lagrange_interpolation(f, Lr, X)

def GeneralHypermatrixFlatten(A, dms, indx):
    """
    Outputs a lower order flattened hypermatrix computed from the higher order 
    input. The second input corresponds to the desired dimensions for the 
    flattened hypermatrix. The third input is the index of the most significant
    index. The default flatteing scheme is the column major order 
    

    EXAMPLES:

    ::
        sage: sz=3; A=HM(sz,sz,sz,'a')
        sage: GeneralHypermatrixFlatten(A, [sz, sz^2], 0).printHM() # Flattening scheme with the most significant index being 0
        [:, :]=
        [a000 a010 a020 a001 a011 a021 a002 a012 a022]
        [a100 a110 a120 a101 a111 a121 a102 a112 a122]
        [a200 a210 a220 a201 a211 a221 a202 a212 a222]
        sage: HM(sz,sz,sz,GeneralHypermatrixFlatten(A, [sz, sz^2], 0).list())-A # Checking the folding
        [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
        sage: GeneralHypermatrixFlatten(A, [sz, sz^2], 1).printHM()
        [:, :]=
        [a000 a001 a002 a100 a101 a102 a200 a201 a202]
        [a010 a011 a012 a110 a111 a112 a210 a211 a212]
        [a020 a021 a022 a120 a121 a122 a220 a221 a222]
        sage: HM(sz,sz,sz,GeneralHypermatrixFlatten(A, [sz, sz^2], 1).list())-A.transpose() # Checking the folding
        [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
        sage: GeneralHypermatrixFlatten(A, [sz, sz^2], 2).printHM()
        [:, :]=
        [a000 a100 a200 a010 a110 a210 a020 a120 a220]
        [a001 a101 a201 a011 a111 a211 a021 a121 a221]
        [a002 a102 a202 a012 a112 a212 a022 a122 a222] 
        sage: HM(sz,sz,sz,GeneralHypermatrixFlatten(A, [sz, sz^2], 2).list())-A.transpose(2) # Checking the folding
        [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]]
 

    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    - To Do: 
    """
    if len(dms) >= A.order() or prod(dms) != prod(A.dimensions()):
        raise ValueError("Expected smaller order dimensions which match in their products")
    else:
        Ls=dms+[A.transpose(indx).list()]
        return HM(*Ls)

def KroneckerVectorOuterProduct(*args):
    """
    Outputs the hypermatrix resulting from the outer product
    of properly embeded and orriented vectors. The input
    are column vector of any order. This operation is motivated
    by the classical vector outer-product.


    EXAMPLES:
 
    ::

        sage: U=HM(2,1,var_list('u',3)); V=HM(3,1,var_list('v',3)); W=HM(4,1,var_list('w',4))
        sage: KroneckerVectorOuterProduct(U, V, W).printHM()
        [:, :, 0]=
        [u0*v0*w0 u0*v1*w0 u0*v2*w0]
        [u1*v0*w0 u1*v1*w0 u1*v2*w0]
        <BLANKLINE>
        [:, :, 1]=
        [u0*v0*w1 u0*v1*w1 u0*v2*w1]
        [u1*v0*w1 u1*v1*w1 u1*v2*w1]
        <BLANKLINE>
        [:, :, 2]=
        [u0*v0*w2 u0*v1*w2 u0*v2*w2]
        [u1*v0*w2 u1*v1*w2 u1*v2*w2]
        <BLANKLINE>
        [:, :, 3]=
        [u0*v0*w3 u0*v1*w3 u0*v2*w3]
        [u1*v0*w3 u1*v1*w3 u1*v2*w3]
        sage: U=HM(2,1,var_list('u',3)); V=HM(3,1,var_list('v',3))
        sage: KroneckerVectorOuterProduct(U, V).printHM()
        [:, :]=
        [u0*v0 u0*v1 u0*v2]
        [u1*v0 u1*v1 u1*v2]


    AUTHORS: Edinah Gnang and Fan Tian
    - To Do: 
    """
    if len(args) == 2:
        return Prod(HM((args[0]).n(0),1,(args[0]).list()), HM((args[1]).n(0),1,(args[1]).list()).transpose())
    else:
        # Initialization of the canonical embeding into vectors of the appropriate order.
        #Lv = [apply(HM,[(args[i]).n(0)]+[1 for j in rg(len(args)-1)]+[(args[i]).list()]) for i in rg(len(args))]
        Lv = [HM(*([(args[i]).n(0)]+[1 for j in rg(len(args)-1)]+[(args[i]).list()])) for i in rg(len(args))]
        # Initialization of the list hypermatrix slices of the appropriate orders.
        #Lh=[Lv[j].tensor_product(apply(HM,[1,1]+[(args[i]).n(0) for i in rg(2,len(args))]+['one'])) for j in rg(len(args))]
        Lh=[Lv[j].tensor_product(HM(*([1,1]+[(args[i]).n(0) for i in rg(2,len(args))]+['one']))) for j in rg(len(args))]
        # returning the BM product of the appropriately orriented slices
        return Prod(*[Lh[i].transpose(len(args)-i) for i in rg(len(args))])

def HypermatrixList(bnd, DmsL):
    """
    Outputs a list of all hypermatrix with entries
    in {0,1,2,...,bnd-1} of size specified by the list DmsL
    This fucntion is motivated by the study of hypermatrices
    with elements from a finite field.


    EXAMPLES:
 
    ::

        sage: L=HypermatrixList(2,[2,2,2])
        sage: L[0].printHM()
        [:, :, 0]=
        [0 0]
        [0 0]
        <BLANKLINE>
        [:, :, 1]=
        [0 0]
        [0 0]


    AUTHORS: Edinah Gnang 
    - To Do: 
    """
    # Initialization of the list specifying the dimensions of the output
    l=[bnd for i in rg(prod(DmsL))]
    # Initialization of the list of Hypermatrices
    Lh=[]
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        #Lh.append(apply(HM,DmsL+[entry]))
        Lh.append(HM(*(DmsL+[entry])))
    return Lh

def HypermatrixSn(L):
    """
    Generates the permutation pair of third order hypermatrices.
    hypermatrix deduced from sigma. Note that as a result of 
    the  non associativity, permutations must be performed as
    one transposition at a time.

    EXAMPLES:

    ::

        sage: P0,P1 = HypermatrixSn([1,2,0])
        sage: Prod(P0,HM(3,3,3,'a'),P1).printHM()
        [:, :, 0]=
        [a001 a011 a021]
        [a101 a111 a121]
        [a201 a211 a221]
        <BLANKLINE>
        [:, :, 1]=
        [a002 a012 a022]
        [a102 a112 a122]
        [a202 a212 a222]
        <BLANKLINE>
        [:, :, 2]=
        [a000 a010 a020]
        [a100 a110 a120]
        [a200 a210 a220]


    AUTHORS:
    - Edinah K. Gnang, Ori Parzanchevski, Fan Tian 
    """
    sz=len(L)
    # Test for dimension match
    if sz > 0:
        # Initialization of the first input (P0)
        P0=HM([HM(2,L,'perm').transpose().listHM() for i in rg(sz)])
        # Initialization of the second input (P1)
        P1=HM([HM(2,L,'perm').listHM() for i in rg(sz)]).transpose(2)
        return [P0, P1]
    else :
        raise ValueError("Input list must me non empty ")

def layer_rotation(M, v):
    """
    Performs a layered rotation which amounts to viewing the entries
    as forming a spanning union of cycles whose cycles are made up
    of layers of entries. The input matrix M must be square, the second
    input v must be a character will will be used as the base symbol 
    variable to be used to fill up the template matrix. It is 
    important that indexings of v do not appear in M. In this current
    implementation it will cause bugs.


    EXAMPLES:

    ::


        sage: [U, V]=layer_rotation(HM(4,4,'c'), 'a')
        sage: U.printHM()
        [:, :]=
        [c10 c00 c01 c02]
        [c20 c21 c11 c03]
        [c30 c22 c12 c13]
        [c31 c32 c33 c23]
        sage: V.printHM()
        [:, :]=
        [c01 c02 c03 c13]
        [c00 c12 c22 c23]
        [c10 c11 c21 c33]
        [c20 c30 c31 c32]        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=min(M.dimensions())
    # Iinitialization of the symbolic template matrix
    # This codes collects all the layers into a list of lists
    A=HM(sz, sz, v); L=[[] for i in rg(ceil(sz/2))]
    for l in rg(ceil(sz/2)): 
        TmpA = A.slice(rg(l,sz-l),0).slice(rg(l,sz-l),1)
        for i in rg(3):
            hA = TmpA.index_rotation(-2*i*pi/4)
            tmpL=hA.listHM()[0]
            for j in rg(hA.n(1)):
                if not tmpL[j] in L[l]:
                    L[l].append(tmpL[j])
        tmpL=TmpA.transpose().listHM()[0]
        tmpL.reverse()
        for j in rg(hA.n(1)):
            if not tmpL[j] in L[l]:
                L[l].append(tmpL[j])
    # Performing the cyclic permutation
    Ln=[l[1:]+[l[0]] for l in L]
    # Concatenating the lists
    L0=L[0];L1=Ln[0]
    for i in rg(1,len(L)):
        L0=L0+L[i]; L1=L1+Ln[i]
    # Performing the substition for the forward mapping
    B=A.subs([L1[i]==L0[i] for i in rg(len(L0))])
    # Performing the substition for the backward mapping
    C=A.subs([L0[i]==L1[i] for i in rg(len(L0))])
    return [B.subs([A[i,j]==M[i,j] for j in rg(sz) for i in rg(sz)]), C.subs([A[i,j]==M[i,j] for j in rg(sz) for i in rg(sz)])]
 
def ThirdOrderIdentityPair(DimList):
    """
    Generates the left right identity pair for a midel third
    order hypermatrix whose dimensions corresponds to the input
    

    EXAMPLES:

    ::

        sage: A=HM(2,3,4,'a')
        sage: I0,I1 = ThirdOrderIdentityPair(A.dimensions())
        sage: Prod(I0, A, I1).printHM()
        [:, :, 0]=
        [a000 a010 a020]
        [a100 a110 a120]
        <BLANKLINE>
        [:, :, 1]=
        [a001 a011 a021]
        [a101 a111 a121]
        <BLANKLINE>
        [:, :, 2]=
        [a002 a012 a022]
        [a102 a112 a122]
        <BLANKLINE>
        [:, :, 3]=
        [a003 a013 a023]
        [a103 a113 a123]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the first of the two identity hypermatrix pairs
    I0=HM(DimList[0], DimList[2], DimList[2], 'zero')
    for i in rg(I0.n(0)):
        for t in rg(I0.n(1)):
            I0[i,t,t]=1
    # Initialization of the second of the two identity hypermatrix pairs
    I1=HM(DimList[2], DimList[1], DimList[2], 'zero')
    for j in rg(I1.n(1)):
        for t in rg(I1.n(0)):
            I1[t,j,t]=1
    return [I0, I1]

def GeneralHypermatrixSupport(A):
    """
    Procedure for determining the support
    of non-zero entries

    EXAMPLES:

    ::

        sage: GeneralHypermatrixSupport(HM(2,2,2,'a')).printHM()
        [:, :, 0]=
        [1 1]
        [1 1]
        <BLANKLINE>
        [:, :, 1]=
        [1 1]
        [1 1]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list specifying the dimensions of the output
    l = [A.n(i) for i in range(A.order())]
    # Initializing the input for generating a symbolic hypermatrix
    inpts = l+['zero']
    # Initialization of the hypermatrix
    Rh = HM(*inpts)
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        if A[tuple(entry)].is_zero():
            Rh[tuple(entry)]=Integer(0)
        else:
            Rh[tuple(entry)]=Integer(1)
    return Rh

def EliminationHM(Ha):
    """
    Performs row operations to zero out entries bellow the first pivot
    row operation involve roots of unity whose primitive member is of
    the number of non-zero entries in the first column i.e. row operations
    are root of unity weighted linear combination of a maximal number of
    of rows.


    EXAMPLES:
 
    ::

        sage: sz=Integer(2); Ha=HM(sz,sz,'a') # Initialization of a symbolic 3x3 matrix
        sage: Hb=EliminationHM(Ha); Hb.p() # Performing the elimination
        [:, :]=
        [              a00               a01]
        [                0 a01*a10 - a00*a11]


        sage: sz=Integer(3); Ha=HM(sz,sz,'a') # Initialization of a symbolic 3x3 matrix
        sage: Hb=EliminationHM(Ha); Hb.p() # Performing the elimination
        [:, :]=
        [                                                                                                    a00                                                                                                     a01                                                                                                     a02]
        [                                                                                                      0                                                                                       a01*a20 - a00*a21                                                                                       a02*a20 - a00*a22]
        [                                                                                                      0 1/2*I*sqrt(3)*a00*a11*a20 - 1/2*I*sqrt(3)*a00*a10*a21 + a01*a10*a20 - 1/2*a00*a11*a20 - 1/2*a00*a10*a21 1/2*I*sqrt(3)*a00*a12*a20 - 1/2*I*sqrt(3)*a00*a10*a22 + a02*a10*a20 - 1/2*a00*a12*a20 - 1/2*a00*a10*a22]


        sage: sz=Integer(3); Ha=HM(sz,sz,'a'); Ha[1,0]=SR(0) # Initialization of a symbolic 3x3 matrix
        sage: Hb=EliminationHM(Ha); Hb.p() # Performing the elimination
        [:, :]=
        [              a00               a01               a02]
        [                0 a01*a20 - a00*a21 a02*a20 - a00*a22]
        [                0               a11               a12]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of a copy of the input matrix
    A=Ha.copy()
    # Initialization of the list of indices of zero entries in the first column
    ZrIndxL=[i for i in rg(A.n(0)) if A[i,0].is_zero()]
    # Initialization of the list of indices of non-zero entries in the first column
    nZrIndxL=[i for i in rg(A.n(0)) if not i in ZrIndxL]
    # Checking that if there are only zero entries bellow the pivot in the first column
    if len(ZrIndxL)>=A.n(0)-1:
        # Reodering the rows to ensure that rows whose first entry is equal to 0 appear at the bottom of the matrix
        A=HM([A.slice([i],0).list() for i in nZrIndxL]+[A.slice([j],0).list() for j in ZrIndxL])
        return A
    else:
        # While there are are non-zero entries bellow the pivot in the first column we run this loop
        while len([i for i in rg(A.n(0)) if A[i,0].is_zero()])<A.n(0)-1:
            # Initialization of the matrix
            A=HM([A.slice([i],0).list() for i in nZrIndxL]+[A.slice([j],0).list() for j in ZrIndxL])
            # Update the list of indices of zero entries on the first column
            ZrIndxL=[i for i in rg(A.n(0)) if A[i,0].is_zero()]
            # Update the list of indices of the nonzero entries on the first column
            nZrIndxL=[i for i in rg(A.n(0)) if not i in ZrIndxL]
            # Initialization of the root of unity
            od=len(nZrIndxL); w=exp(I*2*pi/od)
            #print('od = ',od)
            # Initialization of a dictionary
            Dct=dict([(i,nZrIndxL[i]) for i in rg(len(nZrIndxL))])
            #print('Dct = ',Dct)
            # Performing the row operation
            Sm=sum([w^k*prod(A[Dct[i],0] for i in rg(len(nZrIndxL)) if i != Dct[k])*A.slice([Dct[k]],0) for k in rg(len(nZrIndxL))])
            #print('Sm = ',Sm)
            # Updating the matrix row
            for j in rg(A.n(1)):
                A[1,j]=Sm[0,j]
            # Update the list of indices of zero entries on the first column
            ZrIndxL=[i for i in rg(A.n(0)) if A[i,0].is_zero()]
            # Update the list of indices of the nonzero entries on the first column
            nZrIndxL=[i for i in rg(A.n(0)) if not i in ZrIndxL]
    #return A
    return A.expand()

def GaussianEliminationHM(Ha):
    """
    This method repeatedly call the EliminationHM by
    root of unity weighted linear combination
    method to put the input matrix in Row Echelon Form


    EXAMPLES:
 
    ::

        sage: sz=Integer(3); Ha=HM(sz,sz,'a') # Initialization of a symbolic 3x3 matrix
        sage: Hb=GaussianEliminationHM(Ha); Hb.p()
        [:, :]=
        [                                                                                                                                                                                                                                                                                                                                                              a00                                                                                                                                                                                                                                                                                                                                                               a01                                                                                                                                                                                                                                                                                                                                                               a02]
        [                                                                                                                                                                                                                                                                                                                                                                0                                                                                                                                                                                                                                                                                                                                                 a01*a20 - a00*a21                                                                                                                                                                                                                                                                                                                                                 a02*a20 - a00*a22]
        [                                                                                                                                                                                                                                                                                                                                                                0                                                                                                                                                                                                                                                                                                                                                                 0 1/2*I*sqrt(3)*a00*a02*a11*a20^2 - 1/2*I*sqrt(3)*a00*a01*a12*a20^2 - 1/2*I*sqrt(3)*a00*a02*a10*a20*a21 + 1/2*I*sqrt(3)*a00^2*a12*a20*a21 + 1/2*I*sqrt(3)*a00*a01*a10*a20*a22 - 1/2*I*sqrt(3)*a00^2*a11*a20*a22 - 1/2*a00*a02*a11*a20^2 + 1/2*a00*a01*a12*a20^2 + 1/2*a00*a02*a10*a20*a21 - 1/2*a00^2*a12*a20*a21 - 1/2*a00*a01*a10*a20*a22 + 1/2*a00^2*a11*a20*a22]
        sage: factor(Hb[2,2])
        1/2*(a02*a11*a20 - a01*a12*a20 - a02*a10*a21 + a00*a12*a21 + a01*a10*a22 - a00*a11*a22)*a00*a20*(I*sqrt(3) - 1)
        sage: sz=Integer(2); Ha=HM(sz,sz,'a') # Initialization of a symbolic 3x3 matrix
        sage: Hb=GaussianEliminationHM(Ha); Hb.p()
        [:, :]=
        [              a00               a01]
        [                0 a01*a10 - a00*a11]
        sage: sz=Integer(3); Lx=var_list('x',sz); Vx=Vandermonde(Lx)
        sage: Hb=GaussianEliminationHM(Vx); Hb.p()
        [:, :]=
        [                                                                                                                                                                                                                                                            1                                                                                                                                                                                                                                                             1                                                                                                                                                                                                                                                             1]
        [                                                                                                                                                                                                                                                            0                                                                                                                                                                                                                                                   x0^2 - x1^2                                                                                                                                                                                                                                                   x0^2 - x2^2]
        [                                                                                                                                                                                                                                                            0                                                                                                                                                                                                                                                             0 1/2*I*sqrt(3)*x0^4*x1 - 1/2*I*sqrt(3)*x0^3*x1^2 - 1/2*I*sqrt(3)*x0^4*x2 + 1/2*I*sqrt(3)*x0^2*x1^2*x2 + 1/2*I*sqrt(3)*x0^3*x2^2 - 1/2*I*sqrt(3)*x0^2*x1*x2^2 - 1/2*x0^4*x1 + 1/2*x0^3*x1^2 + 1/2*x0^4*x2 - 1/2*x0^2*x1^2*x2 - 1/2*x0^3*x2^2 + 1/2*x0^2*x1*x2^2]
        sage: factor(Hb[2,2])
        1/2*(x0 - x1)*(x0 - x2)*x0^2*(x1 - x2)*(I*sqrt(3) - 1)




    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of a copy of the input matrix
    A=Ha.copy()
    for i in rg(A.n(0)-1):
        A=A.fill_with(EliminationHM(A.slice(rg(i,A.n(0)),'row').slice(rg(i,A.n(1)),'col')),[i,i])
    return A

def GaussJordanEliminationHM(Ha):
    """
    This method repeatedly call the EliminationHM by root of unity weighted linear combination
    method to put the input matrix in Reduced Row Echelon Form. This implementation makes use
    matrix index rotation operations. 


    EXAMPLES:
 
    ::

        sage: sz=Integer(2); Ha=HM(sz,sz,'a') # Initialization of a symbolic 3x3 matrix
        sage: Hb=GaussJordanEliminationHM(Ha); Hb.p()
        [:, :]=
        [-a00*a01*a10 + a00^2*a11                        0]
        [                       0        a01*a10 - a00*a11]


    AUTHORS:
    - Edinah K. Gnang
    - To Do: 
    """
    # Initialization of a copy of the input matrix
    A=Ha.copy()
    B=GaussianEliminationHM(A).index_rotation(2*2*pi/4)
    for i in rg(B.n(0)-1):
        B = B.fill_with(GaussianEliminationHM(B.slice(rg(i,A.n(0)),'row').slice(rg(i,A.n(1)),'col')),[i,i])
    return B.index_rotation(2*2*pi/4)

def EliminationHMI(Ha,i):
    """
    Procedure for performing a row linear combination which cancels the first entry
    of non-zero entries. This implementation can serve as the basis for a parallel
    solver. The input Ha is the coefficient matrix of the linear system where as
    the second input i correspond to the index of the row being replaced. This
    implementation has a very symbolic bent to it. It also handles zero initial
    entries for some of the rows


    EXAMPLES:

    ::

        sage: sz=3; Ha=HM(sz,sz,'a'); Hb=EliminationHMI(Ha,1).canonicalize_radical(); Hb.p()
        [:, :]=
        [                                                                              a00                                                                               a01                                                                               a02]
        [                                                                                0 -1/2*a00*a10*a21*(I*sqrt(3) + 1) - 1/2*(a00*a11*(-I*sqrt(3) + 1) - 2*a01*a10)*a20 -1/2*a00*a10*a22*(I*sqrt(3) + 1) - 1/2*(a00*a12*(-I*sqrt(3) + 1) - 2*a02*a10)*a20]
        [                                                                              a20                                                                               a21                                                                               a22]
        sage: sz=3; Ha=HM(sz,sz,'a'); Hb=EliminationHMI(Ha,2).canonicalize_radical(); Hb.p()
        [:, :]=
        [                                                                             a00                                                                              a01                                                                              a02]
        [                                                                             a10                                                                              a11                                                                              a12]
        [                                                                               0 1/2*a00*a10*a21*(I*sqrt(3) - 1) + 1/2*(a00*a11*(-I*sqrt(3) - 1) + 2*a01*a10)*a20 1/2*a00*a10*a22*(I*sqrt(3) - 1) + 1/2*(a00*a12*(-I*sqrt(3) - 1) + 2*a02*a10)*a20]
        sage: sz=3; Ha=HM(sz,sz,'a'); Ha[1,0]=0; Hb=EliminationHMI(Ha,1).canonicalize_radical(); Hb.p()
        [:, :]=
        [a00 a01 a02]
        [  0 a11 a12]
        [a20 a21 a22]
        sage: sz=4; Ha=HM(sz,sz,'a'); Ha[2,0]=0; Hb=EliminationHMI(Ha,3).canonicalize_radical(); Hb.p()                                                                                                                    
        [:, :]=
        [                                                                             a00                                                                              a01                                                                              a02                                                                              a03]
        [                                                                             a10                                                                              a11                                                                              a12                                                                              a13]
        [                                                                               0                                                                              a21                                                                              a22                                                                              a23]
        [                                                                               0 1/2*a00*a10*a31*(I*sqrt(3) - 1) + 1/2*(a00*a11*(-I*sqrt(3) - 1) + 2*a01*a10)*a30 1/2*a00*a10*a32*(I*sqrt(3) - 1) + 1/2*(a00*a12*(-I*sqrt(3) - 1) + 2*a02*a10)*a30 1/2*a00*a10*a33*(I*sqrt(3) - 1) + 1/2*(a00*a13*(-I*sqrt(3) - 1) + 2*a03*a10)*a30]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Testing that the first entry is not already zero
    if Ha[i,0].is_zero():
        return Ha
    else:
        # Initialization of a copy of the input hypermatrix
        Hr=Ha.copy()
        # Indexing the row with non-zero first entry
        eL=[u for u in rg(Ha.n(0)) if not Ha[u,0].is_zero()]
        # Initialization of the matrix A with rows in Ha whose first entry is non-zero
        A=Ha.slice(eL,0) #; A.p()
        # obtaining the new index
        for u in rg(len(eL)):
            if A.slice([u],'row') == Ha.slice([i],'row'):
                indx=u; break
        Sm=sum([exp(I*2*pi*indx*k/A.n(0))*GeneralHypermatrixScaleRight(GeneralHypermatrixScale(A.slice([k],'row'),prod(A[j,0] for j in rg(A.n(0)) if j<k)), prod([A[j,0] for j in rg(A.n(0)) if j>k])) for k in rg(A.n(0))])
        for jndx in rg(A.n(1)):
            Hr[i,jndx]=Sm[0,jndx]
        return Hr

def EliminationHMII(Ha):
    """
    Procedure for clearing bellow the first pivot


    EXAMPLES:

    ::

        sage: sz=3; Ha=HM(sz,sz,'a'); Hc=EliminationHMII(Ha).canonicalize_radical()
        sage: Hc.printHM()
        [:, :]=
        [                                                                              a00                                                                               a01                                                                               a02]
        [                                                                                0 -1/2*a00*a10*a21*(I*sqrt(3) + 1) - 1/2*(a00*a11*(-I*sqrt(3) + 1) - 2*a01*a10)*a20 -1/2*a00*a10*a22*(I*sqrt(3) + 1) - 1/2*(a00*a12*(-I*sqrt(3) + 1) - 2*a02*a10)*a20]
        [                                                                                0  1/2*a00*a10*a21*(I*sqrt(3) - 1) + 1/2*(a00*a11*(-I*sqrt(3) - 1) + 2*a01*a10)*a20  1/2*a00*a10*a22*(I*sqrt(3) - 1) + 1/2*(a00*a12*(-I*sqrt(3) - 1) + 2*a02*a10)*a20]
        sage: Deter(Hc).is_zero()
        False
        sage: Ha = HM([[HM(2,2,'a'),HM(2,2,'b'),HM(2,2,'c')],[HM(2,2,'d'),HM(2,2,'e'),HM(2,2,'f')],[HM(2,2,'g'),HM(2,2,'h'),HM(2,2,'i')]])
        sage: Hb=EliminationHMII(Ha); HM(sz,sz,[Hb[i,j].is_zero() for j in rg(sz) for i in rg(sz)]).printHM()
        [:, :]=
        [0 0 0]
        [1 0 0]
        [1 0 0]


    AUTHORS:
    - Edinah K. Gnang
    """
    A=Ha.copy(); B=Ha.copy()
    for i in rg(1,A.n(0)):
        # Zeroing out the first entry of row i
        Tmp=EliminationHMI(A,i)
        for jndx in rg(A.n(1)):
            B[i,jndx]=Tmp[i,jndx]
    return B

def GaussEliminationHMI(Ha):
    """
    Procedure for obtaining the Row Echelon Form (REF)


    EXAMPLES:

    ::

        sage: sz=3; Ha=HM(sz,sz,'a'); Hc=GaussEliminationHMI(Ha).canonicalize_radical()
        sage: Hc.printHM()
        [:, :]=
        [                                                                                                                                                                                        a00                                                                                                                                                                                         a01                                                                                                                                                                                         a02]
        [                                                                                                                                                                                          0                                                                                                           -1/2*a00*a10*a21*(I*sqrt(3) + 1) - 1/2*(a00*a11*(-I*sqrt(3) + 1) - 2*a01*a10)*a20                                                                                                           -1/2*a00*a10*a22*(I*sqrt(3) + 1) - 1/2*(a00*a12*(-I*sqrt(3) + 1) - 2*a02*a10)*a20]
        [                                                                                                                                                                                          0                                                                                                                                                                                           0 (-I*sqrt(3)*a00*a02*a10*a11 + I*sqrt(3)*a00*a01*a10*a12)*a20^2 + (I*sqrt(3)*a00*a02*a10^2 - I*sqrt(3)*a00^2*a10*a12)*a20*a21 + (-I*sqrt(3)*a00*a01*a10^2 + I*sqrt(3)*a00^2*a10*a11)*a20*a22]
        sage: Ha = HM([[HM(2,2,'a'),HM(2,2,'b'),HM(2,2,'c')],[HM(2,2,'d'),HM(2,2,'e'),HM(2,2,'f')],[HM(2,2,'g'),HM(2,2,'h'),HM(2,2,'i')]])
        sage: Hb=GaussEliminationHMI(Ha); HM(sz,sz,[Hb[i,j].is_zero() for j in rg(sz) for i in rg(sz)]).printHM()
        [:, :]=
        [0 0 0]
        [1 0 0]
        [1 1 0]


    AUTHORS:
    - Edinah K. Gnang
    """
    A=Ha.copy()
    for i in rg(A.n(0)-1):
        A = A.fill_with(EliminationHMII(A.slice(rg(i,A.n(0)),'row').slice(rg(i,A.n(1)),'col')),[i,i])
    return A

def GaussJordanEliminationHMI(Ha):
    """
    Procedure for obtaining the Reduced Row Echelon Form (RREF)


    EXAMPLES:

    ::

        sage: sz=2; Ha=HM(sz,sz,'a'); Hd=GaussJordanEliminationHM(Ha).canonicalize_radical()
        sage: Hd.printHM()
        [:, :]=
        [-a00*a01*a10 + a00^2*a11                        0]
        [                       0        a01*a10 - a00*a11]
        sage: Hb=GaussJordanEliminationHMI(Ha); Hb[0,1].is_zero()
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    A=Ha.copy()
    B=GaussEliminationHMI(A).index_rotation(2*2*pi/4)
    for i in rg(B.n(0)-1):
        B=B.fill_with(GaussEliminationHMI(B.slice(rg(i,A.n(0)),'row').slice(rg(i,A.n(1)),'col')),[i,i])
    return B.index_rotation(2*2*pi/4)

def general_derivative(f, v, od):
    """
    Returns the vector of generalized derivatives for the input function
    f in the variable v of order od.


    EXAMPLES:
    ::

        sage: f=x^2
        sage: general_derivative(f, x, 2).printHM()
        [:, :]=
        [2*h^2 + 4*h*x + 2*x^2]
        [                4*h*x]
        sage: general_derivative(f, x, 3).printHM()
        [:, :]=
        [3*h^2 + 6*h*x + 3*x^2]
        [                3*h^2]
        [                3*h^2]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the step variable
    h=var('h')
    # Initialization of the DFT matrix
    Ha=SecondOrderDFT(od,od)[0]
    return HM(od, 1, [sum(Ha[i,j]*f.subs(v==v+Ha[i,j]*h) for j in rg(od)) for i in rg(od)]).expand()

def Grph_EliminationHMII(Ha):
    """
    Procedure for clearing bellow the first pivot.
    This implementation is motivated by functional directed graph listing


    EXAMPLES:

    ::

        sage: sz=2; Ha=HM(sz,sz,'a'); Hc=Grph_EliminationHMII(Ha)
        sage: Hc.printHM()
        [:, :]=
        [        2*a00*a10 a01*a10 + a00*a11]
        [                0 a01*a10 - a00*a11]
        sage: sz=3; Ha=HM(sz,sz,'a'); Hc=Grph_EliminationHMII(Ha)
        sage: Hc.printHM()
        [:, :]=
        [                                                                    3*a00*a10*a20                                           a01*a10*a20 + a00*a11*a20 + a00*a10*a21                                           a02*a10*a20 + a00*a12*a20 + a00*a10*a22]
        [-1/2*a00*a10*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a20*(-I*sqrt(3) + 1) + a00*a10*a20 -1/2*a00*a10*a21*(I*sqrt(3) + 1) - 1/2*a00*a11*a20*(-I*sqrt(3) + 1) + a01*a10*a20 -1/2*a00*a10*a22*(I*sqrt(3) + 1) - 1/2*a00*a12*a20*(-I*sqrt(3) + 1) + a02*a10*a20]
        [-1/2*a00*a10*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a20*(-I*sqrt(3) + 1) + a00*a10*a20 -1/2*a00*a11*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a21*(-I*sqrt(3) + 1) + a01*a10*a20 -1/2*a00*a12*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a22*(-I*sqrt(3) + 1) + a02*a10*a20]


    AUTHORS:
    - Edinah K. Gnang
    """
    A=Ha.copy(); B=Ha.copy()
    #for i in rg(1,A.n(0)):
    for i in rg(A.n(0)):
        # Zeroing out the first entry of row i
        Tmp=EliminationHMI(A,i)
        for jndx in rg(A.n(1)):
            B[i,jndx]=Tmp[i,jndx]
    return B

def Grph_GaussEliminationHM(Ha):
    """
    Procedure for obtaining the Row Echelon Form (REF)
    This implementation is motivated by functional directed graph listing

    EXAMPLES:

    ::

        sage: sz=3; Ha=HM(sz,sz,'a'); Hc=Grph_GaussEliminationHM(Ha)
        sage: Hc.printHM()
        [:, :]=
        [                                                                                                                                                                                                                                                                                                                 3*a00*a10*a20                                                                                                                                                                                                                                                                                        a01*a10*a20 + a00*a11*a20 + a00*a10*a21                                                                                                                                                                                                                                                                                        a02*a10*a20 + a00*a12*a20 + a00*a10*a22]
        [                                                                                                                                                                                                                                             -1/2*a00*a10*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a20*(-I*sqrt(3) + 1) + a00*a10*a20                                                                                                                                                                  1/2*(a00*a11*a20*(I*sqrt(3) + 1) + a00*a10*a21*(-I*sqrt(3) + 1) - 2*a01*a10*a20)*(a00*a10*a21*(I*sqrt(3) + 1) + a00*a11*a20*(-I*sqrt(3) + 1) - 2*a01*a10*a20)  1/4*(a00*a12*a20*(I*sqrt(3) + 1) + a00*a10*a22*(-I*sqrt(3) + 1) - 2*a02*a10*a20)*(a00*a10*a21*(I*sqrt(3) + 1) + a00*a11*a20*(-I*sqrt(3) + 1) - 2*a01*a10*a20) + 1/4*(a00*a11*a20*(I*sqrt(3) + 1) + a00*a10*a21*(-I*sqrt(3) + 1) - 2*a01*a10*a20)*(a00*a10*a22*(I*sqrt(3) + 1) + a00*a12*a20*(-I*sqrt(3) + 1) - 2*a02*a10*a20)]
        [                                                                                                                                                                                                                                             -1/2*a00*a10*a20*(I*sqrt(3) + 1) - 1/2*a00*a10*a20*(-I*sqrt(3) + 1) + a00*a10*a20                                                                                                                                                                                                                                                                                                                              0 -1/4*(a00*a12*a20*(I*sqrt(3) + 1) + a00*a10*a22*(-I*sqrt(3) + 1) - 2*a02*a10*a20)*(a00*a10*a21*(I*sqrt(3) + 1) + a00*a11*a20*(-I*sqrt(3) + 1) - 2*a01*a10*a20) + 1/4*(a00*a11*a20*(I*sqrt(3) + 1) + a00*a10*a21*(-I*sqrt(3) + 1) - 2*a01*a10*a20)*(a00*a10*a22*(I*sqrt(3) + 1) + a00*a12*a20*(-I*sqrt(3) + 1) - 2*a02*a10*a20)]



    AUTHORS:
    - Edinah K. Gnang
    """
    A=Ha.copy()
    for i in rg(A.n(0)-1):
        A = A.fill_with(Grph_EliminationHMII(A.slice(rg(i,A.n(0)),'row').slice(rg(i,A.n(1)),'col')),[i,i])
    return A

def FindCycleTupleComponents(T):
    """
    Returns the cycle decomposition of the input
    permutation.


    EXAMPLES:

    ::


        sage: FindCycleTupleComponents([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)])
        [[(0, 0)], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], [(6, 7), (7, 6)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the temporary list
    Tp=[T[i] for i in rg(len(T))]
    # Initialization of the list of components
    cL=[]
    while len(Tp) > 0:
        # Testing for the cycle length equal to one
        if Tp[0][0] == Tp[0][1]:
            # Updating the temporary list
            cL.append([Tp[0]]); Tp.remove(Tp[0])
        # case where the cycle length equal > one
        else:
            tmp_vL=[Tp[0][0]]; tmp_cL=[Tp[0]]
            nv=tmp_cL[len(tmp_cL)-1][1]
            Tp.remove( (Tp[0][0], Tp[0][1]) )
            while nv not in tmp_vL:
                tmp_vL.append(tmp_cL[len(tmp_cL)-1][1]); tmp_cL.append(T[nv])
                Tp.remove(T[nv])
                nv=tmp_cL[len(tmp_cL)-1][1]
            cL.append(tmp_cL)
    return cL

def FindNumberCycleTupleComponents(T):
    """
    Returns the number of cycle decomposition of the input
    permutation.


    EXAMPLES:

    ::


        sage: FindNumberCycleTupleComponents([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)])
        3


    AUTHORS:
    - Edinah K. Gnang
    """
    return len(FindCycleTupleComponents(T))

def signf(T):
    """
    Returns the sign of a permutation inputed as
    a list of tuples of the form [(i, f(i))  for i in rg(sz)].


    EXAMPLES:
    ::
        sage: signf([(0, 0), (1, 1), (2, 2)])
        1
        sage: signf([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)])
        -1 


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the cylce decomposition of the permutation
    cL=FindCycleTupleComponents(T)
    return prod((-1)^Integer(mod(1+len(lst),2)) for lst in cL)

def mod_coefficients(F, d, Lx):
    """
    Returns the multivariate polynomial where all coefficients of the
    input multivariate polynomial F in the variables in the input list Lx
    are moded by in the integer input d.The implementation of this function
    is rather naive.
    This implementation expects the input polynomial to be in expanded form.


    EXAMPLES:
    ::
        sage: sz=3; A=HM(sz,sz,'a'); F=expand(prod(A[j,1]+A[i,1] for i in rg(sz) for j in rg(sz) if i<j))
        sage: Lv =[HM(*([sz]+[1 for k in rg(sz-1)]+[[A[sz-1-i,1]^j for j in rg(sz)]])) for i in rg(sz)]
        sage: prm = expand(prod(A[u,0] for u in rg(sz))*\
        ....: fast_reduce(F, [A[i,1]^(sz-j-1) for j in rg(sz-1) for i in rg(sz)], \
        ....: [A[i,sz-j-1]/A[i,0] for j in rg(sz-1) for i in rg(sz)]))
        sage: mod_coefficients(prm, 2, A.list())
        a02*a11*a20 + a01*a12*a20 + a02*a10*a21 + a00*a12*a21 + a01*a10*a22 + a00*a11*a22


    AUTHORS:

    - Edinah K. Gnang
    """
    add = var('x0') + var('x1')
    mul = var('x0') * var('x1')
    if F.operator() == add.operator():
        return sum(Integer(mod(mnm.subs([v==1 for v in Lx]),2))*(mnm/mnm.subs([v==1 for v in Lx])) for mnm in F.operands())
    elif F.operator() == mul.operator():
        return Integer(mod(F.subs([v==1 for v in Lx]),2))*(F/F.subs([v==1 for v in Lx]))

def HM2Poly(A, X):
    """
    Returns multivariate polynomial whose evaluation over 
    the transformation monoid lattice Zn^Zm, where n is
    is the side length of the input hypermatrix
    A and m is order of the input hypermatrix A.


    EXAMPLES:
    ::

        sage: sz=Integer(3); A=HM(sz, sz, 'a'); X=var_list('x', 2)
        sage: P=HM2Poly(A, X)
        sage: HM(3,3,[HM2Poly(A,var_list('x',2)).subs([x0==T[0][1],x1==T[1][1]]) for T in TupleFunctionListII(2, sz)]).p()
        [:, :]=
        [a00 a01 a02]
        [a10 a11 a12]
        [a20 a21 a22]


    AUTHORS:

    - Edinah K. Gnang
    """
    if len(X) == A.order():
        Lp=TupleFunctionListII(A.order(), sz)
        return sum(A[tuple([Ts[l][1] for l in rg(A.order())])]*prod(prod((X[k]-jk)/(Ts[k][1]-jk) for jk in rg(sz) if jk !=Ts[k][1]) for k in rg(A.order())) for Ts in Lp)
    else:
        raise ValueError("Expected the length of the list to match the order of the hypermatrix")

def HM2PolyII(A,Y):
    """
    Encodes the input hypermatrix A of arbitrary order
    as a multivariate polynomial whose entries correspond
    to evaluation over roots of unity. The input Y is a 
    list of variables All sides of the hypermatrix have
    the same length

 
    EXAMPLES:

    ::

        sage: sz=Integer(2); A=HM(sz,sz,'a'); x,y=var('x,y'); HM2PolyII(A,[x,y])
        1/4*(a00 - a01 - a10 + a11)*x*y + 1/4*(a00 + a01 - a10 - a11)*x + 1/4*(a00 - a01 + a10 - a11)*y + 1/4*a00 + 1/4*a01 + 1/4*a10 + 1/4*a11
        sage: sz=Integer(2); A=HM(sz,sz,'a'); x,y=var('x,y'); F=HM2PolyII(A, [x, y])
        sage: B=HM(sz,sz,[F.subs([x==(-1)^i, y==(-1)^j]) for j in rg(sz) for i in rg(sz)]); B.printHM()
        [:, :]=
        [a00 a01]
        [a10 a11]
        sage: sz=Integer(2); A=HM(sz,sz,sz,'a'); x,y,z=var('x,y,z'); F=HM2PolyII(A, [x, y, z])
        sage: B=HM(sz,sz,sz,[F.subs([x==(-1)^i, y==(-1)^j, z==(-1)^k]) for k in rg(sz) for j in rg(sz) for i in rg(sz)]); B.printHM()
        [:, :, 0]=
        [a000 a010]
        [a100 a110]

        [:, :, 1]=
        [a001 a011]
        [a101 a111]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the sisze and order and parameter
    sz=min(A.dimensions()); od=A.order()
    # Initialization of the list of transpose of the vectors
    Lw=[HM(*([sz]+[1 for i in rg(od-1)]+[ [exp(sqrt(-1)*2*k*pi/sz) for k in rg(sz)] ])).transpose(od-j) for j in rg(od)]
    # Initialization of the list of functions
    Lf=TupleFunctionListII(od, sz)
    # Loop performing the sum
    Sm=0
    for T in Lf:
        # Initialization of the Kronecker product
        TmpW=Lw[0].elementwise_exponent(-T[0][1])
        for i in rg(1,od):
            TmpW=TmpW.tensor_product(Lw[i].elementwise_exponent(-T[i][1]))
        Sm=Sm+prod(Y[i]^T[i][1] for i in rg(od))*sum(A.elementwise_product(TmpW).list())/(sz^od)
    # Initialization of the polynomial
    return Sm

def svd_numeric2x2(A, dgts=15):
    """
    Returns the matrix of left singular vectors and the matrix of
    right singular vectors both with the diagonal matrix
    whose entries are [1, sigma1/sigma0].
    The format is [[U,Dg0],[V,Dg1]]
    This code is only needed when A is not rank deficient    


    EXAMPLES:
    ::

        sage: A=HM(2,2,[1,2,1,4]); svd_numeric2x2(A)
        [[[[1.35353252429997, -4.47041424613582], [4.47041424613582, 1.35353252429997]],
          [[1, 0], [0, 0.00840395484417606]]],
         [[[-0.377523729112191, 0.202044568264666], [-0.202044568264666, -0.377523729112191]],
          [[1, 0], [0, 118.991596045157]]]]


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=2; z=var('z')
    # Initialization of the first product of transposes
    AAt=A*A.transpose()
    # Initialization of the variables
    x00,x10=var('x00,x10')
    # Obtaining the constraints for the e-vectors
    EqL0=[\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[0,0],\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[0,1],\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[1,1]]
    # Putting the system in row echelon form
    L0=[expand(p) for p in eulerian_eliminationHM(EqL0,[z,x00,x10])]
    # Initialization of the degree matrix
    M0=degree_matrix(L0, [z,x00,x10])
    # Solution to the equation in x10
    Sln_x10=[N(eq.rhs(), digits=dgts) for eq in solve(L0[2]==0, x10) if eq.rhs()!=0]
    Sln_x00=[]
    for u10 in Sln_x10:
        Sln_x00=Sln_x00+[N(eq.rhs(), digits=dgts) for eq in solve(L0[1].subs(x10==u10)==0, x00) if eq.rhs()!=0]
    Sln_z0=[]
    for u10 in Sln_x10:
        for u00 in Sln_x00:
            Sln_z0=Sln_z0+[N(eq.rhs(), digits=dgts) for eq in solve(L0[0].subs([x10==u10, x00==u00])==0, z) if eq.rhs()!=0]
    min_norm0=AAt.norm()
    # Performing the checking
    for u00 in Sln_x00:
        for u10 in Sln_x10:
            for z0 in Sln_z0:
                if (AAt-HM(sz,1,[u00,u10])*HM(1,sz,[u00,u10])-z0*HM(sz,1,[-u10,u00])*HM(1,sz,[-u10,u00])).norm() < min_norm0:
                    min_norm0=(AAt-HM(sz,1,[u00,u10])*HM(1,sz,[u00,u10])-z0*HM(sz,1,[-u10,u00])*HM(1,sz,[-u10,u00])).norm()
                    U=HM([[u00, -u10], [u10, u00]]); Dg0=HM(2,[1,z0],'diag')
    # Initialization of the second product of transposes
    AtA=A.transpose()*A
    # Initialization of the variables
    y00,y01=var('y00,y01')
    # Obtaining the constraints for the e-vectors
    EqL1=[\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[0,0],\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[0,1],\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[1,1]]
    # Putting the system in row echelon form
    L1=[expand(p) for p in eulerian_eliminationHM(EqL1,[z,y00,y01])]
    # Initialization of the degree matrix
    M1=degree_matrix(L1, [z,y00,y01])
    # Solution to the equation in y01
    Sln_y01=[N(eq.rhs(), digits=dgts) for eq in solve(L1[2]==0, y01) if eq.rhs()!=0]
    Sln_y00=[]
    for v01 in Sln_y01:
        Sln_y00=Sln_y00+[N(eq.rhs(), digits=dgts) for eq in solve(L1[1].subs(y01==v01)==0, y00) if eq.rhs()!=0]
    Sln_z1=[]
    for v01 in Sln_y01:
        for v00 in Sln_y00:
            Sln_z1=Sln_z1+[N(eq.rhs(), digits=dgts) for eq in solve(L1[0].subs([y01==v01, y00==v00])==0, z) if eq.rhs()!=0]
    min_norm1=AtA.norm()
    # Performing the checking
    for v00 in Sln_y00:
        for v01 in Sln_y01:
            for z1 in Sln_z1:
                if (AtA-HM(sz,1,[v00,v01])*HM(1,sz,[v00,v01])-z1*HM(sz,1,[-v01,v00])*HM(1,sz,[-v01,v00])).norm() < min_norm1:
                    min_norm1=(AtA-HM(sz,1,[v00,v01])*HM(1,sz,[v00,v01])-z1*HM(sz,1,[-v01,v00])*HM(1,sz,[-v01,v00])).norm()
                    V=HM([[v00, v01], [-v01, v00]]); Dg1=HM(2,[1,z1],'diag')
    return [[U,Dg0],[V,Dg1]]

def svd_symbolic2x2(A):
    """
    Returns the solutions to the algebraic constraints associated with
    the SVD decomposition of the 2x2 matrix.
    


    EXAMPLES:
    ::

        sage: A=HM(2,2,[1,2,1,4]); svd_symbolic2x2(A)[0][0]
        x00 == 1/39*(sqrt(13)*(5*sqrt(13) + 18) - 13)*(-I*sqrt(3) + 1)/(-3*13^(1/4)*sqrt(2/13)*sqrt(5*sqrt(13) + 18) + 1/39*sqrt(2/3)*sqrt(4*sqrt(13)*(5*sqrt(13) + 18)^3 - 156*(5*sqrt(13) + 18)^2 + 156*sqrt(13)*(5*sqrt(13) + 18) + 56862*sqrt(13) + 204659))^(1/3) - 1/2*(-3*13^(1/4)*sqrt(2/13)*sqrt(5*sqrt(13) + 18) + 1/39*sqrt(2/3)*sqrt(4*sqrt(13)*(5*sqrt(13) + 18)^3 - 156*(5*sqrt(13) + 18)^2 + 156*sqrt(13)*(5*sqrt(13) + 18) + 56862*sqrt(13) + 204659))^(1/3)*(I*sqrt(3) + 1)


    AUTHORS:

    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=2; z=var('z')
    # Initialization of the first product of transposes
    AAt=A*A.transpose()
    # Initialization of the variables
    x00,x10=var('x00,x10')
    # Obtaining the constraints for the e-vectors
    EqL0=[\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[0,0],\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[0,1],\
    (AAt-HM(sz,1,[x00,x10])*HM(1,sz,[x00,x10])-z*HM(sz,1,[-x10,x00])*HM(1,sz,[-x10,x00]))[1,1]]
    # Putting the system in row echelon form
    L0=[expand(p) for p in eulerian_eliminationHM(EqL0,[z,x00,x10])]
    # Initialization of the degree matrix
    M0=degree_matrix(L0, [z,x00,x10])
    # Solution to the equation in x10
    Sln_x10=[eq for eq in solve(L0[2]==0, x10) if eq.rhs()!=0]
    Sln_x00=[]
    for u10 in Sln_x10:
        Sln_x00=Sln_x00+[eq for eq in solve(L0[1].subs(x10==u10.rhs())==0, x00) if eq.rhs()!=0]
    Sln_z0=[]
    for u10 in Sln_x10:
        for u00 in Sln_x00:
            Sln_z0=Sln_z0+[eq for eq in solve(L0[0].subs([x10==u10.rhs(), x00==u00.rhs()])==0, z) if eq.rhs()!=0]
    # Initialization of the second product of transposes
    AtA=A.transpose()*A
    # Initialization of the variables
    y00,y01=var('y00,y01')
    # Obtaining the constraints for the e-vectors
    EqL1=[\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[0,0],\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[0,1],\
    (AtA-HM(sz,1,[y00,y01])*HM(1,sz,[y00,y01])-z*HM(sz,1,[-y01,y00])*HM(1,sz,[-y01,y00]))[1,1]]
    # Putting the system in row echelon form
    L1=[expand(p) for p in eulerian_eliminationHM(EqL1,[z,y00,y01])]
    # Initialization of the degree matrix
    M1=degree_matrix(L1, [z,y00,y01])
    # Solution to the equation in y01
    Sln_y01=[eq for eq in solve(L1[2]==0, y01) if eq.rhs()!=0]
    Sln_y00=[]
    for v01 in Sln_y01:
        Sln_y00=Sln_y00+[eq for eq in solve(L1[1].subs(y01==v01.rhs())==0, y00) if eq.rhs()!=0]
    Sln_z1=[]
    for v01 in Sln_y01:
        for v00 in Sln_y00:
            Sln_z1=Sln_z1+[eq for eq in solve(L1[0].subs([y01==v01.rhs(), y00==v00.rhs()])==0, z) if eq.rhs()!=0]
    return [Sln_x00,Sln_x10,Sln_z0,Sln_y00,Sln_y01,Sln_z1]

def Division(p, d,  v):
    """
    Outputs the quotient and the remainder of the Euclidean division.
    The algorithm takes as input two univariate polynomials in the
    input variable v,  p and d respectively associated with the 
    dividend and the divisor. 


    EXAMPLES:

    ::
        
        sage: p = 4*x^3+3*x^2+2*x+1; d = 5*x^2+3*x+7; [q, r] = Division(p, d, x); [q, r]
        [4/5*x + 3/25, -99/25*x + 4/25]
        sage: expand(d*q+r) # Checking the computation
        4*x^3 + 3*x^2 + 2*x + 1
        sage: p=13*x^7; d=5*x^2+3*x+7; [q,r] = Division(p, d, x); [q, r]
        [13/5*x^5 - 39/25*x^4 - 338/125*x^3 + 2379/625*x^2 + 4693/3125*x - 97344/15625,
         127777/15625*x + 681408/15625]
        sage: expand(d*q+r) # Checking the computation
        13*x^7
        sage: p=x^7; d=5*x^2+3*x+7; [q,r] = Division(p, d, x); [q,r]
        [1/5*x^5 - 3/25*x^4 - 26/125*x^3 + 183/625*x^2 + 361/3125*x - 7488/15625,
         9829/15625*x + 52416/15625]
        sage: expand(d*q+r) # Checking the computation
        x^7
        sage: p=x^7; d=5*x^2; [q,r] = Division(p, d, x); [q,r]
        [1/5*x^5, 0]
        sage: expand(d*q+r) # Checking the computation
        x^7


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of remainder
    r = p
    # Initialization of the Quotient list
    Lq = []
    # Checking that neither p or d are monomials.
    if p.degree(v)>=1 and d.degree(v)>=1:
        # Obtaining the leading term of d
        ltd = d.coefficients(v)[len(d.coefficients(v))-1][0]* v^d.coefficients(v)[len(d.coefficients(v))-1][1]
        # Main loop
        while r.degree(v) >= d.degree(v):
            # Obtaining the leading term of r
            ltr = r.coefficients(v)[len(r.coefficients(v))-1][0]* v^r.coefficients(v)[len(r.coefficients(v))-1][1]
            # Updating the quotient list
            Lq.append((ltr.subs(v==1)/ltd.subs(v==1))*v^(ltr.degree(v)-ltd.degree(v)))
            #print 'Lq = ',Lq
            # Updating the remainder
            r = expand(r-d*Lq[len(Lq)-1])
            #print 'r = ',r
        return [sum(Lq), r]
    else:
        raise ValueError("Expected inputs of degree >= 1 in the input variable.")

def EuclidsPolynomialGCD(a, b, v):
    """

    This function implements Euclid's GCD algorithm for
    polynomials.
    The function checks that the inputs are not degree 0
    polynomials and returns as output the matrix which
    describes all the iterations of the algorithm.


    EXAMPLES:
    ::


        sage: p=x^5+1; d=x^2+1; G=EuclidsPolynomialGCD(p, d, x); G.printHM()
        [:, :]=
        [x^5 + 1 x^2 + 1 x^3 - x   x + 1]
        [x^2 + 1   x + 1   x - 1       2]
        sage: p=x^5-1; d=x^2-1; G=EuclidsPolynomialGCD(p, d, x); G.printHM()
        [:, :]=
        [x^5 - 1 x^2 - 1 x^3 + x   x - 1]
        [x^2 - 1   x - 1   x + 1       0]


    AUTHORS:
    - Edinah K. Gnang
    """
    if a.degree(v)>0 and b.degree(v)>0:
        # Initialization of the matrix Data Structure.
        G = HM(1, 4, 'zero')
        # Initialization of the initial conditions
        G[0, 0] = a; G[0, 1] = b; [q, r] = Division(G[0, 0], G[0, 1], v)
        G[0, 3] = r; G[0, 2] = q
        # Initialization of the index
        indx = 0
        while G[indx, 3].degree(v) > 0:
            # Updating the size of G
            G=G.zero_pad([G.n(0)+1, G.n(1)])
            # Incrementing the index
            indx=indx+1
            G[indx, 0] = G[indx-1, 1]; G[indx, 1] = G[indx-1, 3]; [q, r]=Division(G[indx, 0], G[indx, 1], v)
            G[indx, 3] = r; G[indx, 2] = q
        return G
    else:
        raise ValueError("Expected inputs of degree >= 1.")

def PolynomialBezout(a, b, v):
    """

    This function uses Euclid's GCD algorithm for
    polynomials to devise Bezouts identity for polynomials.
    Cramers identity is also used here. The implementation
    is very similar to the previous IntegerBezout function.
    The function checks that the inputs are not degree 0
    polynomials and returns as output the matrix which
    describes all the iterations of the algorithm.


    EXAMPLES:
    ::


        sage: p=expand(sum(i*x^i for i in rg(6))*(x^3+x+2)); d=expand((x^2-4)*(x^3+x+2)); [G, M, s, t]=PolynomialBezout(p, d, x); G.printHM()
        [:, :]=
        [5*x^8 + 4*x^7 + 8*x^6 + 16*x^5 + 12*x^4 + 8*x^3 + 5*x^2 + 2*x                                 x^5 - 3*x^3 + 2*x^2 - 4*x - 8                                     5*x^3 + 4*x^2 + 23*x + 18                        93*x^4 + 72*x^3 + 93*x^2 + 258*x + 144]
        [                                x^5 - 3*x^3 + 2*x^2 - 4*x - 8                        93*x^4 + 72*x^3 + 93*x^2 + 258*x + 144                                                1/93*x - 8/961                         -3268/961*x^3 - 3268/961*x - 6536/961]
        [                       93*x^4 + 72*x^3 + 93*x^2 + 258*x + 144                         -3268/961*x^3 - 3268/961*x - 6536/961                                     -89373/3268*x - 17298/817                                                             0]
        sage: expand(s*p+t*d)
        -3268/961*x^3 - 3268/961*x - 6536/961


    AUTHORS:
    - Edinah K. Gnang
    """
    if a.degree(v)>0 and b.degree(v)>0:
        # Initialization of the matrix Data Structure.
        G = HM(1, 4, 'zero')
        # Initialization of the initial conditions
        G[0, 0] = a; G[0, 1] = b; [q, r] = Division(G[0, 0], G[0, 1], v)
        G[0, 3] = r; G[0, 2] = q
        # Initialization of the index
        indx = 0
        while G[indx, 3].degree(v) > 0:
            # Updating the size of G
            G=G.zero_pad([G.n(0)+1, G.n(1)])
            # Incrementing the index
            indx=indx+1
            G[indx, 0] = G[indx-1, 1]; G[indx, 1] = G[indx-1, 3]; [q, r]=Division(G[indx, 0], G[indx, 1], v)
            G[indx, 3] = SR(r); G[indx, 2] = SR(q)
        if G[G.n(0)-1,G.n(1)-1].is_zero():
            # Filling up the matrix
            M=HM(G.n(0)-1, G.n(0)-1, 'zero')
            # Initialization of the first two rows of the matrix
            M[0,0]=1; M[1,0]=G[1,2]; M[1,1]=1
            # Loop Filling up the rest of the matrix
            for i in rg(2,G.n(0)-1):
                # Filling up the i-th row
                M[i,i-2]=Integer(1); M[i,i-1]=-G[i,2]; M[i,i]=-Integer(1)
            # Computing Bezout's coefficients
            s=M.slice(rg(1,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()
            t=-G[0,2]*M.slice(rg(1,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()-\
            M.slice([0]+rg(2,G.n(0)-1),'row').slice(rg(G.n(0)-2),'col').det()
            return [G, M, -s, -t]
        else:
            # Filling up the matrix
            M=HM(G.n(0), G.n(0), 'zero')
            # Initialization of the first two rows of the matrix
            M[0,0]=1; M[1,0]=G[1,2]; M[1,1]=1
            # Loop Filling up the rest of the matrix
            for i in rg(2,G.n(0)):
                # Filling up the i-th row
                M[i,i-2]=Integer(1); M[i,i-1]=-G[i,2]; M[i,i]=-Integer(1)
            # Computing Bezout's coefficients
            s=M.slice(rg(1,G.n(0)),'row').slice(rg(G.n(0)-1),'col').det()
            t=-G[0,2]*M.slice(rg(1,G.n(0)),'row').slice(rg(G.n(0)-1),'col').det()-\
            M.slice([0]+rg(2,G.n(0)),'row').slice(rg(G.n(0)-1),'col').det()
            return [G, M, -s, -t]
    else:
        raise ValueError("Expected inputs of degree >= 1.")

def CompositionalDivision(p, d,  v):
    """
    Outputs the quotient list and the remainder of the composition version
    the Euclidean division. The algorithm takes as input
    two univariate polynomials in the input variable v,  p and d respectively
    associated with the dividend and the divisor. The stoping criteria is when the
    remainder degree is less then the divisor degree which implies that all terms in
    the quotient have exponent greater or equal to one. 


    EXAMPLES:

    ::
        
        sage: p = 4*x^3+3*x^2+2*x+1; d = 5*x^2+3*x+7; [Lq, r] = CompositionalDivision(p, d, x); [Lq, r] 
        [[2*sqrt(1/5)*x^(3/2), sqrt(3/5)*x],
         -1/5*(3*sqrt(5)*sqrt(3) - 10)*x - 6/5*sqrt(5)*x^(3/2) - 13]
        sage: (sum(d.subs(x==q) for q in Lq)+r).canonicalize_radical() # Checking the computation
        4*x^3 + 3*x^2 + 2*x + 1
        sage: p=13*x^7; d=5*x^2+3*x+7; [Lq,r] = CompositionalDivision(p, d, x); [Lq, r]
        [[sqrt(13/5)*x^(7/2), 1/5*sqrt(3)*sqrt(-sqrt(13)*sqrt(5))*x^(7/4)],
         -3/5*5^(1/4)*sqrt(3)*x^(7/4)*sqrt(-sqrt(13)) - 14]
        sage: (sum(d.subs(x==q) for q in Lq)+r).canonicalize_radical() # Checking the computation
        13*x^7
        sage: p=x^7; d=5*x^2+3*x+7; [Lq,r] = CompositionalDivision(p, d, x); [Lq,r]
        [[sqrt(1/5)*x^(7/2), 1/5*sqrt(3)*x^(7/4)*sqrt(-sqrt(5))],
         -3/5*sqrt(3)*x^(7/4)*sqrt(-sqrt(5)) - 14]
        sage: (sum(d.subs(x==q) for q in Lq)+r).canonicalize_radical() # Checking the computation
        x^7
        sage: p=x^7; d=5*x^2; [Lq,r] = CompositionalDivision(p, d, x); [Lq,r]
        [[sqrt(1/5)*x^(7/2)], 0]
        sage: sum(d.subs(x==q) for q in Lq)+r # Checking the computation
        x^7
        sage: p=x*(var('t')+1)*(var('t')+2); d=x*(var('t')+1); [Lq,r] = CompositionalDivision(p, d, x); [Lq,r]
        [[(t + 2)*x], 0]
        sage: P = 4*x^3 + 3*x^2 + 2*x + 1 # Initialization of the "dividend"
        sage: D = 5*x^2 + 3*x + 7 # Initialization of the "divisor"
        sage: [Lq, Rem] = CompositionalDivision(P, D, x) # Performing the compositional division
        sage: (GProd([D*HM(1,len(Lq),'one'),HM(len(Lq),1,Lq)], sum, [x])[0,0]+Rem).canonicalize_radical()
        4*x^3 + 3*x^2 + 2*x + 1
        sage: p = x^5; d = x^3+x^2; [Lq, r] = CompositionalDivision(p, d, x); [Lq, r]
        [[x^(5/3), (-1)^(1/3)*x^(10/9)], -(-1)^(2/3)*x^(20/9)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of remainder
    r = p
    # Initialization of the Quotient list
    Lq = []
    # Checking that neither p or d are monomials.
    if p.degree(v)>=1 and d.degree(v)>=1:
        # Obtaining the leading term of d
        ltd = d.coefficients(v)[len(d.coefficients(v))-1][0]* v^d.coefficients(v)[len(d.coefficients(v))-1][1]
        # Main loop
        while r.degree(v) >= d.degree(v):
            # Obtaining the leading term of r
            ltr = r.coefficients(v)[len(r.coefficients(v))-1][0]* v^r.coefficients(v)[len(r.coefficients(v))-1][1]
            # Updating the quotient list
            Lq.append((ltr.subs(v==1)/ltd.subs(v==1))^(1/ltd.degree(v))*v^(ltr.degree(v)/ltd.degree(v)))
            #print 'Lq = ',Lq
            # Updating the remainder
            #r = r-d.subs(v==Lq[len(Lq)-1])
            #r = (r-d.subs(v==Lq[len(Lq)-1])).canonicalize_radical()
            r = sum( l[0]*v^l[1] for l in (r-d.subs(v==Lq[len(Lq)-1])).canonicalize_radical().coefficients() )
            #print 'r = ',r
        return [Lq, r]
    else:
        raise ValueError("Expected inputs of degree >= 1 in the input variable.")

def CompositionalDivisionII(p, d, v, Rlt):
    """
    Outputs the quotient list and the remainder of the composition version
    the Euclidean division. By working modulo relations of the form v^n-1 
    where n is prime. The algorithm takes as input two univariate polynomials
    in the input variable v, p and d respectively associated with the dividend
    and the divisor. The last input is the relation we do not check in the current
    implementation that Rlt is a polynomial of the form x^n-1 where n is prime. 


    EXAMPLES:

    ::
        
        sage: p = 4*x^7*x^2+2*x+1; d = 5*x^2+3*x+7; Rlt=x^3-1; [L, Rm] = CompositionalDivisionII(p, d, x, Rlt) 
        sage: F0 = ModuloII(p, [x], [Rlt])
        sage: F1 = ModuloII((GProd([d*HM(1,len(L),'one'),HM(len(L),1,L)], sum, [x])[0,0]+Rm).canonicalize_radical(), [x], [Rlt])
        sage: F0 == F1
        True


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of remainder
    Rem = p
    # Initialization of the Quotient list
    Lq = []
    # Checking that neither p or d are monomials.
    if p.degree(v)>=1 and d.degree(v)>=1:
        # Obtaining the leading term of d
        ltd = d.coefficients(v)[len(d.coefficients(v))-1][0]* v^d.coefficients(v)[len(d.coefficients(v))-1][1]
        # Main loop
        while Rem.degree(v) >= d.degree(v):
            # Obtaining the leading term of Rem
            ltr = Rem.coefficients(v)[len(Rem.coefficients(v))-1][0]* v^Rem.coefficients(v)[len(Rem.coefficients(v))-1][1]
            # Updating the quotient list
            Lq.append((ltr.subs(v==1)/ltd.subs(v==1))^(1/ltd.degree(v))*v^(ltr.degree(v)/ltd.degree(v)))
            Rem = sum( l[0]*v^l[1] for l in (Rem-d.subs(v==Lq[len(Lq)-1])).canonicalize_radical().coefficients() )
        # Loop turning exponents into integers using the relation
        L=[]
        for trm in Lq:
            cf=trm.subs(v==1); ep=log(trm/trm.subs(v==1),v).canonicalize_radical()
            if ep in ZZ:
                L.append(cf*v^Integer(mod(ep,Rlt.degree(v))))
            else:
                Num=ep.numerator(); Den=ep.denominator()
                [G, M, s, t]=IntegerBezout(Integer(Den),Integer(Rlt.degree(v)))
                L.append(cf*v^Integer(mod(Num*s,Rlt.degree(v))))
        # Expression used for specifying the type of the operation.
        add = var('x0') + var('x1'); mul = var('x0') * var('x1'); xpo = var('x0') ^ var('x1')
        # Checking if the remainder is identically constant
        if Rem.subs(v==0)==Rem:
            Rm=Rem
        # Otherwise checking that it is a sum
        elif Rem.operator() == add.operator():
            Rm=SR(0)
            for trm in Rem.operands():
                cf=trm.subs(v==1); ep=log(trm/trm.subs(v==1),v).canonicalize_radical()
                if ep in ZZ:
                    Rm=Rm+(cf*v^Integer(mod(ep,Rlt.degree(v))))
                else:
                    Num=ep.numerator(); Den=ep.denominator()
                    [G, M, s, t]=IntegerBezout(Integer(Den),Integer(Rlt.degree(v)))
                    Rm=Rm+(cf*v^Integer(mod(Num*s,Rlt.degree(v))))
        # Otherwise checking that it is a monomial
        elif Rem.operator() == mul.operator():
            cf=trm.subs(v==1); ep=log(trm/trm.subs(v==1),v).canonicalize_radical()
            if ep in ZZ:
                Rm=(cf*v^Integer(mod(ep,Rlt.degree(v))))
            else:
                Num=ep.numerator(); Den=ep.denominator()
                [G, M, s, t]=IntegerBezout(Integer(Den),Integer(Rlt.degree(v)))
                Rm=(cf*v^Integer(mod(Num*s,Rlt.degree(v))))
        # Otherwise checking that the remainder is of the form v^ep
        elif Rem.operator() == xpo.operator():
            ep=log(trm/trm.subs(v==1),v).canonicalize_radical()
            if ep in ZZ:
                Rm=v^Integer(mod(ep,Rlt.degree(v)))
            else:
                Num=ep.numerator(); Den=ep.denominator()
                [G, M, s, t]=IntegerBezout(Integer(Den),Integer(Rlt.degree(v)))
                Rm=v^Integer(mod(Num*s,Rlt.degree(v)))
        return [L, Rm]
    else:
        raise ValueError("Expected inputs of degree >= 1 in the input variable.")

def EuclidsCompositionalGCD(a, b, v):
    """

    This function implements the composition version
    of the Euclid's GCD algorithm.
    The function checks that the inputs are polynomials
    of degree >1 and returns as output the matrix which
    describes all the iterations of the algorithm.


    EXAMPLES:
    ::


        sage: p=x^5+1; d=x^2+1; G=EuclidsCompositionalGCD(p, d, x); G.slice([0,1,3],'col').printHM()
        [:, :]=
        [x^5 + 1 x^2 + 1       0]
        sage: p=x^5-1; d=x^2-1; G=EuclidsCompositionalGCD(p, d, x); G.slice([0,1,3],'col').printHM()
        [:, :]=
        [x^5 - 1 x^2 - 1       0]
        sage: p=x^5+1; d=x^3+2*x^2+1; G=EuclidsCompositionalGCD(p, d, x); G.slice([0,1,3],'col').printHM() 
        [:, :]=
        [                           x^5 + 1                    x^3 + 2*x^2 + 1 -2*2^(2/3)*(-1)^(2/3)*x^(20/9) - 1]
        [                   x^3 + 2*x^2 + 1 -2*2^(2/3)*(-1)^(2/3)*x^(20/9) - 1                          2*x^2 + 2]
        [-2*2^(2/3)*(-1)^(2/3)*x^(20/9) - 1                          2*x^2 + 2                                 -3]


    AUTHORS:
    - Edinah K. Gnang
    """
    if a.degree(v)>1 and b.degree(v)>1:
        # Initialization of the matrix Data Structure.
        G = HM(1, 4, 'zero')
        # Initialization of the initial conditions
        G[0, 0] = a; G[0, 1] = b
        # Performing the compositional division
        [Lq, r] = CompositionalDivision(G[0, 0], G[0, 1], v)
        G[0, 3] = r.canonicalize_radical(); G[0, 2] = Lq
        #print G.slice([0],'row')
        # Initialization of the index
        indx = 0
        while G[indx, 3].degree(v) > 1:
            #print G.slice([G.n(0)-1],'row')
            # Updating the size of G
            G=G.zero_pad([G.n(0)+1, G.n(1)])
            # Incrementing the index
            indx=indx+1
            G[indx, 0] = G[indx-1, 1]; G[indx, 1] = G[indx-1, 3]
            #print G.slice([G.n(0)-1],'row')
            # Performing the compositional division
            [Lq, r] = CompositionalDivision(G[indx, 0], G[indx, 1], v)
            G[indx, 3] = r.canonicalize_radical(); G[indx, 2] = Lq
            #print G.slice([G.n(0)-1],'row')
        return G
    else:
        raise ValueError("Expected inputs of degree > 1.")

def Permutation_lex(T):
    """
    Outputs the lexicographic ordering of the permutaions.
    The lexicographic ordering is based upon the invertion
    count.


    EXAMPLES:

    ::
        
        sage: T=[(0, 0), (1, 2), (2, 3), (3, 0)]; Permutation_lex(T)
        18
        sage: T=[(0, 0), (1, 1), (2, 2), (3, 3)]; Permutation_lex(T)
        0
        sage: T=[(0, 3), (1, 2), (2, 1), (3, 0)]; Permutation_lex(T)
        23


    AUTHORS:
    - Edinah K. Gnang
    """
    sm=0
    for k in rg(len(T)):
        # Inversion count
        cnt = 0
        for i in rg(k):
            if T[i][1]>=T[k][1]:
                cnt=cnt+1
        sm=sm+cnt*factorial(k) 
    return sm

def Permutation_Pair_lex(L):
    """
    Outputs the lexicographic ordering of the permutaions.
    The lexicographic ordering is based upon the invertion
    count.


    EXAMPLES:

    ::
        
        sage: T=[(0, 0), (1, 2), (2, 3), (3, 0)]; Permutation_Pair_lex([T,T])
        450
        sage: T=[(0, 0), (1, 1), (2, 2), (3, 3)]; Permutation_Pair_lex([T,[(i,i) for i in rg(4)]])
        432
        sage: Permutation_Pair_lex([[(i,i) for i in rg(4)], [(i,i) for i in rg(4)]])
        0


    AUTHORS:
    - Edinah K. Gnang
    """
    if len(L[0]) == len(L[1]):
        return factorial(len(L[0]))*Permutation_lex(L[0])+Permutation_lex(L[1])
    else:
        raise ValueError("Expected Tuples descriptions of permutations should be of the same size.")

@cached_function
def DictionaryAlternatingGroup(sz):
    """
    Returns a dictionary for indexing elements of the alternating
    group. This implementation is based upon the permutation lexicographic
    map function


    EXAMPLES:
    ::
        sage: DictionaryAlternatingGroup(3)
        {0: 0, 4: 1, 3: 2}


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the alternating group
    L=AlternatingGroupFunctionList(sz)
    # Returning the dictionary
    return dict([(Permutation_lex(L[i]),i) for i in rg(len(L))])

def Alt_Permutation_lex(T,Dct):
    """
    Outputs the lexicographic ordering of the permutaions.
    The lexicographic ordering is based upon the invertion
    count. The input T is a tuple description of a member of
    the alternating group. The input Dct is dictionary
    mapping the permutation_lex order to Z_(n!/2)


    EXAMPLES:

    ::
       
        sage: Dct=DictionaryAlternatingGroup(4) # Initialization of the dictionary 
        sage: T=[(0, 1), (1, 2), (2, 0), (3, 3)]; Alt_Permutation_lex(T,Dct)
        4


    AUTHORS:
    - Edinah K. Gnang
    """
    return Dct[Permutation_lex(T)]

def Function_lex(T):
    """
    Outputs the lexicographic ordering of the input function.
    The input is taken to be the tuple description of a member of
    the composition monoid.
    The lexicographic ordering is based upon the decimal expansion where
    the digits correspond to evaluations of the function
    count.


    EXAMPLES:

    ::
        
        sage: T=[(0, 0), (1, 2), (2, 3), (3, 0)]; Function_lex(T)
        56
        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0)]; Function_lex(T)
        0
        sage: T=[(0, 3), (1, 3), (2, 3), (3, 3)]; Function_lex(T)
        255


    AUTHORS:
    - Edinah K. Gnang
    """
    return sum(T[i][1]*len(T)^i for i in rg(len(T)))

def Function_lexII(T, b):
    """
    Outputs the lexicographic ordering of the input function.
    The input is taken to be the tuple description of a member of
    the composition monoid.
    The lexicographic ordering is based upon the decimal expansion where
    the digits correspond to evaluations of the function
    count.


    EXAMPLES:

    ::
        
        sage: T=[(0, 0), (1, 2), (2, 3), (3, 0)]; b=Integer(4); Function_lexII(T, b)
        56
        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0)]; b=Integer(4); Function_lexII(T, b)
        0
        sage: T=[(0, 3), (1, 3), (2, 3), (3, 3)]; b=Integer(4); Function_lexII(T, b)
        255


    AUTHORS:
    - Edinah K. Gnang
    """
    return sum(T[i][1]*b^i for i in rg(len(T)))

def DictionaryZn_to_the_ZnSubset(L,sz):
    """
    Returns a dictionary for indexing elements of arbitrary subset of the
    transformation monoid on sz elements. The subset is specified as a list
    group. This implementation is based upon the functional lexicographic
    map function


    EXAMPLES:
    ::
        sage: sz=Integer(3); SnL=PermutationFunctionList(sz)
        sage: DictionaryZn_to_the_ZnSubset(SnL,sz)
        {21: 0, 15: 1, 19: 2, 7: 3, 11: 4, 5: 5}


    AUTHORS:
    - Edinah K. Gnang
    """
    # Returning the dictionary
    return dict([(Function_lex(L[i]),i) for i in rg(len(L))])

def Zn_to_the_ZnSubset_lex(T,Dct):
    """
    Outputs the lexicographic ordering defined for some
    arbitray subset of the transformation monoid encapsulated
    by the dictionay input Dct. The lexicographic ordering is 
    based upon the functional lexicographic map. The input T is
    a tuple description of a member of the alternating group. 


    EXAMPLES:

    ::
       
        sage: sz=Integer(4); AnL=AlternatingGroupFunctionList(sz); Dct=DictionaryZn_to_the_ZnSubset(AnL,sz)
        sage: T=[(0, 1), (1, 2), (2, 0), (3, 3)]; Zn_to_the_ZnSubset_lex(T,Dct)
        4
        sage: sz=Integer(3); SnL=PermutationFunctionList(sz); Dct=DictionaryZn_to_the_ZnSubset(SnL,sz)
        sage: T=[(0, 1), (1, 2), (2, 0)]; Zn_to_the_ZnSubset_lex(T,Dct)
        3


    AUTHORS:
    - Edinah K. Gnang
    """
    return Dct[Function_lex(T)]

def Graph_lex(A):
    """
    Outputs the lexicographic ordering of the input graph.
    The lexicographic ordering is based uopn the binary 
    expansion using the adjancency matrix as input of type HM
    but works fine with sage Matrix object.


    EXAMPLES:

    ::
        
        sage: sz=2; A=HM(2,2,'zero'); Graph_lex(A)
        0
        sage: sz=2; A=HM(2,2,'one'); Graph_lex(A)
        15
        sage: sz=2; od=2; A=HM(od,sz,'kronecker'); Graph_lex(A)
        9
        sage: sz=2; od=2; A=HM(2,2,'one')-HM(od,sz,'kronecker'); Graph_lex(A)
        6


    AUTHORS:
    - Edinah K. Gnang
    """
    sz=min(A.nrows(),A.ncols())
    return sum(A[i,j]*2^(A.nrows()*i+j) for j in rg(sz) for i in rg(sz))

def Triangular_lex(i,j):
    """
    Outputs the lexicographic ordering of the input pair 0=< i < j < sz.


    EXAMPLES:

    ::
        
        sage: Triangular_lex(1,2)
        2

    AUTHORS:
    - Edinah K. Gnang
    """
    if 0 <= i and i < j:
        return j*(j-1)/2+i
    else:
        raise ValueError("Expected 0 <= i and i < j")

def Triangular_lex_inv(i,sz):
    """
    Outputs the pre-image of the lexicographic ordering of the input pair 0=< i < j < sz.


    EXAMPLES:

    ::
        
        sage: Triangular_lex_inv(3,4)
        [1, 2]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the counter
    cnt=0
    for v in rg(sz):
        for u in rg(sz):
            if u<v:
                if cnt==i:
                    return [u,v]
                else:
                    cnt=cnt+1

def SupFunctionalDigraphList(T, sz):
    """
    Outputs the list of all labeled functional directed graphs of sz vertices
    assuming that len(T) =< sz which contained the labeled functional directed
    associated with the tuple description T.

    EXAMPLES:
    ::
        sage: T=[(0, 1), (1, 2), (2, 2)]; SupFunctionalDigraphList(T, 4)
        [[(0, 1), (1, 2), (2, 2), (3, 0)],
         [(0, 1), (1, 2), (2, 2), (3, 1)],
         [(0, 1), (1, 2), (2, 2), (3, 2)],
         [(0, 1), (1, 2), (2, 2), (3, 3)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the symbolically weighted adjacency matrix.
    A=HM(sz, sz, 'a')
    if sz >= len(T):
        # Initialization of the multilinear polynomial constructions
        F=expand(prod(A[T[i][0], T[i][1]] for i in rg(len(T)))*prod(sum(A[i,j] for j in rg(sz)) for i in rg(len(T),sz)))
        return [Monomial2Tuple(mnm, A.list(), sz) for mnm in F.operands()]
    else:
        raise ValueError("Expected the lenght of the tuple to <= to the number of vertices in the larger graph")

def SubFunctionalDigraphList(T, sz):
    """
    Outputs the list of all labeled functional directed graphs of sz vertices
    assuming that len(T) >= sz which is contained the labeled functional directed
    associated with the tuple description T.

    EXAMPLES:
    ::
        sage: T=[(0, 0), (1, 0), (2, 0)]; SubFunctionalDigraphList(T, 2)
        [[(0, 0), (1, 0)], [(0, 0), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the adjacency matrix
    B=Tuple_to_Adjacency(T)
    # Initialization of the symbolically weighted adjacency matrix.
    A=HM(len(T), len(T), 'a').elementwise_product(B); Ha=HM(len(T),len(T),'a')
    if sz <= len(T):
        # Initialization of the multilinear polynomial constructions
        F=0
        # Initialization of the sets
        St=Set(rg(len(T)))
        for s in St.subsets(sz):
            # Initialization of the principal minor
            M=A.slice(s.list(),'row').slice(s.list(),'col')
            F=F+expand(prod(sum(M[i,j] for j in rg(sz)) for i in rg(sz)))
        return [Monomial2Tuple(mnm, Ha.list(), len(T)) for mnm in F.operands()]
    else:
        raise ValueError("Expected the lenght of the tuple to >= to the number of vertices in the smaller graph")

def CurtailedFunctionalDigraphList(T):
    """
    Outputs the list of all labeled functional directed graphs which
    correspond to curtailements of the functional directed graph 
    specified as input a tuple description of a function.
    Curtailement is mean in the Ruffuss Isaac sense meaning
    possible removal of leaf noded.
    

    EXAMPLES:
    ::
        sage: T=[(0, 0), (1, 0), (2, 0)]; CurtailedFunctionalDigraphList(T)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables which keep track of vertex indegrees
    X=var_list('x',len(T))
    # Initialization of the symbolically weighted adjacency matrix.
    A=HM(len(T), len(T), 'a'); Ha=HM(len(T), len(T), 'a')
    # Initialization of the edge monomial term
    F=prod(X[T[i][1]] for i in rg(len(T)))
    # Obtaining the list of vertices having indegree 0
    Lv=[]
    for i in rg(len(T)):
        if F.degree(X[i]) == 0:
            Lv.append(i)
    # Updatding the symbolically weighted adjancency matrix
    for i in rg(len(T)):
        if T[i][0] in Lv:
            A[T[i][0], T[i][1]]=A[T[i][0], T[i][0]]+A[T[i][0], T[i][1]]
    # Initialization of the edge monomial listing construction
    F=expand(prod(A[T[i][0], T[i][1]] for i in rg(len(T))))
    if len(Lv)==0:
        return [F]
    else:
        return [Monomial2Tuple(mnm, Ha.list(), len(T)) for mnm in F.operands()]

def ContractionMonomialList(T):
    """
    returns a list of list which are associated 
    with possible contraction according to the contraction
    part of the Rufus Isaacs compositional square root theorem.
    The input is tuple description of the function of interest
    the integer one indicates no contraction when it occurs as a
    monomial in each internal list the edges a separated according
    to the pre-image structure.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]; ContractionMonomialList(T)
        [[a10*a20*a30, a43*a53],
         [a10*a20, a43*a53],
         [a10*a30, a43*a53],
         [a20*a30, a43*a53],
         [1, a43*a53],
         [a10*a20*a30, 1],
         [a10*a20, 1],
         [a10*a30, 1],
         [a20*a30, 1]]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(T)
    # Initialization of the list of matrix
    A=HM(sz,sz,'a')
    # Initialization of the list of pre-images
    Lpre=tpl_pre_image_set_functionII(T)
    # Initialization of the contraction candidate list
    L=[expand(prod(1+A[Lpre[j][k],j] for k in rg(len(Lpre[j])))-sum(A[Lpre[j][k],j] for k in rg(len(Lpre[j])))).operands() for j in rg(len(Lpre)) if len(Lpre[j])>1]
    # Loop initializing the index list for contraction prescriptions
    l=[len(L[i]) for i in rg(len(L))]
    # Initialization of the list which will store the final result
    Lr=[]
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Lr.append([L[i][entry[i]] for i in rg(len(l))])
    Lr.pop()
    return Lr

def CurtailmentMonomialList(T):
    """
    returns a list of list which are associated 
    with possible curtailements according to the curtailement 
    part of the Rufus Isaacs compositional square root theorem.
    The input is tuple description of the function of interest
    the integer one indicates no contraction when it occurs as a
    monomial in each internal list the edges a separated according
    to the pre-image structure.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]; CurtailmentMonomialList(T)
        [a00*a10*a20*a30*a43*a53,
         a00*a11*a20*a30*a43*a53,
         a00*a10*a22*a30*a43*a53,
         a00*a11*a22*a30*a43*a53,
         a00*a10*a20*a30*a44*a53,
         a00*a11*a20*a30*a44*a53,
         a00*a10*a22*a30*a44*a53,
         a00*a11*a22*a30*a44*a53,
         a00*a10*a20*a30*a43*a55,
         a00*a11*a20*a30*a43*a55,
         a00*a10*a22*a30*a43*a55,
         a00*a11*a22*a30*a43*a55,
         a00*a10*a20*a30*a44*a55,
         a00*a11*a20*a30*a44*a55,
         a00*a10*a22*a30*a44*a55,
         a00*a11*a22*a30*a44*a55]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(T)
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Obtaining the leaf nodes of T
    Llf=tpl_leaf_set(T)
    # Expressing the functions
    if len(Llf) == 0:
        return prod(A[i,T[i][1]] for i in rg(sz))
    else:
        return [t for t in expand(prod(A[i,i]+A[i,T[i][1]] for i in Llf)*prod(A[i,T[i][1]] for i in rg(sz) if not i in Llf)).operands() if t!=1]

def CurtailmentTupleList(T):
    """
    returns a list of list which are associated 
    with possible curtailements according to the curtailement 
    part of the Rufus Isaacs compositional square root theorem.
    The input is tuple description of the function of interest
    the integer one indicates no contraction when it occurs as a
    monomial in each internal list the edges a separated according
    to the pre-image structure.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]; CurtailmentTupleList(T)
        [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)],
         [(0, 0), (1, 1), (2, 0), (3, 0), (4, 3), (5, 3)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 3), (5, 3)],
         [(0, 0), (1, 1), (2, 2), (3, 0), (4, 3), (5, 3)],
         [(0, 0), (1, 0), (2, 0), (3, 0), (4, 4), (5, 3)],
         [(0, 0), (1, 1), (2, 0), (3, 0), (4, 4), (5, 3)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 4), (5, 3)],
         [(0, 0), (1, 1), (2, 2), (3, 0), (4, 4), (5, 3)],
         [(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 1), (2, 0), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 1), (2, 2), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 0), (2, 0), (3, 0), (4, 4), (5, 5)],
         [(0, 0), (1, 1), (2, 0), (3, 0), (4, 4), (5, 5)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 4), (5, 5)],
         [(0, 0), (1, 1), (2, 2), (3, 0), (4, 4), (5, 5)]] 


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(T)
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Obtaining the leaf nodes of T
    Llf=tpl_leaf_set(T)
    # Expressing the functions
    if len(Llf) == 0:
        return prod(A[i,T[i][1]] for i in rg(sz))
    else:
        return [Monomial2Tuple(t, A.list(), sz) for t in expand(prod(A[i,i]+A[i,T[i][1]] for i in Llf)*prod(A[i,T[i][1]] for i in rg(sz) if not i in Llf)).operands() if t!=1]

def Contract(T,l):
    """
    returns the contraction of the tuple description of the input T
    specified by the list l derived from the monomial contraction listing.
    This is part of the Rufus Isaacs compositional square root theorem.
    The input is tuple description of the function of interest
    the integer one indicates no contraction when it occurs as a
    monomial in each internal list the edges a separated according
    to the pre-image structure.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]; l=[[(1, 0), (2, 0), (3, 0)], [(4, 3), (5, 3)]]; Contract(T,l)
        [(0, 0), (1, 0), (2, 2), (3, 3), (4, 1), (5, 5)]

 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the copy
    Tp=copy(T)
    # Initialization of the size parameter
    sz=len(Tp)
    # Initialization of the modifier which implements the merger as a function
    mrG=[(i,i) for i in rg(sz)]
    # Initialization of the list of currently merged vertices 
    bL=[]
    # Looping throug the list specifying the contrations
    for ll in l:
        if len(ll)>1:
            for i in rg(1,len(ll)):
                Tp[ll[i][0]]=(ll[i][0],ll[i][0])
                bL.append(ll[i][0])
            for i in rg(1,len(ll)):
                mrG[ll[i][0]]=(ll[i][0],ll[0][0])
    #print('bL=',bL); print('mrG=',mrG)
    # fixing the image set
    for i in rg(sz):
        if (not Tp[i][0] in bL) and (Tp[i][1] in bL):
            Tp[i]=(i,mrG[Tp[i][1]][1])
    return Tp

def ContractionTupleList(T):
    """
    returns a list of list which are associated 
    with possible contraction according to the contraction
    part of the Rufus Isaacs compositional square root theorem.
    The input is tuple description of the function of interest
    the integer one indicates no contraction when it occurs as a
    monomial in each internal list the edges a separated according
    to the pre-image structure.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 3)]; ContractionTupleList(T)
        [[(0, 0), (1, 0), (2, 2), (3, 3), (4, 1), (5, 5)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 0), (2, 0), (3, 3), (4, 1), (5, 5)],
         [(0, 0), (1, 0), (2, 0), (3, 3), (4, 2), (5, 5)],
         [(0, 0), (1, 0), (2, 0), (3, 0), (4, 3), (5, 5)],
         [(0, 0), (1, 0), (2, 2), (3, 3), (4, 1), (5, 1)],
         [(0, 0), (1, 0), (2, 2), (3, 0), (4, 3), (5, 3)],
         [(0, 0), (1, 0), (2, 0), (3, 3), (4, 1), (5, 1)],
         [(0, 0), (1, 0), (2, 0), (3, 3), (4, 2), (5, 2)]]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(T)
    # Initialization of the list of matrix
    A=HM(sz,sz,'a')
    # Initialization of the list of pre-images
    Lpre=tpl_pre_image_set_functionII(T)
    # Initialization of the contraction candidate list
    L=[expand(prod(1+A[Lpre[j][k],j] for k in rg(len(Lpre[j])))-sum(A[Lpre[j][k],j] for k in rg(len(Lpre[j])))).operands() for j in rg(len(Lpre)) if len(Lpre[j])>1]
    # Loop initializing the index list for contraction prescriptions
    l=[len(L[i]) for i in rg(len(L))]
    # Initialization of the list which will store the final result
    Lr=[]
    # Main loop performing the transposition of the entries
    for i in range(prod(l)):
        # Turning the index i into an hypermatrix array location using the decimal encoding trick
        entry = [Integer(mod(i,l[0]))]
        sm = Integer(mod(i,l[0]))
        for k in range(len(l)-1):
            entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
            sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
        Lr.append([L[i][entry[i]] for i in rg(len(l))])
    # Initialization of the list which prescribes the non loop edge contractions
    Lr.pop() # Getting rid of the [1,1]
    # Initialization of the tuple description of the part which are to be contracted
    rLs=[[Monomial2Tuple(Lr[i][t],A.list(),sz) for t in rg(len(Lr[i])) if Lr[i][t]!=Integer(1)] for i in rg(len(Lr))]
    # Converting the description into functions
    Rslt=[]
    for l in rLs:
        #Rslt.append([[(l[j][i][0],l[j][0][0]) for i in rg(1,len(l[j]))]+[(k,k) for k in rg(sz) if k not in [l[j][i][0] for i in rg(1,len(l[j]))]] for j in rg(len(l))])
        #for i in rg(len(Rslt[len(Rslt)-1])):
        #    Rslt[len(Rslt)-1][i].sort()
        Rslt.append(Contract(T,l))
    return Rslt

def generate_unlabeled_listing_scriptA(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled directed graph on sz vertices
    allowing for loop edges this implementation is very
    slow.


    EXAMPLES:

    ::

        sage: sz=Integer(2); generate_unlabeled_listing_scriptA(sz)
        sage: load('Unlabeled_Listing_of_Directed_Graphs_on_2_vertices.sage')
        sage: L
        [a_a00^2*a_a01^2*a_a10^2*a_a11^2,
         2*a_c00*a_c01*a_c11*a_d00*a_d10*a_d11,
         2*a_b00*a_b01*a_b10*a_e01*a_e10*a_e11,
         a_h01^2*a_h10^2,
         a_i00^2*a_i11^2,
         2*a_g00*a_g10*a_j01*a_j11,
         2*a_f00*a_f01*a_k10*a_k11,
         2*a_m01*a_n10,
         2*a_l00*a_o11]
        sage: sz=Integer(3); generate_unlabeled_listing_scriptA(sz)
        sage: load('Unlabeled_Listing_of_Directed_Graphs_on_3_vertices.sage')
        sage: L
        [a_a_a00^6*a_a_a01^6*a_a_a02^6*a_a_a10^6*a_a_a11^6*a_a_a12^6*a_a_a20^6*a_a_a21^6*a_a_a22^6,
         6*a_a_c00*a_a_c01*a_a_c02*a_a_c10*a_a_c11*a_a_c12*a_a_c20*a_a_c22*a_a_d00*a_a_d01*a_a_d02*a_a_d10*a_a_d11*a_a_d12*a_a_d21*a_a_d22*a_a_e00*a_a_e01*a_a_e02*a_a_e10*a_a_e11*a_a_e20*a_a_e21*a_a_e22*a_a_g00*a_a_g01*a_a_g02*a_a_g11*a_a_g12*a_a_g20*a_a_g21*a_a_g22*a_a_h00*a_a_h01*a_a_h10*a_a_h11*a_a_h12*a_a_h20*a_a_h21*a_a_h22*a_a_i00*a_a_i02*a_a_i10*a_a_i11*a_a_i12*a_a_i20*a_a_i21*a_a_i22,
         3*a_a_b00^2*a_a_b01^2*a_a_b02^2*a_a_b10^2*a_a_b11^2*a_a_b12^2*a_a_b20^2*a_a_b21^2*a_a_f00^2*a_a_f01^2*a_a_f02^2*a_a_f10^2*a_a_f12^2*a_a_f20^2*a_a_f21^2*a_a_f22^2*a_a_j01^2*a_a_j02^2*a_a_j10^2*a_a_j11^2*a_a_j12^2*a_a_j20^2*a_a_j21^2*a_a_j22^2,
         3*a_a_x00^2*a_a_x02^2*a_a_x10^2*a_a_x11^2*a_a_x12^2*a_a_x20^2*a_a_x22^2*a_b_b00^2*a_b_b01^2*a_b_b02^2*a_b_b11^2*a_b_b12^2*a_b_b21^2*a_b_b22^2*a_b_h00^2*a_b_h01^2*a_b_h10^2*a_b_h11^2*a_b_h20^2*a_b_h21^2*a_b_h22^2,
         6*a_a_o00*a_a_o01*a_a_o02*a_a_o11*a_a_o12*a_a_o20*a_a_o21*a_a_q00*a_a_q02*a_a_q10*a_a_q11*a_a_q12*a_a_q20*a_a_q21*a_a_y01*a_a_y02*a_a_y10*a_a_y11*a_a_y12*a_a_y20*a_a_y22*a_b_a00*a_b_a01*a_b_a02*a_b_a10*a_b_a12*a_b_a21*a_b_a22*a_b_j01*a_b_j02*a_b_j10*a_b_j11*a_b_j20*a_b_j21*a_b_j22*a_b_l00*a_b_l01*a_b_l10*a_b_l12*a_b_l20*a_b_l21*a_b_l22,
         3*a_a_n00^2*a_a_n01^2*a_a_n02^2*a_a_n10^2*a_a_n12^2*a_a_n20^2*a_a_n21^2*a_a_r01^2*a_a_r02^2*a_a_r10^2*a_a_r11^2*a_a_r12^2*a_a_r20^2*a_a_r21^2*a_b_n01^2*a_b_n02^2*a_b_n10^2*a_b_n12^2*a_b_n20^2*a_b_n21^2*a_b_n22^2,
         6*a_a_v00*a_a_v01*a_a_v02*a_a_v11*a_a_v12*a_a_v20*a_a_v22*a_a_w00*a_a_w01*a_a_w10*a_a_w11*a_a_w12*a_a_w20*a_a_w22*a_a_z00*a_a_z01*a_a_z02*a_a_z10*a_a_z11*a_a_z21*a_a_z22*a_b_d00*a_b_d02*a_b_d10*a_b_d11*a_b_d12*a_b_d21*a_b_d22*a_b_i00*a_b_i02*a_b_i10*a_b_i11*a_b_i20*a_b_i21*a_b_i22*a_b_o00*a_b_o01*a_b_o11*a_b_o12*a_b_o20*a_b_o21*a_b_o22,
         3*a_a_t00^2*a_a_t01^2*a_a_t02^2*a_a_t10^2*a_a_t11^2*a_a_t20^2*a_a_t22^2*a_b_c00^2*a_b_c01^2*a_b_c10^2*a_b_c11^2*a_b_c12^2*a_b_c21^2*a_b_c22^2*a_b_p00^2*a_b_p02^2*a_b_p11^2*a_b_p12^2*a_b_p20^2*a_b_p21^2*a_b_p22^2,
         6*a_a_m00*a_a_m01*a_a_m02*a_a_m10*a_a_m11*a_a_m20*a_a_m21*a_a_p00*a_a_p01*a_a_p10*a_a_p11*a_a_p12*a_a_p20*a_a_p21*a_a_u00*a_a_u01*a_a_u02*a_a_u10*a_a_u12*a_a_u20*a_a_u22*a_b_e01*a_b_e02*a_b_e10*a_b_e11*a_b_e12*a_b_e21*a_b_e22*a_b_m00*a_b_m02*a_b_m10*a_b_m12*a_b_m20*a_b_m21*a_b_m22*a_b_q01*a_b_q02*a_b_q11*a_b_q12*a_b_q20*a_b_q21*a_b_q22,
         3*a_a_s00^2*a_a_s01^2*a_a_s02^2*a_a_s10^2*a_a_s11^2*a_a_s12^2*a_a_s22^2*a_b_g00^2*a_b_g01^2*a_b_g02^2*a_b_g11^2*a_b_g20^2*a_b_g21^2*a_b_g22^2*a_b_r00^2*a_b_r10^2*a_b_r11^2*a_b_r12^2*a_b_r20^2*a_b_r21^2*a_b_r22^2,
         6*a_a_k00*a_a_k01*a_a_k02*a_a_k10*a_a_k11*a_a_k12*a_a_k20*a_a_l00*a_a_l01*a_a_l02*a_a_l10*a_a_l11*a_a_l12*a_a_l21*a_b_f00*a_b_f01*a_b_f02*a_b_f10*a_b_f20*a_b_f21*a_b_f22*a_b_k00*a_b_k01*a_b_k02*a_b_k12*a_b_k20*a_b_k21*a_b_k22*a_b_s01*a_b_s10*a_b_s11*a_b_s12*a_b_s20*a_b_s21*a_b_s22*a_b_t02*a_b_t10*a_b_t11*a_b_t12*a_b_t20*a_b_t21*a_b_t22,
         a_c_p01^6*a_c_p02^6*a_c_p10^6*a_c_p12^6*a_c_p20^6*a_c_p21^6,
         2*a_d_l00^3*a_d_l01^3*a_d_l11^3*a_d_l12^3*a_d_l20^3*a_d_l22^3*a_d_u00^3*a_d_u02^3*a_d_u10^3*a_d_u11^3*a_d_u21^3*a_d_u22^3,
         3*a_c_r00^2*a_c_r02^2*a_c_r11^2*a_c_r12^2*a_c_r20^2*a_c_r21^2*a_d_g01^2*a_d_g02^2*a_d_g10^2*a_d_g11^2*a_d_g20^2*a_d_g22^2*a_d_x00^2*a_d_x01^2*a_d_x10^2*a_d_x12^2*a_d_x21^2*a_d_x22^2,
         6*a_c_k00*a_c_k02*a_c_k10*a_c_k11*a_c_k20*a_c_k21*a_c_q00*a_c_q01*a_c_q11*a_c_q12*a_c_q20*a_c_q21*a_d_i00*a_d_i01*a_d_i10*a_d_i12*a_d_i20*a_d_i22*a_d_n01*a_d_n02*a_d_n11*a_d_n12*a_d_n20*a_d_n22*a_d_v01*a_d_v02*a_d_v10*a_d_v11*a_d_v21*a_d_v22*a_d_y00*a_d_y02*a_d_y10*a_d_y12*a_d_y21*a_d_y22,
         6*a_c_l01*a_c_l02*a_c_l10*a_c_l11*a_c_l20*a_c_l21*a_c_n00*a_c_n01*a_c_n10*a_c_n12*a_c_n20*a_c_n21*a_c_o00*a_c_o02*a_c_o10*a_c_o12*a_c_o20*a_c_o21*a_c_s01*a_c_s02*a_c_s11*a_c_s12*a_c_s20*a_c_s21*a_d_k01*a_d_k02*a_d_k10*a_d_k12*a_d_k20*a_d_k22*a_d_z01*a_d_z02*a_d_z10*a_d_z12*a_d_z21*a_d_z22,
         6*a_d_e00*a_d_e01*a_d_e10*a_d_e11*a_d_e20*a_d_e22*a_d_f00*a_d_f02*a_d_f10*a_d_f11*a_d_f20*a_d_f22*a_d_m00*a_d_m02*a_d_m11*a_d_m12*a_d_m20*a_d_m22*a_d_t00*a_d_t01*a_d_t10*a_d_t11*a_d_t21*a_d_t22*a_e_a00*a_e_a01*a_e_a11*a_e_a12*a_e_a21*a_e_a22*a_e_b00*a_e_b02*a_e_b11*a_e_b12*a_e_b21*a_e_b22,
         3*a_c_j00^2*a_c_j01^2*a_c_j10^2*a_c_j11^2*a_c_j20^2*a_c_j21^2*a_d_j00^2*a_d_j02^2*a_d_j10^2*a_d_j12^2*a_d_j20^2*a_d_j22^2*a_e_c01^2*a_e_c02^2*a_e_c11^2*a_e_c12^2*a_e_c21^2*a_e_c22^2,
         6*a_c_y00*a_c_y01*a_c_y02*a_c_y11*a_c_y12*a_c_y22*a_d_a00*a_d_a02*a_d_a10*a_d_a11*a_d_a12*a_d_a22*a_d_o00*a_d_o10*a_d_o11*a_d_o12*a_d_o20*a_d_o22*a_d_s00*a_d_s01*a_d_s02*a_d_s11*a_d_s21*a_d_s22*a_e_k00*a_e_k01*a_e_k11*a_e_k20*a_e_k21*a_e_k22*a_e_n00*a_e_n10*a_e_n11*a_e_n20*a_e_n21*a_e_n22,
         6*a_b_z00*a_b_z02*a_b_z10*a_b_z11*a_b_z12*a_b_z20*a_c_d00*a_c_d01*a_c_d02*a_c_d11*a_c_d12*a_c_d21*a_d_q02*a_d_q10*a_d_q11*a_d_q12*a_d_q20*a_d_q22*a_d_w00*a_d_w01*a_d_w02*a_d_w12*a_d_w21*a_d_w22*a_e_h00*a_e_h01*a_e_h10*a_e_h20*a_e_h21*a_e_h22*a_e_o01*a_e_o10*a_e_o11*a_e_o20*a_e_o21*a_e_o22,
         6*a_b_x00*a_b_x01*a_b_x02*a_b_x11*a_b_x12*a_b_x20*a_c_f00*a_c_f02*a_c_f10*a_c_f11*a_c_f12*a_c_f21*a_d_p01*a_d_p10*a_d_p11*a_d_p12*a_d_p20*a_d_p22*a_d_r00*a_d_r01*a_d_r02*a_d_r10*a_d_r21*a_d_r22*a_e_p02*a_e_p10*a_e_p11*a_e_p20*a_e_p21*a_e_p22*a_e_q00*a_e_q01*a_e_q12*a_e_q20*a_e_q21*a_e_q22,
         6*a_c_i00*a_c_i01*a_c_i02*a_c_i11*a_c_i20*a_c_i21*a_c_t00*a_c_t10*a_c_t11*a_c_t12*a_c_t20*a_c_t21*a_c_x00*a_c_x01*a_c_x02*a_c_x10*a_c_x12*a_c_x22*a_d_b01*a_d_b02*a_d_b10*a_d_b11*a_d_b12*a_d_b22*a_e_m01*a_e_m02*a_e_m11*a_e_m20*a_e_m21*a_e_m22*a_e_t00*a_e_t10*a_e_t12*a_e_t20*a_e_t21*a_e_t22,
         6*a_c_a01*a_c_a02*a_c_a10*a_c_a11*a_c_a12*a_c_a20*a_c_c00*a_c_c01*a_c_c02*a_c_c10*a_c_c12*a_c_c21*a_c_m00*a_c_m01*a_c_m02*a_c_m12*a_c_m20*a_c_m21*a_c_v02*a_c_v10*a_c_v11*a_c_v12*a_c_v20*a_c_v21*a_e_j01*a_e_j02*a_e_j10*a_e_j20*a_e_j21*a_e_j22*a_e_u01*a_e_u10*a_e_u12*a_e_u20*a_e_u21*a_e_u22,
         6*a_b_w00*a_b_w01*a_b_w02*a_b_w10*a_b_w12*a_b_w20*a_c_g01*a_c_g02*a_c_g10*a_c_g11*a_c_g12*a_c_g21*a_c_h00*a_c_h01*a_c_h02*a_c_h10*a_c_h20*a_c_h21*a_c_u01*a_c_u10*a_c_u11*a_c_u12*a_c_u20*a_c_u21*a_e_s01*a_e_s02*a_e_s12*a_e_s20*a_e_s21*a_e_s22*a_e_v02*a_e_v10*a_e_v12*a_e_v20*a_e_v21*a_e_v22,
         6*a_c_w00*a_c_w01*a_c_w02*a_c_w10*a_c_w11*a_c_w22*a_c_z00*a_c_z01*a_c_z10*a_c_z11*a_c_z12*a_c_z22*a_d_d00*a_d_d01*a_d_d02*a_d_d11*a_d_d20*a_d_d22*a_e_d00*a_e_d10*a_e_d11*a_e_d12*a_e_d21*a_e_d22*a_e_l00*a_e_l02*a_e_l11*a_e_l20*a_e_l21*a_e_l22*a_e_w00*a_e_w11*a_e_w12*a_e_w20*a_e_w21*a_e_w22,
         6*a_b_y00*a_b_y01*a_b_y10*a_b_y11*a_b_y12*a_b_y20*a_c_b00*a_c_b01*a_c_b02*a_c_b10*a_c_b11*a_c_b21*a_d_h00*a_d_h01*a_d_h02*a_d_h12*a_d_h20*a_d_h22*a_e_f02*a_e_f10*a_e_f11*a_e_f12*a_e_f21*a_e_f22*a_e_i00*a_e_i02*a_e_i10*a_e_i20*a_e_i21*a_e_i22*a_e_x01*a_e_x11*a_e_x12*a_e_x20*a_e_x21*a_e_x22,
         6*a_b_v00*a_b_v01*a_b_v02*a_b_v10*a_b_v11*a_b_v20*a_c_e00*a_c_e01*a_c_e10*a_c_e11*a_c_e12*a_c_e21*a_d_c00*a_d_c01*a_d_c02*a_d_c10*a_d_c20*a_d_c22*a_e_e01*a_e_e10*a_e_e11*a_e_e12*a_e_e21*a_e_e22*a_e_r00*a_e_r02*a_e_r12*a_e_r20*a_e_r21*a_e_r22*a_e_y02*a_e_y11*a_e_y12*a_e_y20*a_e_y21*a_e_y22,
         3*a_b_u00^2*a_b_u01^2*a_b_u02^2*a_b_u10^2*a_b_u11^2*a_b_u12^2*a_e_g00^2*a_e_g01^2*a_e_g02^2*a_e_g20^2*a_e_g21^2*a_e_g22^2*a_e_z10^2*a_e_z11^2*a_e_z12^2*a_e_z20^2*a_e_z21^2*a_e_z22^2,
         6*a_f_o01*a_f_o02*a_f_o10*a_f_o12*a_f_o20*a_g_d01*a_g_d02*a_g_d10*a_g_d12*a_g_d21*a_g_n01*a_g_n02*a_g_n10*a_g_n20*a_g_n21*a_g_w01*a_g_w02*a_g_w12*a_g_w20*a_g_w21*a_g_y01*a_g_y10*a_g_y12*a_g_y20*a_g_y21*a_g_z02*a_g_z10*a_g_z12*a_g_z20*a_g_z21,
         3*a_g_q01^2*a_g_q02^2*a_g_q11^2*a_g_q20^2*a_g_q21^2*a_g_x00^2*a_g_x10^2*a_g_x12^2*a_g_x20^2*a_g_x21^2*a_h_m01^2*a_h_m02^2*a_h_m10^2*a_h_m12^2*a_h_m22^2,
         6*a_f_r01*a_f_r02*a_f_r11*a_f_r12*a_f_r20*a_g_c00*a_g_c02*a_g_c10*a_g_c12*a_g_c21*a_g_t02*a_g_t10*a_g_t11*a_g_t20*a_g_t21*a_g_u00*a_g_u01*a_g_u12*a_g_u20*a_g_u21*a_i_h01*a_i_h10*a_i_h12*a_i_h20*a_i_h22*a_i_q01*a_i_q02*a_i_q10*a_i_q21*a_i_q22,
         3*a_h_o00^2*a_h_o02^2*a_h_o11^2*a_h_o12^2*a_h_o22^2*a_i_a00^2*a_i_a10^2*a_i_a11^2*a_i_a20^2*a_i_a22^2*a_i_r00^2*a_i_r01^2*a_i_r11^2*a_i_r21^2*a_i_r22^2,
         6*a_g_o00*a_g_o01*a_g_o11*a_g_o20*a_g_o21*a_g_r00*a_g_r10*a_g_r11*a_g_r20*a_g_r21*a_h_l00*a_h_l02*a_h_l10*a_h_l12*a_h_l22*a_h_p01*a_h_p02*a_h_p11*a_h_p12*a_h_p22*a_i_g00*a_i_g10*a_i_g12*a_i_g20*a_i_g22*a_i_t01*a_i_t02*a_i_t11*a_i_t21*a_i_t22,
         6*a_h_h00*a_h_h02*a_h_h10*a_h_h11*a_h_h22*a_h_n00*a_h_n01*a_h_n11*a_h_n12*a_h_n22*a_h_x00*a_h_x01*a_h_x11*a_h_x20*a_h_x22*a_i_j00*a_i_j11*a_i_j12*a_i_j20*a_i_j22*a_i_s00*a_i_s02*a_i_s11*a_i_s21*a_i_s22*a_i_u00*a_i_u10*a_i_u11*a_i_u21*a_i_u22,
         6*a_f_p00*a_f_p01*a_f_p11*a_f_p12*a_f_p20*a_f_y00*a_f_y02*a_f_y10*a_f_y11*a_f_y21*a_i_d00*a_i_d01*a_i_d12*a_i_d20*a_i_d22*a_i_k01*a_i_k11*a_i_k12*a_i_k20*a_i_k22*a_i_p00*a_i_p02*a_i_p10*a_i_p21*a_i_p22*a_i_w02*a_i_w10*a_i_w11*a_i_w21*a_i_w22,
         6*a_f_q00*a_f_q02*a_f_q11*a_f_q12*a_f_q20*a_g_f00*a_g_f02*a_g_f11*a_g_f12*a_g_f21*a_i_b01*a_i_b10*a_i_b11*a_i_b20*a_i_b22*a_i_c02*a_i_c10*a_i_c11*a_i_c20*a_i_c22*a_i_o00*a_i_o01*a_i_o10*a_i_o21*a_i_o22*a_i_x00*a_i_x01*a_i_x12*a_i_x21*a_i_x22,
         6*a_f_j00*a_f_j02*a_f_j10*a_f_j11*a_f_j20*a_g_e00*a_g_e01*a_g_e11*a_g_e12*a_g_e21*a_h_u00*a_h_u01*a_h_u10*a_h_u20*a_h_u22*a_i_l02*a_i_l11*a_i_l12*a_i_l20*a_i_l22*a_i_v01*a_i_v10*a_i_v11*a_i_v21*a_i_v22*a_i_y00*a_i_y02*a_i_y12*a_i_y21*a_i_y22,
         6*a_f_n00*a_f_n02*a_f_n10*a_f_n12*a_f_n20*a_g_g01*a_g_g02*a_g_g11*a_g_g12*a_g_g21*a_g_l00*a_g_l01*a_g_l10*a_g_l20*a_g_l21*a_g_s01*a_g_s10*a_g_s11*a_g_s20*a_g_s21*a_i_i02*a_i_i10*a_i_i12*a_i_i20*a_i_i22*a_i_z01*a_i_z02*a_i_z12*a_i_z21*a_i_z22,
         6*a_g_p00*a_g_p02*a_g_p11*a_g_p20*a_g_p21*a_h_a00*a_h_a11*a_h_a12*a_h_a20*a_h_a21*a_h_i01*a_h_i02*a_h_i10*a_h_i11*a_h_i22*a_h_k00*a_h_k01*a_h_k10*a_h_k12*a_h_k22*a_h_z01*a_h_z02*a_h_z11*a_h_z20*a_h_z22*a_j_a00*a_j_a10*a_j_a12*a_j_a21*a_j_a22,
         6*a_f_k01*a_f_k02*a_f_k10*a_f_k11*a_f_k20*a_g_b00*a_g_b01*a_g_b10*a_g_b12*a_g_b21*a_g_v00*a_g_v02*a_g_v12*a_g_v20*a_g_v21*a_h_c02*a_h_c11*a_h_c12*a_h_c20*a_h_c21*a_h_w01*a_h_w02*a_h_w10*a_h_w20*a_h_w22*a_j_b01*a_j_b10*a_j_b12*a_j_b21*a_j_b22,
         6*a_f_m00*a_f_m01*a_f_m10*a_f_m12*a_f_m20*a_f_z01*a_f_z02*a_f_z10*a_f_z11*a_f_z21*a_g_m00*a_g_m02*a_g_m10*a_g_m20*a_g_m21*a_h_b01*a_h_b11*a_h_b12*a_h_b20*a_h_b21*a_i_f01*a_i_f02*a_i_f12*a_i_f20*a_i_f22*a_j_c02*a_j_c10*a_j_c12*a_j_c21*a_j_c22,
         3*a_h_g00^2*a_h_g01^2*a_h_g10^2*a_h_g11^2*a_h_g22^2*a_h_y00^2*a_h_y02^2*a_h_y11^2*a_h_y20^2*a_h_y22^2*a_j_d00^2*a_j_d11^2*a_j_d12^2*a_j_d21^2*a_j_d22^2,
         6*a_f_i00*a_f_i01*a_f_i10*a_f_i11*a_f_i20*a_f_x00*a_f_x01*a_f_x10*a_f_x11*a_f_x21*a_h_v00*a_h_v02*a_h_v10*a_h_v20*a_h_v22*a_i_e00*a_i_e02*a_i_e12*a_i_e20*a_i_e22*a_j_e01*a_j_e11*a_j_e12*a_j_e21*a_j_e22*a_j_f02*a_j_f11*a_j_f12*a_j_f21*a_j_f22,
         3*a_f_u02^2*a_f_u10^2*a_f_u11^2*a_f_u12^2*a_f_u20^2*a_g_a00^2*a_g_a01^2*a_g_a02^2*a_g_a12^2*a_g_a21^2*a_j_l01^2*a_j_l10^2*a_j_l20^2*a_j_l21^2*a_j_l22^2,
         3*a_h_f00^2*a_h_f01^2*a_h_f02^2*a_h_f11^2*a_h_f22^2*a_h_q00^2*a_h_q10^2*a_h_q11^2*a_h_q12^2*a_h_q22^2*a_j_n00^2*a_j_n11^2*a_j_n20^2*a_j_n21^2*a_j_n22^2,
         6*a_f_s00*a_f_s10*a_f_s11*a_f_s12*a_f_s20*a_f_w00*a_f_w01*a_f_w02*a_f_w11*a_f_w21*a_h_j00*a_h_j01*a_h_j02*a_h_j12*a_h_j22*a_h_s02*a_h_s10*a_h_s11*a_h_s12*a_h_s22*a_j_k00*a_j_k10*a_j_k20*a_j_k21*a_j_k22*a_j_o01*a_j_o11*a_j_o20*a_j_o21*a_j_o22,
         6*a_f_c00*a_f_c01*a_f_c02*a_f_c11*a_f_c12*a_f_e00*a_f_e02*a_f_e10*a_f_e11*a_f_e12*a_i_m10*a_i_m11*a_i_m12*a_i_m20*a_i_m22*a_i_n00*a_i_n01*a_i_n02*a_i_n21*a_i_n22*a_j_h00*a_j_h01*a_j_h20*a_j_h21*a_j_h22*a_j_q10*a_j_q11*a_j_q20*a_j_q21*a_j_q22,
         6*a_f_h00*a_f_h01*a_f_h02*a_f_h11*a_f_h20*a_g_h00*a_g_h10*a_g_h11*a_g_h12*a_g_h21*a_h_e00*a_h_e01*a_h_e02*a_h_e10*a_h_e22*a_h_r01*a_h_r10*a_h_r11*a_h_r12*a_h_r22*a_j_p02*a_j_p11*a_j_p20*a_j_p21*a_j_p22*a_j_r00*a_j_r12*a_j_r20*a_j_r21*a_j_r22,
         6*a_f_l00*a_f_l01*a_f_l02*a_f_l12*a_f_l20*a_f_t01*a_f_t10*a_f_t11*a_f_t12*a_f_t20*a_f_v00*a_f_v01*a_f_v02*a_f_v10*a_f_v21*a_g_j02*a_g_j10*a_g_j11*a_g_j12*a_g_j21*a_j_m02*a_j_m10*a_j_m20*a_j_m21*a_j_m22*a_j_s01*a_j_s12*a_j_s20*a_j_s21*a_j_s22,
         3*a_f_g00^2*a_f_g01^2*a_f_g02^2*a_f_g10^2*a_f_g20^2*a_g_i01^2*a_g_i10^2*a_g_i11^2*a_g_i12^2*a_g_i21^2*a_j_t02^2*a_j_t12^2*a_j_t20^2*a_j_t21^2*a_j_t22^2,
         6*a_f_b00*a_f_b01*a_f_b02*a_f_b10*a_f_b12*a_f_f01*a_f_f02*a_f_f10*a_f_f11*a_f_f12*a_g_k00*a_g_k01*a_g_k02*a_g_k20*a_g_k21*a_h_d10*a_h_d11*a_h_d12*a_h_d20*a_h_d21*a_j_j01*a_j_j02*a_j_j20*a_j_j21*a_j_j22*a_j_u10*a_j_u12*a_j_u20*a_j_u21*a_j_u22,
         6*a_f_a00*a_f_a01*a_f_a02*a_f_a10*a_f_a11*a_f_d00*a_f_d01*a_f_d10*a_f_d11*a_f_d12*a_h_t00*a_h_t01*a_h_t02*a_h_t20*a_h_t22*a_j_g10*a_j_g11*a_j_g12*a_j_g21*a_j_g22*a_j_i00*a_j_i02*a_j_i20*a_j_i21*a_j_i22*a_j_v11*a_j_v12*a_j_v20*a_j_v21*a_j_v22,
         3*a_l_a02^2*a_l_a10^2*a_l_a12^2*a_l_a20^2*a_l_r01^2*a_l_r02^2*a_l_r12^2*a_l_r21^2*a_m_d01^2*a_m_d10^2*a_m_d20^2*a_m_d21^2,
         6*a_k_x01*a_k_x02*a_k_x12*a_k_x20*a_k_z01*a_k_z10*a_k_z12*a_k_z20*a_l_i01*a_l_i02*a_l_i10*a_l_i21*a_l_u02*a_l_u10*a_l_u12*a_l_u21*a_m_e02*a_m_e10*a_m_e20*a_m_e21*a_m_k01*a_m_k12*a_m_k20*a_m_k21,
         3*a_k_o01^2*a_k_o02^2*a_k_o10^2*a_k_o20^2*a_l_t01^2*a_l_t10^2*a_l_t12^2*a_l_t21^2*a_m_l02^2*a_m_l12^2*a_m_l20^2*a_m_l21^2,
         3*a_k_e01^2*a_k_e02^2*a_k_e10^2*a_k_e12^2*a_m_b01^2*a_m_b02^2*a_m_b20^2*a_m_b21^2*a_m_m10^2*a_m_m12^2*a_m_m20^2*a_m_m21^2,
         3*a_m_f00^2*a_m_f11^2*a_m_f20^2*a_m_f21^2*a_m_u01^2*a_m_u02^2*a_m_u11^2*a_m_u22^2*a_n_b00^2*a_n_b10^2*a_n_b12^2*a_n_b22^2,
         6*a_k_r01*a_k_r02*a_k_r11*a_k_r20*a_l_s00*a_l_s10*a_l_s12*a_l_s21*a_m_h02*a_m_h11*a_m_h20*a_m_h21*a_m_j00*a_m_j12*a_m_j20*a_m_j21*a_m_r01*a_m_r02*a_m_r10*a_m_r22*a_n_c01*a_n_c10*a_n_c12*a_n_c22,
         6*a_k_y00*a_k_y10*a_k_y12*a_k_y20*a_l_l01*a_l_l02*a_l_l11*a_l_l21*a_m_c00*a_m_c10*a_m_c20*a_m_c21*a_m_g01*a_m_g11*a_m_g20*a_m_g21*a_n_a01*a_n_a02*a_n_a12*a_n_a22*a_n_d02*a_n_d10*a_n_d12*a_n_d22,
         3*a_k_g00^2*a_k_g02^2*a_k_g11^2*a_k_g12^2*a_n_r10^2*a_n_r11^2*a_n_r20^2*a_n_r22^2*a_n_x00^2*a_n_x01^2*a_n_x21^2*a_n_x22^2,
         6*a_k_d00*a_k_d02*a_k_d10*a_k_d12*a_k_h01*a_k_h02*a_k_h11*a_k_h12*a_l_z00*a_l_z01*a_l_z20*a_l_z21*a_m_i10*a_m_i11*a_m_i20*a_m_i21*a_n_v10*a_n_v12*a_n_v20*a_n_v22*a_n_z01*a_n_z02*a_n_z21*a_n_z22,
         6*a_l_b00*a_l_b11*a_l_b12*a_l_b20*a_l_k00*a_l_k02*a_l_k11*a_l_k21*a_m_x02*a_m_x10*a_m_x11*a_m_x22*a_m_y00*a_m_y01*a_m_y12*a_m_y22*a_n_p01*a_n_p11*a_n_p20*a_n_p22*a_o_a00*a_o_a10*a_o_a21*a_o_a22,
         6*a_k_u02*a_k_u10*a_k_u11*a_k_u20*a_l_d02*a_l_d11*a_l_d12*a_l_d20*a_l_p00*a_l_p01*a_l_p12*a_l_p21*a_l_q00*a_l_q02*a_l_q12*a_l_q21*a_n_m01*a_n_m10*a_n_m20*a_n_m22*a_o_b01*a_o_b10*a_o_b21*a_o_b22,
         6*a_k_v00*a_k_v01*a_k_v12*a_k_v20*a_l_c01*a_l_c11*a_l_c12*a_l_c20*a_l_h00*a_l_h02*a_l_h10*a_l_h21*a_l_o02*a_l_o10*a_l_o11*a_l_o21*a_n_t01*a_n_t12*a_n_t20*a_n_t22*a_o_c02*a_o_c10*a_o_c21*a_o_c22,
         6*a_m_s00*a_m_s01*a_m_s11*a_m_s22*a_m_t00*a_m_t02*a_m_t11*a_m_t22*a_m_v00*a_m_v10*a_m_v11*a_m_v22*a_n_e00*a_n_e11*a_n_e12*a_n_e22*a_n_o00*a_n_o11*a_n_o20*a_n_o22*a_o_d00*a_o_d11*a_o_d21*a_o_d22,
         6*a_k_s00*a_k_s10*a_k_s11*a_k_s20*a_l_j00*a_l_j01*a_l_j11*a_l_j21*a_m_z00*a_m_z02*a_m_z12*a_m_z22*a_n_g02*a_n_g11*a_n_g12*a_n_g22*a_n_l00*a_n_l10*a_n_l20*a_n_l22*a_o_e01*a_o_e11*a_o_e21*a_o_e22,
         6*a_k_p00*a_k_p01*a_k_p11*a_k_p20*a_l_m00*a_l_m10*a_l_m11*a_l_m21*a_m_q00*a_m_q02*a_m_q10*a_m_q22*a_n_f01*a_n_f11*a_n_f12*a_n_f22*a_n_s00*a_n_s12*a_n_s20*a_n_s22*a_o_f02*a_o_f11*a_o_f21*a_o_f22,
         6*a_j_z00*a_j_z02*a_j_z10*a_j_z11*a_k_f00*a_k_f01*a_k_f11*a_k_f12*a_n_i00*a_n_i01*a_n_i20*a_n_i22*a_n_w11*a_n_w12*a_n_w20*a_n_w22*a_n_y00*a_n_y02*a_n_y21*a_n_y22*a_o_g10*a_o_g11*a_o_g21*a_o_g22,
         6*a_k_q00*a_k_q02*a_k_q11*a_k_q20*a_l_v00*a_l_v11*a_l_v12*a_l_v21*a_m_p00*a_m_p01*a_m_p10*a_m_p22*a_m_w01*a_m_w10*a_m_w11*a_m_w22*a_n_q02*a_n_q11*a_n_q20*a_n_q22*a_o_h00*a_o_h12*a_o_h21*a_o_h22,
         6*a_k_t01*a_k_t10*a_k_t11*a_k_t20*a_k_w00*a_k_w02*a_k_w12*a_k_w20*a_l_g00*a_l_g01*a_l_g10*a_l_g21*a_l_x02*a_l_x11*a_l_x12*a_l_x21*a_n_n02*a_n_n10*a_n_n20*a_n_n22*a_o_i01*a_o_i12*a_o_i21*a_o_i22,
         6*a_k_m00*a_k_m01*a_k_m10*a_k_m20*a_k_n00*a_k_n02*a_k_n10*a_k_n20*a_l_n01*a_l_n10*a_l_n11*a_l_n21*a_l_w01*a_l_w11*a_l_w12*a_l_w21*a_n_u02*a_n_u12*a_n_u20*a_n_u22*a_o_j02*a_o_j12*a_o_j21*a_o_j22,
         6*a_k_a01*a_k_a02*a_k_a10*a_k_a11*a_k_c00*a_k_c01*a_k_c10*a_k_c12*a_m_a00*a_m_a02*a_m_a20*a_m_a21*a_m_n11*a_m_n12*a_m_n20*a_m_n21*a_n_k01*a_n_k02*a_n_k20*a_n_k22*a_o_k10*a_o_k12*a_o_k21*a_o_k22,
         3*a_j_y00^2*a_j_y01^2*a_j_y10^2*a_j_y11^2*a_n_j00^2*a_n_j02^2*a_n_j20^2*a_n_j22^2*a_o_l11^2*a_o_l12^2*a_o_l21^2*a_o_l22^2,
         6*a_k_b00*a_k_b01*a_k_b02*a_k_b12*a_k_k02*a_k_k10*a_k_k11*a_k_k12*a_l_e10*a_l_e11*a_l_e12*a_l_e20*a_l_f00*a_l_f01*a_l_f02*a_l_f21*a_o_n01*a_o_n20*a_o_n21*a_o_n22*a_o_p10*a_o_p20*a_o_p21*a_o_p22,
         6*a_j_x00*a_j_x01*a_j_x02*a_j_x11*a_k_i00*a_k_i10*a_k_i11*a_k_i12*a_m_o00*a_m_o01*a_m_o02*a_m_o22*a_n_h10*a_n_h11*a_n_h12*a_n_h22*a_o_m00*a_o_m20*a_o_m21*a_o_m22*a_o_q11*a_o_q20*a_o_q21*a_o_q22,
         6*a_j_w00*a_j_w01*a_j_w02*a_j_w10*a_k_j01*a_k_j10*a_k_j11*a_k_j12*a_k_l00*a_k_l01*a_k_l02*a_k_l20*a_l_y10*a_l_y11*a_l_y12*a_l_y21*a_o_o02*a_o_o20*a_o_o21*a_o_o22*a_o_r12*a_o_r20*a_o_r21*a_o_r22,
         2*a_p_x01^3*a_p_x12^3*a_p_x20^3*a_q_g02^3*a_q_g10^3*a_q_g21^3,
         6*a_p_q01*a_p_q10*a_p_q20*a_p_r02*a_p_r10*a_p_r20*a_p_y02*a_p_y12*a_p_y20*a_q_f01*a_q_f10*a_q_f21*a_q_m01*a_q_m12*a_q_m21*a_q_n02*a_q_n12*a_q_n21,
         6*a_p_e01*a_p_e02*a_p_e12*a_p_h02*a_p_h10*a_p_h12*a_p_z10*a_p_z12*a_p_z20*a_q_d01*a_q_d02*a_q_d21*a_q_r01*a_q_r20*a_q_r21*a_q_t10*a_q_t20*a_q_t21,
         6*a_o_v01*a_o_v02*a_o_v10*a_p_g01*a_p_g10*a_p_g12*a_p_o01*a_p_o02*a_p_o20*a_q_o10*a_q_o12*a_q_o21*a_q_s02*a_q_s20*a_q_s21*a_q_v12*a_q_v20*a_q_v21,
         3*a_p_u02^2*a_p_u11^2*a_p_u20^2*a_q_l00^2*a_q_l12^2*a_q_l21^2*a_r_a01^2*a_r_a10^2*a_r_a22^2,
         a_r_c00^6*a_r_c11^6*a_r_c22^6,
         6*a_p_s00*a_p_s11*a_p_s20*a_q_h00*a_q_h11*a_q_h21*a_q_z00*a_q_z10*a_q_z22*a_r_d01*a_r_d11*a_r_d22*a_r_e02*a_r_e11*a_r_e22*a_r_g00*a_r_g12*a_r_g22,
         6*a_p_t01*a_p_t11*a_p_t20*a_p_w00*a_p_w12*a_p_w20*a_q_e00*a_q_e10*a_q_e21*a_q_j02*a_q_j11*a_q_j21*a_r_b02*a_r_b10*a_r_b22*a_r_h01*a_r_h12*a_r_h22,
         3*a_p_p00^2*a_p_p10^2*a_p_p20^2*a_q_i01^2*a_q_i11^2*a_q_i21^2*a_r_i02^2*a_r_i12^2*a_r_i22^2,
         6*a_o_y01*a_o_y02*a_o_y11*a_p_f00*a_p_f10*a_p_f12*a_q_q00*a_q_q20*a_q_q21*a_q_u11*a_q_u20*a_q_u21*a_q_y01*a_q_y02*a_q_y22*a_r_j10*a_r_j12*a_r_j22,
         6*a_o_x00*a_o_x02*a_o_x11*a_p_i00*a_p_i11*a_p_i12*a_q_w00*a_q_w01*a_q_w22*a_r_f10*a_r_f11*a_r_f22*a_r_p11*a_r_p20*a_r_p22*a_r_r00*a_r_r21*a_r_r22,
         6*a_p_d00*a_p_d02*a_p_d12*a_p_k02*a_p_k11*a_p_k12*a_p_v10*a_p_v11*a_p_v20*a_q_b00*a_q_b01*a_q_b21*a_r_o10*a_r_o20*a_r_o22*a_r_s01*a_r_s21*a_r_s22,
         6*a_o_u00*a_o_u02*a_o_u10*a_p_j01*a_p_j11*a_p_j12*a_p_m00*a_p_m01*a_p_m20*a_q_k10*a_q_k11*a_q_k21*a_r_q12*a_r_q20*a_r_q22*a_r_t02*a_r_t21*a_r_t22,
         6*a_p_b02*a_p_b10*a_p_b11*a_p_c00*a_p_c01*a_p_c12*a_q_a11*a_q_a12*a_q_a20*a_q_c00*a_q_c02*a_q_c21*a_r_m01*a_r_m20*a_r_m22*a_r_u10*a_r_u21*a_r_u22,
         6*a_o_w00*a_o_w01*a_o_w11*a_o_z00*a_o_z10*a_o_z11*a_q_x00*a_q_x02*a_q_x22*a_r_k11*a_r_k12*a_r_k22*a_r_l00*a_r_l20*a_r_l22*a_r_v11*a_r_v21*a_r_v22,
         6*a_o_t00*a_o_t01*a_o_t10*a_p_a01*a_p_a10*a_p_a11*a_p_n00*a_p_n02*a_p_n20*a_q_p11*a_q_p12*a_q_p21*a_r_n02*a_r_n20*a_r_n22*a_r_w12*a_r_w21*a_r_w22,
         3*a_o_s00^2*a_o_s01^2*a_o_s02^2*a_p_l10^2*a_p_l11^2*a_p_l12^2*a_r_x20^2*a_r_x21^2*a_r_x22^2,
         3*a_s_k02^2*a_s_k12^2*a_s_q10^2*a_s_q20^2*a_s_u01^2*a_s_u21^2,
         6*a_s_d02*a_s_d10*a_s_j01*a_s_j12*a_s_o01*a_s_o20*a_s_s12*a_s_s20*a_s_v02*a_s_v21*a_s_w10*a_s_w21,
         3*a_s_c01^2*a_s_c10^2*a_s_p02^2*a_s_p20^2*a_s_y12^2*a_s_y21^2,
         3*a_s_a01^2*a_s_a02^2*a_s_l10^2*a_s_l12^2*a_s_z20^2*a_s_z21^2,
         6*a_s_g02*a_s_g11*a_s_i00*a_s_i12*a_s_r11*a_s_r20*a_s_t00*a_s_t21*a_t_b01*a_t_b22*a_t_d10*a_t_d22,
         3*a_s_e00^2*a_s_e11^2*a_t_a00^2*a_t_a22^2*a_t_e11^2*a_t_e22^2,
         6*a_s_b00*a_s_b10*a_s_f01*a_s_f11*a_s_n00*a_s_n20*a_s_x11*a_s_x21*a_t_c02*a_t_c22*a_t_f12*a_t_f22,
         6*a_r_y00*a_r_y01*a_r_z00*a_r_z02*a_s_h10*a_s_h11*a_s_m11*a_s_m12*a_t_g20*a_t_g22*a_t_h21*a_t_h22,
         6*a_t_j01*a_t_k02*a_t_l10*a_t_n12*a_t_o20*a_t_p21,
         3*a_t_i00^2*a_t_m11^2*a_t_q22^2]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz^2), Integer(26)))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Directed_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz=Integer('+str(sz)+')\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz^2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz^2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1,2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(1+A[i,j] for j in rg(sz) for i in rg(sz))-1)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(1+TmpA[j][u,v] for v in rg(sz) for u in rg(sz))-1).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(1+Bh[i,j] for j in rg(sz) for i in rg(sz))-1).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()+[1]\n')
    # Closing the file
    f.close()

def generate_unlabeled_listing_scriptB(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled directed graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_listing_scriptB(3)
        sage: load('Unlabeled_Listing_of_Directed_Graphs_on_3_vertices.sage')
        sage: L
        [a_a01^6*a_a02^6*a_a10^6*a_a12^6*a_a20^6*a_a21^6,
         6*a_b01*a_b02*a_b10*a_b12*a_b20*a_c01*a_c02*a_c10*a_c12*a_c21*a_d01*a_d02*a_d10*a_d20*a_d21*a_e01*a_e02*a_e12*a_e20*a_e21*a_f01*a_f10*a_f12*a_f20*a_f21*a_g02*a_g10*a_g12*a_g20*a_g21,
         3*a_l02^2*a_l10^2*a_l12^2*a_l20^2*a_n01^2*a_n02^2*a_n12^2*a_n21^2*a_r01^2*a_r10^2*a_r20^2*a_r21^2,
         6*a_j01*a_j02*a_j12*a_j20*a_k01*a_k10*a_k12*a_k20*a_m01*a_m02*a_m10*a_m21*a_p02*a_p10*a_p12*a_p21*a_s02*a_s10*a_s20*a_s21*a_t01*a_t12*a_t20*a_t21,
         3*a_i01^2*a_i02^2*a_i10^2*a_i20^2*a_o01^2*a_o10^2*a_o12^2*a_o21^2*a_u02^2*a_u12^2*a_u20^2*a_u21^2,
         3*a_h01^2*a_h02^2*a_h10^2*a_h12^2*a_q01^2*a_q02^2*a_q20^2*a_q21^2*a_v10^2*a_v12^2*a_v20^2*a_v21^2,
         2*b_d01^3*b_d12^3*b_d20^3*b_i02^3*b_i10^3*b_i21^3,
         6*b_b01*b_b10*b_b20*b_c02*b_c10*b_c20*b_e02*b_e12*b_e20*b_h01*b_h10*b_h21*b_j01*b_j12*b_j21*b_k02*b_k12*b_k21,
         6*a_x01*a_x02*a_x12*a_z02*a_z10*a_z12*b_f10*b_f12*b_f20*b_g01*b_g02*b_g21*b_m01*b_m20*b_m21*b_o10*b_o20*b_o21,
         6*a_w01*a_w02*a_w10*a_y01*a_y10*a_y12*b_a01*b_a02*b_a20*b_l10*b_l12*b_l21*b_n02*b_n20*b_n21*b_p12*b_p20*b_p21,
         3*b_u02^2*b_u12^2*b_y10^2*b_y20^2*c_a01^2*c_a21^2,
         6*b_s02*b_s10*b_t01*b_t12*b_w01*b_w20*b_z12*b_z20*c_b02*c_b21*c_c10*c_c21,
         3*b_r01^2*b_r10^2*b_x02^2*b_x20^2*c_d12^2*c_d21^2,
         3*b_q01^2*b_q02^2*b_v10^2*b_v12^2*c_e20^2*c_e21^2,
         6*c_f01*c_g02*c_h10*c_i12*c_j20*c_k21]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz*(sz-1)), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Directed_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz=Integer('+str(sz)+')\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(1+A[i,j] for j in rg(sz) for i in rg(sz) if i!=j)-1)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(1+TmpA[j][u,v] for v in rg(sz) for u in rg(sz) if u!=v)-1).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(1+Bh[i,j] for j in rg(sz) for i in rg(sz) if i!=j)-1).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_listing_scriptII(sz,m):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled directed graph on sz vertices
    having no loop edges on exaclty m edges this implementation
    is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_listing_scriptII(3,2)
        sage: load('Unlabeled_Listing_of_Directed_Graphs_on_3_vertices_and_2_edges.sage')
        sage: L
        [3*d10^2*d20^2*g01^2*g21^2*l02^2*l12^2,
         6*a10*a21*e02*e10*i02*i21*j01*j12*k12*k20*m01*m20,
         3*b10^2*b12^2*h20^2*h21^2*n01^2*n02^2,
         3*c01^2*c10^2*f12^2*f21^2*o02^2*o20^2]        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(binomial(sz*(sz-1),m), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]; Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Directed_Graphs_on_'+str(sz)+'_vertices_and_'+str(m)+'_edges.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the vertex set size parameter\n')
    f.write('sz=Integer('+str(sz)+')\n')
    f.write('\n# Initializing the edge set size parameter\n')
    f.write('m='+str(m)+'\n')
    # Writing the symbols in upper case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(binomial(sz*(sz-1),m)-1):
        if Integer(mod(cnt,4))==0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(binomial(sz*(sz-1),m)-1):
        if Integer(mod(cnt,4))==0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(prod(s), Bh.list(), sz) for s in Set([Bh[i,j] for j in rg(sz) for i in rg(sz) if i!=j]).subsets(m)]\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[LtG[k][i]] for i in rg(len(LtG[k]))) for k in rg(len(LtG)))\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpA)):\n')
    f.write('    for k in rg(len(LtG)):\n')
    f.write('        LstM.append(prod(TmpA[j][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()
 
def generate_unlabeled_undirected_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled undirected graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_undirected_listing_script(3)
        sage: load('Unlabeled_Listing_of_Unirected_Graphs_on_3_vertices.sage')
        sage: L
        [a01^6*a02^6*a10^6*a12^6*a20^6*a21^6,
         3*b01^2*b02^2*b10^2*b20^2*c01^2*c10^2*c12^2*c21^2*d02^2*d12^2*d20^2*d21^2,
         3*e01^2*e10^2*f02^2*f20^2*g12^2*g21^2]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz*(sz-1)/2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Unirected_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(1+A[i,j]*A[j,i] for j in rg(sz) for i in rg(sz) if i<j)-1)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(1+TmpA[j][u,v]*TmpA[j][v,u] for v in rg(sz) for u in rg(sz) if u<v)-1).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(1+Bh[i,j]*Bh[j,i] for j in rg(sz) for i in rg(sz) if i<j)-1).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()
 
def generate_unlabeled_functional_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional directed graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_functional_listing_script(3)
        sage: load('Unlabeled_Listing_of_Functional_Graphs_on_3_vertices.sage')
        sage: L
        [2*a_h01^3*a_h12^3*a_h20^3*a_l02^3*a_l10^3*a_l21^3,
         6*a_b01*a_b10*a_b20*a_c02*a_c10*a_c20*a_i02*a_i12*a_i20*a_k01*a_k10*a_k21*a_q01*a_q12*a_q21*a_r02*a_r12*a_r21,
         3*a_f02^2*a_f11^2*a_f20^2*a_p00^2*a_p12^2*a_p21^2*a_t01^2*a_t10^2*a_t22^2,
         a_v00^6*a_v11^6*a_v22^6,
         6*a_d00*a_d11*a_d20*a_m00*a_m11*a_m21*a_s00*a_s10*a_s22*a_w01*a_w11*a_w22*a_x02*a_x11*a_x22*a_y00*a_y12*a_y22,
         6*a_e01*a_e11*a_e20*a_g00*a_g12*a_g20*a_j00*a_j10*a_j21*a_o02*a_o11*a_o21*a_u02*a_u10*a_u22*a_z01*a_z12*a_z22,
         3*a_a00^2*a_a10^2*a_a20^2*a_n01^2*a_n11^2*a_n21^2*b_a02^2*b_a12^2*b_a22^2]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^sz, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(sum(A[i,j] for j in rg(sz)) for i in rg(sz)))\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_iterates_functional_listing_script(sz, pwr):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled iterates of functional directed graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_iterates_functional_listing_script(3,2)
        sage: load("Unlabeled_Listing_of_2-th_iterate_Functional_Graphs_on_3_vertices.sage")
        sage: L
        [2*a_h01^3*a_h12^3*a_h20^3*a_l02^3*a_l10^3*a_l21^3,
         a_v00^6*a_v11^6*a_v22^6,
         6*a_d00*a_d11*a_d20*a_m00*a_m11*a_m21*a_s00*a_s10*a_s22*a_w01*a_w11*a_w22*a_x02*a_x11*a_x22*a_y00*a_y12*a_y22,
         3*a_a00^2*a_a10^2*a_a20^2*a_n01^2*a_n11^2*a_n21^2*b_a02^2*b_a12^2*b_a22^2]        
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^sz, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_'+str(pwr)+'-th_iterate_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size and iterate order parameters\n')
    f.write('sz='+str(sz)+'; pwr='+str(pwr)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[tp[i][0],tp[i][1]] for i in rg(sz)) for tp in CompostionalPowerList(sz,pwr))\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_right_coset_functional_listing_script(Tp):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional directed graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_right_coset_functional_listing_script([(0, 0), (1, 0), (2, 1)])
        sage: load('Unlabeled_right_coset_Listing_of_Functional_Graphs_on_3_vertices.sage')
        sage: L
        [6*a_b01*a_b10*a_b20*a_c02*a_c10*a_c20*a_i02*a_i12*a_i20*a_k01*a_k10*a_k21*a_q01*a_q12*a_q21*a_r02*a_r12*a_r21,
         6*a_d00*a_d11*a_d20*a_m00*a_m11*a_m21*a_s00*a_s10*a_s22*a_w01*a_w11*a_w22*a_x02*a_x11*a_x22*a_y00*a_y12*a_y22,
         6*a_e01*a_e11*a_e20*a_g00*a_g12*a_g20*a_j00*a_j10*a_j21*a_o02*a_o11*a_o21*a_u02*a_u10*a_u22*a_z01*a_z12*a_z22,
         9*a_a00^2*a_a10^2*a_a20^2*a_n01^2*a_n11^2*a_n21^2*b_a02^2*b_a12^2*b_a22^2]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz = len(Tp)
    # Initialization of the order
    od = ceil(log(sz^sz, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_right_coset_Listing_of_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writing the part which initializes the input tuple
    f.write('\n# Initialization of the input tuple\n')
    f.write('Tp='+str(Tp)+'\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(sum(A[i,Tp[j][1]] for j in rg(sz)) for i in rg(sz)))\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()
 
def generate_unlabeled_functional_tree_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional trees on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_functional_tree_listing_script(3)
        sage: load('Unlabeled_Listing_of_Functional_Tree_Graphs_on_3_vertices.sage')
        sage: L
        [6*b01*b11*b20*c00*c12*c20*d00*d10*d21*f02*f11*f21*g02*g10*g22*h01*h12*h22,
         3*a00^2*a10^2*a20^2*e01^2*e11^2*e21^2*i02^2*i12^2*i22^2]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^(sz-1), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Functional_Tree_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(sum(A[i,i]*Deter((HM(2,(A*HM(sz,1,'one')).list(),'diag')-A).slice([z for z in rg(sz) if z!=i],'row').slice([z for z in rg(sz) if z!=i],'col'))  for i in rg(sz)))\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(sum(TmpA[j][u,u]*Deter((HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')-TmpA[j]).slice([z for z in rg(sz) if z!=u],'row').slice([z for z in rg(sz) if z!=u],'col'))  for u in rg(sz))).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(sum(Bh[i,i]*Deter((HM(2,(Bh*HM(sz,1,'one')).list(),'diag')-Bh).slice([z for z in rg(sz) if z!=i],'row').slice([z for z in rg(sz) if z!=i],'col'))  for i in rg(sz))).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_functional_forest_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional forest on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_unlabeled_functional_forest_listing_script(3)
        sage: load('Unlabeled_Listing_of_Functional_Forest_Graphs_on_3_vertices.sage')
        sage: L
        [k00^6*k11^6*k22^6,
        6*b00*b11*b20*f00*f11*f21*i00*i10*i22*l01*l11*l22*m02*m11*m22*n00*n12*n22,
        6*c01*c11*c20*d00*d12*d20*e00*e10*e21*h02*h11*h21*j02*j10*j22*o01*o12*o22,
        3*a00^2*a10^2*a20^2*g01^2*g11^2*g21^2*p02^2*p12^2*p22^2]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log((sz+1)^(sz-1), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Functional_Forest_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(((sz+1)^(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(((sz+1)^(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(Deter(HM(2,(A*HM(sz,1,'one')).list(),'diag')+HM(2,[A[i,i] for i in rg(sz)],'diag')-A))\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(Deter(HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')+HM(2,[TmpA[j][u,u] for u in rg(sz)],'diag')-TmpA[j])).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(Deter(HM(2,(Bh*HM(sz,1,'one')).list(),'diag')+HM(2,[Bh[i,i] for i in rg(sz)],'diag')-Bh)).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_undirected_tree_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional trees on sz vertices
    having no loop edges this implementation is very slow.
    The smallest number of vertices for which this works
    is sz=5


    EXAMPLES:

    ::

        sage: generate_unlabeled_undirected_tree_listing_script(5)
        sage: load('Unlabeled_Listing_of_Undirected_Tree_Graphs_on_5_vertices.sage')
        sage: L
        [60*a_f20^2*a_f21^2*a_f31^2*a_f40^2*a_h21^2*a_h30^2*a_h31^2*a_h40^2*a_j10^2*a_j21^2*a_j32^2*a_j40^2*a_m21^2*a_m30^2*a_m32^2*a_m40^2*a_n10^2*a_n31^2*a_n32^2*a_n40^2*a_o20^2*a_o31^2*a_o32^2*a_o40^2*a_s20^2*a_s21^2*a_s30^2*a_s41^2*a_w20^2*a_w30^2*a_w31^2*a_w41^2*a_y10^2*a_y20^2*a_y32^2*a_y41^2*b_b10^2*b_b30^2*b_b32^2*b_b41^2*b_c21^2*b_c30^2*b_c32^2*b_c41^2*b_e20^2*b_e31^2*b_e32^2*b_e41^2*b_h21^2*b_h30^2*b_h40^2*b_h41^2*b_i20^2*b_i31^2*b_i40^2*b_i41^2*b_k20^2*b_k32^2*b_k40^2*b_k41^2*b_l21^2*b_l32^2*b_l40^2*b_l41^2*b_m30^2*b_m32^2*b_m40^2*b_m41^2*b_n31^2*b_n32^2*b_n40^2*b_n41^2*b_p10^2*b_p21^2*b_p30^2*b_p42^2*b_r10^2*b_r20^2*b_r31^2*b_r42^2*b_u20^2*b_u30^2*b_u31^2*b_u42^2*b_v21^2*b_v30^2*b_v31^2*b_v42^2*b_z10^2*b_z30^2*b_z32^2*b_z42^2*c_b10^2*c_b31^2*c_b32^2*c_b42^2*c_f21^2*c_f30^2*c_f40^2*c_f42^2*c_g10^2*c_g31^2*c_g40^2*c_g42^2*c_h21^2*c_h31^2*c_h40^2*c_h42^2*c_i30^2*c_i31^2*c_i40^2*c_i42^2*c_j10^2*c_j32^2*c_j40^2*c_j42^2*c_l31^2*c_l32^2*c_l40^2*c_l42^2*c_m10^2*c_m30^2*c_m41^2*c_m42^2*c_n20^2*c_n30^2*c_n41^2*c_n42^2*c_p20^2*c_p31^2*c_p41^2*c_p42^2*c_q30^2*c_q31^2*c_q41^2*c_q42^2*c_r10^2*c_r32^2*c_r41^2*c_r42^2*c_t30^2*c_t32^2*c_t41^2*c_t42^2*c_y10^2*c_y21^2*c_y30^2*c_y43^2*c_z20^2*c_z21^2*c_z30^2*c_z43^2*d_a10^2*d_a20^2*d_a31^2*d_a43^2*d_c20^2*d_c21^2*d_c31^2*d_c43^2*d_f10^2*d_f20^2*d_f32^2*d_f43^2*d_g10^2*d_g21^2*d_g32^2*d_g43^2*d_o10^2*d_o21^2*d_o40^2*d_o43^2*d_p20^2*d_p21^2*d_p40^2*d_p43^2*d_q20^2*d_q31^2*d_q40^2*d_q43^2*d_r21^2*d_r31^2*d_r40^2*d_r43^2*d_s10^2*d_s32^2*d_s40^2*d_s43^2*d_t21^2*d_t32^2*d_t40^2*d_t43^2*d_v10^2*d_v20^2*d_v41^2*d_v43^2*d_x20^2*d_x21^2*d_x41^2*d_x43^2*d_y20^2*d_y30^2*d_y41^2*d_y43^2*d_z21^2*d_z30^2*d_z41^2*d_z43^2*e_a10^2*e_a32^2*e_a41^2*e_a43^2*e_b20^2*e_b32^2*e_b41^2*e_b43^2*e_g10^2*e_g20^2*e_g42^2*e_g43^2*e_h10^2*e_h21^2*e_h42^2*e_h43^2*e_j10^2*e_j30^2*e_j42^2*e_j43^2*e_k21^2*e_k30^2*e_k42^2*e_k43^2*e_l10^2*e_l31^2*e_l42^2*e_l43^2*e_m20^2*e_m31^2*e_m42^2*e_m43^2,
 60*a_b10^2*a_b21^2*a_b30^2*a_b40^2*a_c20^2*a_c21^2*a_c30^2*a_c40^2*a_d10^2*a_d20^2*a_d31^2*a_d40^2*a_e10^2*a_e21^2*a_e31^2*a_e40^2*a_g20^2*a_g30^2*a_g31^2*a_g40^2*a_i10^2*a_i20^2*a_i32^2*a_i40^2*a_k20^2*a_k21^2*a_k32^2*a_k40^2*a_l10^2*a_l30^2*a_l32^2*a_l40^2*a_p30^2*a_p31^2*a_p32^2*a_p40^2*a_q10^2*a_q20^2*a_q30^2*a_q41^2*a_r10^2*a_r21^2*a_r30^2*a_r41^2*a_t10^2*a_t20^2*a_t31^2*a_t41^2*a_v20^2*a_v21^2*a_v31^2*a_v41^2*a_x21^2*a_x30^2*a_x31^2*a_x41^2*a_z10^2*a_z21^2*a_z32^2*a_z41^2*b_a20^2*b_a21^2*b_a32^2*b_a41^2*b_d10^2*b_d31^2*b_d32^2*b_d41^2*b_f30^2*b_f31^2*b_f32^2*b_f41^2*b_g20^2*b_g30^2*b_g40^2*b_g41^2*b_j21^2*b_j31^2*b_j40^2*b_j41^2*b_o10^2*b_o20^2*b_o30^2*b_o42^2*b_q20^2*b_q21^2*b_q30^2*b_q42^2*b_s10^2*b_s21^2*b_s31^2*b_s42^2*b_t20^2*b_t21^2*b_t31^2*b_t42^2*b_w10^2*b_w20^2*b_w32^2*b_w42^2*b_x10^2*b_x21^2*b_x32^2*b_x42^2*c_a21^2*c_a30^2*c_a32^2*c_a42^2*c_c20^2*c_c31^2*c_c32^2*c_c42^2*c_d30^2*c_d31^2*c_d32^2*c_d42^2*c_e10^2*c_e30^2*c_e40^2*c_e42^2*c_k21^2*c_k32^2*c_k40^2*c_k42^2*c_o10^2*c_o31^2*c_o41^2*c_o42^2*c_s20^2*c_s32^2*c_s41^2*c_s42^2*c_u30^2*c_u40^2*c_u41^2*c_u42^2*c_v31^2*c_v40^2*c_v41^2*c_v42^2*c_w32^2*c_w40^2*c_w41^2*c_w42^2*c_x10^2*c_x20^2*c_x30^2*c_x43^2*d_b10^2*d_b21^2*d_b31^2*d_b43^2*d_d20^2*d_d30^2*d_d31^2*d_d43^2*d_e21^2*d_e30^2*d_e31^2*d_e43^2*d_h20^2*d_h21^2*d_h32^2*d_h43^2*d_i10^2*d_i30^2*d_i32^2*d_i43^2*d_j21^2*d_j30^2*d_j32^2*d_j43^2*d_k10^2*d_k31^2*d_k32^2*d_k43^2*d_l20^2*d_l31^2*d_l32^2*d_l43^2*d_n10^2*d_n20^2*d_n40^2*d_n43^2*d_u31^2*d_u32^2*d_u40^2*d_u43^2*d_w10^2*d_w21^2*d_w41^2*d_w43^2*e_c30^2*e_c32^2*e_c41^2*e_c43^2*e_d20^2*e_d40^2*e_d41^2*e_d43^2*e_e21^2*e_e40^2*e_e41^2*e_e43^2*e_f32^2*e_f40^2*e_f41^2*e_f43^2*e_i20^2*e_i21^2*e_i42^2*e_i43^2*e_n30^2*e_n31^2*e_n42^2*e_n43^2*e_o10^2*e_o40^2*e_o42^2*e_o43^2*e_p21^2*e_p40^2*e_p42^2*e_p43^2*e_q31^2*e_q40^2*e_q42^2*e_q43^2*e_r10^2*e_r41^2*e_r42^2*e_r43^2*e_s20^2*e_s41^2*e_s42^2*e_s43^2*e_t30^2*e_t41^2*e_t42^2*e_t43^2,
 5*a_a10^24*a_a20^24*a_a30^24*a_a40^24*a_u10^24*a_u21^24*a_u31^24*a_u41^24*b_y20^24*b_y21^24*b_y32^24*b_y42^24*d_m30^24*d_m31^24*d_m32^24*d_m43^24*e_u40^24*e_u41^24*e_u42^24*e_u43^24]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^(sz-2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Undirected_Tree_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [Integer(1), Integer(2)]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Lc[cnt]+"','sym')]"+"\n")
    f.write("\nBh=HM(od,sz,'a','sym')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Ll[cnt]+"','sym')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(Deter((HM(2,(A*HM(sz,1,'one')).list(),'diag')-A).slice(rg(1,sz),'row').slice(rg(1,sz),'col')))\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(Deter((HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')-TmpA[j]).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, HM(sz,sz,'a').list(), sz) for mnm in expand(Deter((HM(od, (Bh*HM(sz,1,'one')).list(),'diag')-Bh).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_tree_semigroup_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional trees on sz vertices
    steming from the semigroup on functional trees.
    This is meant to be contrasted with the previous
    directed matrix tree construction.
    The smallest number of vertices for which this works
    is sz=5


    EXAMPLES:

    ::

        sage: generate_unlabeled_tree_semigroup_listing_script(5)
        sage: load('Unlabeled_Listing_of_Tree_Semigroup_Graphs_on_5_vertices.sage')
        sage: L
        [8*a_f20^2*a_f21^2*a_f31^2*a_f40^2*a_h21^2*a_h30^2*a_h31^2*a_h40^2*a_j10^2*a_j21^2*a_j32^2*a_j40^2*a_m21^2*a_m30^2*a_m32^2*a_m40^2*a_n10^2*a_n31^2*a_n32^2*a_n40^2*a_o20^2*a_o31^2*a_o32^2*a_o40^2*a_s20^2*a_s21^2*a_s30^2*a_s41^2*a_w20^2*a_w30^2*a_w31^2*a_w41^2*a_y10^2*a_y20^2*a_y32^2*a_y41^2*b_b10^2*b_b30^2*b_b32^2*b_b41^2*b_c21^2*b_c30^2*b_c32^2*b_c41^2*b_e20^2*b_e31^2*b_e32^2*b_e41^2*b_h21^2*b_h30^2*b_h40^2*b_h41^2*b_i20^2*b_i31^2*b_i40^2*b_i41^2*b_k20^2*b_k32^2*b_k40^2*b_k41^2*b_l21^2*b_l32^2*b_l40^2*b_l41^2*b_m30^2*b_m32^2*b_m40^2*b_m41^2*b_n31^2*b_n32^2*b_n40^2*b_n41^2*b_p10^2*b_p21^2*b_p30^2*b_p42^2*b_r10^2*b_r20^2*b_r31^2*b_r42^2*b_u20^2*b_u30^2*b_u31^2*b_u42^2*b_v21^2*b_v30^2*b_v31^2*b_v42^2*b_z10^2*b_z30^2*b_z32^2*b_z42^2*c_b10^2*c_b31^2*c_b32^2*c_b42^2*c_f21^2*c_f30^2*c_f40^2*c_f42^2*c_g10^2*c_g31^2*c_g40^2*c_g42^2*c_h21^2*c_h31^2*c_h40^2*c_h42^2*c_i30^2*c_i31^2*c_i40^2*c_i42^2*c_j10^2*c_j32^2*c_j40^2*c_j42^2*c_l31^2*c_l32^2*c_l40^2*c_l42^2*c_m10^2*c_m30^2*c_m41^2*c_m42^2*c_n20^2*c_n30^2*c_n41^2*c_n42^2*c_p20^2*c_p31^2*c_p41^2*c_p42^2*c_q30^2*c_q31^2*c_q41^2*c_q42^2*c_r10^2*c_r32^2*c_r41^2*c_r42^2*c_t30^2*c_t32^2*c_t41^2*c_t42^2*c_y10^2*c_y21^2*c_y30^2*c_y43^2*c_z20^2*c_z21^2*c_z30^2*c_z43^2*d_a10^2*d_a20^2*d_a31^2*d_a43^2*d_c20^2*d_c21^2*d_c31^2*d_c43^2*d_f10^2*d_f20^2*d_f32^2*d_f43^2*d_g10^2*d_g21^2*d_g32^2*d_g43^2*d_o10^2*d_o21^2*d_o40^2*d_o43^2*d_p20^2*d_p21^2*d_p40^2*d_p43^2*d_q20^2*d_q31^2*d_q40^2*d_q43^2*d_r21^2*d_r31^2*d_r40^2*d_r43^2*d_s10^2*d_s32^2*d_s40^2*d_s43^2*d_t21^2*d_t32^2*d_t40^2*d_t43^2*d_v10^2*d_v20^2*d_v41^2*d_v43^2*d_x20^2*d_x21^2*d_x41^2*d_x43^2*d_y20^2*d_y30^2*d_y41^2*d_y43^2*d_z21^2*d_z30^2*d_z41^2*d_z43^2*e_a10^2*e_a32^2*e_a41^2*e_a43^2*e_b20^2*e_b32^2*e_b41^2*e_b43^2*e_g10^2*e_g20^2*e_g42^2*e_g43^2*e_h10^2*e_h21^2*e_h42^2*e_h43^2*e_j10^2*e_j30^2*e_j42^2*e_j43^2*e_k21^2*e_k30^2*e_k42^2*e_k43^2*e_l10^2*e_l31^2*e_l42^2*e_l43^2*e_m20^2*e_m31^2*e_m42^2*e_m43^2,
 14*a_b10^2*a_b21^2*a_b30^2*a_b40^2*a_c20^2*a_c21^2*a_c30^2*a_c40^2*a_d10^2*a_d20^2*a_d31^2*a_d40^2*a_e10^2*a_e21^2*a_e31^2*a_e40^2*a_g20^2*a_g30^2*a_g31^2*a_g40^2*a_i10^2*a_i20^2*a_i32^2*a_i40^2*a_k20^2*a_k21^2*a_k32^2*a_k40^2*a_l10^2*a_l30^2*a_l32^2*a_l40^2*a_p30^2*a_p31^2*a_p32^2*a_p40^2*a_q10^2*a_q20^2*a_q30^2*a_q41^2*a_r10^2*a_r21^2*a_r30^2*a_r41^2*a_t10^2*a_t20^2*a_t31^2*a_t41^2*a_v20^2*a_v21^2*a_v31^2*a_v41^2*a_x21^2*a_x30^2*a_x31^2*a_x41^2*a_z10^2*a_z21^2*a_z32^2*a_z41^2*b_a20^2*b_a21^2*b_a32^2*b_a41^2*b_d10^2*b_d31^2*b_d32^2*b_d41^2*b_f30^2*b_f31^2*b_f32^2*b_f41^2*b_g20^2*b_g30^2*b_g40^2*b_g41^2*b_j21^2*b_j31^2*b_j40^2*b_j41^2*b_o10^2*b_o20^2*b_o30^2*b_o42^2*b_q20^2*b_q21^2*b_q30^2*b_q42^2*b_s10^2*b_s21^2*b_s31^2*b_s42^2*b_t20^2*b_t21^2*b_t31^2*b_t42^2*b_w10^2*b_w20^2*b_w32^2*b_w42^2*b_x10^2*b_x21^2*b_x32^2*b_x42^2*c_a21^2*c_a30^2*c_a32^2*c_a42^2*c_c20^2*c_c31^2*c_c32^2*c_c42^2*c_d30^2*c_d31^2*c_d32^2*c_d42^2*c_e10^2*c_e30^2*c_e40^2*c_e42^2*c_k21^2*c_k32^2*c_k40^2*c_k42^2*c_o10^2*c_o31^2*c_o41^2*c_o42^2*c_s20^2*c_s32^2*c_s41^2*c_s42^2*c_u30^2*c_u40^2*c_u41^2*c_u42^2*c_v31^2*c_v40^2*c_v41^2*c_v42^2*c_w32^2*c_w40^2*c_w41^2*c_w42^2*c_x10^2*c_x20^2*c_x30^2*c_x43^2*d_b10^2*d_b21^2*d_b31^2*d_b43^2*d_d20^2*d_d30^2*d_d31^2*d_d43^2*d_e21^2*d_e30^2*d_e31^2*d_e43^2*d_h20^2*d_h21^2*d_h32^2*d_h43^2*d_i10^2*d_i30^2*d_i32^2*d_i43^2*d_j21^2*d_j30^2*d_j32^2*d_j43^2*d_k10^2*d_k31^2*d_k32^2*d_k43^2*d_l20^2*d_l31^2*d_l32^2*d_l43^2*d_n10^2*d_n20^2*d_n40^2*d_n43^2*d_u31^2*d_u32^2*d_u40^2*d_u43^2*d_w10^2*d_w21^2*d_w41^2*d_w43^2*e_c30^2*e_c32^2*e_c41^2*e_c43^2*e_d20^2*e_d40^2*e_d41^2*e_d43^2*e_e21^2*e_e40^2*e_e41^2*e_e43^2*e_f32^2*e_f40^2*e_f41^2*e_f43^2*e_i20^2*e_i21^2*e_i42^2*e_i43^2*e_n30^2*e_n31^2*e_n42^2*e_n43^2*e_o10^2*e_o40^2*e_o42^2*e_o43^2*e_p21^2*e_p40^2*e_p42^2*e_p43^2*e_q31^2*e_q40^2*e_q42^2*e_q43^2*e_r10^2*e_r41^2*e_r42^2*e_r43^2*e_s20^2*e_s41^2*e_s42^2*e_s43^2*e_t30^2*e_t41^2*e_t42^2*e_t43^2,
 2*a_a10^24*a_a20^24*a_a30^24*a_a40^24*a_u10^24*a_u21^24*a_u31^24*a_u41^24*b_y20^24*b_y21^24*b_y32^24*b_y42^24*d_m30^24*d_m31^24*d_m32^24*d_m43^24*e_u40^24*e_u41^24*e_u42^24*e_u43^24]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^(sz-2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Tree_Semigroup_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [Integer(1), Integer(2)]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Lc[cnt]+"','sym')]"+"\n")
    f.write("\nBh=HM(od,sz,'a','sym')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Ll[cnt]+"','sym')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(prod(sum(A[i,j] for j in rg(i+1,sz)) for i in rg(sz-1)))\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(Deter((HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')-TmpA[j]).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, HM(sz,sz,'a').list(), sz) for mnm in expand(Deter((HM(od, (Bh*HM(sz,1,'one')).list(),'diag')-Bh).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_tree_graceful_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled graceful trees on sz vertices
    this implementation is very slow. The smallest 
    number of vertices for which this works
    is sz=5


    EXAMPLES:

    ::

        sage: generate_unlabeled_tree_graceful_listing_script(5)
        sage: load('Unlabeled_Listing_of_Tree_Graceful_Graphs_on_5_vertices.sage')
        sage: L[2]
        [a_f20^2*a_f21^2*a_f31^2*a_f40^2*a_h21^2*a_h30^2*a_h31^2*a_h40^2*a_j10^2*a_j21^2*a_j32^2*a_j40^2*a_m21^2*a_m30^2*a_m32^2*a_m40^2*a_n10^2*a_n31^2*a_n32^2*a_n40^2*a_o20^2*a_o31^2*a_o32^2*a_o40^2*a_s20^2*a_s21^2*a_s30^2*a_s41^2*a_w20^2*a_w30^2*a_w31^2*a_w41^2*a_y10^2*a_y20^2*a_y32^2*a_y41^2*b_b10^2*b_b30^2*b_b32^2*b_b41^2*b_c21^2*b_c30^2*b_c32^2*b_c41^2*b_e20^2*b_e31^2*b_e32^2*b_e41^2*b_h21^2*b_h30^2*b_h40^2*b_h41^2*b_i20^2*b_i31^2*b_i40^2*b_i41^2*b_k20^2*b_k32^2*b_k40^2*b_k41^2*b_l21^2*b_l32^2*b_l40^2*b_l41^2*b_m30^2*b_m32^2*b_m40^2*b_m41^2*b_n31^2*b_n32^2*b_n40^2*b_n41^2*b_p10^2*b_p21^2*b_p30^2*b_p42^2*b_r10^2*b_r20^2*b_r31^2*b_r42^2*b_u20^2*b_u30^2*b_u31^2*b_u42^2*b_v21^2*b_v30^2*b_v31^2*b_v42^2*b_z10^2*b_z30^2*b_z32^2*b_z42^2*c_b10^2*c_b31^2*c_b32^2*c_b42^2*c_f21^2*c_f30^2*c_f40^2*c_f42^2*c_g10^2*c_g31^2*c_g40^2*c_g42^2*c_h21^2*c_h31^2*c_h40^2*c_h42^2*c_i30^2*c_i31^2*c_i40^2*c_i42^2*c_j10^2*c_j32^2*c_j40^2*c_j42^2*c_l31^2*c_l32^2*c_l40^2*c_l42^2*c_m10^2*c_m30^2*c_m41^2*c_m42^2*c_n20^2*c_n30^2*c_n41^2*c_n42^2*c_p20^2*c_p31^2*c_p41^2*c_p42^2*c_q30^2*c_q31^2*c_q41^2*c_q42^2*c_r10^2*c_r32^2*c_r41^2*c_r42^2*c_t30^2*c_t32^2*c_t41^2*c_t42^2*c_y10^2*c_y21^2*c_y30^2*c_y43^2*c_z20^2*c_z21^2*c_z30^2*c_z43^2*d_a10^2*d_a20^2*d_a31^2*d_a43^2*d_c20^2*d_c21^2*d_c31^2*d_c43^2*d_f10^2*d_f20^2*d_f32^2*d_f43^2*d_g10^2*d_g21^2*d_g32^2*d_g43^2*d_o10^2*d_o21^2*d_o40^2*d_o43^2*d_p20^2*d_p21^2*d_p40^2*d_p43^2*d_q20^2*d_q31^2*d_q40^2*d_q43^2*d_r21^2*d_r31^2*d_r40^2*d_r43^2*d_s10^2*d_s32^2*d_s40^2*d_s43^2*d_t21^2*d_t32^2*d_t40^2*d_t43^2*d_v10^2*d_v20^2*d_v41^2*d_v43^2*d_x20^2*d_x21^2*d_x41^2*d_x43^2*d_y20^2*d_y30^2*d_y41^2*d_y43^2*d_z21^2*d_z30^2*d_z41^2*d_z43^2*e_a10^2*e_a32^2*e_a41^2*e_a43^2*e_b20^2*e_b32^2*e_b41^2*e_b43^2*e_g10^2*e_g20^2*e_g42^2*e_g43^2*e_h10^2*e_h21^2*e_h42^2*e_h43^2*e_j10^2*e_j30^2*e_j42^2*e_j43^2*e_k21^2*e_k30^2*e_k42^2*e_k43^2*e_l10^2*e_l31^2*e_l42^2*e_l43^2*e_m20^2*e_m31^2*e_m42^2*e_m43^2,
 2*a_b10^2*a_b21^2*a_b30^2*a_b40^2*a_c20^2*a_c21^2*a_c30^2*a_c40^2*a_d10^2*a_d20^2*a_d31^2*a_d40^2*a_e10^2*a_e21^2*a_e31^2*a_e40^2*a_g20^2*a_g30^2*a_g31^2*a_g40^2*a_i10^2*a_i20^2*a_i32^2*a_i40^2*a_k20^2*a_k21^2*a_k32^2*a_k40^2*a_l10^2*a_l30^2*a_l32^2*a_l40^2*a_p30^2*a_p31^2*a_p32^2*a_p40^2*a_q10^2*a_q20^2*a_q30^2*a_q41^2*a_r10^2*a_r21^2*a_r30^2*a_r41^2*a_t10^2*a_t20^2*a_t31^2*a_t41^2*a_v20^2*a_v21^2*a_v31^2*a_v41^2*a_x21^2*a_x30^2*a_x31^2*a_x41^2*a_z10^2*a_z21^2*a_z32^2*a_z41^2*b_a20^2*b_a21^2*b_a32^2*b_a41^2*b_d10^2*b_d31^2*b_d32^2*b_d41^2*b_f30^2*b_f31^2*b_f32^2*b_f41^2*b_g20^2*b_g30^2*b_g40^2*b_g41^2*b_j21^2*b_j31^2*b_j40^2*b_j41^2*b_o10^2*b_o20^2*b_o30^2*b_o42^2*b_q20^2*b_q21^2*b_q30^2*b_q42^2*b_s10^2*b_s21^2*b_s31^2*b_s42^2*b_t20^2*b_t21^2*b_t31^2*b_t42^2*b_w10^2*b_w20^2*b_w32^2*b_w42^2*b_x10^2*b_x21^2*b_x32^2*b_x42^2*c_a21^2*c_a30^2*c_a32^2*c_a42^2*c_c20^2*c_c31^2*c_c32^2*c_c42^2*c_d30^2*c_d31^2*c_d32^2*c_d42^2*c_e10^2*c_e30^2*c_e40^2*c_e42^2*c_k21^2*c_k32^2*c_k40^2*c_k42^2*c_o10^2*c_o31^2*c_o41^2*c_o42^2*c_s20^2*c_s32^2*c_s41^2*c_s42^2*c_u30^2*c_u40^2*c_u41^2*c_u42^2*c_v31^2*c_v40^2*c_v41^2*c_v42^2*c_w32^2*c_w40^2*c_w41^2*c_w42^2*c_x10^2*c_x20^2*c_x30^2*c_x43^2*d_b10^2*d_b21^2*d_b31^2*d_b43^2*d_d20^2*d_d30^2*d_d31^2*d_d43^2*d_e21^2*d_e30^2*d_e31^2*d_e43^2*d_h20^2*d_h21^2*d_h32^2*d_h43^2*d_i10^2*d_i30^2*d_i32^2*d_i43^2*d_j21^2*d_j30^2*d_j32^2*d_j43^2*d_k10^2*d_k31^2*d_k32^2*d_k43^2*d_l20^2*d_l31^2*d_l32^2*d_l43^2*d_n10^2*d_n20^2*d_n40^2*d_n43^2*d_u31^2*d_u32^2*d_u40^2*d_u43^2*d_w10^2*d_w21^2*d_w41^2*d_w43^2*e_c30^2*e_c32^2*e_c41^2*e_c43^2*e_d20^2*e_d40^2*e_d41^2*e_d43^2*e_e21^2*e_e40^2*e_e41^2*e_e43^2*e_f32^2*e_f40^2*e_f41^2*e_f43^2*e_i20^2*e_i21^2*e_i42^2*e_i43^2*e_n30^2*e_n31^2*e_n42^2*e_n43^2*e_o10^2*e_o40^2*e_o42^2*e_o43^2*e_p21^2*e_p40^2*e_p42^2*e_p43^2*e_q31^2*e_q40^2*e_q42^2*e_q43^2*e_r10^2*e_r41^2*e_r42^2*e_r43^2*e_s20^2*e_s41^2*e_s42^2*e_s43^2*e_t30^2*e_t41^2*e_t42^2*e_t43^2,
 a_a10^24*a_a20^24*a_a30^24*a_a40^24*a_u10^24*a_u21^24*a_u31^24*a_u41^24*b_y20^24*b_y21^24*b_y32^24*b_y42^24*d_m30^24*d_m31^24*d_m32^24*d_m43^24*e_u40^24*e_u41^24*e_u42^24*e_u43^24]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^(sz-2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Tree_Graceful_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size and order parameters\n')
    f.write('sz=Integer('+str(sz)+'); od=Integer(2)\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [Integer(1), Integer(2)]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Lc[cnt]+"','sym')]"+"\n")
    f.write('# Initializing the second hypermatrix\n')
    f.write("\nBh=HM(od,sz,'a','sym')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Ll[cnt]+"','sym')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Initializes the kronecker delta
    f.write('\n# Initialization of the Kornecker delta\n')
    f.write("D=HM(od, sz, 'kronecker')\n")
    # Writing the part which initializes the list of functions which do not touch y=x from bellow
    f.write('\n# Initialization of the list of functions\n')
    f.write('L=[T+[(sz-1,0)] for T in DecreasingFunctionList(sz-1)]\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(sum(Deter((HM(2,(sum(A[T[i][1]+sz-1-i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))*HM(sz,1,'one')).list(),'diag')+(-1)*sum(A[T[i][1]+sz-1-i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))).slice(rg(1,sz),'row').slice(rg(1,sz),'col')) for T in L))\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(Deter((HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')-TmpA[j]).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, HM(sz,sz,'a').list(), sz) for mnm in expand(Deter((HM(od, (Bh*HM(sz,1,'one')).list(),'diag')-Bh).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_tree_graceful_preimage_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list pre-image unlabeled unlabeled orbit of graceful
    trees on sz vertices having no loop edges this implementation is very slow.
    The smallest number of vertices for which this works
    is sz=5. This is in reference to the maping of trees in the semigroup
    to gracefully labeled trees


    EXAMPLES:

    ::

        sage: generate_unlabeled_tree_graceful_preimage_listing_script(5)
        sage: load('Unlabeled_Listing_of_Tree_Graceful_Preimage_Graphs_on_5_vertices.sage')
        sage: L
        [a_f20^2*a_f21^2*a_f31^2*a_f40^2*a_h21^2*a_h30^2*a_h31^2*a_h40^2*a_j10^2*a_j21^2*a_j32^2*a_j40^2*a_m21^2*a_m30^2*a_m32^2*a_m40^2*a_n10^2*a_n31^2*a_n32^2*a_n40^2*a_o20^2*a_o31^2*a_o32^2*a_o40^2*a_s20^2*a_s21^2*a_s30^2*a_s41^2*a_w20^2*a_w30^2*a_w31^2*a_w41^2*a_y10^2*a_y20^2*a_y32^2*a_y41^2*b_b10^2*b_b30^2*b_b32^2*b_b41^2*b_c21^2*b_c30^2*b_c32^2*b_c41^2*b_e20^2*b_e31^2*b_e32^2*b_e41^2*b_h21^2*b_h30^2*b_h40^2*b_h41^2*b_i20^2*b_i31^2*b_i40^2*b_i41^2*b_k20^2*b_k32^2*b_k40^2*b_k41^2*b_l21^2*b_l32^2*b_l40^2*b_l41^2*b_m30^2*b_m32^2*b_m40^2*b_m41^2*b_n31^2*b_n32^2*b_n40^2*b_n41^2*b_p10^2*b_p21^2*b_p30^2*b_p42^2*b_r10^2*b_r20^2*b_r31^2*b_r42^2*b_u20^2*b_u30^2*b_u31^2*b_u42^2*b_v21^2*b_v30^2*b_v31^2*b_v42^2*b_z10^2*b_z30^2*b_z32^2*b_z42^2*c_b10^2*c_b31^2*c_b32^2*c_b42^2*c_f21^2*c_f30^2*c_f40^2*c_f42^2*c_g10^2*c_g31^2*c_g40^2*c_g42^2*c_h21^2*c_h31^2*c_h40^2*c_h42^2*c_i30^2*c_i31^2*c_i40^2*c_i42^2*c_j10^2*c_j32^2*c_j40^2*c_j42^2*c_l31^2*c_l32^2*c_l40^2*c_l42^2*c_m10^2*c_m30^2*c_m41^2*c_m42^2*c_n20^2*c_n30^2*c_n41^2*c_n42^2*c_p20^2*c_p31^2*c_p41^2*c_p42^2*c_q30^2*c_q31^2*c_q41^2*c_q42^2*c_r10^2*c_r32^2*c_r41^2*c_r42^2*c_t30^2*c_t32^2*c_t41^2*c_t42^2*c_y10^2*c_y21^2*c_y30^2*c_y43^2*c_z20^2*c_z21^2*c_z30^2*c_z43^2*d_a10^2*d_a20^2*d_a31^2*d_a43^2*d_c20^2*d_c21^2*d_c31^2*d_c43^2*d_f10^2*d_f20^2*d_f32^2*d_f43^2*d_g10^2*d_g21^2*d_g32^2*d_g43^2*d_o10^2*d_o21^2*d_o40^2*d_o43^2*d_p20^2*d_p21^2*d_p40^2*d_p43^2*d_q20^2*d_q31^2*d_q40^2*d_q43^2*d_r21^2*d_r31^2*d_r40^2*d_r43^2*d_s10^2*d_s32^2*d_s40^2*d_s43^2*d_t21^2*d_t32^2*d_t40^2*d_t43^2*d_v10^2*d_v20^2*d_v41^2*d_v43^2*d_x20^2*d_x21^2*d_x41^2*d_x43^2*d_y20^2*d_y30^2*d_y41^2*d_y43^2*d_z21^2*d_z30^2*d_z41^2*d_z43^2*e_a10^2*e_a32^2*e_a41^2*e_a43^2*e_b20^2*e_b32^2*e_b41^2*e_b43^2*e_g10^2*e_g20^2*e_g42^2*e_g43^2*e_h10^2*e_h21^2*e_h42^2*e_h43^2*e_j10^2*e_j30^2*e_j42^2*e_j43^2*e_k21^2*e_k30^2*e_k42^2*e_k43^2*e_l10^2*e_l31^2*e_l42^2*e_l43^2*e_m20^2*e_m31^2*e_m42^2*e_m43^2,
 2*a_b10^2*a_b21^2*a_b30^2*a_b40^2*a_c20^2*a_c21^2*a_c30^2*a_c40^2*a_d10^2*a_d20^2*a_d31^2*a_d40^2*a_e10^2*a_e21^2*a_e31^2*a_e40^2*a_g20^2*a_g30^2*a_g31^2*a_g40^2*a_i10^2*a_i20^2*a_i32^2*a_i40^2*a_k20^2*a_k21^2*a_k32^2*a_k40^2*a_l10^2*a_l30^2*a_l32^2*a_l40^2*a_p30^2*a_p31^2*a_p32^2*a_p40^2*a_q10^2*a_q20^2*a_q30^2*a_q41^2*a_r10^2*a_r21^2*a_r30^2*a_r41^2*a_t10^2*a_t20^2*a_t31^2*a_t41^2*a_v20^2*a_v21^2*a_v31^2*a_v41^2*a_x21^2*a_x30^2*a_x31^2*a_x41^2*a_z10^2*a_z21^2*a_z32^2*a_z41^2*b_a20^2*b_a21^2*b_a32^2*b_a41^2*b_d10^2*b_d31^2*b_d32^2*b_d41^2*b_f30^2*b_f31^2*b_f32^2*b_f41^2*b_g20^2*b_g30^2*b_g40^2*b_g41^2*b_j21^2*b_j31^2*b_j40^2*b_j41^2*b_o10^2*b_o20^2*b_o30^2*b_o42^2*b_q20^2*b_q21^2*b_q30^2*b_q42^2*b_s10^2*b_s21^2*b_s31^2*b_s42^2*b_t20^2*b_t21^2*b_t31^2*b_t42^2*b_w10^2*b_w20^2*b_w32^2*b_w42^2*b_x10^2*b_x21^2*b_x32^2*b_x42^2*c_a21^2*c_a30^2*c_a32^2*c_a42^2*c_c20^2*c_c31^2*c_c32^2*c_c42^2*c_d30^2*c_d31^2*c_d32^2*c_d42^2*c_e10^2*c_e30^2*c_e40^2*c_e42^2*c_k21^2*c_k32^2*c_k40^2*c_k42^2*c_o10^2*c_o31^2*c_o41^2*c_o42^2*c_s20^2*c_s32^2*c_s41^2*c_s42^2*c_u30^2*c_u40^2*c_u41^2*c_u42^2*c_v31^2*c_v40^2*c_v41^2*c_v42^2*c_w32^2*c_w40^2*c_w41^2*c_w42^2*c_x10^2*c_x20^2*c_x30^2*c_x43^2*d_b10^2*d_b21^2*d_b31^2*d_b43^2*d_d20^2*d_d30^2*d_d31^2*d_d43^2*d_e21^2*d_e30^2*d_e31^2*d_e43^2*d_h20^2*d_h21^2*d_h32^2*d_h43^2*d_i10^2*d_i30^2*d_i32^2*d_i43^2*d_j21^2*d_j30^2*d_j32^2*d_j43^2*d_k10^2*d_k31^2*d_k32^2*d_k43^2*d_l20^2*d_l31^2*d_l32^2*d_l43^2*d_n10^2*d_n20^2*d_n40^2*d_n43^2*d_u31^2*d_u32^2*d_u40^2*d_u43^2*d_w10^2*d_w21^2*d_w41^2*d_w43^2*e_c30^2*e_c32^2*e_c41^2*e_c43^2*e_d20^2*e_d40^2*e_d41^2*e_d43^2*e_e21^2*e_e40^2*e_e41^2*e_e43^2*e_f32^2*e_f40^2*e_f41^2*e_f43^2*e_i20^2*e_i21^2*e_i42^2*e_i43^2*e_n30^2*e_n31^2*e_n42^2*e_n43^2*e_o10^2*e_o40^2*e_o42^2*e_o43^2*e_p21^2*e_p40^2*e_p42^2*e_p43^2*e_q31^2*e_q40^2*e_q42^2*e_q43^2*e_r10^2*e_r41^2*e_r42^2*e_r43^2*e_s20^2*e_s41^2*e_s42^2*e_s43^2*e_t30^2*e_t41^2*e_t42^2*e_t43^2,
 a_a10^24*a_a20^24*a_a30^24*a_a40^24*a_u10^24*a_u21^24*a_u31^24*a_u41^24*b_y20^24*b_y21^24*b_y32^24*b_y42^24*d_m30^24*d_m31^24*d_m32^24*d_m43^24*e_u40^24*e_u41^24*e_u42^24*e_u43^24]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(sz^(sz-2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_Listing_of_Tree_Graceful_Preimage_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [Integer(1), Integer(2)]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Lc[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Lc[cnt]+"','sym')]"+"\n")
    f.write("\nBh=HM(od,sz,'a','sym')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg((sz^(sz-2))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),")
                cnt=cnt+1
        else:
            f.write("HM(od,sz,'"+Ll[cnt]+"','sym'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(od,sz,'"+Ll[cnt]+"','sym')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Initializes the kronecker delta
    f.write('\n# Initialization of the Kornecker delta\n')
    f.write("D=HM(od, sz, 'kronecker')\n")
    # Writing the part which initializes the list of functions which do not touch y=x from bellow
    f.write('\n# Initialization of the list of functions\n')
    f.write('L=[T+[(sz-1,0)] for T in DecreasingFunctionList(sz-1)]\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write("F=expand(sum(Deter((HM(2,(sum(A[i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))*HM(sz,1,'one')).list(),'diag')+(-1)*sum(A[i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))).slice(rg(1,sz),'row').slice(rg(1,sz),'col')) for T in L)*A[sz-1,0]/A[0,0])\n")
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write("    LstM=LstM+expand(Deter((HM(2,(TmpA[j]*HM(sz,1,'one')).list(),'diag')-TmpA[j]).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()\n")
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write("LtG=[Monomial2Tuple(mnm, HM(sz,sz,'a').list(), sz) for mnm in expand(Deter((HM(od, (Bh*HM(sz,1,'one')).list(),'diag')-Bh).slice(rg(1,sz),'row').slice(rg(1,sz),'col'))).operands()]\n")
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_permutation_listing(sz,A):
    """
    The function lists representative of the conjugacy class of spanning union of 
    directed cycles. The implementation thus describes unlabeled spanning union of
    directed cycles on sz vertices.


    EXAMPLES:

    ::

        sage: sz=Integer(3); L=generate_unlabeled_permutation_listing(sz,HM(sz,sz,'a')); L
        [a01*a12*a20, a01*a10*a22, a00*a11*a22]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the the list which store the computation
    Lm=[]; VrbL=[]
    # Loop running through the partitions
    for P in Partitions(sz):
        Lm.append(1)
        for indx in rg(len(P)):
            Lm[len(Lm)-1]=Lm[len(Lm)-1]*prod(A[sum(P[:indx])+u,sum(P[:indx])+Integer(mod(u+1,P[indx]))] for u in rg(P[indx]))
    return Lm

def generate_representative_functions_listing(sz,A):
    """
    The function lists representative functions of the orbit under the Sn x Sn action each function is described
    by a bipartite graph on 2*sz vertices as a result in the symbolic input matrix A must be of size 2*sz x 2*sz
    the implementation leans rather heavily on the partition function


    EXAMPLES:

    ::

        sage: sz=Integer(3); L=generate_representative_functions_listing(sz,HM(2*sz,2*sz,'a')); L
        [a04*a15*a23, a04*a13*a25, a03*a14*a25]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the the list which store the computation
    Lm=[]; VrbL=[]
    # Loop running through the partitions
    for P in Partitions(sz):
        Lm.append(1)
        for indx in rg(len(P)):
            Lm[len(Lm)-1]=Lm[len(Lm)-1]*prod(A[sum(P[:indx])+u,sz+sum(P[:indx])+Integer(mod(u+1,P[indx]))] for u in rg(P[indx]))
    return Lm

def generate_unlabeled_spanning_union_of_stars_listing(sz,A):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled spanning union of stars
    on sz vertices having no loop edges this implementation
    is very slow. The input character c is the pre-index
    character.


    EXAMPLES:

    ::

        sage: sz=Integer(3); L=generate_unlabeled_spanning_union_of_stars_listing(sz, HM(sz,sz,'a')); L
        [a00*a11*a22, a00*a11*a20, a00*a10*a20]
        sage: od=Integer(2);sz=Integer(3); X=var_list('x',sz); L=generate_unlabeled_spanning_union_of_stars_listing(sz,HM(sz,sz,'a')*HM(od,X,'diag')); L
        [a00*a11*a22*x0*x1*x2, a00*a11*a20*x0^2*x1, a00*a10*a20*x0^3] 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the the list which store the computation
    Lm=[]; VrbL=[]
    # Loop running through the partitions
    for P in Partitions(sz):
        Lm.append(1)
        for indx in rg(len(P)):
            #Lm[len(Lm)-1]=Lm[len(Lm)-1]*prod(A[sum(P[:indx])+u,sum(P[:indx])+Integer(mod(u+1,P[indx]))] for u in rg(P[indx]))
            Lm[len(Lm)-1]=Lm[len(Lm)-1]*prod(A[sum(P[:indx])+u,u] for u in rg(P[indx]))
    return Lm

def RandomCaterpillarTuple(sz):
    """
    Outputs a random functional caterpillar tree
    described in tuple notation chosen uniformly at random


    EXAMPLES:

    ::

        sage: sz=Integer(5); len(RandomCaterpillarTuple(sz))
        5
       

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the empty partition list
    pL=[] 
    # Initialization of the Tuple and the list which
    # will store values that were already used
    Tp=[]
    # Initialization of the residue value
    rsdv=sz
    while rsdv > Integer(0):
        # Random choice of the number vertices in the current star
        strsz=randint(Integer(1), rsdv)
        pL.append(strsz);  rsdv=rsdv-strsz
    # Displaying on screen for debugging purposes
    #print('pL =',pL)
    for indx in rg(len(pL)):
        Tp=Tp+[[sum(pL[:indx])+u,sum(pL[:indx])] for u in rg(pL[indx])] 
    # Fixing the spanning union of stars into a caterpillar
    T=[(Tp[0][0], Tp[0][1])]
    for i in rg(1,sz):
        if Tp[i][0] == Tp[i][1]:
            T.append((Tp[i][0], Tp[i][1]-Integer(1)))
        else:
            T.append((Tp[i][0], Tp[i][1]))
    # Displaying on screen for debugging purposes
    #print('Tp =',Tp)
    return T

def generate_unlabeled_curtailement_functional_listing_script(Tp):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled curtailed functional directed graph on sz vertices
    the curtailment is dont by replacing non-loop leaf edges by loop edges


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 2)]; generate_unlabeled_curtailement_functional_listing_script(T)
        sage: load('Unlabeled_curtailement_Listing_of_Functional_Graphs_on_4_vertices.sage')
        sage: G
        12*b_k00^2*b_k11^2*b_k22^2*b_k30^2*d_w00^2*d_w11^2*d_w22^2*d_w31^2*g_i00^2*g_i11^2*g_i22^2*g_i32^2*h_o00^2*h_o11^2*h_o20^2*h_o33^2*i_e00^2*i_e11^2*i_e21^2*i_e33^2*i_q00^2*i_q10^2*i_q22^2*i_q33^2*i_v01^2*i_v11^2*i_v22^2*i_v33^2*i_w02^2*i_w11^2*i_w22^2*i_w33^2*i_x03^2*i_x11^2*i_x22^2*i_x33^2*i_y00^2*i_y12^2*i_y22^2*i_y33^2*j_c00^2*j_c13^2*j_c22^2*j_c33^2*j_k00^2*j_k11^2*j_k23^2*j_k33^2 + 24*b_l01*b_l11*b_l22*b_l30*b_m02*b_m11*b_m22*b_m30*b_s00*b_s13*b_s22*b_s30*c_a00*c_a11*c_a23*c_a30*d_s00*d_s10*d_s22*d_s31*d_z03*d_z11*d_z22*d_z31*e_a00*e_a12*e_a22*e_a31*e_m00*e_m11*e_m23*e_m31*f_c00*f_c11*f_c20*f_c32*f_s00*f_s11*f_s21*f_s32*g_l03*g_l11*g_l22*g_l32*g_q00*g_q13*g_q22*g_q32*h_p01*h_p11*h_p20*h_p33*h_r03*h_r11*h_r20*h_r33*h_s00*h_s12*h_s20*h_s33*i_a00*i_a10*i_a21*i_a33*i_g02*i_g11*i_g21*i_g33*i_m00*i_m13*i_m21*i_m33*i_s02*i_s10*i_s22*i_s33*i_t03*i_t10*i_t22*i_t33*i_z01*i_z12*i_z22*i_z33*j_d01*j_d13*j_d22*j_d33*j_m02*j_m11*j_m23*j_m33*j_o00*j_o12*j_o23*j_o33 + 12*a_e00^2*a_e11^2*a_e20^2*a_e30^2*b_g00^2*b_g10^2*b_g22^2*b_g30^2*d_g00^2*d_g11^2*d_g21^2*d_g31^2*d_x01^2*d_x11^2*d_x22^2*d_x31^2*g_k02^2*g_k11^2*g_k22^2*g_k32^2*g_m00^2*g_m12^2*g_m22^2*g_m32^2*h_k00^2*h_k10^2*h_k20^2*h_k33^2*i_f01^2*i_f11^2*i_f21^2*i_f33^2*j_a02^2*j_a12^2*j_a22^2*j_a33^2*j_f03^2*j_f13^2*j_f22^2*j_f33^2*j_n03^2*j_n11^2*j_n23^2*j_n33^2*j_s00^2*j_s13^2*j_s23^2*j_s33^2 + 24*a_i00*a_i12*a_i20*a_i30*a_m00*a_m13*a_m20*a_m30*a_q00*a_q10*a_q21*a_q30*a_v01*a_v11*a_v21*a_v30*b_q02*b_q12*b_q22*b_q30*b_w00*b_w10*b_w23*b_w30*c_m00*c_m10*c_m20*c_m31*c_r01*c_r11*c_r20*c_r31*d_i02*d_i11*d_i21*d_i31*d_j03*d_j11*d_j21*d_j31*e_c02*e_c12*e_c22*e_c31*e_n01*e_n11*e_n23*e_n31*e_y00*e_y10*e_y20*e_y32*f_t01*f_t11*f_t21*f_t32*g_g02*g_g10*g_g22*g_g32*g_n01*g_n12*g_n22*g_n32*g_p03*g_p12*g_p22*g_p32*g_s02*g_s13*g_s22*g_s32*h_z03*h_z13*h_z20*h_z33*i_p03*i_p13*i_p21*i_p33*j_j03*j_j10*j_j23*j_j33*j_r03*j_r12*j_r23*j_r33*j_t01*j_t13*j_t23*j_t33*j_u02*j_u13*j_u23*j_u33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz = len(Tp)
    cL=CurtailmentTupleList(Tp)
    # Initialization of the order
    od = ceil(log(sz^sz, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_curtailement_Listing_of_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writing the part which initializes the input tuple
    f.write('\n# Initialization of the input tuple\n')
    f.write('Tp='+str(Tp)+'\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('cL=CurtailmentTupleList(Tp)\n')
    f.write('for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('    for T in CurtailmentTupleList(Tp):\n')
    f.write('        if not ConjugateTuple(T, p) in cL:\n')
    f.write('            cL.append(ConjugateTuple(T, p))\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[tp[i][0],tp[i][1]] for i in rg(sz)) for tp in cL)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial substituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_unlabeled_contraction_functional_listing_script(Tp):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled functional directed graph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: T=[(0, 0), (1, 0), (2, 0), (3, 2)];generate_unlabeled_contraction_functional_listing_script(T)
        sage: load('Unlabeled_contraction_Listing_of_Functional_Graphs_on_4_vertices.sage')
        sage: G
        24*b_l01*b_l11*b_l22*b_l30*b_m02*b_m11*b_m22*b_m30*b_s00*b_s13*b_s22*b_s30*c_a00*c_a11*c_a23*c_a30*d_s00*d_s10*d_s22*d_s31*d_z03*d_z11*d_z22*d_z31*e_a00*e_a12*e_a22*e_a31*e_m00*e_m11*e_m23*e_m31*f_c00*f_c11*f_c20*f_c32*f_s00*f_s11*f_s21*f_s32*g_l03*g_l11*g_l22*g_l32*g_q00*g_q13*g_q22*g_q32*h_p01*h_p11*h_p20*h_p33*h_r03*h_r11*h_r20*h_r33*h_s00*h_s12*h_s20*h_s33*i_a00*i_a10*i_a21*i_a33*i_g02*i_g11*i_g21*i_g33*i_m00*i_m13*i_m21*i_m33*i_s02*i_s10*i_s22*i_s33*i_t03*i_t10*i_t22*i_t33*i_z01*i_z12*i_z22*i_z33*j_d01*j_d13*j_d22*j_d33*j_m02*j_m11*j_m23*j_m33*j_o00*j_o12*j_o23*j_o33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz = len(Tp)
    # Initialization of the order
    od = ceil(log(sz^sz, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_contraction_Listing_of_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(sz^sz-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writing the part which initializes the input tuple
    f.write('\n# Initialization of the input tuple\n')
    f.write('Tp='+str(Tp)+'\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('cL=ContractionTupleList(Tp)\n')
    f.write('for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('    for T in ContractionTupleList(Tp):\n')
    f.write('        if not ConjugateTuple(T, p) in cL:\n')
    f.write('            cL.append(ConjugateTuple(T, p))\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[tp[i][0],tp[i][1]] for i in rg(sz)) for tp in cL)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial substituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def ConjugateTuple(T, P):
    """
    Returns the conjugation of T 
    by the permutation P.


    EXAMPLES:

    ::


        sage: ConjugateTuple([(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)], [(i, i)  for i in rg(8)])
        [(0, 0), (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (6, 7), (7, 6)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list
    L = [(P[t[0]][1], P[t[1]][1]) for t in T]
    # Sorting the list
    L.sort()
    return L

def LeftRightActionTuple(T, P, Q):
    """
    Returns the result of the left action on T by the permutation P
    followed by the right action by Q.


    EXAMPLES:

    ::


        sage: sz=Integer(5); LeftRightActionTuple([(0,0)]+[(i,i-1) for i in rg(1,sz)], [(i,Integer(mod(i+1,sz))) for i in rg(sz)], [(i,Integer(mod(i+2,sz))) for i in rg(sz)])
        [(0, 2), (1, 3), (2, 4), (3, 0), (4, 2)]


    AUTHORS:
    - Edinah K. Gnang
    """
    return Adjacency_to_Tuple(Tuple_to_Adjacency(P)*Tuple_to_Adjacency(T)*Tuple_to_Adjacency(Q))

def generate_subgraph_unlabeled_listing_script(sz, T):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled directed subgraph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_subgraph_unlabeled_listing_script(4, [(0, 1), (1, 0)])
        sage: load('Unlabeled_subgraph_Listing_of_Directed_Graphs_on_3_vertices.sage')
        sage: L
        [6*a_a_a_a01^4*a_a_a_a10^4*a_a_a_b02^4*a_a_a_b20^4*a_a_a_c12^4*a_a_a_c21^4*a_a_a_d03^4*a_a_a_d30^4*a_a_a_e13^4*a_a_a_e31^4*a_a_a_f23^4*a_a_a_f32^4,
         12*a_a_a_g01^2*a_a_a_h02^2*a_a_a_i03^2*a_a_a_j10^2*a_a_a_k12^2*a_a_a_l13^2*a_a_a_m20^2*a_a_a_n21^2*a_a_a_o23^2*a_a_a_p30^2*a_a_a_q31^2*a_a_a_r32^2]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz^2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_subgraph_Listing_of_Directed_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz^2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz^2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the Tuple
    f.write('\n# Initialization of the Tuple\n')
    f.write('T='+str(T)+'\n')
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('SgPh=Set(expand(prod(1+Bh[t] for t in T)-1).operands())\n')
    f.write('for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('    SgPh=SgPh.union(Set(expand(prod(1+Bh[t] for t in ConjugateTuple(T, p))-1).operands()))\n')
    f.write('LgPh=sum(SgPh).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in LgPh]\n')
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[t] for t in Tp) for Tp in LtG)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpA)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstM.append(prod(TmpA[j][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writing the last which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writing the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_supgraph_unlabeled_listing_script(sz,T):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled directed supgraph on sz vertices
    having no loop edges this implementation is very slow.


    EXAMPLES:

    ::

        sage: generate_supgraph_unlabeled_listing_script(3, [])
        sage: load('Unlabeled_supgraph_Listing_of_Directed_Graphs_on_3_vertices.sage')
        sage: L
        [a_a01^6*a_a02^6*a_a10^6*a_a12^6*a_a20^6*a_a21^6,
         6*a_b01*a_b02*a_b10*a_b12*a_b20*a_c01*a_c02*a_c10*a_c12*a_c21*a_d01*a_d02*a_d10*a_d20*a_d21*a_e01*a_e02*a_e12*a_e20*a_e21*a_f01*a_f10*a_f12*a_f20*a_f21*a_g02*a_g10*a_g12*a_g20*a_g21,
         3*a_l02^2*a_l10^2*a_l12^2*a_l20^2*a_n01^2*a_n02^2*a_n12^2*a_n21^2*a_r01^2*a_r10^2*a_r20^2*a_r21^2,
         6*a_j01*a_j02*a_j12*a_j20*a_k01*a_k10*a_k12*a_k20*a_m01*a_m02*a_m10*a_m21*a_p02*a_p10*a_p12*a_p21*a_s02*a_s10*a_s20*a_s21*a_t01*a_t12*a_t20*a_t21,
         3*a_i01^2*a_i02^2*a_i10^2*a_i20^2*a_o01^2*a_o10^2*a_o12^2*a_o21^2*a_u02^2*a_u12^2*a_u20^2*a_u21^2,
         3*a_h01^2*a_h02^2*a_h10^2*a_h12^2*a_q01^2*a_q02^2*a_q20^2*a_q21^2*a_v10^2*a_v12^2*a_v20^2*a_v21^2,
         2*b_d01^3*b_d12^3*b_d20^3*b_i02^3*b_i10^3*b_i21^3,
         6*b_b01*b_b10*b_b20*b_c02*b_c10*b_c20*b_e02*b_e12*b_e20*b_h01*b_h10*b_h21*b_j01*b_j12*b_j21*b_k02*b_k12*b_k21,
         6*a_x01*a_x02*a_x12*a_z02*a_z10*a_z12*b_f10*b_f12*b_f20*b_g01*b_g02*b_g21*b_m01*b_m20*b_m21*b_o10*b_o20*b_o21,
         6*a_w01*a_w02*a_w10*a_y01*a_y10*a_y12*b_a01*b_a02*b_a20*b_l10*b_l12*b_l21*b_n02*b_n20*b_n21*b_p12*b_p20*b_p21,
         3*b_u02^2*b_u12^2*b_y10^2*b_y20^2*c_a01^2*c_a21^2,
         6*b_s02*b_s10*b_t01*b_t12*b_w01*b_w20*b_z12*b_z20*c_b02*c_b21*c_c10*c_c21,
         3*b_r01^2*b_r10^2*b_x02^2*b_x20^2*c_d12^2*c_d21^2,
         3*b_q01^2*b_q02^2*b_v10^2*b_v12^2*c_e20^2*c_e21^2,
         6*c_f01*c_g02*c_h10*c_i12*c_j20*c_k21]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz*(sz-1)), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_supgraph_Listing_of_Directed_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1))-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the Tuple
    f.write('\n# Initialization of the Tuple\n')
    f.write('T='+str(T)+'\n')
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('if len(T)==0:\n')
    f.write('    SgPh=Set(expand(prod(1+Bh[i,j] for i in rg(sz) for j in rg(sz) if i!=j)-1).operands())\n')
    f.write('else:\n')
    f.write('    SgPh=Set(expand(prod(1+Bh[i,j] for i in rg(sz) for j in rg(sz) if i!=j and not (i,j) in T)*prod(Bh[t] for t in T)).operands())\n')
    f.write('    for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('        SgPh=SgPh.union(Set(expand(prod(1+Bh[i,j] for i in rg(sz) for j in rg(sz) if i!=j and not (i,j) in ConjugateTuple(T, p))*prod(Bh[t] for t in ConjugateTuple(T, p))).operands()))\n')
    f.write('LgPh=sum(SgPh).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in LgPh]\n')
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[t] for t in Tp) for Tp in LtG)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpA)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstM.append(prod(TmpA[j][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_undirected_subgraph_unlabeled_listing_script(sz,T):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled undirected subgraph on sz vertices
    having no loop edges this implementation is very slow.
    The input list of edge tuple treats every directed edges
    as if it was acompanied by its compnion edge.


    EXAMPLES:

    ::

        sage: generate_undirected_subgraph_unlabeled_listing_script(3, [(0, 1), (2, 1), (2, 0)])
        sage: load('Unlabeled_subgraph_Listing_of_Undirected_Graphs_on_3_vertices.sage')
        sage: L
        [a01^6*a02^6*a10^6*a12^6*a20^6*a21^6,
         3*b01^2*b02^2*b10^2*b20^2*c01^2*c10^2*c12^2*c21^2*d02^2*d12^2*d20^2*d21^2,
         3*e01^2*e10^2*f02^2*f20^2*g12^2*g21^2]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz*(sz-1)/2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_subgraph_Listing_of_Undirected_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a'); Bht=Bh.transpose()\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the Tuple
    f.write('\n# Initialization of the Tuple\n')
    f.write('T='+str(T)+'\n')
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('SgPh=Set(expand(prod(1+Bh[t]*Bht[t] for t in T)-1).operands())\n')
    f.write('for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('    SgPh=SgPh.union(Set(expand(prod(1+Bh[t]*Bht[t] for t in ConjugateTuple(T, p))-1).operands()))\n')
    f.write('LgPh=sum(SgPh).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in LgPh]\n')
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[t] for t in Tp) for Tp in LtG)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpA)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstM.append(prod(TmpA[j][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writing the last which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writing the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_undirected_supgraph_unlabeled_listing_script(sz,T):
    """
    Creates a sage file which corresponds to a script
    which list unlabeled undirected supgraph on sz vertices
    having no loop edges this implementation is very slow.
    The input list of edge tuple treats every directed edges
    as if it was acompanied by its compnion edge.


    EXAMPLES:

    ::

        sage: generate_undirected_supgraph_unlabeled_listing_script(3, [(0, 1), (2, 1)])
        sage: load('Unlabeled_supgraph_Listing_of_Undirected_Graphs_on_3_vertices.sage')
        sage: L
        [a01^6*a02^6*a10^6*a12^6*a20^6*a21^6,
         3*b01^2*b02^2*b10^2*b20^2*c01^2*c10^2*c12^2*c21^2*d02^2*d12^2*d20^2*d21^2]

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(2^(sz*(sz-1)/2), 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Unlabeled_supgraph_Listing_of_Undirected_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a'); Bht=Bh.transpose()\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(2^(sz*(sz-1)/2)-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the Tuple
    f.write('\n# Initialization of the Tuple\n')
    f.write('T='+str(T)+'\n')
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(sz,sz,[prod(TmpA[indx][P[indx][i]-1,P[indx][j]-1] for indx in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('if len(T)==0:\n')
    f.write('    SgPh=Set(expand(prod(1+Bh[i,j]*Bh[j,i] for i in rg(sz) for j in rg(sz) if i<j)-1).operands())\n')
    f.write('else:\n')
    f.write('    SgPh=Set(expand(prod(1+Bh[i,j]*Bh[j,i] for i in rg(sz) for j in rg(sz) if i<j and not (i,j) in T and not (j,i) in T)*prod(Bh[t]*Bht[t] for t in T)).operands())\n')
    f.write('    for p in PermutationFunctionList(sz)[1:]:\n')
    f.write('        SgPh=SgPh.union(Set(expand(prod(1+Bh[i,j]*Bh[j,i] for i in rg(sz) for j in rg(sz) if i<j and not (i,j) in ConjugateTuple(T, p) and not (j,i) in ConjugateTuple(T, p))*prod(Bh[t]*Bht[t] for t in ConjugateTuple(T, p))).operands()))\n')
    f.write('LgPh=sum(SgPh).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in LgPh]\n')
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=sum(prod(A[t] for t in Tp) for Tp in LtG)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpA)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstM.append(prod(TmpA[j][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def generate_tensorial_functional_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which list tensorial functional directed graph on sz vertices.
    In other words the code describes the orbit induced by the left-right
    action of S_sz x S_sz on the functional directed graphs this implementation
    is very slow.


    EXAMPLES:

    ::

        sage: generate_tensorial_functional_listing_script(2)
        sage: load('Tensorial_Listing_of_Functional_Graphs_on_2_vertices.sage')
        sage: L
        [2*b01^2*b10^2*c00^2*c11^2, 2*a00^2*a10^2*d01^2*d11^2]       
        sage: generate_tensorial_functional_listing_script(3)
        sage: load('Tensorial_Listing_of_Functional_Graphs_on_3_vertices.sage')
        sage: L
        [6*a_f02^6*a_f11^6*a_f20^6*a_h01^6*a_h12^6*a_h20^6*a_l02^6*a_l10^6*a_l21^6*a_p00^6*a_p12^6*a_p21^6*a_t01^6*a_t10^6*a_t22^6*a_v00^6*a_v11^6*a_v22^6, 18*a_b01^2*a_b10^2*a_b20^2*a_c02^2*a_c10^2*a_c20^2*a_d00^2*a_d11^2*a_d20^2*a_e01^2*a_e11^2*a_e20^2*a_g00^2*a_g12^2*a_g20^2*a_i02^2*a_i12^2*a_i20^2*a_j00^2*a_j10^2*a_j21^2*a_k01^2*a_k10^2*a_k21^2*a_m00^2*a_m11^2*a_m21^2*a_o02^2*a_o11^2*a_o21^2*a_q01^2*a_q12^2*a_q21^2*a_r02^2*a_r12^2*a_r21^2*a_s00^2*a_s10^2*a_s22^2*a_u02^2*a_u10^2*a_u22^2*a_w01^2*a_w11^2*a_w22^2*a_x02^2*a_x11^2*a_x22^2*a_y00^2*a_y12^2*a_y22^2*a_z01^2*a_z12^2*a_z22^2, 3*a_a00^12*a_a10^12*a_a20^12*a_n01^12*a_n11^12*a_n21^12*b_a02^12*b_a12^12*b_a22^12]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the order
    od = ceil(log(factorial(sz)^2, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    #for i in rg(od-1):
    for i in rg(od):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Creating the string storing the file name
    filename = 'Tensorial_Listing_of_Functional_Graphs_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size parameter
    f.write('# Initializing the size parameter\n')
    f.write('sz=Integer('+str(sz)+')\n')
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(factorial(sz)^2-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(sz,sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(factorial(sz)^2-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(sz,sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(sz,sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(sz,sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations\n')
    f.write('P=Permutations(sz)\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('A=HM(sz,sz,[prod(TmpA[factorial(sz)*indx0+indx1][P[indx0][i]-1,P[indx1][j]-1] for indx0 in rg(factorial(sz)) for indx1 in rg(factorial(sz))) for j in rg(sz) for i in rg(sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    f.write('F=expand(prod(sum(A[i,j] for j in rg(sz)) for i in rg(sz)))\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+expand(prod(sum(TmpA[j][u,v] for v in rg(sz)) for u in rg(sz))).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), sz) for mnm in expand(prod(sum(Bh[i,j] for j in rg(sz)) for i in rg(sz))).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n')
    # Closing the file
    f.close()

def Endo_tensorial_GL_Fp_action_script(p, sz):
    """
    Creates a sage file which yields the orbit list
    generating polynomial for the left right action
    of GLn on the monoid of endormphism of sz x sz
    matrix over the finite filed with two elements.


    EXAMPLES:

    ::

        sage: Endo_tensorial_GL_Fp_action_script(2,2)
        sage: load('Endo_tensorial_orbit_GL_F2_action_4.sage')
        sage: G
        sage: a_a00^36*a_a10^36*a_a20^36*a_a30^36 + 6*a_g00^6*a_g13^6*a_g22^6*a_g31^6*a_h00^6*a_h12^6*a_h23^6*a_h31^6*a_j00^6*a_j13^6*a_j21^6*a_j32^6*a_l00^6*a_l11^6*a_l23^6*a_l32^6*a_n00^6*a_n12^6*a_n21^6*a_n33^6*a_o00^6*a_o11^6*a_o22^6*a_o33^6 + 9*a_b00^4*a_b11^4*a_b21^4*a_b30^4*a_c00^4*a_c12^4*a_c22^4*a_c30^4*a_d00^4*a_d13^4*a_d23^4*a_d30^4*a_e00^4*a_e11^4*a_e20^4*a_e31^4*a_f00^4*a_f10^4*a_f21^4*a_f31^4*a_i00^4*a_i12^4*a_i20^4*a_i32^4*a_k00^4*a_k10^4*a_k22^4*a_k32^4*a_m00^4*a_m13^4*a_m20^4*a_m33^4*a_p00^4*a_p10^4*a_p23^4*a_p33^4


    AUTHORS:
    - Edinah K. Gnang
    """
    # FIRST PART INITIALIZING THE MEMBERS OF THE GENERAL LINEAR GROUP
    # Creating the string storing the file name
    filename = 'Endo_tensorial_orbit_GL_F'+str(p)+'_action_'+str(p^sz)+'.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size\n')
    f.write('sz='+str(sz)+'\n\n')
    f.write('# Initializing the prime characteristic of the field\n')
    f.write('p='+str(p)+'\n\n')
    if sz==2:
        f.write('# Initialization of the list which stores the members of our group\n')
        f.write('Lm=[HM(2,2,m) for m in List_of_Integers([p for i in rg(2^2)]) if mod(Deter(HM(2,2,m)),p)!=mod(0,p)]\n\n')
    else:
        # Writing the variables
        f.write('\n# Initialization of the list which stores the members of our group\n')
        f.write("Lm=[]\n")
        f.write('\n# Initialization of the list of binary lists\n')
        f.write("Li=List_of_Integers([p for i in rg(sz)])\n")
        f.write('\n# Looping through the vector with field elements\n')
        f.write("cnt=0; F=0; L0=List_of_Integers([p for i in rg(sz)])[1:]\n")
        f.write('for l0 in L0:\n')
        f.write('    L1=copy(L0); L1.remove(l0)\n')
        # Begining of the loop
        # Initialization of the indentation space
        spc_indt=''
        for i in rg(1,sz-1):
            # Updateing the space indentation
            spc_indt=spc_indt+'    '
            f.write(spc_indt+'for l'+str(i)+' in L'+str(i)+':\n')
            f.write(spc_indt+'    L'+str(i+1)+'=copy(L'+str(i)+')\n')
            f.write(spc_indt+'    for lc'+str(i+1)+' in List_of_Integers([p for i in rg('+str(i+1)+')])[1:]:\n')
            # Writing the if condition
            f.write(spc_indt+'        if (')
            for j in rg(i):
                f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
            f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(p).list() in L2:\n')
            f.write(spc_indt+'            L'+str(i+1)+'.remove((')
            for j in rg(i):
                f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
            f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(p).list())\n')
        # End the loop
        f.write(spc_indt+'    for l'+str(i+1)+' in L'+str(i+1)+':\n')
        f.write(spc_indt+'        # Initializing the matrix representation of the Grassmanian variables\n')
        f.write(spc_indt+'        M=HM(sz,sz,')
        for j in rg(i+1):
            f.write('l'+str(j)+'+')
        f.write('l'+str(i+1)+'); Lm.append(M)\n')
        f.write(spc_indt+'        # Incrementing the counter\n') 
        f.write(spc_indt+'        cnt=cnt+1\n\n') 
    # SECOND PART FOR THE ACTION
    f.write('# Initialization of the order parameters\n')
    f.write('od=Integer(2)\n\n')
    f.write('# Initialization of the list of variables\n')
    f.write("X=var_list('x',sz)\n\n")
    f.write('# Initialization of Background hypermatrix\n')
    f.write("iL=[sz for i in rg(od)]+['a']; A=HM(*iL)\n\n")
    f.write('# Initialization of the list of projectors\n')
    f.write('DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)\n\n')
    f.write('# Performing the projectors\n')
    f.write('Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]\n\n')
    f.write('# Initialization of the list of transpose of the vectors\n')
    f.write("Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]\n\n")
    f.write('# Initialization of the vector\n')
    f.write('Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor().elementwise_exponent(1/od)\n\n')
    f.write('# Initializing the list of integer lists associated with the hypermatrix choices\n')
    f.write('Li=List_of_Integers([p for i in rg(sz^od)])\n\n')
    f.write('# Initialization of the list of integer lists associated with evaluation points\n')
    f.write('Lev=List_of_Integers([p for i in rg(sz)])\n\n')
    f.write('# Tuple list description of the elements of the transformation monoid\n')
    f.write('Lt=[]\n\n')
    f.write('# Looping over the hypermatrix choices\n')
    f.write('for al in Li:\n')
    f.write('    Lt.append([(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev])\n\n')
    f.write('# Tuple list description of the elements of the transformation monoid\n')
    f.write('Lmt=[]\n\n')
    f.write('# Looping over the hypermatrix choices\n')
    f.write('for al in [m.list() for m in Lm]:\n')
    f.write('    Lmt.append([(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev])\n\n')
    f.write('# Displaying the graphs on screen\n')
    f.write('for T in Lt:\n')
    f.write('    Tuple2DiGraph(T,p^sz).plot().show()\n\n')
    # THIRD PART FOR THE ORBIT LISTING
    # Initialization of the order
    od = ceil(log(prod(p^sz-p^k for k in rg(sz))^2, 26))
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Inflating the alphabet to the appropriate size
    Ll=AlphaBl.copy(); Lc=AlphaBc.copy()
    for i in rg(od-1):
        Ll=[a+'_'+b for a in Ll for b in AlphaBl]
        Lc=[A+'_'+B for A in Lc for B in AlphaBc]
    # Writing the symbols in capital letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpA=[\\\n')
    cnt = 0
    for i in rg(prod(p^sz-p^k for k in rg(sz))^2-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(p^sz,p^sz,'"+Lc[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(p^sz,p^sz,'"+Lc[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(p^sz,p^sz,'"+Lc[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(p^sz,p^sz,'"+Lc[cnt]+"')]"+"\n")
    f.write("\nBh=HM(p^sz,p^sz,'a')\n")
    # Writing the symbols in lower case letters
    f.write('\n# Initialization of the symbolic edge weights\nTmpB=[\\\n')
    cnt = 0
    for i in rg(prod(p^sz-p^k for k in rg(sz))^2-1):
        if Integer(mod(cnt,4)) == 0:
            f.write("HM(p^sz,p^sz,'"+Ll[cnt]+"'),")
            cnt=cnt+1
        elif Integer(mod(cnt,4)) in [1, 2]:
            for k in rg(2):
                f.write("HM(p^sz,p^sz,'"+Ll[cnt]+"'),")
                cnt=cnt+1
        else:
            f.write("HM(p^sz,p^sz,'"+Ll[cnt]+"'),\\"+"\n")
            cnt=cnt+1
    f.write("HM(p^sz,p^sz,'"+Ll[cnt]+"')]"+"\n")
    # Writing the part which initializes the permutations
    f.write('\n# Initialization of the permutations associated with the GLn(Fp)\n')
    f.write('P=[[t[i][1] for i in rg(p^sz)]  for t in Lmt]\n')
    # Writting the part which initializes the symbolic adjacency matrices
    f.write('\n# Initialization of the Adjacency matrix\n')
    f.write('\nA=HM(p^sz,p^sz,[prod(TmpA[prod(p^sz-p^k for k in rg(sz))*indx0+indx1][P[indx0][i],P[indx1][j]] for indx0 in rg(len(Lmt)) for indx1 in rg(len(Lmt))) for j in rg(p^sz) for i in rg(p^sz)])\n')
    # Writting the critical piece of the code
    f.write('\n# Initialization of listing of directed graphs\n')
    #f.write('F=expand(prod(sum(A[i,j] for j in rg(sz)) for i in rg(sz)))\n')
    f.write('F=sum(prod(A[i,T[i][1]] for i in rg(p^sz)) for T in Lt)\n')
    # Writing the loop which initializes the first list
    f.write('\n# Initiallization of the list of monomials to be substituted\n')
    f.write('LstM=[]\nfor j in rg(len(TmpB)):\n')
    f.write('    LstM=LstM+sum(prod(TmpA[j][i,T[i][1]] for i in rg(p^sz)) for T in Lt).operands()\n')
    # Writting the part which initializes the list of graphs
    f.write('\n# Initialization of the list of graphs\n')
    f.write('LtG=[Monomial2Tuple(mnm, Bh.list(), p^sz) for mnm in sum(prod(Bh[i,T[i][1]] for i in rg(p^sz)) for T in Lt).operands()]\n')
    # Writtin the lart which initializes the substituting monomials
    f.write('\n# Initialization of the list of monomial sbstituting\n')
    f.write('LstSubs=[]\nfor j in rg(len(TmpB)):\n    for k in rg(len(LtG)):\n')
    f.write('        LstSubs.append(prod(TmpB[k][LtG[k][i]] for i in rg(len(LtG[k]))))\n')
    # Writting the piece of the code which performs the substitution
    f.write('\n# Performing the substitution\n')
    f.write('G=fast_reduce_no_expand(F, LstM, LstSubs)\n')
    f.write('\n#Initialization of the operand list\n')
    f.write('L=G.operands()\n\n')
    # Closing the file
    f.close()

def generate_grassmanian_determinant_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution construction
    for the determinant as a signed listing of spanning union
    of directed cycles.


    EXAMPLES:

    ::

        sage: generate_grassmanian_determinant_listing_script(3)
        sage: load('Grassmanian_Determinant_Listing_on_3_vertices.sage')
        sage: rslt
        -(a02*a11 - a01*a12)*a20 + (a02*a10 - a00*a12)*a21 - (a01*a10 - a00*a11)*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Determinant_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(sz))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_permanent_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution construction
    for the permanent as a listing of spanning union
    of directed cycles.


    EXAMPLES:

    ::

        sage: generate_grassmanian_permanent_listing_script(3)
        sage: load('Grassmanian_Permanent_Listing_on_3_vertices.sage')
        sage: rslt
        a02*a11*a20 + a01*a12*a20 + a02*a10*a21 + a00*a12*a21 + a01*a10*a22 + a00*a11*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Permanent_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = expand(prod(sum(A[i,j]*X[j] for j in rg(sz)) for i in rg(sz)))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_graceful_determinant_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the determinantal graceful listing construction as a 
    signed listing of gracefully labeled graphs.


    EXAMPLES:

    ::

        sage: generate_grassmanian_graceful_determinant_listing_script(3)
        sage: load('Grassmanian_Graceful_Determinant_Listing_on_3_vertices.sage')
        sage: rslt
        a02*a11*a21 - a02*(a10 + a12)*a22 + (a00*(a10 + a12) - a01*a11)*a20

 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Graceful_Determinant_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = prod(sum(A[i,j]*X[abs(j-i)] for j in rg(sz)) for i in rg(sz))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_graceful_permanent_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the graceful permanental listing constructions.


    EXAMPLES:

    ::

        sage: generate_grassmanian_graceful_permanent_listing_script(3)
        sage: load('Grassmanian_Graceful_Permanent_Listing_on_3_vertices.sage')
        sage: rslt
        a00*a10*a20 + a01*a11*a20 + a00*a12*a20 + a02*a11*a21 + a02*a10*a22 + a02*a12*a22
    
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Graceful_Permanent_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = expand(prod(sum(A[i,j]*X[abs(j-i)] for j in rg(sz)) for i in rg(sz)))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_harmonious_determinant_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the determinantal harmonious listing construction as a 
    signed listing of gracefully labeled graphs.


    EXAMPLES:

    ::

        sage: generate_grassmanian_harmonious_determinant_listing_script(3)
        sage: load('Grassmanian_Harmonious_Determinant_Listing_on_3_vertices.sage')
        sage: rslt
        (a00*a10 - a01*a12)*a20 - (a02*a10 - a01*a11)*a21 - (a00*a11 - a02*a12)*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Harmonious_Determinant_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = prod(sum(A[i,j]*X[Integer(mod(j+i,sz))] for j in rg(sz)) for i in rg(sz))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_harmonious_permanent_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the harmonious permanental listing constructions.


    EXAMPLES:

    ::

        sage: generate_grassmanian_harmonious_permanent_listing_script(3)
        sage: load('Grassmanian_Harmonious_Permanent_Listing_on_3_vertices.sage')
        sage: rslt
        a00*a10*a20 + a01*a12*a20 + a02*a10*a21 + a01*a11*a21 + a00*a11*a22 + a02*a12*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Harmonious_Permanent_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = expand(prod(sum(A[i,j]*X[Integer(mod(j+i,sz))] for j in rg(sz)) for i in rg(sz)))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_poised_determinant_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the determinantal poised listing construction as a 
    signed listing of gracefully labeled graphs.


    EXAMPLES:

    ::

        sage: generate_grassmanian_poised_determinant_listing_script(3)
        sage: load('Grassmanian_Poised_Determinant_Listing_on_3_vertices.sage')
        sage: rslt
        (a00 + a01 + a02)*a11*a21 - (a00 + a01 + a02)*a12*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Poised_Determinant_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = prod(sum(A[i,j]*X[Integer(mod(j*i,sz))] for j in rg(sz)) for i in rg(sz))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def generate_grassmanian_poised_permanent_listing_script(sz):
    """
    Creates a sage file which corresponds to a script
    which implement the grassmanian substitution scheme
    for the poised permanental listing constructions.
    Meaning that the induced edge labels are distcint.
    edges are multiplicatively induced modulo the number
    of vertices.


    EXAMPLES:

    ::

        sage: generate_grassmanian_poised_permanent_listing_script(3)
        sage: load('Grassmanian_Poised_Permanent_Listing_on_3_vertices.sage')
        sage: rslt
        a00*a11*a21 + a01*a11*a21 + a02*a11*a21 + a00*a12*a22 + a01*a12*a22 + a02*a12*a22
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the matrix
    A=HM(sz,sz,'a')
    # Initialization of the alphabet of characters
    AlphaBl = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    AlphaBc = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # Creating the string storing the file name
    filename = 'Grassmanian_Poised_Permanent_Listing_on_'+str(sz)+'_vertices.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size and order parameters\n')
    f.write('sz='+str(sz)+'; od=2\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x',sz)\n")
    f.write('\n# Initialization of the square matrix\n')
    f.write("A=HM(sz, sz, 'a')\n")
    f.write('\n# Initialization of the 2x2 matrices used to represent Grassmanian variables\n')
    f.write("I2=HM(od,2,'kronecker'); s3=HM(2,2,[Integer(1),Integer(0),Integer(0),Integer(-1)])\n")
    f.write("c=HM(2,2,[Integer(0),Integer(1),Integer(0),Integer(0)])\n")
    f.write('\n# Initializing the matrix representation of the Grassmanian variables\n')
    f.write("Lm = [s3.tensor_power(j).tensor_product(c).tensor_product(I2.tensor_power(sz-1-j)) for j in rg(sz)]\n")
    f.write('\n# Initialization of the sum over functional directed graph keeping track in the in-degree\n')
    f.write('d = expand(prod(sum(A[i,j]*X[Integer(mod(j*i,sz))] for j in rg(sz)) for i in rg(sz)))\n')
    f.write('\n# Initialization of the substitution variables\n')
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"=var('")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"')\n")
    # Writting the substitution into the matrix step
    f.write('\n# Substituting the matrices into the poynomial\n')
    f.write("M = fast_reduceII(d,X,[")
    for i in rg(1,sz):
        f.write(str(AlphaBc[i])+', ')
    f.write(str(AlphaBc[sz+1])+"],{")
    for i in rg(1,sz):
        f.write("'"+str(AlphaBc[i])+"':Lm["+str(i-1)+"],")
    f.write("'"+str(AlphaBc[sz+1])+"':Lm["+str(sz-1)+"],")
    for u in rg(sz):
        for v in rg(sz):
            f.write("'"+str(A[u,v])+"':"+str(A[u,v])+",")
    f.write("'x':x})\n")
    # Writting the result
    f.write('\n# Selecting the appropriate entry\n')
    f.write("rslt=M[2^sz-1,0]\n")
    # Closing the file
    f.close()

def span(X):
    """
    Creates the span of maps in X uses 
    the FiniteSetMaps function to initialize
    maps which are composed by the * operation.


    EXAMPLES:

    ::

        sage: sz=2; M=FiniteSetMaps(rg(sz)); m=[f for f in list(M) if not f.is_one()]
        sage: span(m)
        {map: 0 -> 0, 1 -> 0,
         map: 0 -> 0, 1 -> 1,
         map: 0 -> 1, 1 -> 0,
         map: 0 -> 1, 1 -> 1}
 

    AUTHORS:
    - Ori Parzanchevski, Edinah K. Gnang
    """
    Y=set(X); s=0
    while len(Y)>s:
        s = len(Y); Z = copy(Y)
        for y in Z:
            for x in X:
                Y.add(x*y)
    return Y

def span_tuple(X):
    """
    Creates the span of maps in X uses 
    the FiniteSetMaps function to initialize
    maps which are composed by the * operation.


    EXAMPLES:

    ::

        sage: sz=2; M=TupleFunctionList(sz)
        sage: span_tuple(M)
        Set of elements of [[(0, 0), (1, 0)], [(0, 1), (1, 0)], [(0, 0), (1, 1)], [(0, 1), (1, 1)]] 


    AUTHORS:
    - Ori Parzanchevski, Edinah K. Gnang
    """
    Y=Set(X); s=0
    while Y.cardinality()>s:
        s=Y.cardinality(); Z=copy(Y)
        for y in Z:
            for x in Z:
                if not compose_tuple(x,y) in Y:
                    Y.union(Set([compose_tuple(x,y)]))
    return Y

def count_submonoids(sz):
    """
    Counting the number of submonoids of functions
    from rg(sz) to rg(sz). Is based upon the FiniteSetMaps
    function to initialize maps which are composed by
    the * operation.


    EXAMPLES:

    ::

        sage: count_submonoids(2)
        [(1, 1), (2, 3), (3, 1), (4, 1)]


    AUTHORS:
    - Ori Parzanchevski, Edinah K. Gnang
    """
    M=FiniteSetMaps(rg(sz)); m=[f for f in list(M) if not f.is_one() ]
    o=M.one(); s=subsets(m); S=set(); size=0
    for i,x in enumerate(s):
        S.add(frozenset(span([o]+x)))
        if len(S)!=size:
            #print (i,"of",2^len(m),", found",len(S),"monoids")
            size=len(S)
    sizes = [len(x) for x in S]
    return [(s,sizes.count(s)) for s in sorted(set(sizes))]

def pseudo_inverse(Tp, k):
    """
    Goes through all the functions and determines which ones
    are associated with k-th pseudo inverse of the function
    specified by input tuple Tp and Hamming diameter k.
    It outputs a list of pseudo-inverse


    EXAMPLES:
    ::
        sage: pseudo_inverse([(0, 0), (1, 0), (2, 1)], 1)
        [[(0, 0), (1, 2), (2, 0)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 2), (2, 1)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 1), (1, 2), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size
    sz=len(Tp)
    # Initialization of the list of functional
    L=TupleFunctionList(sz)
    # Loop going through functions
    RsLt=[]
    for T in L:
        if (Tuple_to_Adjacency(compose_tuple(T,Tp))-Tuple_to_Adjacency([(i, i) for i in rg(sz)])).norm()^2 <= 2*k:
            RsLt.append(T)
    return RsLt

def pseudo_inverse_order(T):
    """
    Determines the largest pseudoinverse order.


    EXAMPLES:
    ::


        sage: sz=3; T=[(0, 1), (1, 2), (2, 0)]; pseudo_inverse_order(T)
        3


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the adjacency matrix
    A = Tuple_to_Adjacency(T)
    # Initialization of the indegree list
    L = [v for v in (A.transpose()*HM(A.nrows(),1,'one')).list() if v==0]
    return len(T)-len(L)

def canonical_pseudo_inverse(Tp):
    """
    Goes through all the permutations and determines which ones
    are associated with canonical pseudo inverse set of the function
    specified by input tuple Tp and Hamming diameter n-pseudoinverse order.
    It outputs a list of pseudo-inverse


    EXAMPLES:
    ::
        sage: sz=4; T=[(Integer(0),Integer(0))]+[(i,i-Integer(1)) for i in rg(1,sz)]; canonical_pseudo_inverse(T)
        [[(0, 0), (1, 2), (2, 3), (3, 1)], [(0, 1), (1, 2), (2, 3), (3, 0)]]
        sage: sz=3; T=[(i,Integer(0)) for i in rg(sz)]; canonical_pseudo_inverse(T)
        [[(0, 0), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 2), (1, 1), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size
    sz=len(Tp)
    # Initialization of the list of functional
    L=PermutationFunctionList(sz)
    # Loop going through functions
    RsLt=[]
    for T in L:
        if (Tuple_to_Adjacency(compose_tuple(T,Tp))-Tuple_to_Adjacency([(i, i) for i in rg(sz)])).norm()^2 <= 2*(sz-pseudo_inverse_order(Tp)):
            RsLt.append(T)
    return RsLt

def semigroup_tree_graceful_map(sz):
    """
    Lists terms wihich describe the mapping from trees
    in the semigroup of function which do not touch the line 
    y=x when x ranges from (0,sz-1] to gracefully labeled trees.


    EXAMPLES:
    ::
        sage: semigroup_tree_graceful_map(5)
        a00*a10*a20*a30*a40*b00*b10*b20*b30*b40 + a00*a10*a20*a31*a40*b00*b20*b21*b30*b40 + a00*a10*a21*a31*a40*b00*b21*b30*b31*b40 + a00*a10*a21*a32*a40*b00*b30*b31*b32*b40


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the variables which track the degree
    X=var_list('x', sz)
    # Initiaization of the hypermatrix
    A=HM(sz, sz, 'a'); B=HM(sz, sz, 'b')
    # Initialization of the identity matrix
    D=HM(2, sz, 'kronecker')
    # Initialization of the functions which never touch the line y=x from bellow
    L=[T+[(sz-1, 0)] for T in DecreasingFunctionList(sz-1)]
    # Initialization of the polynomial construction
    return expand(A[sz-1,0]*B[0,0]*sum(Deter((HM(2,(sum(A[i,T[i][1]]*B[T[i][1]+sz-1-i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))*HM(sz,1,'one')).list(),'diag')+(-1)*sum(A[i,T[i][1]]*B[T[i][1]+sz-1-i,T[i][1]]*(D.slice([T[i][1]+sz-1-i],'col')*D.slice([T[i][1]],'row')+D.slice([T[i][1]],'col')*D.slice([T[i][1]+sz-1-i],'row')) for i in rg(sz))).slice(rg(1,sz),'row').slice(rg(1,sz),'col')) for T in L))

def semigroup_graceful_map(sz):
    """
    Lists terms which describe the mapping from trees
    in the semigroup of function which do not touch the line 
    y=x when x ranges from (0,sz-1] to gracefully labeled
    directed acyclic graphs whose edges are orriented in
    deacreasing order.


    EXAMPLES:
    ::
        sage: semigroup_graceful_map(5)
        a00*a10*a20*a30*a40*b00*b10*b20*b30*b40 + a00*a10*a20*a31*a40*b00*b20*b21*b30*b40 + a00*a10*a21*a30*a40*b00*b10*b30*b31*b40 + a00*a10*a21*a31*a40*b00*b21*b30*b31*b40 + a00*a10*a20*a32*a40*b00*b20*b30*b32*b40 + a00*a10*a21*a32*a40*b00*b30*b31*b32*b40

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the variables which track the degree
    X=var_list('x', sz)
    # Initiaization of the hypermatrix
    A=HM(sz, sz, 'a'); B=HM(sz, sz, 'b')
    # Initialization of the identity matrix
    D=HM(2, sz, 'kronecker')
    # Initialization of the functions which never touch the line y=x from bellow
    L=[T+[(sz-1, 0)] for T in DecreasingFunctionList(sz-1)]
    # Initialization of the polynomial construction
    return expand(A[0,0]*B[sz-1,0]*A[sz-1,0]*B[0,0]*prod(sum(A[i,j]*B[j+sz-1-i,j] for j in rg(i)) for i in rg(1,sz-1))) 

def functionalize_Tree(T, sz):
    """
    Reverses the orientation of edges to obtain a functional
    tree. If the input tuple is such that the edges can not
    be re-orriented to form a functional tree then
    the input is returned unchanged and warning message is
    displayed on screen.


    EXAMPLES:

    ::


        sage: functionalize_Tree([(0, 0), (2, 0), (2, 1), (3, 0), (4, 0)], 5)
        [(0, 0), (2, 0), (3, 0), (1, 2), (4, 0)]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the identity matrix
    Id=identity_matrix(sz)
    if not is_Tree(sum([Id[:,T[j][0]]*Id[T[j][1],:]+Id[:,T[j][1]]*Id[T[j][0],:] for j in rg(sz)])):
        # displaying the warning message  
        raise ValueError("Expected a tree")
    else:
        # Finding the loop edge
        for t in T:
            if t[1]==t[0]:
                break
        # Initialization of the current list of vertices
        Lv=[t[0]]
        Tp=[t]; T.remove(t)
        #for k in rg(sz):
        while len(T)>0:
            for tp in T:
                if tp[0] in Lv:
                    Tp.append((tp[1],tp[0]))
                    Lv.append(tp[1]); T.remove(tp)
                elif tp[1] in Lv:
                    Tp.append(tp)
                    Lv.append(tp[0]); T.remove(tp)
        return Tp

def GracefulPreImageFunctionList(sz):
    """
    Goes through all the functions and determines which ones
    are associated with functions which do not cross the y=x
    axis and map to gracefully labeled connected graphs
    under the edged permutation A[i,j] |-> A[n-1-i+j,i].

    EXAMPLES:
    ::
        sage: GracefulPreImageFunctionList(3)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 0), (1, 0), (2, 1)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 0), (1, 1), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list storing the member of the monoid.
    L=[]
    for Tf in NonIncreasingFunctionList(sz)[0]:
        # Initialization of the Super vertex set
        S = [ Tf[sz-1][1] ]
        # Running the first test of the stoping criteria
        Test=0
        for w in [u for u in rg(sz) if not u in S]:
            for x in S:
                if ((sz-1-w+x, x) in Tf) or ((sz-1-x+w, w) in Tf):
                    Test=1; S.append(w); break; break
        # Main Loop of the algorithm
        while (len(S) < sz) and Test==1:
            Test=0
            # Testing the stoping criteria.
            for w in [u for u in rg(sz) if not u in S]:
                for x in S:
                    if ((sz-1-w+x, x) in Tf) or ((sz-1-x+w, w) in Tf):
                        Test=1; S.append(w); break; break
        if len(S)==sz:
            L.append(Tf)
    return L

def GracefulbidirectedTreeList(sz):
    """
    Uses the Graceful Preimage set to obtain the listing
    of gracefully labeled bi-directed graphs.
    The mapping is obtained using the edged permutation
    A[i, j] |-> A[n-1-i+j, i].


    EXAMPLES:
    ::
        sage: GracefulbidirectedTreeList(3)
        [[(0, 0), (1, 0), (2, 0), (0, 1), (0, 2)],
         [(0, 0), (2, 1), (2, 0), (1, 2), (0, 2)],
         [(1, 1), (1, 0), (2, 0), (0, 1), (0, 2)],
         [(1, 1), (2, 1), (2, 0), (1, 2), (0, 2)],
         [(2, 2), (1, 0), (2, 0), (0, 1), (0, 2)],
         [(2, 2), (2, 1), (2, 0), (1, 2), (0, 2)]]        


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list storing the member of the monoid.
    L=[]
    for Tf in GracefulPreImageFunctionList(sz):
        L.append([(Tf[sz-1][1], Tf[sz-1][1])]+[(i+Tf[sz-1-i][1],Tf[sz-1-i][1]) for i in rg(1,sz)]+[(Tf[sz-1-i][1],i+Tf[sz-1-i][1]) for i in rg(1,sz)])
    return L

def weaving_submatrices(A):
    """
    The fucntion outputs a list of submatrices with
    entries scaled for the weaving construction.
    The input HM must be a square matrix with three
    or more rows.


    EXAMPLES:

    ::


        sage: sz=3; A=HM(sz,sz,'a'); L=weaving_submatrices(A); L[0]
        [[0, 0, 0], [0, 1/2*a11, a12], [0, a21, 1/2*a22]]
        sage: sum(L)
        [[a00, a01, a02], [a10, a11, a12], [a20, a21, a22]]
        

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz = min(A.n(0), A.n(1))
    # Initialization of the output list
    L = []
    for k in rg(sz):
        # Initilization of the output matrix
        Tmp = HM(sz, sz, 'zero')
        for i in rg(sz):
            for j in rg(sz):
                if i != k and j != k:
                    if i==j:
                        Tmp[i,j] = A[i,j]/(sz-1)
                    else:
                        Tmp[i,j] = A[i,j]/(sz-2)
        L.append(Tmp.copy())
    return L

def generate_GL_Fp_script(p, sz):
    """
    Creates a sage file which corresponds to a script
    which computes the members of the general linear
    group over the field of prime order p. It is not
    checked that p is prime. Also sz must be > 2 


    EXAMPLES:

    ::

        sage: generate_GL_Fp_script(2, 3)
        sage: load('GL_F2_3.sage')
        sage: len(Lm)
        168 


    AUTHORS:
    - Edinah K. Gnang
    """
    # Creating the string storing the file name
    filename = 'GL_F'+str(p)+'_'+str(sz)+'.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size\n')
    f.write('sz='+str(sz)+'\n')
    f.write('# Initializing the prime characteristic of the field\n')
    f.write('p='+str(p)+'\n')
    # Writing the variables
    f.write('\n# Initialization of the list which stores the members of our group\n')
    f.write("Lm=[]\n")
    f.write('\n# Initialization of the list of binary lists\n')
    f.write("Li=List_of_Integers([p for i in rg(sz)])\n")
    f.write('\n# Looping through the vector with field elements\n')
    f.write("cnt=0; F=0; L0=List_of_Integers([p for i in rg(sz)])[1:]\n")
    f.write('for l0 in L0:\n')
    f.write('    L1=copy(L0); L1.remove(l0)\n')
    # Begining of the loop
    # Initialization of the indentation space
    spc_indt=''
    for i in rg(1,sz-1):
        # Updateing the space indentation
        spc_indt=spc_indt+'    '
        f.write(spc_indt+'for l'+str(i)+' in L'+str(i)+':\n')
        f.write(spc_indt+'    L'+str(i+1)+'=copy(L'+str(i)+')\n')
        f.write(spc_indt+'    for lc'+str(i+1)+' in List_of_Integers([p for i in rg('+str(i+1)+')])[1:]:\n')
        # Writing the if condition
        f.write(spc_indt+'        if (')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(p).list() in L2:\n')
        f.write(spc_indt+'            L'+str(i+1)+'.remove((')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(p).list())\n')
    # End the loop
    f.write(spc_indt+'    for l'+str(i+1)+' in L'+str(i+1)+':\n')
    f.write(spc_indt+'        # Initializing the matrix representation of the Grassmanian variables\n')
    f.write(spc_indt+'        M=HM(sz,sz,')
    for j in rg(i+1):
        f.write('l'+str(j)+'+')
    f.write('l'+str(i+1)+'); Lm.append(M)\n')
    f.write(spc_indt+'        # Incrementing the counter\n') 
    f.write(spc_indt+'        cnt=cnt+1\n') 
    # Closing the file
    f.close()

def generate_GL_F2_cycle_index_script(sz):
    """
    Creates a sage file which corresponds to a script
    which computes the cycle index of the general linear
    group as a subgroup of the permutation group over
    2^sz elements.


    EXAMPLES:

    ::

        sage: generate_GL_F2_cycle_index_script(3)
        sage: load('Cycle_Index_GL_F2_3.sage')
        At iteration 1 F =  x1^8 + x1^4*x2^2
        At iteration 2 F =  x1^8 + 2*x1^4*x2^2
        At iteration 4 F =  x1^8 + 4*x1^4*x2^2
        At iteration 8 F =  x1^8 + 6*x1^4*x2^2 + 2*x1^2*x2*x4
        At iteration 16 F =  x1^8 + 7*x1^4*x2^2 + 5*x1^2*x3^2 + 4*x1^2*x2*x4
        At iteration 32 F =  x1^8 + 11*x1^4*x2^2 + 13*x1^2*x3^2 + 8*x1^2*x2*x4
        At iteration 64 F =  x1^8 + 13*x1^4*x2^2 + 22*x1^2*x3^2 + 16*x1^2*x2*x4 + 13*x1*x7
        sage: F
        x1^8 + 21*x1^4*x2^2 + 56*x1^2*x3^2 + 42*x1^2*x2*x4 + 48*x1*x7
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Creating the string storing the file name
    filename = 'Cycle_Index_GL_F2_'+str(sz)+'.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x', 2^sz)\n")
    f.write('\n# Initialization of the list of binary lists\n')
    f.write("Li=List_of_Integers([2 for i in rg(sz)])\n")
    f.write('\n# Initialization of the counter for displaying purposes\n')
    f.write("Lcnt=[2^k for k in rg(floor(log(prod(2^sz-2^k for k in rg(sz)),2)))]\n")
    f.write('\n# Looping through the binary vector\n')
    f.write("cnt=0; F=0; L0=List_of_Integers([2 for i in rg(sz)])[1:]\n")
    f.write('for l0 in L0:\n')
    f.write('    L1=copy(L0); L1.remove(l0)\n')
    # Begining of the loop
    # Initialization of the indentation space
    spc_indt=''
    for i in rg(1,sz-1):
        # Updateing the space indentation
        spc_indt=spc_indt+'    '
        f.write(spc_indt+'for l'+str(i)+' in L'+str(i)+':\n')
        f.write(spc_indt+'    L'+str(i+1)+'=copy(L'+str(i)+')\n')
        f.write(spc_indt+'    for lc'+str(i+1)+' in List_of_Integers([2 for i in rg('+str(i+1)+')])[1:]:\n')
        # Writing the if condition
        f.write(spc_indt+'        if (')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(2).list() in L2:\n')
        f.write(spc_indt+'            L'+str(i+1)+'.remove((')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(2).list())\n')
    # End the loop
    f.write(spc_indt+'    for l'+str(i+1)+' in L'+str(i+1)+':\n')
    f.write(spc_indt+'        # Initializing the matrix representation of the Grassmanian variables\n')
    f.write(spc_indt+'        M=HM(sz,sz,')
    for j in rg(i+1):
        f.write('l'+str(j)+'+')
    f.write('l'+str(i+1)+')\n')
    f.write(spc_indt+'        T=[(sum(l[i]*2^i for i in rg(sz)), sum(2^j*Integer(mod((M*HM(sz,1,l))[j,0],2)) for j in rg(sz))) for l in Li]\n') 
    f.write(spc_indt+'        F=F+prod(X[len(l)] for l in FindCycleTupleComponents(T))\n') 
    f.write(spc_indt+'        if cnt in Lcnt:\n') 
    f.write(spc_indt+"            print('At iteration '+str(cnt)+' F = ',F)\n") 
    f.write(spc_indt+'        # Incrementing the counter\n') 
    f.write(spc_indt+'        cnt=cnt+1\n') 
    # Closing the file
    f.close()

def generate_GL_F2_charpoly_index_script(sz):
    """
    Creates a sage file which corresponds to a script
    which computes the cycle index of characteristic general linear
    group as a subgroup of the permutation group over
    2^sz elements.


    EXAMPLES:

    ::

        sage: generate_GL_F2_charpoly_index_script(3)
        sage: load('Charpoly_Index_GL_F2_3.sage')
        At iteration 1 F =  2*y^((x - 1)^3)
        At iteration 2 F =  3*y^((x - 1)^3)
        At iteration 4 F =  5*y^((x - 1)^3)
        At iteration 8 F =  8*y^((x - 1)^3) + y^((x - 1)*x^2 - x + 1)
        At iteration 16 F =  8*y^((x - 1)^3) + 5*y^((x - 1)^2*x - x + 1) + 4*y^((x - 1)*x^2 - x + 1)
        At iteration 32 F =  12*y^((x - 1)^3) + 12*y^((x - 1)^2*x - x + 1) + 8*y^((x - 1)*x^2 - x + 1) + y^(x^3 - 1)
        At iteration 64 F =  16*y^((x - 1)^3) + 19*y^((x - 1)^2*x - x + 1) + y^((x - 1)^2*x - x - 1) + 2*y^((x - 1)^2*x - 2*x + 1) + 3*y^((x - 1)^2*x - 1) + 10*y^((x - 1)*x^2 - x + 1) + 4*y^((x - 1)*x^2 - x - 1) + 2*y^((x - 1)*x^2 - 2*x + 1) + y^((x - 1)*x^2 - 2*x - 1) + 3*y^((x - 1)*x^2 - 1) + 2*y^(x^3 - x - 1) + y^(x^3 - 2*x - 1) + y^(x^3 - 1)
        sage: F
        6*y^((x - 1)^3 - x) + 3*y^((x - 1)^3 - 2*x + 2) + 25*y^((x - 1)^3) + 42*y^((x - 1)^2*x - x + 1) + 6*y^((x - 1)^2*x - x - 1) + 12*y^((x - 1)^2*x - 2*x + 1) + 6*y^((x - 1)^2*x - 1) + 21*y^((x - 1)*x^2 - x + 1) + 12*y^((x - 1)*x^2 - x - 1) + 6*y^((x - 1)*x^2 - 2*x + 1) + 6*y^((x - 1)*x^2 - 2*x - 1) + 3*y^((x - 1)*x^2 - 3*x - 1) + 6*y^((x - 1)*x^2 - 1) + 6*y^(x^3 - x - 1) + 6*y^(x^3 - 2*x - 1) + 2*y^(x^3 - 1)
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Creating the string storing the file name
    filename = 'Charpoly_Index_GL_F2_'+str(sz)+'.sage'
    # Opening the file
    f = open(filename,'w')
    # Writting the size and order parameters
    f.write('# Initializing the size\n')
    f.write('sz='+str(sz)+'\n')
    # Writing the variables
    f.write('\n# Initialization of the vertex variables\n')
    f.write("X=var_list('x', 2^sz)\n")
    f.write("x,y=var('x,y')\n")
    f.write('\n# Initialization of the list of binary lists\n')
    f.write("Li=List_of_Integers([2 for i in rg(sz)])\n")
    f.write('\n# Initialization of the counter for displaying purposes\n')
    f.write("Lcnt=[2^k for k in rg(floor(log(prod(2^sz-2^k for k in rg(sz)),2)))]\n")
    f.write('\n# Looping through the binary vector\n')
    f.write("cnt=0; F=0; L0=List_of_Integers([2 for i in rg(sz)])[1:]\n")
    f.write('for l0 in L0:\n')
    f.write('    L1=copy(L0); L1.remove(l0)\n')
    # Begining of the loop
    # Initialization of the indentation space
    spc_indt=''
    for i in rg(1,sz-1):
        # Updateing the space indentation
        spc_indt=spc_indt+'    '
        f.write(spc_indt+'for l'+str(i)+' in L'+str(i)+':\n')
        f.write(spc_indt+'    L'+str(i+1)+'=copy(L'+str(i)+')\n')
        f.write(spc_indt+'    for lc'+str(i+1)+' in List_of_Integers([2 for i in rg('+str(i+1)+')])[1:]:\n')
        # Writing the if condition
        f.write(spc_indt+'        if (')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(2).list() in L2:\n')
        f.write(spc_indt+'            L'+str(i+1)+'.remove((')
        for j in rg(i):
            f.write('lc'+str(i+1)+'['+str(j)+']*HM(sz,1,l'+str(j)+')+')
        f.write('lc'+str(i+1)+'['+str(i)+']*HM(sz,1,l'+str(i)+')).mod(2).list())\n')
    # End the loop
    f.write(spc_indt+'    for l'+str(i+1)+' in L'+str(i+1)+':\n')
    f.write(spc_indt+'        # Initializing the matrix representation of the Grassmanian variables\n')
    f.write(spc_indt+'        M=HM(sz,sz,')
    for j in rg(i+1):
        f.write('l'+str(j)+'+')
    f.write('l'+str(i+1)+')\n')
    f.write(spc_indt+'        F=F+y^expand(Deter(x*HM(2,sz,"kronecker")-M))\n') 
    f.write(spc_indt+'        if cnt in Lcnt:\n') 
    f.write(spc_indt+"            print('At iteration '+str(cnt)+' F = ',F)\n") 
    f.write(spc_indt+'        # Incrementing the counter\n') 
    f.write(spc_indt+'        cnt=cnt+1\n') 
    # Closing the file
    f.close()


def GrL(T):
    """
    Outputs the list of graceful relabling of the input functional
    directed graph T specified in tuple description.


    EXAMPLES:

    ::

        sage: sz=5; GrL([(i,0) for i in rg(sz)])
        [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],  [(0, 4), (1, 4), (2, 4), (3, 4), (4, 4)]]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the number of vertices
    sz = len(T)
    # Shifting the vertex indices to make the sage graph theory package happy
    tp = [(1+T[i][0], 1+T[i][1]) for i in rg(sz)]
    # Initializing the permutations
    P = Permutations(sz); S = SymmetricGroup(sz)
    # Initializing the graph
    grph = Tuple2DiGraph(tp,sz+1)
    # Initializing the automorphism group
    AutGrp = grph.automorphism_group()
    # Initializing representatives of Left coset as strings
    Lcst = [CstL[0] for CstL in S.cosets(AutGrp)]
    # Initializing the output list
    Lf = []
    # Looping through the coset representatives
    for p in Lcst:
        if Set([abs(p.dict()[tp[i][1]] - p.dict()[tp[i][0]]) for i in rg(sz)]) == Set(rg(sz)):
            Lf.append([(p.dict()[tp[i][0]]-1, p.dict()[tp[i][1]]-1) for i in rg(sz)])
    return Lf

def HaL(T):
    """
    Outputs the list of harmonious relabling of the input functional
    directed graph T specified in tuple description.


    EXAMPLES:

    ::

        sage: sz=5; HaL([(i,0) for i in rg(sz)])
        [[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],
         [(1, 1), (0, 1), (2, 1), (3, 1), (4, 1)],
         [(2, 2), (0, 2), (1, 2), (3, 2), (4, 2)],
         [(3, 3), (0, 3), (1, 3), (2, 3), (4, 3)],
         [(4, 4), (0, 4), (1, 4), (2, 4), (3, 4)]]
 

    AUTHORS:
    - Edinah K. Gnang
    """
    # Initializing the number of vertices
    sz = len(T)
    # Shifting the vertex indices to make the sage graph theory package happy
    tp = [(1+T[i][0], 1+T[i][1]) for i in rg(sz)]
    # Initializing the permutations
    P = Permutations(sz); S = SymmetricGroup(sz)
    # Initializing the graph
    grph = Tuple2DiGraph(tp,sz+1)
    # Initializing the automorphism group
    AutGrp = grph.automorphism_group()
    # Initializing representatives of Left coset as strings
    Lcst = [CstL[0] for CstL in S.cosets(AutGrp)]
    # Initializing the output list
    Lf = []
    # Looping through the coset representatives
    for p in Lcst:
        if Set([Integer(mod(p.dict()[tp[i][1]] + p.dict()[tp[i][0]], sz)) for i in rg(sz)]) == Set(rg(sz)):
            Lf.append([(p.dict()[tp[i][0]]-1, p.dict()[tp[i][1]]-1) for i in rg(sz)])
    return Lf

def CompostionalPowerList(sz, pwr):
    """
    Return a symbolic listing of tuple description of functions which are compositional
    pwr-th power in (Z_sz)^Z_sz.


    EXAMPLES:
    ::
        sage: sz=3; CompostionalPowerList(sz, 2)
        [[(0, 0), (1, 0), (2, 0)],
         [(0, 0), (1, 1), (2, 1)],
         [(0, 0), (1, 2), (2, 2)],
         [(0, 0), (1, 1), (2, 0)],
         [(0, 1), (1, 1), (2, 1)],
         [(0, 0), (1, 1), (2, 2)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 0), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 1), (2, 2)],
         [(0, 1), (1, 1), (2, 2)],
         [(0, 2), (1, 2), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of functions
    L=TupleFunctionList(sz)
    # Initialization of the list of operands
    Lf=[]
    for Tp in L:
        Tt=compose_tuple_power(Tp, pwr)
        if not Tt in Lf:
            Lf.append(Tt)
    return Lf 

def Embedding(A, B, cor):
    """
    This function takes three inputs. The first input is a hypermatrix A of arbitrary 
    order and size length 2 that is to be embedded into the larger hypermatrix B. 
    The second input is the larger hypermatrix B of side length SZ bigger than 1. 
    The order of B is the same as the order of A. When order is 2, both A and B are matrices.

    The third input is a tuple of two coordinates (a,b) for the embedding. The first 
    coordinate selects the a-th row slice, column slice and depth slice of B, and the 
    second coordinate selects the b-th row slice, column slice and depth slice of B.
    This is similar to the matrix row operations.  

    EXAMPLES:
 
    ::

        sage: sz0=2; sz1=3; A = HM(sz0,sz0,sz0,'a'); B = HM(sz1,sz1,sz1,'b')
        sage: Embedding(A,B,(0,2)).printHM()
        [:, :, 0]=
        [a000 b010 a010]
        [b100 b110 b120]
        [a100 b210 a110]
        <BLANKLINE>
        [:, :, 1]=
        [b001 b011 b021]
        [b101 b111 b121]
        [b201 b211 b221]
        <BLANKLINE>
        [:, :, 2]=
        [a001 b012 a011]
        [b102 b112 b122]
        [a101 b212 a111]


    AUTHORS:
    - Fan Tian and Edinah K. Gnang
    - To Do: Implement the arbitrary order version
    """
    # Initialialization
    if A.order()==B.order() and len(cor)==2:
        Bc=B.copy()
        # Initialization of the order parameter
        od=A.order()
        # Initialization of the index list
        indxL=List_of_Integers([2 for i in rg(od)])
        for l in indxL:
            Bc[tuple([cor[l[i]] for i in rg(od)])]=A[tuple(l)]
        return Bc
    else:
        raise ValueError("Expected orders to match and third input to be a 2-tuple")

def Uncorrelated2x2x2(U,V,W):
    """
    Generates a list of three 2x2x2 hypermatrices whose entries are rational functions
    in the entries of the three input hypermatrices. The input hypermatrices are assumed
    to be symbolic. The product of the output hypermatrices is a Kronecker delta.

    EXAMPLES:

    ::

        sage: [A,B,C]=Uncorrelated2x2x2(U,V,W); Prod(A,B,C).simplify_full()
        [:, :, 0]=
        [1 0]
        [0 0]
        <BLANKLINE>
        [:, :, 1]=
        [0 0]
        [0 1]


    AUTHORS:

    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size and order parameters
    sz=Integer(2); od=Integer(3)
    # Initialization of the Kronecker projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Initialization of the Kronecler delta
    Dlt=sum(DltL)
    # Initialization of the left and right hypermatrix
    Hl=(HM(sz,sz,sz,'one')-Dlt).elementwise_product(ProdB(U,V,W,DltL[0]))
    Hr=(HM(sz,sz,sz,'one')-Dlt).elementwise_product(ProdB(U,V,W,DltL[1])).elementwise_exponent(-1)
    # Initialization of the list of constraints
    EqL=[]
    for i in rg(sz):
        for j in rg(sz):
            for k in rg(sz):
                if i!=j or i!=k or j!=k:
                    EqL.append(Hl.elementwise_product(Hr)[i,j,k]==exp(sqrt(-1)*pi))
    # Formating the constraints
    [A,b]=multiplicativeConstraintFormatorHM(EqL, U.list()+V.list()+W.list())
    # Solving the constraints
    Mv=HM(A.ncols(),1,U.list()+V.list()+W.list())
    Sln=multiplicative_linear_solverHM(A,b,Mv,Mv)
    # Performing the substitutions
    Hu=U.subs(Sln); Hv=V.subs(Sln); Hw=W.subs(Sln)
    # Initializing the product
    Pd=Prod(Hu,Hv,Hw)
    # Updating the third hypermatrix for normalization purposes
    for i in rg(sz):
        Hw[i,0,0]=Hw[i,0,0]/Pd[0,0,0]
        Hw[i,1,1]=Hw[i,1,1]/Pd[1,1,1]
    return [Hu,Hv,Hw]

def SymPoly_leading_term_list(mf, Xv, Pp):
    """
    Takes as inputs a monomial term mf, a list of variables, 
    and a list of primes. The function returns the list of leading
    terms greater or equal to  the input leading term mf which 
    appear as a result of trying to eliminate mf using product 
    of  sum of powers of the variables.


    EXAMPLES:

    ::

        sage: sz=Integer(4); Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp)
        sage: SymPoly_leading_term_list(mf, Xv, Pp)
        [x2*x3^2, x3^3]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the sparsest generators for the ring of symmetric polynomials
    Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+sum(mf.degree(v) for v in Xv))]
    # Initialization of the list storing the desired monomials
    Lm=[mf/mf.subs([Xv[i]==Integer(1) for i in rg(sz)])]
    # Initialization of the while loop update Boolean variable and the running index
    Updt=True; indx=Integer(0)
    while Updt:
        # Initialization of the list which stores new monomials
        Lm_new=[]
        for u in rg(indx,len(Lm)):
            mnm=Lm[u]
            # Initialization of the list storing the monomials
            tmp=expand(prod(Lp[mnm.degree(Xv[i])] for i in rg(sz)))
            # Initialization of the list of leadingterms stricly greater then mnm
            #print('Lm_new=',Lm_new)
            tmpL=[mon/mon.subs([Xv[i]==Integer(1) for i in rg(sz)]) for mon in tmp.operands() \
            if (mon/mon.subs([Xv[i]==Integer(1) for i in rg(sz)])).subs([Xv[i]==Pp[i] for i in rg(sz)]) > \
            (mnm/mnm.subs([Xv[i]==Integer(1) for i in rg(sz)])).subs([Xv[i]==Pp[i] for i in rg(sz)]) and not mon in Lm and not mon in Lm_new]
            # updating the list with newly found terms
            Lm_new=Lm_new+tmpL
            #print('Lm_new=',Lm_new)
        if len(Lm_new)==0:
            # Changing the update variable if no new leading terms are found
            Updt=False
        else:
            # Re-initializing the index past the terms we already processed
            indx=Integer(len(Lm)-1)
            Lm=Lm+[mon for mon in Lm_new if not mon in Lm]
    return Lm

def SymPoly_lead_term_eliminate(mf, Xv, Lm, Pv, Sv):
    """
    Takes as inputs a monomial term mf, a list of variables, 
    a list of monomial terms which are strictly greater then mf
    according to some prime induced orderering, a list of sum of powers
    a list of len(Xv) variables specified by the users to describe the list
    of the variable describing the sum of powers
    a list of  variables describing specified by the user to describe elementary
    symmetric polynomials.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: SymPoly_lead_term_eliminate(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1))
        [p1*p2*y1 + p3*y0,
         [y0 == 1, y1 == -1], 
         [p1 == s1, p2 == s1^2 - 2*s2, p3 == s1^3 - 3*s1*s2 + 3*s3],
         [s1 == x0 + x1 + x2, s2 == x0*x1 + x0*x2 + x1*x2, s3 == x0*x1*x2]]
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: rsLt=SymPoly_lead_term_eliminate(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1))
        sage: rsLt
        [p1^2*p3*y5 + p2*p3*y0 + p2*p3*y1 + p1*p4*y2 + p1*p4*y3 + (p4*s1 - p3*s2 + p2*s3 - p1*s4)*y4,
         [y0 == -y1 + 1/2, y2 == -y3 + 1, y4 == -1, y5 == (-1/2), 0 == 0, 0 == 0],
         [p1 == s1,
          p2 == s1^2 - 2*s2,
          p3 == s1^3 - 3*s1*s2 + 3*s3,
          p4 == s1^4 - 4*s1^2*s2 + 2*s2^2 + 4*s1*s3 - 4*s4],
         [s1 == x0 + x1 + x2 + x3,
          s2 == x0*x1 + x0*x2 + x1*x2 + x0*x3 + x1*x3 + x2*x3,
          s3 == x0*x1*x2 + x0*x1*x3 + x0*x2*x3 + x1*x2*x3,
          s4 == x0*x1*x2*x3]]
        sage: rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2])
        -1/2*(s1^3 - 3*s1*s2 + 3*s3)*s1^2 - 1/2*(s1^3 - 3*s1*s2 + 3*s3)*(s1^2 - 2*s2)*(2*y1 - 1) + (s1^3 - 3*s1*s2 + 3*s3)*(s1^2 - 2*s2)*y1 - (s1^4 - 4*s1^2*s2 + 2*s2^2 + 4*s1*s3 - 4*s4)*s1*(y3 - 1) + (s1^4 - 4*s1^2*s2 + 2*s2^2 + 4*s1*s3 - 4*s4)*s1*y3 - (s1^4 - 4*s1^2*s2 + 2*s2^2 + 4*s1*s3 - 4*s4)*s1 + (s1^3 - 3*s1*s2 + 3*s3)*s2 - (s1^2 - 2*s2)*s3 + s1*s4


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the vector of unknowns
    Y=var_list('y',1+len(Lm))
    #print('Y=',Y)
    # Initialization of the total degree
    td=sum(mf.degree(v) for v in Xv)
    # Initialization of the list of sum of powers
    Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
    # Initialization of the polynomial
    Fn=expand(sum(Y[i]*prod(Lp[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
    #print('Fn=',Fn)
    G=sum(Y[i]*prod(Pv[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
    # Obtaining the system of linear constraints
    CnstrLst=[Fn.coefficient(mnm) for mnm in Lm]+[Fn.coefficient(mf)-1]
    #print('CnstrLst=',CnstrLst)
    # Initialization of the total degree
    [A,b]=ConstraintFormatorIVHM(CnstrLst,Y)
    #A.printHM()
    Sln=linear_solverHM(A, b, HM(A.n(1),1,Y), HM(A.n(1),1,Y))
    # Performing the reduction in degrees
    for d in rg(td):
        if (td-d)>sz:
            G=fast_reduce_no_expand(G,[Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
    # Initialization of the list derived from Girard's identities
    GiL=[Pv[1]==Sv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        GiL.append( Pv[bnd]==bnd*(-1)^bnd*sum( ( factorial(sum(l)-1)/prod(factorial(l[j]) for j in rg(len(l)))) * prod( (-Sv[i])^l[i-1] for i in rg(1,bnd+1) ) for l in eL ) )
    return [G]+[Sln]+[GiL,[Sv[i]==sum(prod(s) for s in Set(Xv).subsets(i)) for i in rg(1,sz+1)]]

def SymPoly_lead_term_eliminateG(mf, Xv, Lm, Pv, Sv, RtL):
    """
    Takes as inputs a monomial term mf, a list of variables, 
    a list of monomial terms which are strictly greater then mf
    according to some prime induced orderering, a list of sum of powers shifted
    by constants a list of len(Xv) variables specified by the users to describe the list
    of the variable describing the sum of powers
    a list of variables describing specified by the user to describe elementary
    symmetric polynomials.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: SymPoly_lead_term_eliminateG(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1), rg(sz))
        [p1*p2*y1 + p3*y0,
         [y0 == -1, y1 == 1],
         [p1 == s1,
          p2 == (s1 + 3)^2 - 2*s2 - 9,
          p3 == (s1 + 3)^3 - 3*(s1 + 3)*(s2 + 2) + 3*s3 - 9],
         [s1 == x0 + x1 + x2 - 3, s2 == x0*x1 + x0*x2 + x1*x2 - 2, s3 == x0*x1*x2]]
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: rsLt=SymPoly_lead_term_eliminateG(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1), rg(sz))
        sage: rsLt
        [p1^2*p3*y5 + p2*p3*y0 + p2*p3*y1 + p1*p4*y2 + p1*p4*y3 + ((p4 + 98)*(s1 + 6) - (p3 + 36)*(s2 + 11) + (p2 + 14)*(s3 + 6) - (p1 + 6)*s4 - 276)*y4,
         [y0 == -y1 - 1/2, y2 == -y3 - 1, y4 == 1, y5 == (1/2), 0 == 0, 0 == 0],
         [p1 == s1,
          p2 == (s1 + 6)^2 - 2*s2 - 36,
          p3 == (s1 + 6)^3 - 3*(s1 + 6)*(s2 + 11) + 3*s3 - 18,
          p4 == (s1 + 6)^4 - 4*(s1 + 6)^2*(s2 + 11) + 2*(s2 + 11)^2 + 4*(s1 + 6)*(s3 + 6) - 4*s4 - 98],
         [s1 == x0 + x1 + x2 + x3 - 6,
          s2 == x0*x1 + x0*x2 + x1*x2 + x0*x3 + x1*x3 + x2*x3 - 11,
          s3 == x0*x1*x2 + x0*x1*x3 + x0*x2*x3 + x1*x2*x3 - 6,
          s4 == x0*x1*x2*x3]]
        sage: rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2])
        1/2*((s1 + 6)^3 - 3*(s1 + 6)*(s2 + 11) + 3*s3 - 18)*s1^2 - 1/2*((s1 + 6)^3 - 3*(s1 + 6)*(s2 + 11) + 3*s3 - 18)*((s1 + 6)^2 - 2*s2 - 36)*(2*y1 + 1) + ((s1 + 6)^3 - 3*(s1 + 6)*(s2 + 11) + 3*s3 - 18)*((s1 + 6)^2 - 2*s2 - 36)*y1 - ((s1 + 6)^4 - 4*(s1 + 6)^2*(s2 + 11) + 2*(s2 + 11)^2 + 4*(s1 + 6)*(s3 + 6) - 4*s4 - 98)*s1*(y3 + 1) + ((s1 + 6)^4 - 4*(s1 + 6)^2*(s2 + 11) + 2*(s2 + 11)^2 + 4*(s1 + 6)*(s3 + 6) - 4*s4 - 98)*s1*y3 + ((s1 + 6)^4 - 4*(s1 + 6)^2*(s2 + 11) + 2*(s2 + 11)^2 + 4*(s1 + 6)*(s3 + 6) - 4*s4)*(s1 + 6) - ((s1 + 6)^3 - 3*(s1 + 6)*(s2 + 11) + 3*s3 + 18)*(s2 + 11) + ((s1 + 6)^2 - 2*s2 - 22)*(s3 + 6) - (s1 + 6)*s4 - 276


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the vector of unknowns
    Y=var_list('y',1+len(Lm))
    #print('Y=',Y)
    # Initialization of the total degree
    td=sum(mf.degree(v) for v in Xv)
    # Initialization of the list of sum of powers
    Lp=[1]+[sum(Xv[i]^j - RtL[i]^j for i in rg(sz)) for j in rg(1,1+td)]
    # Initialization of the polynomial
    Fn=expand(sum(Y[i]*prod(Lp[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
    #print('Fn=',Fn)
    G=sum(Y[i]*prod(Pv[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
    # Obtaining the system of linear constraints
    CnstrLst=[Fn.coefficient(mnm) for mnm in Lm]+[Fn.coefficient(mf)-1]
    #print('CnstrLst=',CnstrLst)
    # Initialization of the total degree
    [A,b]=ConstraintFormatorIVHM(CnstrLst, Y)
    #A.printHM()
    Sln=linear_solverHM(A, b, HM(A.n(1),1,Y), HM(A.n(1),1,Y))
    # Performing the reduction in degrees
    for d in rg(td):
        if (td-d)>sz:
            #G=fast_reduce_no_expand(G, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
            G=fast_reduce_no_expand(G, [Pv[td-d]],[-sum(RtL[u]^(td-d) for u in rg(sz))-sum((-1)^k*(Sv[k]+sum(prod(s) for s in Set(RtL).subsets(k)))*(Pv[(td-d)-k]+sum(RtL[u]^((td-d)-k) for u in rg(sz))) for k in rg(1,sz+1))])
    # Initialization of the list derived from Girard's identities
    GiL=[Pv[1]==Sv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        GiL.append( Pv[bnd]==bnd*(-1)^bnd*sum( ( factorial(sum(l)-1)/prod(factorial(l[j]) for j in rg(len(l)))) * prod( (-Sv[i]-sum(prod(s) for s in Set(RtL).subsets(i)))^l[i-1] for i in rg(1,bnd+1) ) for l in eL ) - sum(RtL[u]^bnd for u in rg(sz)))
    return [G]+[Sln]+[GiL,[Sv[i]==sum(prod(s) for s in Set(Xv).subsets(i)) - sum(prod(s) for s in Set(RtL).subsets(i)) for i in rg(1,sz+1)]]

def SymPoly_lead_term_eliminateII(mf, Xv, Lm, Pv, Sv):
    """
    Takes as inputs a monomial term mf, a list of variables, 
    a list of monomial terms which are strictly greater then mf
    according to some prime induced orderering, a list of sum of powers
    a list of len(Xv) variables specified by the users to describe the list
    of the variable describing the sum of powers
    a list of  variables describing specified by the user to describe elementary
    symmetric polynomials.


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: SymPoly_lead_term_eliminateII(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1))
        [p1*p2*y1 + p3*y0,
         [y0 == 1, y1 == -1],
         [s1 == p1, s2 == 1/2*p1^2 - 1/2*p2, s3 == 1/6*p1^3 - 1/2*p1*p2 + 1/3*p3],
         [p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3]]
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: rsLt=SymPoly_lead_term_eliminateII(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1))
        sage: rsLt
        [p1^2*p3*y5 + p1*p4*y0 + p1*p4*y1 + p2*p3*y2 + p2*p3*y3 + (p4*s1 - p3*s2 + p2*s3 - p1*s4)*y4,
         [y0 == -y1 + 1, y2 == -y3 + 1/2, y4 == -1, y5 == (-1/2), 0 == 0, 0 == 0],
         [s1 == p1,
          s2 == 1/2*p1^2 - 1/2*p2,
          s3 == 1/6*p1^3 - 1/2*p1*p2 + 1/3*p3,
          s4 == 1/24*p1^4 - 1/4*p1^2*p2 + 1/8*p2^2 + 1/3*p1*p3 - 1/4*p4],
         [p1 == x0 + x1 + x2 + x3,
          p2 == x0^2 + x1^2 + x2^2 + x3^2,
          p3 == x0^3 + x1^3 + x2^3 + x3^3,
          p4 == x0^4 + x1^4 + x2^4 + x3^4]]
        sage: rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2])
        -1/2*p1^2*p3 - p1*p4*(y1 - 1) + p1*p4*y1 - 1/2*p2*p3*(2*y3 - 1) + p2*p3*y3 + 1/24*(p1^4 - 6*p1^2*p2 + 3*p2^2 + 8*p1*p3 - 6*p4)*p1 - 1/6*(p1^3 - 3*p1*p2 + 2*p3)*p2 + 1/2*(p1^2 - p2)*p3 - p1*p4


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the vector of unknowns
    Y=var_list('y',1+len(Lm))
    #print('Y=',Y)
    # Initialization of the total degree
    td=sum(mf.degree(v) for v in Xv)
    # Initialization of the list of sum of powers
    Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
    # Initialization of the polynomial
    Fn=expand(sum(Y[i]*prod(Lp[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
    #print('Fn=',Fn)
    G=sum(Y[i]*prod(Pv[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
    # Obtaining the system of linear constraints
    CnstrLst=[Fn.coefficient(mnm) for mnm in Lm]+[Fn.coefficient(mf)-1]
    #print('CnstrLst=',CnstrLst)
    # Initialization of the total degree
    [A,b]=ConstraintFormatorIVHM(CnstrLst, Y)
    #A.printHM()
    Sln=linear_solverHM(A, b, HM(A.n(1),1,Y), HM(A.n(1),1,Y))
    # Performing the reduction in degrees
    for d in rg(td):
        if (td-d)>sz:
            G=fast_reduce_no_expand(G, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
    # Initialization of the list derived from Newton's identities
    NwL=[Sv[1]==Pv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        NwL.append( Sv[bnd]==(-1)^bnd*sum( prod( (-Pv[i])^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
    return [G]+[Sln]+[NwL,[Pv[i]==sum(Xv[j]^i for j in rg(sz)) for i in rg(1,1+sz)]]

def SymPoly_lead_term_eliminateIIG(mf, Xv, Lm, Pv, Sv, RtL):
    """
    Takes as inputs a monomial term mf, a list of variables, 
    a list of monomial terms which are strictly greater then mf
    according to some prime induced orderering, a list of sum of powers
    a list of len(Xv) variables specified by the users to describe the list
    of the variable describing the sum of powers, each shifted by a constant
    a list of  variables describing specified by the user to describe elementary
    symmetric polynomials. Making use of the fact that I know the roots now


    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: SymPoly_lead_term_eliminateIIG(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1), rg(sz))
        [p1*p2*y1 + p3*y0,
         [y0 == -1, y1 == 1],
         [s1 == p1,
          s2 == 1/2*(p1 + 3)^2 - 1/2*p2 - 9/2,
          s3 == 1/6*(p1 + 3)^3 - 1/2*(p1 + 3)*(p2 + 5) + 1/3*p3 + 3],
         [p1 == x0 + x1 + x2 - 3,
          p2 == x0^2 + x1^2 + x2^2 - 5,
          p3 == x0^3 + x1^3 + x2^3 - 9]]
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
        sage: rsLt=SymPoly_lead_term_eliminateIIG(mf, Xv, Lm, [1]+var_list('p', sum(mf.degree(v) for v in Xv),1), [1]+var_list('s', len(Xv),1), rg(sz)); rsLt
        [p1^2*p3*y5 + p2*p3*y0 + p2*p3*y1 + p1*p4*y2 + p1*p4*y3 + ((p4 + 98)*(s1 + 6) - (p3 + 36)*(s2 + 11) + (p2 + 14)*(s3 + 6) - (p1 + 6)*s4 - 276)*y4,
         [y0 == -y1 - 1/2, y2 == -y3 - 1, y4 == 1, y5 == (1/2), 0 == 0, 0 == 0],
         [s1 == p1,
          s2 == 1/2*(p1 + 6)^2 - 1/2*p2 - 18,
          s3 == 1/6*(p1 + 6)^3 - 1/2*(p1 + 6)*(p2 + 14) + 1/3*p3 + 6,
          s4 == 1/24*(p1 + 6)^4 - 1/4*(p1 + 6)^2*(p2 + 14) + 1/8*(p2 + 14)^2 + 1/3*(p1 + 6)*(p3 + 36) - 1/4*p4 - 49/2],
         [p1 == x0 + x1 + x2 + x3 - 6,
          p2 == x0^2 + x1^2 + x2^2 + x3^2 - 14,
          p3 == x0^3 + x1^3 + x2^3 + x3^3 - 36,
          p4 == x0^4 + x1^4 + x2^4 + x3^4 - 98]]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the vector of unknowns
    Y=var_list('y',1+len(Lm))
    #print('Y=',Y)
    # Initialization of the total degree
    td=sum(mf.degree(v) for v in Xv)
    # Initialization of the list of sum of powers
    Lp=[1]+[sum(Xv[i]^j - RtL[i]^j for i in rg(sz)) for j in rg(1,1+td)]
    # Initialization of the polynomial
    Fn=expand(sum(Y[i]*prod(Lp[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
    #print('Fn=',Fn)
    G=sum(Y[i]*prod(Pv[Lm[i].degree(Xv[u])] for u in rg(sz)) for i in rg(len(Lm)))+Y[len(Lm)]*prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
    # Obtaining the system of linear constraints
    CnstrLst=[Fn.coefficient(mnm) for mnm in Lm]+[Fn.coefficient(mf)-1]
    #print('CnstrLst=',CnstrLst)
    # Initialization of the total degree
    [A,b]=ConstraintFormatorIVHM(CnstrLst, Y)
    #A.printHM()
    Sln=linear_solverHM(A, b, HM(A.n(1),1,Y), HM(A.n(1),1,Y))
    # Performing the reduction in degrees
    for d in rg(td):
        if (td-d)>sz:
            #G=fast_reduce_no_expand(G, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
            G=fast_reduce_no_expand(G, [Pv[td-d]],[-sum(RtL[u]^(td-d) for u in rg(sz))-sum((-1)^k*(Sv[k]+sum(prod(s) for s in Set(RtL).subsets(k)))*(Pv[(td-d)-k]+sum(RtL[u]^((td-d)-k) for u in rg(sz))) for k in rg(1,sz+1))])
    # Initialization of the list derived from Newton's identities
    NwL=[Sv[1]==Pv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        #NwL.append( Sv[bnd]==(-1)^bnd*sum( prod( (-Pv[i])^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
        NwL.append( Sv[bnd]==-sum(prod(s) for s in Set(RtL).subsets(bnd))+(-1)^bnd*sum( prod( (-Pv[i]-sum(RtL[u]^i for u in rg(sz)))^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
    return [G]+[Sln]+[NwL,[Pv[i]==sum(Xv[j]^i - j^i for j in rg(sz)) for i in rg(1,1+sz)]]

def SymPoly_Expansion(F, Xv, Pv, Sv):
    """
    Takes as inputs a symmetric polynomial F, a list of variables, and
    outputs the expansion of F as a polynomial in the elementary symmetric polynomials

 
    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_Expansion(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [-2*s1^2 + s1*s2 + 6*s2 - 3*s3,
         [s1 == x0 + x1 + x2, s2 == x0*x1 + x0*x2 + x1*x2, s3 == x0*x1*x2]]
        sage: F-expand((-2*s1^2 + s1*s2 + 6*s2 - 3*s3).subs([s1 == x0 + x1 + x2, s2 == x0*x1 + x0*x2 + x1*x2, s3 == x0*x1*x2]))
        0
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_Expansion(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [4*s1^2*s3 + 2*s1*s2 - 8*s2*s3 - 4*s1*s4 - 6*s3 + 120,
         [s1 == x0 + x1 + x2 + x3,
          s2 == x0*x1 + x0*x2 + x1*x2 + x0*x3 + x1*x3 + x2*x3,
          s3 == x0*x1*x2 + x0*x1*x3 + x0*x2*x3 + x1*x2*x3,
          s4 == x0*x1*x2*x3]]
        sage: F-expand((4*s1^2*s3 + 2*s1*s2 - 8*s2*s3 - 4*s1*s4 - 6*s3 + 120).subs([s1==x0+x1+x2+x3, s2==x0*x1+x0*x2+x1*x2+x0*x3+x1*x3+x2*x3, s3==x0*x1*x2+x0*x1*x3+x0*x2*x3+x1*x2*x3, s4==x0*x1*x2*x3]))
        0


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of th elist of primes for the monomial ordering
    P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
    # Initializing the Polynomial
    Pol = F; rG = 0
    #for cnt in rg(4):
    while not Pol.is_zero():
        # Obtaining the leadind term
        mf=multivariate_leading_term(SR(Pol), Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        #print('mf=',mf); print('Pol=',Pol); print('rG=',rG)
        # Testing to find out id the leading term is a constant
        if mf == SR(1):
            rG=rG+Pol; Pol=SR(0)
        else:
            # Obtaining the list of striclty greater monomials
            Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
            # Testing to find out if no greater leading term is obtained as a result of our construction
            if len(Lm) == 0:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the polynomial constructions i.e. product of Ps
                tmpG=prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
                # Performing the reduction in degrees of the sum of powers
                for d in rg(td):
                    if (td-d)>sz:
                        tmpG=fast_reduce_no_expand(tmpG, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
                # Initialization of Girard's identities
                GiL=[Pv[1]==Sv[1]]
                for bnd in rg(2,sz+1):
                    eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
                    GiL.append( Pv[bnd]==bnd*(-1)^bnd*sum( ( factorial(sum(l)-1)/prod(factorial(l[j]) for j in rg(len(l)))) * prod( (-Sv[i])^l[i-1] for i in rg(1,bnd+1) ) for l in eL ) )
                # Performing the substitution reducing the degree of the sum of powers appearing
                tmpG=tmpG.subs(GiL)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Initialization of the polynomial
                tmp=expand(Pol.coefficient(mf)*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
                #print('[] rG=',rG); print('[] Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [tmp], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=multivariate_division(Pol, [tmp], Xv, Pp)[1]
                #print('[] Pol after = ',Pol)
            else:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Obtaining the list of striclty greater monomials
                Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
                #print('Lm=',Lm)
                # Constructing the symmetric polynomial in the elementary symmetric polynomial
                rsLt=SymPoly_lead_term_eliminate(mf, Xv, Lm, Pv, Sv)
                tmp=expand(rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2]))
                #print('rsLt=',rsLt); print('tmp=',tmp)
                #print('rG before =',rG); print('Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]
                #print('rG after =',rG); print('Pol after = ',Pol)
    return [rG, [Sv[i]==sum(prod(s) for s in Set(Xv).subsets(i)) for i in rg(1,sz+1)]]

def SymPoly_ExpansionII(F, Xv, Pv, Sv):
    """
    Takes as inputs a symmetrix polynomial F, a list of variables, and
    outputs the expansion of f as a polynomial of the sparsest generators
    odf the ring of symmetric polynomials

 
    EXAMPLES:

    ::

        sage: sz=Integer(3); Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_ExpansionII(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [p1^2 + p1*p2 - 3*p2 - p3,
         [p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3]]        
        sage: F-expand((p1^2 + p1*p2 - 3*p2 - p3).subs([p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3]))  
        0
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_ExpansionII(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [-1/6*p1^5 + 5/3*p1^3*p2 - 5/2*p1*p2^2 - 4/3*p1^2*p3 + 2*p1*p2 + 4/3*p2*p3 + p1*p4 - 2*p3 + 120,
         [p1 == x0 + x1 + x2 + x3,
          p2 == x0^2 + x1^2 + x2^2 + x3^2,
          p3 == x0^3 + x1^3 + x2^3 + x3^3,
          p4 == x0^4 + x1^4 + x2^4 + x3^4]]
        sage: F-expand((-1/6*p1^5 + 5/3*p1^3*p2 - 5/2*p1*p2^2 - 4/3*p1^2*p3 + 2*p1*p2 + 4/3*p2*p3 + p1*p4 - 2*p3 + 120).subs(p1==x0+x1+x2+x3, p2==x0^2+x1^2+x2^2+x3^2, p3==x0^3+x1^3+x2^3+x3^3, p4==x0^4+x1^4+x2^4+x3^4))
        0
        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: F=-expand(prod(Xv[j]-Xv[i] for j in rg(sz) for i in rg(sz) if i<j)^2) # Vandermonde square 
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_ExpansionII(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [1/6*p1^6 - 3/2*p1^4*p2 + 7/2*p1^2*p2^2 + 4/3*p1^3*p3 - 1/2*p2^3 - 6*p1*p2*p3 + 3*p3^2,
         [p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3]]
        sage: F-expand((1/6*p1^6 - 3/2*p1^4*p2 + 7/2*p1^2*p2^2 + 4/3*p1^3*p3 - 1/2*p2^3 - 6*p1*p2*p3 + 3*p3^2).subs(p1==x0+x1+x2, p2==x0^2+x1^2+x2^2, p3==x0^3+x1^3+x2^3, p4==x0^4+x1^4+x2^4))
        0
        sage: sz=3; Xv=var_list('x',sz,1); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=prod(Xv[i]^(i+1) for i in rg(sz))
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in TupleFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: expand(SymPoly_ExpansionII(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))[0])
        p1*p2*p3
        sage: sz=3; A=HM(sz,sz,'a'); Xv=A.slice([1],1).list(); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: F=Per(VandermondeHM(A.slice([1],1)))
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: SymPoly_ExpansionII(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1))
        [p1*p2 - p3,
         [p1 == a01 + a11 + a21,
          p2 == a01^2 + a11^2 + a21^2,
          p3 == a01^3 + a11^3 + a21^3]]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of th elist of primes for the monomial ordering
    P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
    # Initializing the Polynomial
    Pol = F; rG = 0
    #for cnt in rg(4):
    while not Pol.is_zero():
        # Obtaining the leadind term
        mf=multivariate_leading_term(SR(Pol), Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        #print('mf=',mf); print('Pol=',Pol); print('rG=',rG)
        # Testing to find out id the leading term is a constant
        if mf == SR(1):
            rG=rG+Pol; Pol=SR(0)
        else:
            # Obtaining the list of striclty greater monomials
            Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
            # Testing to find out if no greater leading term is obtained as a result of our construction
            if len(Lm) == 0:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the polynomial constructions i.e. product of Ps
                tmpG=prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
                # Performing the reduction in degrees of the sum of powers
                for d in rg(td):
                    if (td-d)>sz:
                        tmpG=fast_reduce_no_expand(tmpG, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
                # Initialization of Girard's identities
                NwL=[Sv[1]==Pv[1]]
                for bnd in rg(2,sz+1):
                    eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
                    NwL.append( Sv[bnd]==(-1)^bnd*sum( prod( (-Pv[i])^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
                # Performing the substitution reducing the degree of the sum of powers appearing
                tmpG=tmpG.subs(NwL)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Initialization of the polynomial 
                tmp=expand(Pol.coefficient(mf)*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
                #print('[] rG=',rG); print('[] Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [tmp], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=multivariate_division(Pol, [tmp], Xv, Pp)[1]
                #print('[] Pol after = ',Pol)
            else:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Obtaining the list of striclty greater monomials
                Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
                #print('Lm=',Lm)
                # Constructing the symmetric polynomial in the elementary symmetric polynomial
                rsLt=SymPoly_lead_term_eliminateII(mf, Xv, Lm, Pv, Sv)
                tmp=expand(rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2]))
                #print('rsLt=',rsLt); print('tmp=',tmp)
                #print('rG before =',rG); print('Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]
                #print('rG after =',rG); print('Pol after = ',Pol)
    return [rG, [Pv[i]==sum(Xv[j]^i for j in rg(sz)) for i in rg(1,1+sz)]]

def SymPoly_ExpansionIIG(F, Xv, Pv, Sv, RtL):
    """
    Takes as inputs a symmetrix polynomial F, a list of variables, and
    outputs the expansion of f as a polynomial of the sparsest generators
    odf the ring of symmetric polynomials. Each generator is shifted by a
    constant

 
    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] 
        sage: f=Xv[1]*Xv[2]^2 - Xv[1]^2 + Xv[1]*Xv[2] # Initial non-symmetric polynomial 
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: rsLt=SymPoly_ExpansionIIG(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1), rg(sz))); rsLt
        [p1^2 + p1*p2 + 11*p1 - p3,
         [p1 == x0 + x1 + x2 - 3,
          p2 == x0^2 + x1^2 + x2^2 - 5,
          p3 == x0^3 + x1^3 + x2^3 - 9]] 
        sage: F-expand((p1^2 + p1*p2 + 11*p1 - p3).subs([p1 == x0 + x1 + x2-3, p2 == x0^2 + x1^2 + x2^2-5, p3 == x0^3 + x1^3 + x2^3-9]))  
        0
        sage: sz=4; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: f=Xv[0]*Xv[1]^3*Xv[3] + Xv[1]^2*Xv[2] + Xv[0]*Xv[2]^3*Xv[3] + 5
        sage: F=sum(f.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in PermutationFunctionList(sz)) # Symmetrized polynomial
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: rsLt=SymPoly_ExpansionIIG(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1), rg(sz)); rsLt
        [-1/6*p1^5 - 5*p1^4 + 5/3*p1^3*p2 - 110/3*p1^3 + 30*p1^2*p2 - 5/2*p1*p2^2 - 4/3*p1^2*p3 + 12*p1^2 + 112*p1*p2 - 15*p2^2 - 16*p1*p3 + 4/3*p2*p3 + p1*p4 + 500*p1 - 94/3*p3 + 6*p4 + 552,
         [p1 == x0 + x1 + x2 + x3 - 6,
          p2 == x0^2 + x1^2 + x2^2 + x3^2 - 14,
          p3 == x0^3 + x1^3 + x2^3 + x3^3 - 36,
          p4 == x0^4 + x1^4 + x2^4 + x3^4 - 98]]
        sage: F-expand(rsLt[0].subs(rsLt[1]))
        0
        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: F=expand(prod(Xv[j]-Xv[i] for j in rg(sz) for i in rg(sz) if i<j)^2) # determinant of the Vandermonde square 
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: rsLt=SymPoly_ExpansionIIG(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1), rg(sz)); rsLt
        [-1/6*p1^6 - 3*p1^5 + 3/2*p1^4*p2 - 91/6*p1^4 + 18*p1^3*p2 - 7/2*p1^2*p2^2 - 4/3*p1^3*p3 - 14*p1^3 + 47*p1^2*p2 - 21*p1*p2^2 + 1/2*p2^3 - 12*p1^2*p3 + 6*p1*p2*p3 + 1/6*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) + 3*p1^2 - 1/2*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 12*p1*p2 - 49/2*p2^2 + (p1 + 3)*(p3 + 9) - 22/3*p1*p3 + 18*p2*p3 - 3*p3^2 - 12*p1 + 10*p2 - 4*p3 - 13,
         [p1 == x0 + x1 + x2 - 3,
          p2 == x0^2 + x1^2 + x2^2 - 5,
          p3 == x0^3 + x1^3 + x2^3 - 9]]
        sage: F-expand(rsLt[0].subs(rsLt[1]))
        0
        sage: sz=3; Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
        sage: F=Per(VandermondeHM(HM(sz, 1, Xv))) # Permanent of the Vandermonde square 
        sage: mf=multivariate_leading_term(F, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        sage: rsLt=SymPoly_ExpansionIIG(F, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1), rg(sz)); rsLt
        [p1*p2 + 5*p1 + 3*p2 - p3 + 6,
         [p1 == x0 + x1 + x2 - 3,
          p2 == x0^2 + x1^2 + x2^2 - 5,
          p3 == x0^3 + x1^3 + x2^3 - 9]]
        sage: F-expand(rsLt[0].subs(rsLt[1]))
        0
        sage: sz=Integer(3); od=Integer(2);X=var_list('x', sz); Y=var_list('y', od); z=var('z');Tf=[(Integer(0), Integer(2)), (Integer(1), Integer(0)), (Integer(2), Integer(1))]
        sage: Af=Tuple_to_Adjacency(Tf); Pf=HM2Poly(Af, Y); Lt=TupleFunctionListII(od, sz); Lb=[]
        sage: for k in rg(sz): # Initialization of the list of matrices associated with edge labels
        ....:     TmpB=HM(sz,sz,'zero')
        ....:     for i in rg(sz):
        ....:         for j in rg(sz):
        ....:             if abs(j-i) == k:
        ....:                 TmpB[i,j]=1
        ....:                     Lb.append(TmpB.copy())
        sage: F=sum((1-sum(Pf.subs([y0==bli([(u,X[u]) for u in rg(sz)],Q[0][1]),\
        ....: y1==bli([(v,X[v]) for v in rg(sz)],Q[1][1])])*Lb[k][Q[0][1],Q[1][1]] for Q in TupleFunctionListII(od, sz)))^2 for k in rg(sz))
        sage: Lc=CosetPolynomialRepresentativeList(F, X) # Initialization of the list of coset representatives
        sage: Fs=prod(F.subs([X[i]==X[T[i][1]] for i in rg(sz)]) for T in Lc) # Performing the symmetrization
        sage: P=Primes(); Pp=[P.unrank(i) for i in rg(sz)] # Initialization of the list of primes for the monomial ordering in the Hardworking Lemma
        sage: mf=multivariate_leading_term(Fr, X, Pp); mf=mf/mf.subs([X[i]==1 for i in rg(sz)]) # Initialization of the leading term
        sage: rsLt=SymPoly_ExpansionIIG(Fr,X,[1]+var_list('p', max(sum(mf.degree(v) for v in X),sz),1), [1]+var_list('s', len(X),1), rg(sz))
        sage: F-expand(rsLt[0].subs(rsLt[1]))
        0
        sage: sz=Integer(3); Xv=var_list('x',sz); P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]; Tf=[(i,0) for i in rg(sz)]
        sage: F=prod((Xv[j]-Xv[i])^2*((Xv[Tf[j][1]]-Xv[j])^2-(Xv[Tf[i][1]]-Xv[i])^2)^2 for i in rg(sz) for j in rg(sz) if i<j)
        sage: Lc=CosetPolynomialRepresentativeList(F, Xv) # Initialization of the list of coset representatives
        sage: Fs=expand(sum(F.subs([Xv[i]==Xv[T[i][1]] for i in rg(sz)]) for T in Lc)) # Performing the additive symmetrization of F
        sage: mf=multivariate_leading_term(Fs, Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)]) # Initialization of the leading term
        sage: rsLt=SymPoly_ExpansionIIG(Fs, Xv, [1]+var_list('p', max(sum(mf.degree(v) for v in Xv),sz),1), [1]+var_list('s', len(Xv),1), rg(sz)); rsLt
        [1/36*p1^18 + 3/2*p1^17 - 3/4*p1^16*p2 + 69/2*p1^16 - 36*p1^15*p2 + 101/12*p1^14*p2^2 + 7/9*p1^15*p3 + 439*p1^15 - 4355/6*p1^14*p2 + 707/2*p1^13*p2^2 - 301/6*p1^12*p2^3 + 35*p1^14*p3 - 35/2*p1^13*p2*p3 + 4355093/1296*p1^14 - 15925/2*p1^13*p2 + 24563/4*p1^12*p2^2 - 1806*p1^11*p2^3 + 667/4*p1^10*p2^4 + 1295/2*p1^13*p3 - 1365/2*p1^12*p2*p3 + 472/3*p1^11*p2^2*p3 + 319/36*p1^12*p3^2 + 1706285/108*p1^13 - 66792523/1296*p1^12*p2 + 57045*p1^11*p2^2 - 26464*p1^10*p2^3 + 10005/2*p1^9*p2^4 - 577/2*p1^8*p2^5 + 6302*p1^12*p3 - 32135/3*p1^11*p2*p3 + 5192*p1^10*p2^2*p3 - 4235/6*p1^9*p2^3*p3 + 319*p1^11*p3^2 - 319/2*p1^10*p2*p3^2 + 117044429/2592*p1^12 - 1605857/8*p1^11*p2 + 44234929/144*p1^10*p2^2 - 408585/2*p1^9*p2^3 + 241285/4*p1^8*p2^4 - 6924*p1^7*p2^5 + 733/4*p1^6*p2^6 + 11095453/324*p1^11*p3 - 86086*p1^10*p2*p3 + 134585/2*p1^9*p2^2*p3 - 38115/2*p1^8*p2^3*p3 + 1575*p1^7*p2^4*p3 + 4466*p1^10*p3^2 - 4785*p1^9*p2*p3^2 + 4305/4*p1^8*p2^2*p3^2 + 160/3*p1^9*p3^3 + 5584163/72*p1^11 - 67313213/144*p1^10*p2 + 70613513/72*p1^9*p2^2 - 130233523/144*p1^8*p2^3 + 381345*p1^7*p2^4 - 134409/2*p1^6*p2^5 + 6597/2*p1^5*p2^6 + 117/2*p1^4*p2^7 + 22049147/216*p1^10*p3 - 121104461/324*p1^9*p2*p3 + 434430*p1^8*p2^2*p3 - 197190*p1^7*p2^3*p3 + 33075*p1^6*p2^4*p3 - 2745/2*p1^5*p2^5*p3 + 30150*p1^9*p3^2 - 53835*p1^8*p2*p3^2 + 25830*p1^7*p2^2*p3^2 - 3225*p1^6*p2^3*p3^2 + 1440*p1^8*p3^3 - 720*p1^7*p2*p3^3 + 1283077/16*p1^10 - 23149453/36*p1^9*p2 + 177245213/96*p1^8*p2^2 - 9420723/4*p1^7*p2^3 + 199477543/144*p1^6*p2^4 - 699219/2*p1^5*p2^5 + 107145/4*p1^4*p2^6 + 702*p1^3*p2^7 - 27*p1^2*p2^8 + 25723105/162*p1^9*p3 - 6896859/8*p1^8*p2*p3 + 8858153/6*p1^7*p2^2*p3 - 997380*p1^6*p2^3*p3 + 526725/2*p1^5*p2^4*p3 - 41175/2*p1^4*p2^5*p3 - 90*p1^3*p2^6*p3 + 10593103/108*p1^8*p3^2 - 277920*p1^7*p2*p3^2 + 222840*p1^6*p2^2*p3^2 - 58050*p1^5*p2^3*p3^2 + 14445/4*p1^4*p2^4*p3^2 + 13680*p1^7*p3^3 - 15120*p1^6*p2*p3^3 + 3240*p1^5*p2^2*p3^3 + 180*p1^6*p3^4 + 29444*p1^9 - 22316263/48*p1^8*p2 + 1931763*p1^7*p2^2 - 251747351/72*p1^6*p2^3 + 5826055/2*p1^5*p2^4 - 50313995/48*p1^4*p2^5 + 122715*p1^3*p2^6 + 2079*p1^2*p2^7 - 162*p1*p2^8 + 9/4*p2^9 + 3302029/24*p1^8*p3 - 6171551/6*p1^7*p2*p3 + 31477409/12*p1^6*p2^2*p3 - 47488715/18*p1^5*p2^3*p3 + 1038690*p1^4*p2^4*p3 - 126225*p1^3*p2^5*p3 - 810*p1^2*p2^6*p3 + 81/2*p1*p2^7*p3 + 1229284/9*p1^7*p3^2 - 17578571/27*p1^6*p2*p3^2 + 844020*p1^5*p2^2*p3^2 - 363150*p1^4*p2^3*p3^2 + 43335*p1^3*p2^4*p3^2 + 81/2*p1^2*p2^5*p3^2 + 51840*p1^6*p3^3 - 103680*p1^5*p2*p3^3 + 48600*p1^4*p2^2*p3^3 - 4860*p1^3*p2^3*p3^3 + 3240*p1^5*p3^4 - 1620*p1^4*p2*p3^4 - 125405/8*p1^8 - 61293/2*p1^7*p2 + 19486945/24*p1^6*p2^2 - 10087413/4*p1^5*p2^3 + 309292145/96*p1^4*p2^4 - 13798025/8*p1^3*p2^5 + 4912387/16*p1^2*p2^6 + 405/2*p1*p2^7 - 567/4*p2^8 + 589955/12*p1^7*p3 - 7369499/12*p1^6*p2*p3 + 13647749/6*p1^5*p2^2*p3 - 14109449/4*p1^4*p2^3*p3 + 76438213/36*p1^3*p2^4*p3 - 394146*p1^2*p2^5*p3 - 2025/2*p1*p2^6*p3 + 243/2*p2^7*p3 + 5011831/54*p1^6*p3^2 - 647380*p1^5*p2*p3^2 + 8553635/6*p1^4*p2^2*p3^2 - 1006020*p1^3*p2^3*p3^2 + 196020*p1^2*p2^4*p3^2 + 243*p1*p2^5*p3^2 - 81/4*p2^6*p3^2 + 4986220/81*p1^5*p3^3 - 252720*p1^4*p2*p3^3 + 218700*p1^3*p2^2*p3^3 - 43740*p1^2*p2^3*p3^3 + 16200*p1^4*p3^4 - 19440*p1^3*p2*p3^4 + 3645*p1^2*p2^2*p3^4 + 324*p1^3*p3^5 + 111063/2*p1^7 - 333697/4*p1^6*p2 + 24522*p1^5*p2^2 - 12408091/24*p1^4*p2^3 + 11135949/8*p1^3*p2^4 - 20647917/16*p1^2*p2^5 + 2926389/8*p1*p2^6 - 29809/16*p2^7 - 27999/2*p1^6*p3 - 724339/12*p1^5*p2*p3 + 752289*p1^4*p2^2*p3 - 35159891/18*p1^3*p2^3*p3 + 15979673/8*p1^2*p2^4*p3 - 7237519/12*p1*p2^5*p3 + 1458*p2^6*p3 + 156587/6*p1^5*p3^2 - 834490/3*p1^4*p2*p3^2 + 2784808/3*p1^3*p2^2*p3^2 - 10701727/9*p1^2*p2^3*p3^2 + 396090*p1*p2^4*p3^2 - 243*p2^5*p3^2 + 787894/27*p1^4*p3^3 - 15352964/81*p1^3*p2*p3^3 + 349920*p1^2*p2^2*p3^3 - 131220*p1*p2^3*p3^3 + 14580*p1^3*p3^4 - 51030*p1^2*p2*p3^4 + 21870*p1*p2^2*p3^4 + 2916*p1^2*p3^5 - 1458*p1*p2*p3^5 + 12897*p1^6 - 548631/2*p1^5*p2 + 2119047/4*p1^4*p2^2 - 714697/2*p1^3*p2^3 + 3812253/16*p1^2*p2^4 - 593007/2*p1*p2^5 + 5366409/32*p2^6 + 59117*p1^5*p3 - 94485*p1^4*p2*p3 + 744737/12*p1^3*p2^2*p3 - 1070499/4*p1^2*p2^3*p3 + 1607690/3*p1*p2^4*p3 - 2775955/8*p2^5*p3 - 19079/4*p1^4*p3^2 - 47284/3*p1^3*p2*p3^2 + 1021559/6*p1^2*p2^2*p3^2 - 383884*p1*p2^3*p3^2 + 10585045/36*p2^4*p3^2 + 381794/81*p1^3*p3^3 - 43684*p1^2*p2*p3^3 + 1180952/9*p1*p2^2*p3^3 - 131220*p2^3*p3^3 + 295133/81*p1^2*p3^4 - 21870*p1*p2*p3^4 + 32805*p2^2*p3^4 + 1458*p1*p3^5 - 4374*p2*p3^5 + 243*p3^6 - 77760*p1^5 + 1170945/4*p1^4*p2 - 316197/2*p1^3*p2^2 - 585937/4*p1^2*p2^3 + 131973*p1*p2^4 - 407001/16*p2^5 - 28371/2*p1^4*p3 - 121005*p1^3*p2*p3 + 453885/2*p1^2*p2^2*p3 - 1452961/12*p1*p2^3*p3 + 159633/8*p2^4*p3 + 24694*p1^3*p3^2 - 250883/6*p1^2*p2*p3^2 + 42363/2*p1*p2^2*p3^2 - 30205/9*p2^3*p3^2 + 3425/9*p1^2*p3^3 - 1474/9*p1*p2*p3^3 + 98/9*p2^2*p3^3 + 140/27*p1*p3^4 - 28/81*p2*p3^4 + 64305*p1^4 - 80838*p1^3*p2 - 266625/2*p1^2*p2^2 + 328617/2*p1*p2^3 - 327829/8*p2^4 - 41592*p1^3*p3 + 182196*p1^2*p2*p3 - 150516*p1*p2^2*p3 + 33374*p2^3*p3 - 25086*p1^2*p3^2 + 25416*p1*p2*p3^2 - 70597/12*p2^2*p3^2 - 1100/3*p1*p3^3 + 955/9*p2*p3^3 - 317/81*p3^4 - 21816*p1^3 - 30726*p1^2*p2 + 102222*p1*p2^2 - 157923/4*p2^3 + 41148*p1^2*p3 - 89172*p1*p2*p3 + 65799/2*p2^2*p3 + 11664*p1*p3^2 - 5709*p2*p3^2 + 114*p3^3 - 7/216*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3)) + 1/648*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3)) - 815/432*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3)) + 6563/72*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 269/24*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 806*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) - 35923/6*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) + 128081/36*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 1/432*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3)) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 815/864*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + 7/72*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 269/8*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + 806*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6563/48*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + 128081/24*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 278659/12*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 35923/2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 34512*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) + 1/648*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3)) - 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3)) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3) + 7/72*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3)) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3) - 269/24*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3) + 815/432*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3)) + 3*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) + (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3)) - 3*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - 6*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3) - 6563/24*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9)) + (((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*((p1 + 3)^2 - p2 - 5) - (2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3))*(p1 + 3) + 128081/36*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3) - 806*(2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9)) + 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) + 2*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9)) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 3*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3))*(p1 + 3))*(p1 + 3) + 35923/2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*((p1 + 3)^2 - p2 - 5) - 2*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) - 2*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9))*(p1 + 3) - 46032*(((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + 278659/6*((((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p1 + 3) - 3*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 6*(p1 + 3)*(p3 + 9))*(p1 + 3) + ((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 3*((p1 + 3)^2 - p2 - 5)*(p3 + 9))*(p1 + 3) + 2592*p1^2 - 46032*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p2 + 5) - 103536*((p1 + 3)^2 - p2 - 5)*(p2 + 5) + 20088*p1*p2 - 19035*p2^2 + 278659/6*((p1 + 3)^3 - 3*(p1 + 3)*(p2 + 5) + 2*p3 + 18)*(p3 + 9) + 138096*((p1 + 3)^2 - p2 - 5)*(p3 + 9) + 207072*(p1 + 3)*(p3 + 9) - 14544*p1*p3 + 15228*p2*p3 - 2076*p3^2 - 10368*p1 + 41040*p2 - 112320*p3 - 835920,
    [p1 == x0 + x1 + x2 - 3,
     p2 == x0^2 + x1^2 + x2^2 - 5,
     p3 == x0^3 + x1^3 + x2^3 - 9]]
    sage: rsLt[0].subs([p1==3,p2==5,p3==9])
    11289600


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of th elist of primes for the monomial ordering
    P=Primes(); Pp=[P.unrank(i) for i in rg(sz)]
    # Initializing the Polynomial
    Pol = F; rG = 0
    #for cnt in rg(4):
    while not Pol.is_zero():
        # Obtaining the leadind term
        mf=multivariate_leading_term(SR(Pol), Xv, Pp); mf=mf/mf.subs([Xv[i]==1 for i in rg(sz)])
        #print('mf=',mf); print('Pol=',Pol); print('rG=',rG)
        # Testing to find out id the leading term is a constant
        if mf == SR(1):
            rG=rG+Pol; Pol=SR(0)
        else:
            # Obtaining the list of striclty greater monomials
            Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
            # Testing to find out if no greater leading term is obtained as a result of our construction
            if len(Lm) == 0:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the polynomial constructions i.e. product of Ps
                tmpG=prod(Pv[mf.degree(Xv[u])] for u in rg(sz))
                # Performing the reduction in degrees of the sum of powers
                for d in rg(td):
                    if (td-d)>sz:
                        #print('before tmpG=',tmpG)
                        #tmpG=fast_reduce_no_expand(tmpG, [Pv[td-d]],[-sum((-1)^k*Sv[k]*Pv[(td-d)-k] for k in rg(1,sz+1))])
                        tmpG=fast_reduce_no_expand(tmpG, [Pv[td-d]],[-sum(RtL[u]^(td-d) for u in rg(sz))-sum((-1)^k*(Sv[k]+sum(prod(s) for s in Set(RtL).subsets(k)))*(Pv[(td-d)-k]+sum(RtL[u]^((td-d)-k) for u in rg(sz))) for k in rg(1,sz+1))])
                        #print('after tmpG=',tmpG)
                # Initialization of Girard's identities
                NwL=[Sv[1]==Pv[1]]
                for bnd in rg(2,sz+1):
                    eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
                    #NwL.append( Sv[bnd]==(-1)^bnd*sum( prod( (-Pv[i])^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
                    NwL.append( Sv[bnd]==-sum(prod(s) for s in Set(RtL).subsets(bnd))+(-1)^bnd*sum( prod( (-Pv[i]-sum(RtL[u]^i for u in rg(sz)))^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
                # Performing the substitution reducing the degree of the sum of powers appearing
                tmpG=tmpG.subs(NwL)
                #print('final tmpG=',tmpG)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j - RtL[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Initialization of the polynomial 
                tmp=expand(Pol.coefficient(mf)*prod(Lp[mf.degree(Xv[u])] for u in rg(sz)))
                #print('[] rG=',rG); print('[] Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [tmp], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmpG
                    Pol=multivariate_division(Pol, [tmp], Xv, Pp)[1]
                #print('[] Pol after = ',Pol)
            else:
                # Initialization of the total degree
                td=sum(mf.degree(v) for v in Xv)
                # Initialization of the list of sum of powers
                Lp=[1]+[sum(Xv[i]^j - RtL[i]^j for i in rg(sz)) for j in rg(1,1+td)]
                # Obtaining the list of striclty greater monomials
                Lm=[mnm for mnm in SymPoly_leading_term_list(mf, Xv, Pp) if not mnm==mf]
                #print('\nLm=', Lm)
                # Constructing the symmetric polynomial in the elementary symmetric polynomial
                rsLt=SymPoly_lead_term_eliminateIIG(mf, Xv, Lm, Pv, Sv, RtL)
                tmp=expand(rsLt[0].subs([eq for eq in rsLt[1] if eq.lhs()!=0]+rsLt[2]))
                #print('rsLt=',rsLt); print('tmp=',tmp)
                #print('rG before =',rG); print('Pol before = ',Pol)
                if Pol==multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=SR(0)
                else:
                    rG=rG+Pol.coefficient(mf)*tmp
                    Pol=multivariate_division(Pol, [expand(Pol.coefficient(mf)*tmp.subs(rsLt[3]))], Xv, Pp)[1]
                #print('rG after =',rG); print('Pol after = ',Pol)
    return [rG, [Pv[i]==sum(Xv[j]^i - RtL[j]^i for j in rg(sz)) for i in rg(1,1+sz)]]

def Newton_Identities(Xv, Pv, Sv):
    """
    Takes as inputs three lists of vraiables  and outputs
    the relation specified by Newton's identities.

 
    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); Pv=[1]+var_list('p', sz, 1); Sv=[1]+var_list('s', sz, 1)
        sage: Newton_Identities(Xv, Pv, Sv)
        [[s1 == p1, s2 == 1/2*p1^2 - 1/2*p2, s3 == 1/6*p1^3 - 1/2*p1*p2 + 1/3*p3],
         [p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3],
         [s1 == x0 + x1 + x2, s2 == x0*x1 + x0*x2 + x1*x2, s3 == x0*x1*x2]]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the list derived from Newton's identities
    NwL=[Sv[1]==Pv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        NwL.append( Sv[bnd]==(-1)^bnd*sum( prod( (-Pv[i])^l[i-1]/(factorial(l[i-1])*i^l[i-1]) for i in rg(1,bnd+1) ) for l in eL ) )
    return [NwL, [Pv[i]==sum(Xv[j]^i for j in rg(sz)) for i in rg(1,1+sz)], [Sv[i]==sum(prod(s) for s in Set(Xv).subsets(i)) for i in rg(1,sz+1)]]

def Girard_Identities(Xv, Pv, Sv):
    """
    Takes as inputs three lists of vraiables  and outputs
    the relation specified by Girard's identities.

 
    EXAMPLES:

    ::

        sage: sz=3; Xv=var_list('x',sz); Pv=[1]+var_list('p', sz, 1); Sv=[1]+var_list('s', sz, 1)
        sage: Girard_Identities(Xv, Pv, Sv)
        [[p1 == s1, p2 == s1^2 - 2*s2, p3 == s1^3 - 3*s1*s2 + 3*s3],
         [p1 == x0 + x1 + x2, p2 == x0^2 + x1^2 + x2^2, p3 == x0^3 + x1^3 + x2^3],
         [s1 == x0 + x1 + x2, s2 == x0*x1 + x0*x2 + x1*x2, s3 == x0*x1*x2]]


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    # Initialization of the size parameter
    sz=Integer(len(Xv))
    # Initialization of the list derived from Girard's identities
    GiL=[Pv[1]==Sv[1]]
    for bnd in rg(2,sz+1):
        eL=[l for l in List_of_Integers([1+floor(bnd/i) for i in rg(1,bnd+1)]) if bnd==sum(l[i]*(i+1) for i in rg(bnd))]
        GiL.append( Pv[bnd]==bnd*(-1)^bnd*sum( ( factorial(sum(l)-1)/prod(factorial(l[j]) for j in rg(len(l)))) * prod( (-Sv[i])^l[i-1] for i in rg(1,bnd+1) ) for l in eL ) )
    return [GiL, [Pv[i]==sum(Xv[j]^i for j in rg(sz)) for i in rg(1,1+sz)], [Sv[i]==sum(prod(s) for s in Set(Xv).subsets(i)) for i in rg(1,sz+1)]]

def Symmetrize(F, Xv, Lg):
    """
    Takes the input polynomial F sums over the permutations of the variables
    in Xv by permutation described as tuple list and stored into the input list
    listed in Lg. If Lg is the whole symmetric group then the method
    output is a symmetric polynomial.

 
    EXAMPLES:

    ::

        sage: sz=Integer(3); Xv=var_list('x',sz); Lg=AlternatingGroupFunctionList(3); F=Xv[0]^0*Xv[1]^1*Xv[2]^2-Xv[0]^0*Xv[2]^1*Xv[1]^2
        sage: Symmetrize(F, Xv, Lg).factor()
        -(x0 - x1)*(x0 - x2)*(x1 - x2)


    AUTHORS:
    - Edinah K. Gnang and Fan Tian
    """
    return sum(F.subs([Xv[i]==Xv[T[i][1]] for i in rg(len(Xv))]) for T in Lg)

def hypermatrix_action_over_F2_conj(sz, od):
    """
    Implements the hypermatrix action on vector spaces
    over the field of two elements. The inputs to the
    function are the size and order parameters. 
    The function outputs the list of representative of
    conjugacy classes of functional directed graphs
    as well as the list of all functional directed graphs
    associated with hypermatrix transforms.
    vertex labels arise from the canonical lexicographic
    map on binary vectors in F2^sz.

 
    EXAMPLES:

    ::

        sage: sz=2; od=2; hypermatrix_action_over_F2_conj(sz, od)[0]
        [[(0, 0), (1, 0), (2, 0), (3, 0)],
         [(0, 0), (1, 1), (2, 0), (3, 1)],
         [(0, 0), (1, 0), (2, 1), (3, 1)],
         [(0, 0), (1, 2), (2, 1), (3, 3)],
         [(0, 0), (1, 3), (2, 1), (3, 2)],
         [(0, 0), (1, 1), (2, 2), (3, 3)]] 


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables
    X=var_list('x',sz)
    # Initialization of Background hypermatrix
    iL=[sz for i in rg(od)]+['a']; A=HM(*iL)
    # Initialization of the list of projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Performing the projectors
    Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]
    # Initialization of the list of transpose of the vectors
    Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]
    # Initialization of the vector
    Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor()
    # Initializing the list of integer lists associated with the hypermatrix choices
    Li=List_of_Integers([2 for i in rg(sz^od)])
    # Initialization of the list of integer lists associated with evaluation points
    Lev=List_of_Integers([2 for i in rg(sz)])
    # Tuple list description of the elements of the transformation monoid
    Lt=[]
    # Looping over the hypermatrix choices
    for al in Li:
        Lt.append([(sum(l[k]*2^k for k in rg(sz)), sum(2^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(2).list()[k] for k in rg(sz))) for l in Lev])
    # Initialization of the list storing the representatives of conjugacy classes of functional digraphs.
    cL=[]
    # Loop perfomring the binning by conjugacy classes.
    for T in Lt:
        nwT=True
        for i in range(len(cL)):
            if Tuple2DiGraph(T,2^sz).is_isomorphic(Tuple2DiGraph(cL[i],2^sz)):
                nwT=False
                break
        if nwT==True:
            cL.append(T)
    return [cL, Lt]

def hypermatrix_action_over_F2(sz, od):
    """
    Implements the hypermatrix action on vector spaces
    over the field of two elements. The inputs to the
    function are the size and order parameters. 
    The function outputs the list of representative of
    of the left right action classes of functional directed
    graphs as well as the list of all functional directed
    graphs associated with hypermatrix transforms.
    vertex labels arise from the canonical lexicographic
    map on binary vectors in F2^sz.

 
    EXAMPLES:

    ::

        sage: sz=Integer(2); od=Integer(2); [cL, Lt]=hypermatrix_action_over_F2(sz, od); cL
        [[[(0, 0), (1, 0), (2, 0), (3, 0)], [0, 0, 0, 4]],
         [[(0, 0), (1, 1), (2, 0), (3, 1)], [0, 0, 2, 2]],
         [[(0, 0), (1, 2), (2, 1), (3, 3)], [1, 1, 1, 1]]]
        sage: Lt=[Lt[i][0] for i in rg(len(Lt))]; A=HM(Integer(2)^sz, Integer(2)^sz, 'a'); F=sum(prod(A[i,T[i][1]] for i in rg(2^sz)) for T in Lt); F
        a00*a10*a20*a30 + a00*a11*a21*a30 + a00*a12*a22*a30 + a00*a13*a23*a30 + a00*a11*a20*a31 + a00*a10*a21*a31 + a00*a13*a22*a31 + a00*a12*a23*a31 + a00*a12*a20*a32 + a00*a13*a21*a32 + a00*a10*a22*a32 + a00*a11*a23*a32 + a00*a13*a20*a33 + a00*a12*a21*a33 + a00*a11*a22*a33 + a00*a10*a23*a33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables
    X=var_list('x',sz)
    # Initialization of Background hypermatrix
    iL=[sz for i in rg(od)]+['a']; A=HM(*iL)
    # Initialization of the list of projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Performing the projectors
    Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]
    # Initialization of the list of transpose of the vectors
    Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]
    # Initialization of the vector
    Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor()
    # Initializing the list of integer lists associated with the hypermatrix choices
    Li=List_of_Integers([2 for i in rg(sz^od)])
    # Initialization of the list of integer lists associated with evaluation points
    Lev=List_of_Integers([2 for i in rg(sz)])
    # Tuple list description of the elements of the transformation monoid
    Lt=[]; LtII=[]
    # Looping over the hypermatrix choices
    for al in Li:
        # Setup for initialization the HM constructor for the purposes of obtaining the indegree sequence
        Lt.append([[(sum(l[k]*2^k for k in rg(sz)), sum(2^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(2).list()[k] for k in rg(sz))) for l in Lev], al, (HM(1,len(Lev),'one')*Tuple_to_Adjacency([(sum(l[k]*2^k for k in rg(sz)), sum(2^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(2).list()[k] for k in rg(sz))) for l in Lev])).list()])
    # Initialization of the list storing the rpresentatives of conjugacy classes of functional digraphs.
    cL=[]
    # Loop perfomring the binning by conjugacy classes.
    for u in rg(len(Lt)):
        # Setting the test Boolean variable for a new class
        nwT=True
        for v in rg(len(cL)):
            # Checking the in-degree sequences
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            indSeqL1=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(cL[v][0])).list(); indSeqL1.sort()
            if indSeqL0 == indSeqL1:
                nwT=False
                break
        if nwT==True:
            # Initialization of the degree sequence
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            cL.append([Lt[u][0], indSeqL0])
    return [cL, Lt]

def hypermatrix_action_over_Fp(p, sz, od):
    """
    Implements the hypermatrix action on vector spaces
    over the field with p elements where p is prime. 
    The inputs to the function are the size and order
    parameters.  The function outputs the list of representative
    of the left-right action classes of functional directed
    graphs as well as the list of all functional directed
    graphs associated with hypermatrix transforms.
    vertex labels arise from the canonical lexicographic
    map on binary vectors in Fp^sz.

 
    EXAMPLES:

    ::

        sage: sz=Integer(2); od=Integer(2); [cL, Lt]=hypermatrix_action_over_Fp(2, sz, od); cL
        [[[(0, 0), (1, 0), (2, 0), (3, 0)], [0, 0, 0, 4]],
         [[(0, 0), (1, 1), (2, 0), (3, 1)], [0, 0, 2, 2]],
         [[(0, 0), (1, 2), (2, 1), (3, 3)], [1, 1, 1, 1]]]
        sage: Lt=[Lt[i][0] for i in rg(len(Lt))]; A=HM(Integer(2)^sz, Integer(2)^sz, 'a'); F=sum(prod(A[i,T[i][1]] for i in rg(2^sz)) for T in Lt); F
        a00*a10*a20*a30 + a00*a11*a21*a30 + a00*a12*a22*a30 + a00*a13*a23*a30 + a00*a11*a20*a31 + a00*a10*a21*a31 + a00*a13*a22*a31 + a00*a12*a23*a31 + a00*a12*a20*a32 + a00*a13*a21*a32 + a00*a10*a22*a32 + a00*a11*a23*a32 + a00*a13*a20*a33 + a00*a12*a21*a33 + a00*a11*a22*a33 + a00*a10*a23*a33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables
    X=var_list('x',sz)
    # Initialization of Background hypermatrix
    iL=[sz for i in rg(od)]+['a']; A=HM(*iL)
    # Initialization of the list of projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Performing the projectors
    Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]
    # Initialization of the list of transpose of the vectors
    Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]
    # Initialization of the vector
    Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor()
    # Initializing the list of integer lists associated with the hypermatrix choices
    Li=List_of_Integers([p for i in rg(sz^od)])
    # Initialization of the list of integer lists associated with evaluation points
    Lev=List_of_Integers([p for i in rg(sz)])
    # Tuple list description of the elements of the transformation monoid
    Lt=[]; LtII=[]
    # Looping over the hypermatrix choices
    for al in Li:
        # Setup for initialization the HM constructor for the purposes of obtaining the indegree sequence
        Lt.append([[(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev], al, (HM(1,len(Lev),'one')*Tuple_to_Adjacency([(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev])).list()])
    # Initialization of the list storing the rpresentatives of conjugacy classes of functional digraphs.
    cL=[]
    # Loop perfomring the binning by conjugacy classes.
    for u in rg(len(Lt)):
        # Setting the test Boolean variable for a new class
        nwT=True
        for v in rg(len(cL)):
            # Checking the in-degree sequences
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            indSeqL1=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(cL[v][0])).list(); indSeqL1.sort()
            if indSeqL0 == indSeqL1:
                nwT=False
                break
        if nwT==True:
            # Initialization of the degree sequence
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            cL.append([Lt[u][0], indSeqL0])
    return [cL, Lt]

def hypermatrix_action_over_FpII(p, sz, od):
    """
    Implements the hypermatrix action on vector spaces
    over the field with p elements where p is prime. 
    The inputs to the function are the size and order
    parameters.  The function outputs the list of distinct
    functional directed graphs as well as the list description 
    hypermatrix transforms, followed by the sorted indegree
    sequence. The vertex labels arise from the canonical
    lexicographic map on binary vectors in Fp^sz.

 
    EXAMPLES:

    ::

        sage: p=Integer(2); sz=Integer(2); od=Integer(3); cL=hypermatrix_action_over_FpII(p, sz, od); cL
        [[[(0, 0), (1, 0), (2, 0), (3, 0)], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4]],
         [[(0, 0), (1, 1), (2, 0), (3, 1)], [1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2]],
         [[(0, 0), (1, 1), (2, 0), (3, 0)], [1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 3]],
         [[(0, 0), (1, 2), (2, 0), (3, 2)], [0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 2, 2]],
         [[(0, 0), (1, 3), (2, 0), (3, 2)], [1, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 0), (3, 3)], [0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 3]],
         [[(0, 0), (1, 1), (2, 0), (3, 2)], [1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 0), (3, 3)], [1, 1, 0, 1, 1, 0, 0, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 2), (2, 0), (3, 1)], [0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 3), (2, 0), (3, 1)], [1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 1), (3, 1)], [0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 2, 2]],
         [[(0, 0), (1, 1), (2, 1), (3, 0)], [1, 0, 0, 1, 0, 1, 1, 0], [0, 0, 2, 2]],
         [[(0, 0), (1, 0), (2, 1), (3, 2)], [0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 1), (3, 3)], [1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 1), (3, 1)], [1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 1, 3]],
         [[(0, 0), (1, 2), (2, 1), (3, 0)], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 3), (2, 1), (3, 0)], [1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 2), (3, 2)], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 2, 2]],
         [[(0, 0), (1, 1), (2, 2), (3, 3)], [1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1]],
         [[(0, 0), (1, 1), (2, 2), (3, 2)], [1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 2), (2, 2), (3, 0)], [0, 1, 1, 0, 1, 0, 0, 1], [0, 0, 2, 2]],
         [[(0, 0), (1, 3), (2, 2), (3, 0)], [1, 1, 1, 0, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 2), (3, 1)], [0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 2), (3, 0)], [1, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 2), (3, 1)], [1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 2), (2, 2), (3, 3)], [0, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 3), (2, 2), (3, 3)], [1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 2), (3, 0)], [0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 1, 3]],
         [[(0, 0), (1, 0), (2, 2), (3, 3)], [0, 0, 1, 1, 0, 1, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 2), (2, 2), (3, 2)], [0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 1, 3]],
         [[(0, 0), (1, 3), (2, 2), (3, 2)], [1, 1, 1, 1, 1, 1, 0, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 3), (3, 1)], [0, 0, 0, 1, 0, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 3), (3, 0)], [1, 0, 0, 1, 0, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 0), (2, 3), (3, 2)], [0, 1, 0, 1, 0, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 3), (3, 3)], [1, 1, 0, 1, 0, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 1), (2, 3), (3, 1)], [1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 2), (2, 3), (3, 0)], [0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 2]],
         [[(0, 0), (1, 3), (2, 3), (3, 0)], [1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 2]]]
        sage: Lt=[cL[i][0] for i in rg(len(cL))]; A=HM(Integer(2)^sz, Integer(2)^sz, 'a'); F=sum(prod(A[i,T[i][1]] for i in rg(2^sz)) for T in Lt); F
        a00*a10*a20*a30 + a00*a11*a20*a30 + a00*a11*a21*a30 + a00*a12*a21*a30 + a00*a13*a21*a30 + a00*a10*a22*a30 + a00*a11*a22*a30 + a00*a12*a22*a30 + a00*a13*a22*a30 + a00*a11*a23*a30 + a00*a12*a23*a30 + a00*a13*a23*a30 + a00*a11*a20*a31 + a00*a12*a20*a31 + a00*a13*a20*a31 + a00*a10*a21*a31 + a00*a11*a21*a31 + a00*a10*a22*a31 + a00*a11*a22*a31 + a00*a10*a23*a31 + a00*a11*a23*a31 + a00*a11*a20*a32 + a00*a12*a20*a32 + a00*a13*a20*a32 + a00*a10*a21*a32 + a00*a10*a22*a32 + a00*a11*a22*a32 + a00*a12*a22*a32 + a00*a13*a22*a32 + a00*a10*a23*a32 + a00*a10*a20*a33 + a00*a11*a20*a33 + a00*a11*a21*a33 + a00*a10*a22*a33 + a00*a11*a22*a33 + a00*a12*a22*a33 + a00*a13*a22*a33 + a00*a11*a23*a33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables
    X=var_list('x',sz)
    # Initialization of Background hypermatrix
    iL=[sz for i in rg(od)]+['a']; A=HM(*iL)
    # Initialization of the list of projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Performing the projectors
    Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]
    # Initialization of the list of transpose of the vectors
    Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]
    # Initialization of the vector
    Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor()
    # Initializing the list of integer lists associated with the hypermatrix choices
    Li=List_of_Integers([p for i in rg(sz^od)])
    # Initialization of the list of integer lists associated with evaluation points
    Lev=List_of_Integers([p for i in rg(sz)])
    # Tuple list description of the elements of the transformation monoid
    Lt=[]; LtII=[]
    # Looping over the hypermatrix choices
    for al in Li:
        # Setup for initialization the HM constructor for the purposes of obtaining the indegree sequence
        Lt.append([[(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev], al, (HM(1,len(Lev),'one')*Tuple_to_Adjacency([(sum(l[k]*p^k for k in rg(sz)), sum(p^k*Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(p).list()[k] for k in rg(sz))) for l in Lev])).list()])
    # Initialization of the list storing the rpresentatives of conjugacy classes of functional digraphs.
    cL=[]
    # Loop perfomring the binning by conjugacy classes.
    for u in rg(len(Lt)):
        # Setting the test Boolean variable for a new class
        nwT=True
        for v in rg(len(cL)):
            # In-degree sequences
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            indSeqL1=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(cL[v][0])).list(); indSeqL1.sort()
            if Lt[u][0] == cL[v][0]:
                nwT=False
                break
        if nwT==True:
            # Initialization of the degree sequence
            indSeqL0=(HM(1,len(Lev),'one')*Tuple_to_Adjacency(Lt[u][0])).list(); indSeqL0.sort()
            cL.append([Lt[u][0], Lt[u][1], indSeqL0])
    return cL

def hypermatrix_shifted_action_over_F2(sz, od):
    """
    Implements the hypermatrix shifted action on 
    vector spaces over the field of two elements.
    The inputs to the function are the size and
    order parameters. 
    The function outputs the list of representative of
    of the left right action classes of functional directed
    graphs as well as the list of all functional directed
    graphs associated with hypermatrix transforms.
    vertex labels arise from the canonical lexicographic
    map on binary vectors in F2^sz.

 
    EXAMPLES:

    ::

        sage: sz=2; od=2; [cL, Lt]=hypermatrix_shifted_action_over_F2(sz, od); cL
        [[(0, 0), (1, 0), (2, 0), (3, 0)],
         [(0, 0), (1, 1), (2, 0), (3, 1)],
         [(0, 0), (1, 2), (2, 1), (3, 3)]]
        sage: A=HM(Integer(2)^sz, Integer(2)^sz, 'a'); F=sum(prod(A[i,T[i][1]] for i in rg(2^sz)) for T in Lt); F
        a00*a10*a20*a30 + a01*a11*a20*a30 + a02*a12*a20*a30 + a03*a13*a20*a30 + a01*a10*a21*a30 + a00*a11*a21*a30 + a03*a12*a21*a30 + a02*a13*a21*a30 + a02*a10*a22*a30 + a03*a11*a22*a30 + a00*a12*a22*a30 + a01*a13*a22*a30 + a03*a10*a23*a30 + a02*a11*a23*a30 + a01*a12*a23*a30 + a00*a13*a23*a30 + a01*a10*a20*a31 + a00*a11*a20*a31 + a03*a12*a20*a31 + a02*a13*a20*a31 + a00*a10*a21*a31 + a01*a11*a21*a31 + a02*a12*a21*a31 + a03*a13*a21*a31 + a03*a10*a22*a31 + a02*a11*a22*a31 + a01*a12*a22*a31 + a00*a13*a22*a31 + a02*a10*a23*a31 + a03*a11*a23*a31 + a00*a12*a23*a31 + a01*a13*a23*a31 + a02*a10*a20*a32 + a03*a11*a20*a32 + a00*a12*a20*a32 + a01*a13*a20*a32 + a03*a10*a21*a32 + a02*a11*a21*a32 + a01*a12*a21*a32 + a00*a13*a21*a32 + a00*a10*a22*a32 + a01*a11*a22*a32 + a02*a12*a22*a32 + a03*a13*a22*a32 + a01*a10*a23*a32 + a00*a11*a23*a32 + a03*a12*a23*a32 + a02*a13*a23*a32 + a03*a10*a20*a33 + a02*a11*a20*a33 + a01*a12*a20*a33 + a00*a13*a20*a33 + a02*a10*a21*a33 + a03*a11*a21*a33 + a00*a12*a21*a33 + a01*a13*a21*a33 + a01*a10*a22*a33 + a00*a11*a22*a33 + a03*a12*a22*a33 + a02*a13*a22*a33 + a00*a10*a23*a33 + a01*a11*a23*a33 + a02*a12*a23*a33 + a03*a13*a23*a33


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the list of variables
    X=var_list('x',sz)
    # Initialization of Background hypermatrix
    iL=[sz for i in rg(od)]+['a']; A=HM(*iL)
    # Initialization of the list of projectors
    DltL=GeneralHypermatrixKroneckerDeltaL(od,sz)
    # Performing the projectors
    Lh=[ProdB(*([A.transpose(j) for j in rg(od)]+[DltL[i]])) for i in rg(sz)]
    # Initialization of the list of transpose of the vectors
    Lv=[HM(*([sz]+[1 for i in rg(od-1)]+[var_list('x',sz)])) for j in rg(od)]
    # Initialization of the vector
    Y=HM(*([sz]+[1 for i in rg(od-1)]+[[ProdB(*([Lv[i].transpose(i) for i in rg(od-1,-1,-1)]+[Lh[j]])).list()[0] for j in rg(sz)]])).factor()
    # Initializing the list of integer lists associated with the hypermatrix choices
    Li=List_of_Integers([2 for i in rg(sz^od)])
    # Initialization of the list of integer lists associated with evaluation points
    Lev=List_of_Integers([2 for i in rg(sz)])
    # Tuple list description of the elements of the transformation monoid
    Lt=[]
    # Looping over the hypermatrix choices
    for al in Li:
        for ve in Lev:
            Lt.append([(sum(l[k]*2^k for k in rg(sz)), sum(2^k*imod(ve[k]+Y.subs([X[i]==l[i] for i in rg(sz)]).subs([A.list()[i]==al[i] for i in rg(sz^od)]).mod(2).list()[k],2) for k in rg(sz) ) ) for l in Lev])
    # Initialization of the list storing the rpresentatives of conjugacy classes of functional digraphs.
    cL=[]
    # Loop perfomring the binning by conjugacy classes.
    for T in Lt:
        nwT=True
        for i in range(len(cL)):
            # Initialization of the bipartite adjacency matrices
            Aadj=(Tuple_to_Adjacency(T).index_rotation(-pi/2).block_sum(HM(2^sz,2^sz,'zero')).index_rotation(pi/2)).matrix()
            Badj=(Tuple_to_Adjacency(cL[i]).index_rotation(-pi/2).block_sum(HM(2^sz,2^sz,'zero')).index_rotation(pi/2)).matrix()
            if DiGraph(Aadj).is_isomorphic(DiGraph(Badj)):
                nwT=False
                break
        if nwT==True:
            cL.append(T)
    return [cL, Lt]

def CosetRepresentativeList(T):
    """
    The method returns a list of tuples which describe
    representative of left cosets of the automorphism
    group of the functional directed graph of the
    input tuple function


    EXAMPLES:

    ::

        sage: sz=Integer(3); T=[(i, i) for i in rg(sz)]; CosetRepresentativeList(T)
        [[(0, 0), (1, 1), (2, 2)]]
        sage: sz=3; T=[(0,0)]+[(i, i-1) for i in rg(1,sz)]; CosetRepresentativeList(T)
        [[(0, 0), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 2), (1, 1), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=len(T)
    # Shifting the index of the tuple description for the sake of sage's permutations group code
    tp=[(1+T[i][0], 1+T[i][1]) for i in rg(len(T))]
    # Initializing the permutations
    P=Permutations(sz); S=SymmetricGroup(sz)
    # Initializing the graph on sz+1 vertices 0 is isolated
    grph=Tuple2DiGraph(tp, sz+1)
    # Initializing the automorphism group; sage is doing the heavy lifting here
    AutGrp=grph.automorphism_group()
    # Initializing representatives of Left coset as strings
    Lcstr=[CstL[0].cycle_string() for CstL in S.cosets(AutGrp)]
    # Loop storing the coset representative list
    Sn_quot=[]
    for p in P:
        if p.cycle_string() in Lcstr:
            # fixing the permutations index
            Tq=[(i, p[i]-1) for i in rg(sz)]
            Sn_quot.append(Tq)
    return Sn_quot

def tuple_automorphism_group(Tf):
    """
    The method returns a list of tuples which describe
    automorphism group (under action by conjugation) of
    the input tuple Tf


    EXAMPLES:

    ::

        sage: sz=Integer(4); Tf=[(0,0)]+[(i,i-1) for i in rg(1,sz)]
        sage: tuple_automorphism_group(Tf)
        [[(0, 0), (1, 1), (2, 2), (3, 3)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    sz=Integer(len(Tf))
    # Initialization of the list of permutations
    SnL=PermutationFunctionList(sz)
    # Computing the automorphism group
    return [T for T  in SnL if Tf==compose_tuple_list([T,Tf,invert_tuple(T)])]

def automorphism_group(F, X):
    """
    The method returns a list of tuples which describe
    automorphism group of the  input polynomial F in
    in the input variables X


    EXAMPLES:

    ::

        sage: sz=Integer(3); od=Integer(2); X=var_list('x', sz)
        sage: automorphism_group(prod(X[j]-X[i] for i in rg(sz) for j in rg(sz) if i<j), X)
        [[(0, 0), (1, 1), (2, 2)], [(0, 1), (1, 2), (2, 0)], [(0, 2), (1, 0), (2, 1)]]
        sage: sz=Integer(3); od=Integer(2); X=var_list('x', sz)
        sage: automorphism_group(prod(X[j]+X[i] for i in rg(sz) for j in rg(sz) if i<j), X)
        [[(0, 0), (1, 1), (2, 2)],
         [(0, 0), (1, 2), (2, 1)],
         [(0, 1), (1, 0), (2, 2)],
         [(0, 1), (1, 2), (2, 0)],
         [(0, 2), (1, 0), (2, 1)],
         [(0, 2), (1, 1), (2, 0)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(X))
    # Initialization of the list of permutations
    P=Permutations(sz)
    # Computing the automorphism group
    return [[(i,Integer(p[i]-1)) for i in rg(sz)] for p  in P if (F-F.subs([X[i]==X[p[i]-1] for i in rg(sz)])).is_zero()]

def CosetPolynomialRepresentativeList(F, X):
    """
    The method returns a list of tuples which describe
    representative of left cosets of the automorphism
    group of the input polynomial F in the variables
    specified by the second input list X

    EXAMPLES:

    ::

        sage: sz=Integer(3); od=Integer(2); X=var_list('x', sz)
        sage: CosetPolynomialRepresentativeList(prod(X[j]-X[i] for i in rg(sz) for j in rg(sz) if i<j), X)
        [[(0, 0), (1, 1), (2, 2)], [(0, 0), (1, 2), (2, 1)]]
        sage: sz=Integer(3); od=Integer(2); X=var_list('x', sz)
        sage: CosetPolynomialRepresentativeList(prod(X[j]+X[i] for i in rg(sz) for j in rg(sz) if i<j), X)
        [[(0, 0), (1, 1), (2, 2)]]


    AUTHORS:
    - Edinah K. Gnang
    """
    # Initialization of the size parameter
    sz=Integer(len(X))
    # Initialization of the list of permutations
    SnL=PermutationFunctionList(sz)
    # Computing the automorphism group
    GrP=[T for T  in SnL if (F-F.subs([X[i]==X[T[i][1]] for i in rg(sz)])).is_zero()]
    # Initializing the list which stores the coset
    CstL=[[(i, i) for i in rg(sz)]]; RmSt=[T for T in SnL if not T in GrP]
    while len(RmSt)>0:
        Q=copy(RmSt[0]); CstL.append(RmSt[0])
        for T in GrP:
            RmSt.remove(compose_tuple(Q,T))
    return CstL

