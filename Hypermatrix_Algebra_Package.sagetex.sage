## -*- encoding: utf-8 -*-
## This file (Hypermatrix_Algebra_Package.sagetex.sage) was *autogenerated* from Hypermatrix_Algebra_Package.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('Hypermatrix_Algebra_Package', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
 def MatrixGenerate(nr, nc, c):
     """
     Generates a list of lists associated with a symbolic nr x nc
     matrix using the input character c followed by indices.
 
     EXAMPLES:
     ::
         sage: M = MatrixGenerate(2, 2, 'm'); M
         [[m00, m01], [m10, m11]]
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nc
 
     # Test for dimension match
     if n_q_rows > 0 and n_q_cols > 0:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 # Filling up the matrix
                 (q[i]).append(var(c+str(i)+str(j)))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" and "+str(nc)+" must both be non-zero positive integers."
except:
 _st_.goboom(120)
_st_.blockend()
_st_.blockbegin()
try:
 def SymMatrixGenerate(nr, c):
     """
     Generates a list of lists associated with a symbolic nr x nc
     symmetric matrix using the input character c followed by
     indices.
 
     EXAMPLES:
     ::
         sage: M = SymMatrixGenerate(2, 'm'); M
         [[m00, m01], [m10, m11]]
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
 
     # Test for dimension match
     if n_q_rows > 0 and n_q_cols > 0:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 # Filling up the matrix
                 (q[i]).append(var(c+str(min(i,j))+str(max(i,j))))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integers."
except:
 _st_.goboom(157)
_st_.blockend()
try:
 _st_.inline(0, latex(Matrix(SR,MatrixGenerate(2,3,'m'))))
except:
 _st_.goboom(162)
try:
 _st_.inline(1, latex(Matrix(SR,SymMatrixGenerate(2,'m'))))
except:
 _st_.goboom(165)
_st_.blockbegin()
try:
 def HypermatrixGenerate(*args):
     """
     Generates a list of lists associated with a symbolic arbitrary
     hypematrix of order and size specified by the input.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerate(2, 2, 2, 'm'); M
 
      AUTHORS:
     - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
     """
     if len(args) == 1:
         return var(args[0])
     return [apply(\
 HypermatrixGenerate,args[1:-1]+(args[-1]+str(i),)) for i in range(args[0])]
except:
 _st_.goboom(186)
_st_.blockend()
try:
 _st_.inline(2, latex(HypermatrixGenerate(2,2,2,'t')))
except:
 _st_.goboom(191)
_st_.blockbegin()
try:
 def SymHypermatrixGenerate(nr, c):
     """
     Generates a list of lists associated with a symbolic nr x nc x nd
     third order hypematrix using the input character c followed by
     indices.
 
     EXAMPLES:
     ::
         sage: M = SymHypermatrixGenerate(2, 'm'); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
     n_q_dpts = nr
 
     # Test for dimension match
     if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     if i==j or i==k or j==k:
                         (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                     else:
                         if i == min(i,j,k) and k == max(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         elif k == min(i,j,k) and j == max(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         elif i == max(i,j,k) and j == min(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         else:
                             (q[i][j]).append(\
 var(c+str(i+j+k-min(i,j,k)-max(i,j,k))+str(min(i,j,k))+str(max(i,j,k))))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integer."
except:
 _st_.goboom(249)
_st_.blockend()
try:
 _st_.inline(3, latex(SymHypermatrixGenerate(2,'s')))
except:
 _st_.goboom(253)
_st_.blockbegin()
try:
 def HypermatrixVectorize(A):
     """
     Outputs our canonical vectorization of
     the input hypermatrices A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixVectorize(A); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[0])
     n_q_dpts = len(A[0][0])
 
     # Test for dimension match
     if n_q_rows>0 and n_q_cols>0 and n_q_dpts>0:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             for j in range(n_q_cols):
                 for k in range(n_q_dpts):
                     q.append(A[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions non zero."
except:
 _st_.goboom(289)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixAdd(A, B):
     """
     Outputs a list of lists corresponding to the sum of
     the two input hypermatrices A, B of the same size
 
     EXAMPLES:
     ::
         sage: M = HypermatrixAdd(A, B); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(B)
     n_q_cols = len(B[0])
     n_q_dpts = len(B[0][0])
 
     # Test for dimension match
     if n_q_rows==len(A) and n_q_cols==len(A[0]) and n_q_dpts==len(A[0][0]):
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     (q[i][j]).append(A[i][j][k]+B[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(333)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixHadamardProduct(A, B):
     """
     Outputs a list of lists associated with the addtion of
     the two input hypermatrices A and B
 
     EXAMPLES:
     ::
         sage: M = HypermatrixHadamardProduct(A, B); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[0])
     n_q_dpts = len(A[0][0])
 
     # Test for dimension match
     if n_q_rows==len(A) and n_q_cols==len(A[0]) and n_q_dpts==len(A[0][0]):
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     (q[i][j]).append(A[i][j][k]*B[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(371)
_st_.blockend()
try:
 _st_.inline(4, latex(HypermatrixAdd(SymHypermatrixGenerate(2,'s'),HypermatrixGenerate(2,2,2,'t'))))
except:
 _st_.goboom(377)
try:
 _st_.inline(5, latex(HypermatrixHadamardProduct(SymHypermatrixGenerate(2,'s'),HypermatrixGenerate(2,2,2,'t'))))
except:
 _st_.goboom(384)
_st_.blockbegin()
try:
 def HypermatrixScale(A, s):
     """
     Outputs a list of lists associated with product of the
     input scalar s with the input hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixScale(A, 3); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[0])
     n_q_dpts = len(A[0][0])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(A[i][j][k]*s)
     return q
except:
 _st_.goboom(419)
_st_.blockend()
try:
 _st_.inline(6, latex(HypermatrixScale(HypermatrixGenerate(2,2,2,'t'),3)))
except:
 _st_.goboom(425)
_st_.blockbegin()
try:
 def HypermatrixEntryExponent(A, s):
     """
     Outputs a list of lists associated with product of the
     scalar s with the hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixEntryExponent(A, 3); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[0])
     n_q_dpts = len(A[0][0])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append((A[i][j][k])^s)
     return q
except:
 _st_.goboom(459)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixEntryExponentB(s, A):
     """
     Outputs a list of lists associated with product of the
     scalar s with the hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixEntryExponentB(3,A); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[0])
     n_q_dpts = len(A[0][0])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(s^(A[i][j][k]))
     return q
except:
 _st_.goboom(493)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixProduct(A, B, C):
     """
     Outputs a list of lists associated with the ternary
     non associative Bhattacharya-Mesner product of the
     input hypermatrices A, B and C.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixProduct(A, B, C); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_a_rows = len(A)
     n_a_cols = len(A[0])
     n_a_dpts = len(A[0][0])
 
     n_b_rows = len(B)
     n_b_cols = len(B[0])
     n_b_dpts = len(B[0][0])
 
     n_c_rows = len(C)
     n_c_cols = len(C[0])
     n_c_dpts = len(C[0][0])
 
     # Test for dimension match
     if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and \
 n_a_cols==n_b_dpts and n_b_dpts==n_c_rows:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_a_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_b_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_c_dpts):
                     (q[i][j]).append(\
 sum([A[i][l][k]*B[i][j][l]*C[l][j][k] for l in range(n_a_cols)]))
         return q
 
     else :
         raise ValueError, "Hypermatrix dimension mismatch."
except:
 _st_.goboom(551)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixProductB(A, B, C, D):
     """
     Outputs a list of lists associated with the ternary
     product the input hypermatrices A, B and C with
     background hypermatrix D.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixProductB(A, B, C, D); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_a_rows = len(A)
     n_a_cols = len(A[0])
     n_a_dpts = len(A[0][0])
 
     n_b_rows = len(B)
     n_b_cols = len(B[0])
     n_b_dpts = len(B[0][0])
 
     n_c_rows = len(C)
     n_c_cols = len(C[0])
     n_c_dpts = len(C[0][0])
 
     n_d_rows = len(D)
     n_d_cols = len(D[0])
     n_d_dpts = len(D[0][0])
 
     # Test for dimension match
     if \
 n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and \
 n_a_cols==n_b_dpts and n_b_dpts==n_c_rows and n_a_cols==n_d_rows and \
 n_a_cols==n_d_cols and n_a_cols==n_d_dpts:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_a_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_b_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_c_dpts):
                     (q[i][j]).append(\
 sum([A[i][l0][k]*B[i][j][l1]*C[l2][j][k]*D[l0][l1][l2] for l0 in range(n_d_rows)\
 for l1 in range(n_d_cols) for l2 in range(n_d_dpts)]))
         return q
 
     else :
         raise ValueError, "Hypermatrix dimension mismatch."
except:
 _st_.goboom(618)
_st_.blockend()
_st_.blockbegin()
try:
 # We put here together the seperate pieces we have implemented above.
 A = HypermatrixGenerate(2, 2, 2, 'a')
 B = HypermatrixGenerate(2, 2, 2, 'b')
 C = HypermatrixGenerate(2, 2, 2, 'c')
 T = HypermatrixGenerate(2, 2, 2, 't')
 P = HypermatrixProduct(A, B, C)
 Q = HypermatrixProductB(A, B, C, T)
except:
 _st_.goboom(630)
_st_.blockend()
try:
 _st_.inline(7, latex(P[0][0][0]))
except:
 _st_.goboom(634)
try:
 _st_.inline(8, latex(sum(((Q[0][0][0]).operands())[0:4])))
except:
 _st_.goboom(639)
try:
 _st_.inline(9, latex(sum(((Q[0][0][0]).operands())[4:8])))
except:
 _st_.goboom(642)
_st_.blockbegin()
try:
 def HypermatrixCyclicPermute(A):
     """
     Outputs a list of lists associated with the hypermatrix
     with entries index cycliclly permuted.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixCyclicPermute(A); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A[0])
     n_q_cols = len(A[0][0])
     n_q_dpts = len(A)
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(A[k][i][j])
     return q
except:
 _st_.goboom(687)
_st_.blockend()
try:
 _st_.inline(10, latex(A))
except:
 _st_.goboom(691)
try:
 _st_.inline(11, latex(HypermatrixCyclicPermute(A)))
except:
 _st_.goboom(695)
_st_.blockbegin()
try:
 def HypermatrixKroneckerDelta(nr):
     """
     Generates a list of lists associated with the nr x nr x nr
     Kronecker Delta hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixKroneckerDelta(2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
     n_q_dpts = nr
 
     # Test for dimension match
     if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     if i==j and i==k:
                         (q[i][j]).append(1)
                     else:
                         (q[i][j]).append(0)
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integer."
except:
 _st_.goboom(746)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixGenerateAllOne(*args):
     """
     Generates a list of lists associated with the nr x nr x nr
     all one hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerateAllOne(2,2,2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if len(args) == 1:
         return [1 for i in range(args[0])]
     return [apply(HypermatrixGenerateAllOne, args[1:] ) for i in range(args[0])]
except:
 _st_.goboom(767)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixGenerateAllZero(*args):
     """
     Generates a list of lists associated with the nr x nr x nr
     all zero hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerateAllZero(2,2,2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if len(args) == 1:
         return [0 for i in range(args[0])]
     return [apply(HypermatrixGenerateAllZero, args[1:] ) for i in range(args[0])]
except:
 _st_.goboom(786)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixPermutation(s):
     """
     Generates a list of lists associated with the permutation
     hypermatrix deduced from sigma.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixPermutation([0,2,1]); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     n = len(s)
     # Setting the dimensions parameters.
     n_q_rows = n
     n_q_cols = n
     n_q_dpts = n
 
     # Test for dimension match
     if n_q_rows > 0 and n_q_cols > 0 and n_q_dpts >0:
         # Initialization of the hypermatrix
         q = []
         T = HypermatrixKroneckerDelta(n)
         U = HypermatrixGenerateAllOne(n,n,n)
         Id= HypermatrixProduct(U,U,T)
         Id= HypermatrixCyclicPermute(Id)
         for i in range(n):
             q.append(Id[s[i]])
         return HypermatrixCyclicPermute(HypermatrixCyclicPermute(q))
 
     else :
         raise ValueError, "Input dimensions "+\
 str(n)+" must be a non-zero positive integer."
except:
 _st_.goboom(839)
_st_.blockend()
_st_.blockbegin()
try:
 # the code writen here is merely to put together the peices we have implemented so far.
 # Generic Symbolic hypermatrix
 A   = HypermatrixGenerateAllZero(3,3,3)
 Tmp = HypermatrixGenerate(3, 3, 3, 'a')
 for i in range(2):
     for j in range(3):
         for k in range(3):
             A[i][j][k]=Tmp[i][j][k]
 
 # Initialization of the hypermatrix and it's cyclic permutations
 P  = HypermatrixPermutation([1,0,2])
 Pt =HypermatrixCyclicPermute(P)
 Ptt=HypermatrixCyclicPermute(HypermatrixCyclicPermute(P))
 
 # Effecting the permutation of ...
 # row slices
 Ar = HypermatrixProduct(Pt,Ptt,A)
 # column slice
 Ac = HypermatrixProduct(A,P,Pt)
 # and depth slices
 Ad = HypermatrixProduct(P,A,Ptt)
except:
 _st_.goboom(866)
_st_.blockend()
try:
 _st_.inline(12, latex(A[0]))
except:
 _st_.goboom(870)
try:
 _st_.inline(13, latex(A[1]))
except:
 _st_.goboom(873)
try:
 _st_.inline(14, latex(P))
except:
 _st_.goboom(878)
try:
 _st_.inline(15, latex(Ar[0]))
except:
 _st_.goboom(883)
try:
 _st_.inline(16, latex(Ar[1]))
except:
 _st_.goboom(886)
try:
 _st_.inline(17, latex(Ac[0]))
except:
 _st_.goboom(891)
try:
 _st_.inline(18, latex(Ac[1]))
except:
 _st_.goboom(894)
try:
 _st_.inline(19, latex(Ad[0]))
except:
 _st_.goboom(899)
try:
 _st_.inline(20, latex(Ad[1]))
except:
 _st_.goboom(902)
_st_.blockbegin()
try:
 def DiagonalHypermatrix(Mtrx):
     """
     Outputs a diagonal third order hypermatrix
     constructed using the input square matrix
     to enforce the symmetry constraint we will
     only take entry from the lower triangular
     part of the input matrix.
 
      EXAMPLES:
     ::
         sage: var('a00, a11, a01')
         sage: Mtrx = Matrix(Sr,[[a00,a01],[a01,a11]])
         sage: d = DiagonalHypermatrix(Mtrx)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initialization of the dimensions
     n = min(Mtrx.nrows(),Mtrx.ncols())
     n_d_rows = n
     n_d_cols = n
     n_d_dpts = n
 
     # Initialization of the identity permutations hypermatrix
     D = HypermatrixPermutation(range(n))
 
     # Filling up the entries of the hypermatrix.
     for i in range(n_d_rows):
         for j in range(n_d_cols):
             for k in range(n_d_dpts):
                 if (D[i][j][k] != 0):
                     D[i][j][k] = Mtrx[min(i,k),max(i,k)]
     return D
except:
 _st_.goboom(950)
_st_.blockend()
_st_.blockbegin()
try:
 # Generating a diagonal hypermatrices
 Mtrx = Matrix(SR,MatrixGenerate(2, 3,"lambda"))
 D  = DiagonalHypermatrix(Mtrx)
 Dt = HypermatrixCyclicPermute(D)
 Dtt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(D))
 Dc = HypermatrixProduct(Dt,Dtt,D)
except:
 _st_.goboom(961)
_st_.blockend()
try:
 _st_.inline(21, latex(D))
except:
 _st_.goboom(964)
try:
 _st_.inline(22, latex(Dc))
except:
 _st_.goboom(968)
try:
 _st_.inline(23, latex(HypermatrixEntryExponent(D,3)))
except:
 _st_.goboom(972)
_st_.blockbegin()
try:
 def Orthogonal2x2x2Hypermatrix(t):
     """
     Outputs an orthogonal third order hypermatrix
     of size 2 by 2 by 2.
 
      EXAMPLES:
     ::
         sage: t=var('t')
         sage: Orthogonal2x2x2Hypermatrix(t)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     return [[[cos(t)^(2/3),sin(t)^(2/3)],[sin(t)^(2/3), cos(t)^(2/3)]],\
 [[-sin(t)^(2/3),cos(t)^(2/3)],[sin(t)^(2/3),sin(t)^(2/3)]]]
except:
 _st_.goboom(993)
_st_.blockend()
_st_.blockbegin()
try:
 def Orthogonal3x3x3Hypermatrix(t1,t2):
     """
     Outputs an orthogonal third order hypermatrix
     of size 3 by 3 by 3.
 
      EXAMPLES:
     ::
         sage: t1,t2=var('t1,t2')
         sage: Orthogonal3x3x3Hypermatrix(t1,t2)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     c1=cos(t1)^(2/3)
     s1=sin(t1)^(2/3)
     c2=cos(t2)^(2/3)
     s2=sin(t2)^(2/3)
     return [[[c1,s1*c2,0],[s1*c2,s1*s2,0],[s1*s2,exp(-I*2*pi/3)*c1,0]],\
 [[s1*s2,c1,exp(-I*2*pi/3)*s1*c2],[exp(I*2*pi/3)*c1,s1*c2,s1*s2],\
 [s1*c2,s1*s2,c1]],[[0,s1*s2,c1],[0,c1,s1*c2],[0,exp(I*2*pi/3)*s1*c2,s1*s2]]]
except:
 _st_.goboom(1017)
_st_.blockend()
_st_.blockbegin()
try:
 theta = var('theta')
 Q  = Orthogonal2x2x2Hypermatrix(theta)
 Qt = HypermatrixCyclicPermute(Q)
 Qtt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(Q))
except:
 _st_.goboom(1025)
_st_.blockend()
try:
 _st_.inline(24, latex(Q))
except:
 _st_.goboom(1029)
try:
 _st_.inline(25, latex(HypermatrixProduct(Q,Qtt,Qt)))
except:
 _st_.goboom(1035)
_st_.blockbegin()
try:
 # Defining the Parametrization Variables
 theta1,theta2=var('theta1,theta2')
 c1=cos(theta1)^(2/3)
 s1=sin(theta1)^(2/3)
 c2=cos(theta2)^(2/3)
 s2=sin(theta2)^(2/3)
 
 # Parametrization of a orthogonal hypermatrix
 U  = Orthogonal3x3x3Hypermatrix(theta1,theta2)
 Ut = HypermatrixCyclicPermute(U)
 Utt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(U))
 UUttUt = HypermatrixProduct(U,Utt,Ut)
 for i in range(3):
     for j in range(3):
         for k in range(3):
             UUttUt[i][j][k] = (UUttUt[i][j][k]).simplify_exp()
except:
 _st_.goboom(1056)
_st_.blockend()
try:
 _st_.inline(26, latex(UUttUt[0][0][0]))
except:
 _st_.goboom(1060)
try:
 _st_.inline(27, latex(UUttUt[1][1][1]))
except:
 _st_.goboom(1063)
try:
 _st_.inline(28, latex(UUttUt[2][2][2]))
except:
 _st_.goboom(1066)
try:
 _st_.inline(29, latex(UUttUt[0][0][1]))
except:
 _st_.goboom(1069)
try:
 _st_.inline(30, latex(UUttUt[0][0][2]))
except:
 _st_.goboom(1072)
try:
 _st_.inline(31, latex(UUttUt[1][1][2]))
except:
 _st_.goboom(1075)
try:
 _st_.inline(32, latex(UUttUt[1][1][0]))
except:
 _st_.goboom(1078)
try:
 _st_.inline(33, latex(UUttUt[2][2][0]))
except:
 _st_.goboom(1081)
try:
 _st_.inline(34, latex(UUttUt[2][2][1]))
except:
 _st_.goboom(1084)
try:
 _st_.inline(35, latex(UUttUt[0][1][2]))
except:
 _st_.goboom(1087)
try:
 _st_.inline(36, latex(UUttUt[1][0][2]))
except:
 _st_.goboom(1090)
_st_.blockbegin()
try:
 def HypermatrixCayleyHamiltonList(A, n):
     """
     Outpts a list of hypermatrices of all product
     composition of order n from which it follows
     that n must be odd.
 
      EXAMPLES:
     ::
         sage: A = HypermatrixGenerate(2,2,2,'a')
         sage: L = HypermatrixCayleyHamiltonList(A,3)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if n == 1:
         return [A]
     else:
         gu = []
         for i in range(1,n,2):
             for j in range(1,n-i,2):
                 gu = gu + [HypermatrixProduct(g1,g2,g3) \
 for g1 in HypermatrixCayleyHamiltonList(A,i) \
 for g2 in HypermatrixCayleyHamiltonList(A,j) \
 for g3 in HypermatrixCayleyHamiltonList(A,n-(i+j))]
         return gu
except:
 _st_.goboom(1124)
_st_.blockend()
_st_.blockbegin()
try:
 # Initializing an orthogonal hypermatrix
 A = Orthogonal2x2x2Hypermatrix(e/pi)
 
 # Initialization of the list
 L = HypermatrixCayleyHamiltonList(A,1)+HypermatrixCayleyHamiltonList(A,3)+\
 HypermatrixCayleyHamiltonList(A,5)+HypermatrixCayleyHamiltonList(A,7)
 
 # Initializing the index variables
 Indx = Set(range(len(L))).subsets(8)
 
 # Initialization of the of the matrix
 M = Matrix(RR,identity_matrix(8,8))
 cnt = 0
 for index in Indx:
     if cnt < 10:
         M = M*Matrix(RR,[HypermatrixVectorize(L[i]) for i in index])
         cnt= cnt+1
     else:
         break
 
 # Defining the Parametrization Variables
 c1=cos(e/pi)^(2/3)
 s1=sin(e/pi)^(2/3)
 c2=cos(pi/e)^(2/3)
 s2=sin(pi/e)^(2/3)
 
 # Defining the unitary hypermatrices
 U=[[[c1,s1*c2,0],[s1*c2,s1*s2,0],[s1*s2, exp(-I*2*pi/3)*c1,0]],\
 [[s1*s2,c1,exp(-I*2*pi/3)*s1*c2],\
 [exp(I*2*pi/3)*c1,s1*c2,s1*s2],[s1*c2,s1*s2,c1]],\
 [[0,s1*s2,c1],[0,c1,s1*c2],[0,exp(I*2*pi/3)*s1*c2,s1*s2]]]
 
 Lu = HypermatrixCayleyHamiltonList(U,1)+HypermatrixCayleyHamiltonList(U,3)+\
 HypermatrixCayleyHamiltonList(U,5)+HypermatrixCayleyHamiltonList(U,7)+\
 HypermatrixCayleyHamiltonList(U,9)
 
 # Initializing the index variables
 Indxu = Set(range(len(Lu))).subsets(27)
 
 # Initialization of the of the matrix
 Mu = Matrix(CC,identity_matrix(27,27))
 cntu = 0
 for index in Indxu:
     if cntu < 5:
         Mu = Mu*Matrix(CC,[HypermatrixVectorize(Lu[i]) for i in index])
         cntu = cntu+1
     else:
         break
except:
 _st_.goboom(1180)
_st_.blockend()
try:
 _st_.inline(37, latex(M.det()))
except:
 _st_.goboom(1183)
try:
 _st_.inline(38, latex(Mu.det()))
except:
 _st_.goboom(1187)
_st_.blockbegin()
try:
 def ConstraintFormator(CnstrLst, VrbLst):
     """
     Takes as input a List of linear constraints
     and a list of variables and outputs matrix
     and the right hand side vector associate
     with the matrix formulation of the constraints.
 
     EXAMPLES:
     ::
         sage: x, y = var('x,y')
         sage: CnstrLst = [x+y==1, x-y==2]
         sage: VrbLst = [x, y]
         sage: [A,b] = ConstraintFormator(CnstrLst, VrbLst)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initializing the Matrix
     A=Matrix(CC,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
     b=vector(CC, [eq.rhs() for eq in CnstrLst]).column()
     for r in range(len(CnstrLst)):
         for c in range(len(VrbLst)):
             A[r,c] = diff((CnstrLst[r]).lhs(),VrbLst[c])
     return [A,b]
 
 def ConstraintFormatorII(CnstrLst, VrbLst):
     """
     Takes as input a List of linear constraints
     and a list of variables and outputs matrix
     and the right hand side vector associate
     with the matrix formulation of the constraints.
 
     EXAMPLES:
     ::
         sage: x, y = var('x,y')
         sage: CnstrLst = [x+y==1, x-y==2]
         sage: VrbLst = [x, y]
         sage: [A,b] = ConstraintFormator(CnstrLst, VrbLst)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initializing the Matrix
     A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
     b=vector(SR, [eq.rhs() for eq in CnstrLst]).column()
     for r in range(len(CnstrLst)):
         for c in range(len(VrbLst)):
             A[r,c] = diff((CnstrLst[r]).lhs(),VrbLst[c])
     return [A,b]
except:
 _st_.goboom(1251)
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixPseudoInversePairs(A,B):
     """
      Outputs the pseudo inverse pairs associated with the input pairs of matrices
 
     EXAMPLES:
     ::
         sage: A1=[[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]]\
 ,[[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]]
         sage: A2=[[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]]\
 ,[[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]]
         sage: [B1,B2]=HypermatrixPseudoInversePairs(A1,A2)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     sz = len(A)
 
     # Initializing the list of linear constraints
     CnstrLst = []
 
     # Initilizing the variable list
     Vrbls  = [var('ln_al'+str(i)+str(j)+str(k)) \
 for i in range(sz) for j in range(sz) for k in range(sz)]+\
 [var('ln_bt'+str(i)+str(j)+str(k)) for i in range(sz) for j in range(sz) \
 for k in range(sz)]
 
     for m in range(sz):
         for p in range(sz):
             for n in range(sz):
                 V=Matrix(CC, sz, sz, [(A[m][k1][k0])*(B[k0][k1][p]) \
 for k0 in range(sz) for k1 in range(sz)]).inverse()
                 CnstrLst=CnstrLst+[\
 var('ln_al'+str(m)+str(n)+str(k1))+var('ln_bt'+str(k1)+str(n)+str(p))==\
 ln(V[k1,n])  for k1 in range(sz)]
     [A,b]=ConstraintFormator(CnstrLst,Vrbls)
 
     # Importing the Numerical Python package
     # for computing the matrix pseudo inverse
     import numpy
 
     sln = matrix(numpy.linalg.pinv(A))*b
     R1 = HypermatrixGenerateAllZero(sz,sz,sz)
     for i in range(sz):
         for j in range(sz):
             for k in range(sz):
                 R1[i][j][k] = exp(sln[i*sz^2+j*sz^1+k*sz^0,0])
     R2 = HypermatrixGenerateAllZero(sz, sz, sz)
     for i in range(sz):
         for j in range(sz):
             for k in range(sz):
                 R2[i][j][k] = exp(sln[sz^3+i*sz^2+j*sz^1+k*sz^0,0])
     return [R1,R2]
except:
 _st_.goboom(1319)
_st_.blockend()
_st_.blockbegin()
try:
 # Building from the example mentioned in the implementation
 # we consider the hypermatrices
 A1=[[[0.1631135370902057,0.11600112072013125],\
 [0.9823708115400902,0.39605960486710756]],\
 [[0.061860929755424676,0.2325542810173995],\
 [0.39111210957450926,0.2019809359102137]]]
 
 A2=[[[0.15508921433883183,0.17820377184410963],\
 [0.48648171594508205,0.01568017636082064]],\
 [[0.8250247759993575,0.1938307874191597],\
 [0.23867299119274843,0.3935578730402869]]]
 
 # Numerical computation of the hypermatrix inverse pairs
 [B1,B2]=HypermatrixPseudoInversePairs(A1,A2)
 
 # To appreciate how good the numerical approximation of the
 # inverse pair is we generate the generic symbolic hypermatrix M
 M0 = HypermatrixGenerate(2,2,2,'m')
 
 # We would want to compare the symbolic hypermatrix M to the product
 M1 = HypermatrixProduct(M0,A1,A2)
 M2 = HypermatrixProduct(M1,B1,B2)
except:
 _st_.goboom(1346)
_st_.blockend()
try:
 _st_.inline(39, latex(M0))
except:
 _st_.goboom(1351)
try:
 _st_.inline(40, latex(((M2[0][0][0]).operands())[0]))
except:
 _st_.goboom(1357)
try:
 _st_.inline(41, latex(((M2[0][0][0]).operands())[1]))
except:
 _st_.goboom(1360)
try:
 _st_.inline(42, latex(((M2[0][0][1]).operands())[0]))
except:
 _st_.goboom(1363)
try:
 _st_.inline(43, latex(((M2[0][0][1]).operands())[1]))
except:
 _st_.goboom(1366)
try:
 _st_.inline(44, latex(((M2[0][1][0]).operands())[0]))
except:
 _st_.goboom(1369)
try:
 _st_.inline(45, latex(((M2[0][1][0]).operands())[1]))
except:
 _st_.goboom(1372)
try:
 _st_.inline(46, latex(((M2[0][1][1]).operands())[0]))
except:
 _st_.goboom(1375)
try:
 _st_.inline(47, latex(((M2[0][1][1]).operands())[1]))
except:
 _st_.goboom(1378)
try:
 _st_.inline(48, latex(((M2[1][0][0]).operands())[0]))
except:
 _st_.goboom(1381)
try:
 _st_.inline(49, latex(((M2[1][0][0]).operands())[1]))
except:
 _st_.goboom(1384)
try:
 _st_.inline(50, latex(((M2[1][0][1]).operands())[0]))
except:
 _st_.goboom(1387)
try:
 _st_.inline(51, latex(((M2[1][0][1]).operands())[0]))
except:
 _st_.goboom(1390)
try:
 _st_.inline(52, latex(((M2[1][1][0]).operands())[0]))
except:
 _st_.goboom(1393)
try:
 _st_.inline(53, latex(((M2[1][1][0]).operands())[1]))
except:
 _st_.goboom(1396)
try:
 _st_.inline(54, latex(((M2[1][1][1]).operands())[0]))
except:
 _st_.goboom(1399)
try:
 _st_.inline(55, latex(((M2[1][1][1]).operands())[1]))
except:
 _st_.goboom(1402)
_st_.blockbegin()
try:
 class HM:
     """HM class"""
     def __init__(self,*args):
 # Single argument class constructor specification.
         if len(args) == 1:
             inp = args[0]
             if type(inp)==type(Matrix(SR,2,1,[var('x'),var('y')])) or \
 type(inp)==type(Matrix(RR,2,1,[1,2])) or type(inp)==type(Matrix(CC,2,1,[1,1])):
                 self.hm=DiagonalHypermatrix(inp)
             elif type(inp) == list:
                 self.hm = inp
             else:
                 raise ValueError, \
 "Expected either a list or and an object of type Matrix"
             return
         # Two or more arguments class constructor
         s = args[-1]
         dims = args[:-1]
         if s == 'one':
             self.hm = apply(HypermatrixGenerateAllOne, dims)
         elif s == 'zero':
             self.hm = apply(HypermatrixGenerateAllZero, dims)
         elif s == 'ortho':
             if len(dims) == 1:
                 self.hm=Orthogonal2x2x2Hypermatrix(dims[0])
             elif len(dims) == 2:
                 self.hm=Orthogonal3x3x3Hypermatrix(dims[0],dims[1])
             else:
                 raise ValueError,\
 "ortho not supported for order %d tensors" % len(dims)
         elif s == 'perm':
             self.hm=HypermatrixPermutation(dims[0])
         elif s == 'kronecker':
             self.hm=HypermatrixKroneckerDelta(dims[0])
         elif s == 'sym':
             if len(dims) == 2:
                 self.hm=SymHypermatrixGenerate(dims[0],dims[1])
             else :
                 raise ValueError,\
 "kronecker not supported for order %d tensors" % len(dims)
         else:
             self.hm=apply(HypermatrixGenerate, args)
 
     def __repr__(self):
         return `self.hm`
 
     def __add__(self, other):
         return GeneralHypermatrixAdd(self,other)
 
     def __neg__(self):
         return GeneralHypermatrixScale(self.hm,-1)
 
     def __sub__(self, other):
         return GeneralHypermatrixAdd(self, GeneralHypermatrixScale(other,-1))
 
     def __mul__(self, other):
         if other.__class__.__name__=='HM':
             return HM(GeneralHypermatrixHadamardProduct(self,other))
         elif other.__class__.__name__=='tuple':
             # This function takes a a list as intput
             l = other
             return GeneralHypermatrixProduct(self,*l)
         else:
             return GeneralHypermatrixScale(self,other)
 
     def __rmul__(self, a):
         return self*a
 
     def __getitem__(self,i):
         if i.__class__.__name__=='tuple':
             tmp = self.hm
             for j in i:
                 tmp = tmp[j]
             return tmp
 
     def __setitem__(self, i, v):
         if   i.__class__.__name__=='tuple':
             tmp = self.hm
             while len(i)>1:
                 tmp = tmp[i[0]]
                 i = i[1:]
             tmp[i[0]] = v
 
     def __call__(self, *inpts):
         # This function takes a a list as intput
         return GeneralHypermatrixProduct(self, *inpts)
 
     def hprod(self,*inpts):
         # This function takes a a list as intput
         return GeneralHypermatrixProduct(self,*inpts)
 
     def hprod3b(self, b, c, t):
         return HM(HypermatrixProductB(self.hm, b.hm, c.hm, t.hm))
 
     def elementwise_product(self,B):
         return GeneralHypermatrixHadamardProduct(self,B)
 
     def elementwise_exponent(self,s):
         return GeneralHypermatrixExponent(self,s)
 
     def elementwise_base_exponent(self,s):
         return GeneralHypermatrixBaseExponent(self,s)
 
     def transpose(self, i=1):
         t = Integer(mod(i, self.order()))
         A = self
         for i in range(t):
             A = GeneralHypermatrixCyclicPermute(A)
         return A
 
     def nrows(self):
         return len(self.hm)
 
     def ncols(self):
         return len(self.hm[0])
 
     def ndpts(self):
         return len(self.hm[0][0])
 
     def n(self,i):
         tmp = self.listHM()
         for j in range(i):
             tmp = tmp[0]
         return len(tmp)
 
     def list(self):
         lst = []
         l = [self.n(i) for i in range(self.order())]
         # Main loop canonicaly listing the elements
         for i in range(prod(l)):
             entry = [mod(i,l[0])]
             sm = Integer(mod(i,l[0]))
             for k in range(len(l)-1):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                 sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
             lst.append(self[tuple(entry)])
         return lst
 
     def listHM(self):
         return self.hm
 
     def cayley_hamilton_list(self,n):
         tmp = HypermatrixCayleyHamiltonList(self.hm,n)
         return [HM(h) for h in tmp]
 
     def cayley_hamilton_mtrx(self,itr,bnd):
         tmp = []
         for i in range(itr):
             tmp = tmp + HypermatrixCayleyHamiltonList(self.hm, 2*i+1)
         return Matrix([HM(h).list() for h in tmp[0:bnd]])
 
     def order(self):
         cnt = 0
         H = self.listHM()
         while type(H) == type([]):
             H = H[0]
             cnt = cnt+1
         return cnt
except:
 _st_.goboom(1573)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixProduct(*args):
     # Initialization of the list specifying the dimensions of the output
     l = [(args[i]).n(i) for i in range(len(args))]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['zero']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the assignement
     for i in range(\
 prod([(args[j]).n(Integer(mod(j+1,len(args)))) for j in range(len(args))])):
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         if len(args)<2:
             raise ValueError, "The number of operands must be >= 2"
         elif len(args) >= 2:
             Rh[tuple(entry)]=sum(\
 [prod([args[s][tuple(entry[0:Integer(mod(s+1,len(args)))]+\
 [t]+entry[Integer(mod(s+2,len(args))):])] for s in range(len(args)-2)]+\
 [args[len(args)-2][tuple(entry[0:len(args)-1]+[t])]]+\
 [args[len(args)-1][tuple([t]+entry[1:])]]) for t in range((args[0]).n(1))])
     return Rh
except:
 _st_.goboom(1604)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixCyclicPermute(A):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     l = l[1:]+[l[0]]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         # Performing the transpose
         Rh[tuple(entry)]=A[tuple([entry[len(entry)-1]]+entry[:len(entry)-1])]
     return Rh
except:
 _st_.goboom(1626)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixScale(A,s):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         # Performing the computation
         Rh[tuple(entry)]=s*A[tuple(entry)]
     return Rh
except:
 _st_.goboom(1646)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixExponent(A,s):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         # Performing computation
         Rh[tuple(entry)]=(A[tuple(entry)])^s
     return Rh
except:
 _st_.goboom(1667)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixBaseExponent(A,s):
 # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         # Performing computation
         Rh[tuple(entry)]=s^(A[tuple(entry)])
     return Rh
except:
 _st_.goboom(1688)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixAdd(A,B):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     s = [B.n(i) for i in range(B.order())]
     # Testing the dimensions
     x = var('x')
     if(sum([l[i]*x^i for i in range(len(l))])==sum(\
 [s[i]*x^i for i in range(len(s))])):
         # Initializing the input for generating a symbolic hypermatrix
         inpts = l+['r']
         # Initialization of the hypermatrix
         Rh = HM(*inpts)
         # Main loop performing the transposition of the entries
         for i in range(prod(l)):
             entry = [mod(i,l[0])]
             sm = Integer(mod(i,l[0]))
             for k in range(len(l)-1):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                 sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
             Rh[tuple(entry)]=A[tuple(entry)]+B[tuple(entry)]
         return Rh
     else:
         raise ValueError,\
 "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(1717)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixHadamardProduct(A,B):
 # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     s = [B.n(i) for i in range(B.order())]
     # Testing the dimensions
     x = var('x')
     if(sum([l[i]*x^i for i in range(len(l))])==sum(\
 [s[i]*x^i for i in range(len(s))])):
         # Initializing the input for generating a symbolic hypermatrix
         inpts = l+['r']
         # Initialization of the hypermatrix
         Rh = HM(*inpts)
         # Main loop performing the transposition of the entries
         for i in range(prod(l)):
             entry = [mod(i,l[0])]
             sm = Integer(mod(i,l[0]))
             for k in range(len(l)-1):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
                 sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
             Rh[tuple(entry)]=A[tuple(entry)]+B[tuple(entry)]
         return Rh
     else:
         raise ValueError,\
 "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(1744)
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralOrthogonalHypermatrix(od):
     # Initializing the hypermatrix
     Q = apply(HM,[2 for i in range(od)]+['q'])
 
     # Initilizing the list of variable
     VrbLst = Q.list()
 
     # Reinitializing of Q by exponentiation
     Q = Q.elementwise_base_exponent(e)
 
     # Computing the product
     Eq = apply(GeneralHypermatrixProduct,[Q.transpose(j) for j in range(od,0,-1)])
 
     # Writting up the constraints
     LeQ = (Set(Eq.list())).list()
 
     # Removing the normalization constraints
     LeQ.remove(e^(od*var('q'+''.join(['0' for i in range(od)])))+\
 e^(od*var('q01'+''.join(['0' for i in range(od-2)]))))
     LeQ.remove( e^(od*var('q10'+''.join(['1' for i in range(od-2)])))+\
 e^(od*var('q'+''.join(['1' for i in range(od)]))))
 
     # Filling up the linear constraints
     CnstrLst= []
     for f in LeQ:
         CnstrLst.append(\
 ln((f.operands())[0]).simplify_exp()-I*pi-ln((f.operands())[1]).simplify_exp()==0)
 
     # Directly solving the constraints
     Sl = solve(CnstrLst,VrbLst)
 
     # Main loop performing the substitution of the entries
     Lr = [var('r'+str(i)) for i in range(1,2^od+1)]
     l = [Q.n(i) for i in range(Q.order())]
     for i in range(prod(l)):
         # Turning the index i into an hypermatrix array location
         # using the decimal encoding trick
         entry = [mod(i,l[0])]
         sm = Integer(mod(i,l[0]))
         for k in range(len(l)-1):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[0:k+1])),l[k+1])))
             sm = sm+prod(l[0:k+1])*entry[len(entry)-1]
         Q[tuple(entry)]=Q[tuple(entry)].subs(\
 dict(map(lambda eq: (eq.lhs(),eq.rhs()), Sl[0]))).simplify_exp()
     return Q
except:
 _st_.goboom(1796)
_st_.blockend()
_st_.endofdoc()
