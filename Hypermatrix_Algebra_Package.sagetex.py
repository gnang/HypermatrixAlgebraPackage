## -*- encoding: utf-8 -*-
# This file was *autogenerated* from the file Hypermatrix_Algebra_Package.sagetex.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_186 = Integer(186); _sage_const_1035 = Integer(1035); _sage_const_618 = Integer(618); _sage_const_0p11600112072013125 = RealNumber('0.11600112072013125'); _sage_const_695 = Integer(695); _sage_const_691 = Integer(691); _sage_const_54 = Integer(54); _sage_const_1573 = Integer(1573); _sage_const_767 = Integer(767); _sage_const_333 = Integer(333); _sage_const_1387 = Integer(1387); _sage_const_1384 = Integer(1384); _sage_const_1029 = Integer(1029); _sage_const_1381 = Integer(1381); _sage_const_1025 = Integer(1025); _sage_const_1626 = Integer(1626); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_19 = Integer(19); _sage_const_18 = Integer(18); _sage_const_459 = Integer(459); _sage_const_993 = Integer(993); _sage_const_1399 = Integer(1399); _sage_const_249 = Integer(249); _sage_const_1390 = Integer(1390); _sage_const_1393 = Integer(1393); _sage_const_883 = Integer(883); _sage_const_0p39605960486710756 = RealNumber('0.39605960486710756'); _sage_const_839 = Integer(839); _sage_const_1251 = Integer(1251); _sage_const_0p39111210957450926 = RealNumber('0.39111210957450926'); _sage_const_0p48648171594508205 = RealNumber('0.48648171594508205'); _sage_const_0p3935578730402869 = RealNumber('0.3935578730402869'); _sage_const_746 = Integer(746); _sage_const_425 = Integer(425); _sage_const_551 = Integer(551); _sage_const_1796 = Integer(1796); _sage_const_886 = Integer(886); _sage_const_1646 = Integer(1646); _sage_const_0p1938307874191597 = RealNumber('0.1938307874191597'); _sage_const_1366 = Integer(1366); _sage_const_253 = Integer(253); _sage_const_44 = Integer(44); _sage_const_1717 = Integer(1717); _sage_const_0p15508921433883183 = RealNumber('0.15508921433883183'); _sage_const_0p061860929755424676 = RealNumber('0.061860929755424676'); _sage_const_120 = Integer(120); _sage_const_1319 = Integer(1319); _sage_const_1090 = Integer(1090); _sage_const_47 = Integer(47); _sage_const_0p1631135370902057 = RealNumber('0.1631135370902057'); _sage_const_1688 = Integer(1688); _sage_const_639 = Integer(639); _sage_const_634 = Integer(634); _sage_const_891 = Integer(891); _sage_const_630 = Integer(630); _sage_const_1056 = Integer(1056); _sage_const_1072 = Integer(1072); _sage_const_1075 = Integer(1075); _sage_const_1078 = Integer(1078); _sage_const_493 = Integer(493); _sage_const_31 = Integer(31); _sage_const_1402 = Integer(1402); _sage_const_0p2325542810173995 = RealNumber('0.2325542810173995'); _sage_const_0p9823708115400902 = RealNumber('0.9823708115400902'); _sage_const_950 = Integer(950); _sage_const_40 = Integer(40); _sage_const_41 = Integer(41); _sage_const_42 = Integer(42); _sage_const_43 = Integer(43); _sage_const_1360 = Integer(1360); _sage_const_45 = Integer(45); _sage_const_46 = Integer(46); _sage_const_1363 = Integer(1363); _sage_const_48 = Integer(48); _sage_const_1084 = Integer(1084); _sage_const_1087 = Integer(1087); _sage_const_1081 = Integer(1081); _sage_const_1369 = Integer(1369); _sage_const_157 = Integer(157); _sage_const_37 = Integer(37); _sage_const_642 = Integer(642); _sage_const_1744 = Integer(1744); _sage_const_1063 = Integer(1063); _sage_const_1060 = Integer(1060); _sage_const_1066 = Integer(1066); _sage_const_377 = Integer(377); _sage_const_1069 = Integer(1069); _sage_const_371 = Integer(371); _sage_const_786 = Integer(786); _sage_const_1667 = Integer(1667); _sage_const_866 = Integer(866); _sage_const_55 = Integer(55); _sage_const_1396 = Integer(1396); _sage_const_53 = Integer(53); _sage_const_52 = Integer(52); _sage_const_51 = Integer(51); _sage_const_50 = Integer(50); _sage_const_1375 = Integer(1375); _sage_const_1372 = Integer(1372); _sage_const_384 = Integer(384); _sage_const_1378 = Integer(1378); _sage_const_0p17820377184410963 = RealNumber('0.17820377184410963'); _sage_const_29 = Integer(29); _sage_const_899 = Integer(899); _sage_const_894 = Integer(894); _sage_const_419 = Integer(419); _sage_const_1017 = Integer(1017); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_1351 = Integer(1351); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_870 = Integer(870); _sage_const_878 = Integer(878); _sage_const_28 = Integer(28); _sage_const_873 = Integer(873); _sage_const_22 = Integer(22); _sage_const_23 = Integer(23); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_26 = Integer(26); _sage_const_27 = Integer(27); _sage_const_24 = Integer(24); _sage_const_25 = Integer(25); _sage_const_972 = Integer(972); _sage_const_1180 = Integer(1180); _sage_const_1183 = Integer(1183); _sage_const_1346 = Integer(1346); _sage_const_0p2019809359102137 = RealNumber('0.2019809359102137'); _sage_const_0p23867299119274843 = RealNumber('0.23867299119274843'); _sage_const_0p8250247759993575 = RealNumber('0.8250247759993575'); _sage_const_49 = Integer(49); _sage_const_191 = Integer(191); _sage_const_1604 = Integer(1604); _sage_const_39 = Integer(39); _sage_const_38 = Integer(38); _sage_const_964 = Integer(964); _sage_const_1187 = Integer(1187); _sage_const_1124 = Integer(1124); _sage_const_961 = Integer(961); _sage_const_687 = Integer(687); _sage_const_30 = Integer(30); _sage_const_33 = Integer(33); _sage_const_32 = Integer(32); _sage_const_35 = Integer(35); _sage_const_34 = Integer(34); _sage_const_968 = Integer(968); _sage_const_36 = Integer(36); _sage_const_289 = Integer(289); _sage_const_1357 = Integer(1357); _sage_const_165 = Integer(165); _sage_const_162 = Integer(162); _sage_const_902 = Integer(902); _sage_const_0p01568017636082064 = RealNumber('0.01568017636082064')## This file (Hypermatrix_Algebra_Package.sagetex.sage) was *autogenerated* from Hypermatrix_Algebra_Package.tex with sagetex.sty version 2012/01/16 v2.3.3-69dcb0eb93de.
import sagetex
_st_ = sagetex.SageTeXProcessor('Hypermatrix_Algebra_Package', version='2012/01/16 v2.3.3-69dcb0eb93de', version_check=True)
_st_.blockbegin()
try:
 def MatrixGenerate(nr, nc, c):
     """
     Generates a list of lists associated with a symbolic nr x nc
     matrix using the input character c followed by indices.
 
     EXAMPLES:
     ::
         sage: M = MatrixGenerate(2, 2, 'm'); M
         [[m00, m01], [m10, m11]]
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nc
 
     # Test for dimension match
     if n_q_rows > _sage_const_0  and n_q_cols > _sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 # Filling up the matrix
                 (q[i]).append(var(c+str(i)+str(j)))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" and "+str(nc)+" must both be non-zero positive integers."
except:
 _st_.goboom(_sage_const_120 )
_st_.blockend()
_st_.blockbegin()
try:
 def SymMatrixGenerate(nr, c):
     """
     Generates a list of lists associated with a symbolic nr x nc
     symmetric matrix using the input character c followed by
     indices.
 
     EXAMPLES:
     ::
         sage: M = SymMatrixGenerate(2, 'm'); M
         [[m00, m01], [m10, m11]]
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
 
     # Test for dimension match
     if n_q_rows > _sage_const_0  and n_q_cols > _sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 # Filling up the matrix
                 (q[i]).append(var(c+str(min(i,j))+str(max(i,j))))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integers."
except:
 _st_.goboom(_sage_const_157 )
_st_.blockend()
try:
 _st_.inline(_sage_const_0 , latex(Matrix(SR,MatrixGenerate(_sage_const_2 ,_sage_const_3 ,'m'))))
except:
 _st_.goboom(_sage_const_162 )
try:
 _st_.inline(_sage_const_1 , latex(Matrix(SR,SymMatrixGenerate(_sage_const_2 ,'m'))))
except:
 _st_.goboom(_sage_const_165 )
_st_.blockbegin()
try:
 def HypermatrixGenerate(*args):
     """
     Generates a list of lists associated with a symbolic arbitrary
     hypematrix of order and size specified by the input.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerate(2, 2, 2, 'm'); M
 
      AUTHORS:
     - Edinah K. Gnang, Ori Parzanchevski and Yuval Filmus
     """
     if len(args) == _sage_const_1 :
         return var(args[_sage_const_0 ])
     return [apply(\
 HypermatrixGenerate,args[_sage_const_1 :-_sage_const_1 ]+(args[-_sage_const_1 ]+str(i),)) for i in range(args[_sage_const_0 ])]
except:
 _st_.goboom(_sage_const_186 )
_st_.blockend()
try:
 _st_.inline(_sage_const_2 , latex(HypermatrixGenerate(_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,'t')))
except:
 _st_.goboom(_sage_const_191 )
_st_.blockbegin()
try:
 def SymHypermatrixGenerate(nr, c):
     """
     Generates a list of lists associated with a symbolic nr x nc x nd
     third order hypematrix using the input character c followed by
     indices.
 
     EXAMPLES:
     ::
         sage: M = SymHypermatrixGenerate(2, 'm'); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
     n_q_dpts = nr
 
     # Test for dimension match
     if n_q_rows > _sage_const_0  and n_q_cols > _sage_const_0  and n_q_dpts >_sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     if i==j or i==k or j==k:
                         (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                     else:
                         if i == min(i,j,k) and k == max(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         elif k == min(i,j,k) and j == max(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         elif i == max(i,j,k) and j == min(i,j,k):
                             (q[i][j]).append(\
 var(c+str(min(i,j,k))+str(i+j+k-min(i,j,k)-max(i,j,k))+str(max(i,j,k))))
                         else:
                             (q[i][j]).append(\
 var(c+str(i+j+k-min(i,j,k)-max(i,j,k))+str(min(i,j,k))+str(max(i,j,k))))
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integer."
except:
 _st_.goboom(_sage_const_249 )
_st_.blockend()
try:
 _st_.inline(_sage_const_3 , latex(SymHypermatrixGenerate(_sage_const_2 ,'s')))
except:
 _st_.goboom(_sage_const_253 )
_st_.blockbegin()
try:
 def HypermatrixVectorize(A):
     """
     Outputs our canonical vectorization of
     the input hypermatrices A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixVectorize(A); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[_sage_const_0 ])
     n_q_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     # Test for dimension match
     if n_q_rows>_sage_const_0  and n_q_cols>_sage_const_0  and n_q_dpts>_sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             for j in range(n_q_cols):
                 for k in range(n_q_dpts):
                     q.append(A[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions non zero."
except:
 _st_.goboom(_sage_const_289 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixAdd(A, B):
     """
     Outputs a list of lists corresponding to the sum of
     the two input hypermatrices A, B of the same size
 
     EXAMPLES:
     ::
         sage: M = HypermatrixAdd(A, B); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(B)
     n_q_cols = len(B[_sage_const_0 ])
     n_q_dpts = len(B[_sage_const_0 ][_sage_const_0 ])
 
     # Test for dimension match
     if n_q_rows==len(A) and n_q_cols==len(A[_sage_const_0 ]) and n_q_dpts==len(A[_sage_const_0 ][_sage_const_0 ]):
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     (q[i][j]).append(A[i][j][k]+B[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(_sage_const_333 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixHadamardProduct(A, B):
     """
     Outputs a list of lists associated with the addtion of
     the two input hypermatrices A and B
 
     EXAMPLES:
     ::
         sage: M = HypermatrixHadamardProduct(A, B); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[_sage_const_0 ])
     n_q_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     # Test for dimension match
     if n_q_rows==len(A) and n_q_cols==len(A[_sage_const_0 ]) and n_q_dpts==len(A[_sage_const_0 ][_sage_const_0 ]):
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     (q[i][j]).append(A[i][j][k]*B[i][j][k])
         return q
 
     else :
         raise ValueError, "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(_sage_const_371 )
_st_.blockend()
try:
 _st_.inline(_sage_const_4 , latex(HypermatrixAdd(SymHypermatrixGenerate(_sage_const_2 ,'s'),HypermatrixGenerate(_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,'t'))))
except:
 _st_.goboom(_sage_const_377 )
try:
 _st_.inline(_sage_const_5 , latex(HypermatrixHadamardProduct(SymHypermatrixGenerate(_sage_const_2 ,'s'),HypermatrixGenerate(_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,'t'))))
except:
 _st_.goboom(_sage_const_384 )
_st_.blockbegin()
try:
 def HypermatrixScale(A, s):
     """
     Outputs a list of lists associated with product of the
     input scalar s with the input hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixScale(A, 3); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[_sage_const_0 ])
     n_q_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(A[i][j][k]*s)
     return q
except:
 _st_.goboom(_sage_const_419 )
_st_.blockend()
try:
 _st_.inline(_sage_const_6 , latex(HypermatrixScale(HypermatrixGenerate(_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,'t'),_sage_const_3 )))
except:
 _st_.goboom(_sage_const_425 )
_st_.blockbegin()
try:
 def HypermatrixEntryExponent(A, s):
     """
     Outputs a list of lists associated with product of the
     scalar s with the hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixEntryExponent(A, 3); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[_sage_const_0 ])
     n_q_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append((A[i][j][k])**s)
     return q
except:
 _st_.goboom(_sage_const_459 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixEntryExponentB(s, A):
     """
     Outputs a list of lists associated with product of the
     scalar s with the hypermatrix A.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixEntryExponentB(3,A); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A)
     n_q_cols = len(A[_sage_const_0 ])
     n_q_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(s**(A[i][j][k]))
     return q
except:
 _st_.goboom(_sage_const_493 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixProduct(A, B, C):
     """
     Outputs a list of lists associated with the ternary
     non associative Bhattacharya-Mesner product of the
     input hypermatrices A, B and C.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixProduct(A, B, C); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_a_rows = len(A)
     n_a_cols = len(A[_sage_const_0 ])
     n_a_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     n_b_rows = len(B)
     n_b_cols = len(B[_sage_const_0 ])
     n_b_dpts = len(B[_sage_const_0 ][_sage_const_0 ])
 
     n_c_rows = len(C)
     n_c_cols = len(C[_sage_const_0 ])
     n_c_dpts = len(C[_sage_const_0 ][_sage_const_0 ])
 
     # Test for dimension match
     if n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and \
 n_a_cols==n_b_dpts and n_b_dpts==n_c_rows:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_a_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_b_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_c_dpts):
                     (q[i][j]).append(\
 sum([A[i][l][k]*B[i][j][l]*C[l][j][k] for l in range(n_a_cols)]))
         return q
 
     else :
         raise ValueError, "Hypermatrix dimension mismatch."
except:
 _st_.goboom(_sage_const_551 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixProductB(A, B, C, D):
     """
     Outputs a list of lists associated with the ternary
     product the input hypermatrices A, B and C with
     background hypermatrix D.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixProductB(A, B, C, D); M
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_a_rows = len(A)
     n_a_cols = len(A[_sage_const_0 ])
     n_a_dpts = len(A[_sage_const_0 ][_sage_const_0 ])
 
     n_b_rows = len(B)
     n_b_cols = len(B[_sage_const_0 ])
     n_b_dpts = len(B[_sage_const_0 ][_sage_const_0 ])
 
     n_c_rows = len(C)
     n_c_cols = len(C[_sage_const_0 ])
     n_c_dpts = len(C[_sage_const_0 ][_sage_const_0 ])
 
     n_d_rows = len(D)
     n_d_cols = len(D[_sage_const_0 ])
     n_d_dpts = len(D[_sage_const_0 ][_sage_const_0 ])
 
     # Test for dimension match
     if \
 n_a_rows==n_b_rows and n_b_cols==n_c_cols and n_c_dpts==n_a_dpts and \
 n_a_cols==n_b_dpts and n_b_dpts==n_c_rows and n_a_cols==n_d_rows and \
 n_a_cols==n_d_cols and n_a_cols==n_d_dpts:
         # Initialization of the hypermatrix
         q = []
         for i in range(n_a_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_b_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_c_dpts):
                     (q[i][j]).append(\
 sum([A[i][l0][k]*B[i][j][l1]*C[l2][j][k]*D[l0][l1][l2] for l0 in range(n_d_rows)\
 for l1 in range(n_d_cols) for l2 in range(n_d_dpts)]))
         return q
 
     else :
         raise ValueError, "Hypermatrix dimension mismatch."
except:
 _st_.goboom(_sage_const_618 )
_st_.blockend()
_st_.blockbegin()
try:
 # We put here together the seperate pieces we have implemented above.
 A = HypermatrixGenerate(_sage_const_2 , _sage_const_2 , _sage_const_2 , 'a')
 B = HypermatrixGenerate(_sage_const_2 , _sage_const_2 , _sage_const_2 , 'b')
 C = HypermatrixGenerate(_sage_const_2 , _sage_const_2 , _sage_const_2 , 'c')
 T = HypermatrixGenerate(_sage_const_2 , _sage_const_2 , _sage_const_2 , 't')
 P = HypermatrixProduct(A, B, C)
 Q = HypermatrixProductB(A, B, C, T)
except:
 _st_.goboom(_sage_const_630 )
_st_.blockend()
try:
 _st_.inline(_sage_const_7 , latex(P[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_634 )
try:
 _st_.inline(_sage_const_8 , latex(sum(((Q[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_0 :_sage_const_4 ])))
except:
 _st_.goboom(_sage_const_639 )
try:
 _st_.inline(_sage_const_9 , latex(sum(((Q[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_4 :_sage_const_8 ])))
except:
 _st_.goboom(_sage_const_642 )
_st_.blockbegin()
try:
 def HypermatrixCyclicPermute(A):
     """
     Outputs a list of lists associated with the hypermatrix
     with entries index cycliclly permuted.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixCyclicPermute(A); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = len(A[_sage_const_0 ])
     n_q_cols = len(A[_sage_const_0 ][_sage_const_0 ])
     n_q_dpts = len(A)
 
     # Initialization of the hypermatrix
     q = []
     for i in range(n_q_rows):
         q.append([])
     for i in range(len(q)):
         for j in range(n_q_cols):
             (q[i]).append([])
     for i in range(len(q)):
         for j in range(len(q[i])):
             for k in range(n_q_dpts):
                 (q[i][j]).append(A[k][i][j])
     return q
except:
 _st_.goboom(_sage_const_687 )
_st_.blockend()
try:
 _st_.inline(_sage_const_10 , latex(A))
except:
 _st_.goboom(_sage_const_691 )
try:
 _st_.inline(_sage_const_11 , latex(HypermatrixCyclicPermute(A)))
except:
 _st_.goboom(_sage_const_695 )
_st_.blockbegin()
try:
 def HypermatrixKroneckerDelta(nr):
     """
     Generates a list of lists associated with the nr x nr x nr
     Kronecker Delta hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixKroneckerDelta(2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Setting the dimensions parameters.
     n_q_rows = nr
     n_q_cols = nr
     n_q_dpts = nr
 
     # Test for dimension match
     if n_q_rows > _sage_const_0  and n_q_cols > _sage_const_0  and n_q_dpts >_sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         for i in range(n_q_rows):
             q.append([])
         for i in range(len(q)):
             for j in range(n_q_cols):
                 (q[i]).append([])
         for i in range(len(q)):
             for j in range(len(q[i])):
                 for k in range(n_q_dpts):
                     if i==j and i==k:
                         (q[i][j]).append(_sage_const_1 )
                     else:
                         (q[i][j]).append(_sage_const_0 )
         return q
 
     else :
         raise ValueError, "Input dimensions "+\
 str(nr)+" must be a non-zero positive integer."
except:
 _st_.goboom(_sage_const_746 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixGenerateAllOne(*args):
     """
     Generates a list of lists associated with the nr x nr x nr
     all one hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerateAllOne(2,2,2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if len(args) == _sage_const_1 :
         return [_sage_const_1  for i in range(args[_sage_const_0 ])]
     return [apply(HypermatrixGenerateAllOne, args[_sage_const_1 :] ) for i in range(args[_sage_const_0 ])]
except:
 _st_.goboom(_sage_const_767 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixGenerateAllZero(*args):
     """
     Generates a list of lists associated with the nr x nr x nr
     all zero hypermatrix.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixGenerateAllZero(2,2,2); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if len(args) == _sage_const_1 :
         return [_sage_const_0  for i in range(args[_sage_const_0 ])]
     return [apply(HypermatrixGenerateAllZero, args[_sage_const_1 :] ) for i in range(args[_sage_const_0 ])]
except:
 _st_.goboom(_sage_const_786 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixPermutation(s):
     """
     Generates a list of lists associated with the permutation
     hypermatrix deduced from sigma.
 
     EXAMPLES:
     ::
         sage: M = HypermatrixPermutation([0,2,1]); M
 
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     n = len(s)
     # Setting the dimensions parameters.
     n_q_rows = n
     n_q_cols = n
     n_q_dpts = n
 
     # Test for dimension match
     if n_q_rows > _sage_const_0  and n_q_cols > _sage_const_0  and n_q_dpts >_sage_const_0 :
         # Initialization of the hypermatrix
         q = []
         T = HypermatrixKroneckerDelta(n)
         U = HypermatrixGenerateAllOne(n,n,n)
         Id= HypermatrixProduct(U,U,T)
         Id= HypermatrixCyclicPermute(Id)
         for i in range(n):
             q.append(Id[s[i]])
         return HypermatrixCyclicPermute(HypermatrixCyclicPermute(q))
 
     else :
         raise ValueError, "Input dimensions "+\
 str(n)+" must be a non-zero positive integer."
except:
 _st_.goboom(_sage_const_839 )
_st_.blockend()
_st_.blockbegin()
try:
 # the code writen here is merely to put together the peices we have implemented so far.
 # Generic Symbolic hypermatrix
 A   = HypermatrixGenerateAllZero(_sage_const_3 ,_sage_const_3 ,_sage_const_3 )
 Tmp = HypermatrixGenerate(_sage_const_3 , _sage_const_3 , _sage_const_3 , 'a')
 for i in range(_sage_const_2 ):
     for j in range(_sage_const_3 ):
         for k in range(_sage_const_3 ):
             A[i][j][k]=Tmp[i][j][k]
 
 # Initialization of the hypermatrix and it's cyclic permutations
 P  = HypermatrixPermutation([_sage_const_1 ,_sage_const_0 ,_sage_const_2 ])
 Pt =HypermatrixCyclicPermute(P)
 Ptt=HypermatrixCyclicPermute(HypermatrixCyclicPermute(P))
 
 # Effecting the permutation of ...
 # row slices
 Ar = HypermatrixProduct(Pt,Ptt,A)
 # column slice
 Ac = HypermatrixProduct(A,P,Pt)
 # and depth slices
 Ad = HypermatrixProduct(P,A,Ptt)
except:
 _st_.goboom(_sage_const_866 )
_st_.blockend()
try:
 _st_.inline(_sage_const_12 , latex(A[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_870 )
try:
 _st_.inline(_sage_const_13 , latex(A[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_873 )
try:
 _st_.inline(_sage_const_14 , latex(P))
except:
 _st_.goboom(_sage_const_878 )
try:
 _st_.inline(_sage_const_15 , latex(Ar[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_883 )
try:
 _st_.inline(_sage_const_16 , latex(Ar[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_886 )
try:
 _st_.inline(_sage_const_17 , latex(Ac[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_891 )
try:
 _st_.inline(_sage_const_18 , latex(Ac[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_894 )
try:
 _st_.inline(_sage_const_19 , latex(Ad[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_899 )
try:
 _st_.inline(_sage_const_20 , latex(Ad[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_902 )
_st_.blockbegin()
try:
 def DiagonalHypermatrix(Mtrx):
     """
     Outputs a diagonal third order hypermatrix
     constructed using the input square matrix
     to enforce the symmetry constraint we will
     only take entry from the lower triangular
     part of the input matrix.
 
      EXAMPLES:
     ::
         sage: var('a00, a11, a01')
         sage: Mtrx = Matrix(Sr,[[a00,a01],[a01,a11]])
         sage: d = DiagonalHypermatrix(Mtrx)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initialization of the dimensions
     n = min(Mtrx.nrows(),Mtrx.ncols())
     n_d_rows = n
     n_d_cols = n
     n_d_dpts = n
 
     # Initialization of the identity permutations hypermatrix
     D = HypermatrixPermutation(range(n))
 
     # Filling up the entries of the hypermatrix.
     for i in range(n_d_rows):
         for j in range(n_d_cols):
             for k in range(n_d_dpts):
                 if (D[i][j][k] != _sage_const_0 ):
                     D[i][j][k] = Mtrx[min(i,k),max(i,k)]
     return D
except:
 _st_.goboom(_sage_const_950 )
_st_.blockend()
_st_.blockbegin()
try:
 # Generating a diagonal hypermatrices
 Mtrx = Matrix(SR,MatrixGenerate(_sage_const_2 , _sage_const_3 ,"lambda"))
 D  = DiagonalHypermatrix(Mtrx)
 Dt = HypermatrixCyclicPermute(D)
 Dtt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(D))
 Dc = HypermatrixProduct(Dt,Dtt,D)
except:
 _st_.goboom(_sage_const_961 )
_st_.blockend()
try:
 _st_.inline(_sage_const_21 , latex(D))
except:
 _st_.goboom(_sage_const_964 )
try:
 _st_.inline(_sage_const_22 , latex(Dc))
except:
 _st_.goboom(_sage_const_968 )
try:
 _st_.inline(_sage_const_23 , latex(HypermatrixEntryExponent(D,_sage_const_3 )))
except:
 _st_.goboom(_sage_const_972 )
_st_.blockbegin()
try:
 def Orthogonal2x2x2Hypermatrix(t):
     """
     Outputs an orthogonal third order hypermatrix
     of size 2 by 2 by 2.
 
      EXAMPLES:
     ::
         sage: t=var('t')
         sage: Orthogonal2x2x2Hypermatrix(t)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     return [[[cos(t)**(_sage_const_2 /_sage_const_3 ),sin(t)**(_sage_const_2 /_sage_const_3 )],[sin(t)**(_sage_const_2 /_sage_const_3 ), cos(t)**(_sage_const_2 /_sage_const_3 )]],\
 [[-sin(t)**(_sage_const_2 /_sage_const_3 ),cos(t)**(_sage_const_2 /_sage_const_3 )],[sin(t)**(_sage_const_2 /_sage_const_3 ),sin(t)**(_sage_const_2 /_sage_const_3 )]]]
except:
 _st_.goboom(_sage_const_993 )
_st_.blockend()
_st_.blockbegin()
try:
 def Orthogonal3x3x3Hypermatrix(t1,t2):
     """
     Outputs an orthogonal third order hypermatrix
     of size 3 by 3 by 3.
 
      EXAMPLES:
     ::
         sage: t1,t2=var('t1,t2')
         sage: Orthogonal3x3x3Hypermatrix(t1,t2)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     c1=cos(t1)**(_sage_const_2 /_sage_const_3 )
     s1=sin(t1)**(_sage_const_2 /_sage_const_3 )
     c2=cos(t2)**(_sage_const_2 /_sage_const_3 )
     s2=sin(t2)**(_sage_const_2 /_sage_const_3 )
     return [[[c1,s1*c2,_sage_const_0 ],[s1*c2,s1*s2,_sage_const_0 ],[s1*s2,exp(-I*_sage_const_2 *pi/_sage_const_3 )*c1,_sage_const_0 ]],\
 [[s1*s2,c1,exp(-I*_sage_const_2 *pi/_sage_const_3 )*s1*c2],[exp(I*_sage_const_2 *pi/_sage_const_3 )*c1,s1*c2,s1*s2],\
 [s1*c2,s1*s2,c1]],[[_sage_const_0 ,s1*s2,c1],[_sage_const_0 ,c1,s1*c2],[_sage_const_0 ,exp(I*_sage_const_2 *pi/_sage_const_3 )*s1*c2,s1*s2]]]
except:
 _st_.goboom(_sage_const_1017 )
_st_.blockend()
_st_.blockbegin()
try:
 theta = var('theta')
 Q  = Orthogonal2x2x2Hypermatrix(theta)
 Qt = HypermatrixCyclicPermute(Q)
 Qtt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(Q))
except:
 _st_.goboom(_sage_const_1025 )
_st_.blockend()
try:
 _st_.inline(_sage_const_24 , latex(Q))
except:
 _st_.goboom(_sage_const_1029 )
try:
 _st_.inline(_sage_const_25 , latex(HypermatrixProduct(Q,Qtt,Qt)))
except:
 _st_.goboom(_sage_const_1035 )
_st_.blockbegin()
try:
 # Defining the Parametrization Variables
 theta1,theta2=var('theta1,theta2')
 c1=cos(theta1)**(_sage_const_2 /_sage_const_3 )
 s1=sin(theta1)**(_sage_const_2 /_sage_const_3 )
 c2=cos(theta2)**(_sage_const_2 /_sage_const_3 )
 s2=sin(theta2)**(_sage_const_2 /_sage_const_3 )
 
 # Parametrization of a orthogonal hypermatrix
 U  = Orthogonal3x3x3Hypermatrix(theta1,theta2)
 Ut = HypermatrixCyclicPermute(U)
 Utt= HypermatrixCyclicPermute(HypermatrixCyclicPermute(U))
 UUttUt = HypermatrixProduct(U,Utt,Ut)
 for i in range(_sage_const_3 ):
     for j in range(_sage_const_3 ):
         for k in range(_sage_const_3 ):
             UUttUt[i][j][k] = (UUttUt[i][j][k]).simplify_exp()
except:
 _st_.goboom(_sage_const_1056 )
_st_.blockend()
try:
 _st_.inline(_sage_const_26 , latex(UUttUt[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1060 )
try:
 _st_.inline(_sage_const_27 , latex(UUttUt[_sage_const_1 ][_sage_const_1 ][_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1063 )
try:
 _st_.inline(_sage_const_28 , latex(UUttUt[_sage_const_2 ][_sage_const_2 ][_sage_const_2 ]))
except:
 _st_.goboom(_sage_const_1066 )
try:
 _st_.inline(_sage_const_29 , latex(UUttUt[_sage_const_0 ][_sage_const_0 ][_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1069 )
try:
 _st_.inline(_sage_const_30 , latex(UUttUt[_sage_const_0 ][_sage_const_0 ][_sage_const_2 ]))
except:
 _st_.goboom(_sage_const_1072 )
try:
 _st_.inline(_sage_const_31 , latex(UUttUt[_sage_const_1 ][_sage_const_1 ][_sage_const_2 ]))
except:
 _st_.goboom(_sage_const_1075 )
try:
 _st_.inline(_sage_const_32 , latex(UUttUt[_sage_const_1 ][_sage_const_1 ][_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1078 )
try:
 _st_.inline(_sage_const_33 , latex(UUttUt[_sage_const_2 ][_sage_const_2 ][_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1081 )
try:
 _st_.inline(_sage_const_34 , latex(UUttUt[_sage_const_2 ][_sage_const_2 ][_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1084 )
try:
 _st_.inline(_sage_const_35 , latex(UUttUt[_sage_const_0 ][_sage_const_1 ][_sage_const_2 ]))
except:
 _st_.goboom(_sage_const_1087 )
try:
 _st_.inline(_sage_const_36 , latex(UUttUt[_sage_const_1 ][_sage_const_0 ][_sage_const_2 ]))
except:
 _st_.goboom(_sage_const_1090 )
_st_.blockbegin()
try:
 def HypermatrixCayleyHamiltonList(A, n):
     """
     Outpts a list of hypermatrices of all product
     composition of order n from which it follows
     that n must be odd.
 
      EXAMPLES:
     ::
         sage: A = HypermatrixGenerate(2,2,2,'a')
         sage: L = HypermatrixCayleyHamiltonList(A,3)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     if n == _sage_const_1 :
         return [A]
     else:
         gu = []
         for i in range(_sage_const_1 ,n,_sage_const_2 ):
             for j in range(_sage_const_1 ,n-i,_sage_const_2 ):
                 gu = gu + [HypermatrixProduct(g1,g2,g3) \
 for g1 in HypermatrixCayleyHamiltonList(A,i) \
 for g2 in HypermatrixCayleyHamiltonList(A,j) \
 for g3 in HypermatrixCayleyHamiltonList(A,n-(i+j))]
         return gu
except:
 _st_.goboom(_sage_const_1124 )
_st_.blockend()
_st_.blockbegin()
try:
 # Initializing an orthogonal hypermatrix
 A = Orthogonal2x2x2Hypermatrix(e/pi)
 
 # Initialization of the list
 L = HypermatrixCayleyHamiltonList(A,_sage_const_1 )+HypermatrixCayleyHamiltonList(A,_sage_const_3 )+\
 HypermatrixCayleyHamiltonList(A,_sage_const_5 )+HypermatrixCayleyHamiltonList(A,_sage_const_7 )
 
 # Initializing the index variables
 Indx = Set(range(len(L))).subsets(_sage_const_8 )
 
 # Initialization of the of the matrix
 M = Matrix(RR,identity_matrix(_sage_const_8 ,_sage_const_8 ))
 cnt = _sage_const_0 
 for index in Indx:
     if cnt < _sage_const_10 :
         M = M*Matrix(RR,[HypermatrixVectorize(L[i]) for i in index])
         cnt= cnt+_sage_const_1 
     else:
         break
 
 # Defining the Parametrization Variables
 c1=cos(e/pi)**(_sage_const_2 /_sage_const_3 )
 s1=sin(e/pi)**(_sage_const_2 /_sage_const_3 )
 c2=cos(pi/e)**(_sage_const_2 /_sage_const_3 )
 s2=sin(pi/e)**(_sage_const_2 /_sage_const_3 )
 
 # Defining the unitary hypermatrices
 U=[[[c1,s1*c2,_sage_const_0 ],[s1*c2,s1*s2,_sage_const_0 ],[s1*s2, exp(-I*_sage_const_2 *pi/_sage_const_3 )*c1,_sage_const_0 ]],\
 [[s1*s2,c1,exp(-I*_sage_const_2 *pi/_sage_const_3 )*s1*c2],\
 [exp(I*_sage_const_2 *pi/_sage_const_3 )*c1,s1*c2,s1*s2],[s1*c2,s1*s2,c1]],\
 [[_sage_const_0 ,s1*s2,c1],[_sage_const_0 ,c1,s1*c2],[_sage_const_0 ,exp(I*_sage_const_2 *pi/_sage_const_3 )*s1*c2,s1*s2]]]
 
 Lu = HypermatrixCayleyHamiltonList(U,_sage_const_1 )+HypermatrixCayleyHamiltonList(U,_sage_const_3 )+\
 HypermatrixCayleyHamiltonList(U,_sage_const_5 )+HypermatrixCayleyHamiltonList(U,_sage_const_7 )+\
 HypermatrixCayleyHamiltonList(U,_sage_const_9 )
 
 # Initializing the index variables
 Indxu = Set(range(len(Lu))).subsets(_sage_const_27 )
 
 # Initialization of the of the matrix
 Mu = Matrix(CC,identity_matrix(_sage_const_27 ,_sage_const_27 ))
 cntu = _sage_const_0 
 for index in Indxu:
     if cntu < _sage_const_5 :
         Mu = Mu*Matrix(CC,[HypermatrixVectorize(Lu[i]) for i in index])
         cntu = cntu+_sage_const_1 
     else:
         break
except:
 _st_.goboom(_sage_const_1180 )
_st_.blockend()
try:
 _st_.inline(_sage_const_37 , latex(M.det()))
except:
 _st_.goboom(_sage_const_1183 )
try:
 _st_.inline(_sage_const_38 , latex(Mu.det()))
except:
 _st_.goboom(_sage_const_1187 )
_st_.blockbegin()
try:
 def ConstraintFormator(CnstrLst, VrbLst):
     """
     Takes as input a List of linear constraints
     and a list of variables and outputs matrix
     and the right hand side vector associate
     with the matrix formulation of the constraints.
 
     EXAMPLES:
     ::
         sage: x, y = var('x,y')
         sage: CnstrLst = [x+y==1, x-y==2]
         sage: VrbLst = [x, y]
         sage: [A,b] = ConstraintFormator(CnstrLst, VrbLst)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initializing the Matrix
     A=Matrix(CC,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
     b=vector(CC, [eq.rhs() for eq in CnstrLst]).column()
     for r in range(len(CnstrLst)):
         for c in range(len(VrbLst)):
             A[r,c] = diff((CnstrLst[r]).lhs(),VrbLst[c])
     return [A,b]
 
 def ConstraintFormatorII(CnstrLst, VrbLst):
     """
     Takes as input a List of linear constraints
     and a list of variables and outputs matrix
     and the right hand side vector associate
     with the matrix formulation of the constraints.
 
     EXAMPLES:
     ::
         sage: x, y = var('x,y')
         sage: CnstrLst = [x+y==1, x-y==2]
         sage: VrbLst = [x, y]
         sage: [A,b] = ConstraintFormator(CnstrLst, VrbLst)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     # Initializing the Matrix
     A=Matrix(SR,len(CnstrLst),len(VrbLst),zero_matrix(len(CnstrLst),len(VrbLst)))
     b=vector(SR, [eq.rhs() for eq in CnstrLst]).column()
     for r in range(len(CnstrLst)):
         for c in range(len(VrbLst)):
             A[r,c] = diff((CnstrLst[r]).lhs(),VrbLst[c])
     return [A,b]
except:
 _st_.goboom(_sage_const_1251 )
_st_.blockend()
_st_.blockbegin()
try:
 def HypermatrixPseudoInversePairs(A,B):
     """
      Outputs the pseudo inverse pairs associated with the input pairs of matrices
 
     EXAMPLES:
     ::
         sage: A1=[[[0.1631135370902057,0.11600112072013125],[0.9823708115400902,0.39605960486710756]]\
 ,[[0.061860929755424676,0.2325542810173995],[0.39111210957450926,0.2019809359102137]]]
         sage: A2=[[[0.15508921433883183,0.17820377184410963],[0.48648171594508205,0.01568017636082064]]\
 ,[[0.8250247759993575,0.1938307874191597],[0.23867299119274843,0.3935578730402869]]]
         sage: [B1,B2]=HypermatrixPseudoInversePairs(A1,A2)
 
     AUTHORS:
     - Edinah K. Gnang and Ori Parzanchevski
     """
     sz = len(A)
 
     # Initializing the list of linear constraints
     CnstrLst = []
 
     # Initilizing the variable list
     Vrbls  = [var('ln_al'+str(i)+str(j)+str(k)) \
 for i in range(sz) for j in range(sz) for k in range(sz)]+\
 [var('ln_bt'+str(i)+str(j)+str(k)) for i in range(sz) for j in range(sz) \
 for k in range(sz)]
 
     for m in range(sz):
         for p in range(sz):
             for n in range(sz):
                 V=Matrix(CC, sz, sz, [(A[m][k1][k0])*(B[k0][k1][p]) \
 for k0 in range(sz) for k1 in range(sz)]).inverse()
                 CnstrLst=CnstrLst+[\
 var('ln_al'+str(m)+str(n)+str(k1))+var('ln_bt'+str(k1)+str(n)+str(p))==\
 ln(V[k1,n])  for k1 in range(sz)]
     [A,b]=ConstraintFormator(CnstrLst,Vrbls)
 
     # Importing the Numerical Python package
     # for computing the matrix pseudo inverse
     import numpy
 
     sln = matrix(numpy.linalg.pinv(A))*b
     R1 = HypermatrixGenerateAllZero(sz,sz,sz)
     for i in range(sz):
         for j in range(sz):
             for k in range(sz):
                 R1[i][j][k] = exp(sln[i*sz**_sage_const_2 +j*sz**_sage_const_1 +k*sz**_sage_const_0 ,_sage_const_0 ])
     R2 = HypermatrixGenerateAllZero(sz, sz, sz)
     for i in range(sz):
         for j in range(sz):
             for k in range(sz):
                 R2[i][j][k] = exp(sln[sz**_sage_const_3 +i*sz**_sage_const_2 +j*sz**_sage_const_1 +k*sz**_sage_const_0 ,_sage_const_0 ])
     return [R1,R2]
except:
 _st_.goboom(_sage_const_1319 )
_st_.blockend()
_st_.blockbegin()
try:
 # Building from the example mentioned in the implementation
 # we consider the hypermatrices
 A1=[[[_sage_const_0p1631135370902057 ,_sage_const_0p11600112072013125 ],\
 [_sage_const_0p9823708115400902 ,_sage_const_0p39605960486710756 ]],\
 [[_sage_const_0p061860929755424676 ,_sage_const_0p2325542810173995 ],\
 [_sage_const_0p39111210957450926 ,_sage_const_0p2019809359102137 ]]]
 
 A2=[[[_sage_const_0p15508921433883183 ,_sage_const_0p17820377184410963 ],\
 [_sage_const_0p48648171594508205 ,_sage_const_0p01568017636082064 ]],\
 [[_sage_const_0p8250247759993575 ,_sage_const_0p1938307874191597 ],\
 [_sage_const_0p23867299119274843 ,_sage_const_0p3935578730402869 ]]]
 
 # Numerical computation of the hypermatrix inverse pairs
 [B1,B2]=HypermatrixPseudoInversePairs(A1,A2)
 
 # To appreciate how good the numerical approximation of the
 # inverse pair is we generate the generic symbolic hypermatrix M
 M0 = HypermatrixGenerate(_sage_const_2 ,_sage_const_2 ,_sage_const_2 ,'m')
 
 # We would want to compare the symbolic hypermatrix M to the product
 M1 = HypermatrixProduct(M0,A1,A2)
 M2 = HypermatrixProduct(M1,B1,B2)
except:
 _st_.goboom(_sage_const_1346 )
_st_.blockend()
try:
 _st_.inline(_sage_const_39 , latex(M0))
except:
 _st_.goboom(_sage_const_1351 )
try:
 _st_.inline(_sage_const_40 , latex(((M2[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1357 )
try:
 _st_.inline(_sage_const_41 , latex(((M2[_sage_const_0 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1360 )
try:
 _st_.inline(_sage_const_42 , latex(((M2[_sage_const_0 ][_sage_const_0 ][_sage_const_1 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1363 )
try:
 _st_.inline(_sage_const_43 , latex(((M2[_sage_const_0 ][_sage_const_0 ][_sage_const_1 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1366 )
try:
 _st_.inline(_sage_const_44 , latex(((M2[_sage_const_0 ][_sage_const_1 ][_sage_const_0 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1369 )
try:
 _st_.inline(_sage_const_45 , latex(((M2[_sage_const_0 ][_sage_const_1 ][_sage_const_0 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1372 )
try:
 _st_.inline(_sage_const_46 , latex(((M2[_sage_const_0 ][_sage_const_1 ][_sage_const_1 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1375 )
try:
 _st_.inline(_sage_const_47 , latex(((M2[_sage_const_0 ][_sage_const_1 ][_sage_const_1 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1378 )
try:
 _st_.inline(_sage_const_48 , latex(((M2[_sage_const_1 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1381 )
try:
 _st_.inline(_sage_const_49 , latex(((M2[_sage_const_1 ][_sage_const_0 ][_sage_const_0 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1384 )
try:
 _st_.inline(_sage_const_50 , latex(((M2[_sage_const_1 ][_sage_const_0 ][_sage_const_1 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1387 )
try:
 _st_.inline(_sage_const_51 , latex(((M2[_sage_const_1 ][_sage_const_0 ][_sage_const_1 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1390 )
try:
 _st_.inline(_sage_const_52 , latex(((M2[_sage_const_1 ][_sage_const_1 ][_sage_const_0 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1393 )
try:
 _st_.inline(_sage_const_53 , latex(((M2[_sage_const_1 ][_sage_const_1 ][_sage_const_0 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1396 )
try:
 _st_.inline(_sage_const_54 , latex(((M2[_sage_const_1 ][_sage_const_1 ][_sage_const_1 ]).operands())[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_1399 )
try:
 _st_.inline(_sage_const_55 , latex(((M2[_sage_const_1 ][_sage_const_1 ][_sage_const_1 ]).operands())[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_1402 )
_st_.blockbegin()
try:
 class HM:
     """HM class"""
     def __init__(self,*args):
 # Single argument class constructor specification.
         if len(args) == _sage_const_1 :
             inp = args[_sage_const_0 ]
             if type(inp)==type(Matrix(SR,_sage_const_2 ,_sage_const_1 ,[var('x'),var('y')])) or \
 type(inp)==type(Matrix(RR,_sage_const_2 ,_sage_const_1 ,[_sage_const_1 ,_sage_const_2 ])) or type(inp)==type(Matrix(CC,_sage_const_2 ,_sage_const_1 ,[_sage_const_1 ,_sage_const_1 ])):
                 self.hm=DiagonalHypermatrix(inp)
             elif type(inp) == list:
                 self.hm = inp
             else:
                 raise ValueError, \
 "Expected either a list or and an object of type Matrix"
             return
         # Two or more arguments class constructor
         s = args[-_sage_const_1 ]
         dims = args[:-_sage_const_1 ]
         if s == 'one':
             self.hm = apply(HypermatrixGenerateAllOne, dims)
         elif s == 'zero':
             self.hm = apply(HypermatrixGenerateAllZero, dims)
         elif s == 'ortho':
             if len(dims) == _sage_const_1 :
                 self.hm=Orthogonal2x2x2Hypermatrix(dims[_sage_const_0 ])
             elif len(dims) == _sage_const_2 :
                 self.hm=Orthogonal3x3x3Hypermatrix(dims[_sage_const_0 ],dims[_sage_const_1 ])
             else:
                 raise ValueError,\
 "ortho not supported for order %d tensors" % len(dims)
         elif s == 'perm':
             self.hm=HypermatrixPermutation(dims[_sage_const_0 ])
         elif s == 'kronecker':
             self.hm=HypermatrixKroneckerDelta(dims[_sage_const_0 ])
         elif s == 'sym':
             if len(dims) == _sage_const_2 :
                 self.hm=SymHypermatrixGenerate(dims[_sage_const_0 ],dims[_sage_const_1 ])
             else :
                 raise ValueError,\
 "kronecker not supported for order %d tensors" % len(dims)
         else:
             self.hm=apply(HypermatrixGenerate, args)
 
     def __repr__(self):
         return `self.hm`
 
     def __add__(self, other):
         return GeneralHypermatrixAdd(self,other)
 
     def __neg__(self):
         return GeneralHypermatrixScale(self.hm,-_sage_const_1 )
 
     def __sub__(self, other):
         return GeneralHypermatrixAdd(self, GeneralHypermatrixScale(other,-_sage_const_1 ))
 
     def __mul__(self, other):
         if other.__class__.__name__=='HM':
             return HM(GeneralHypermatrixHadamardProduct(self,other))
         elif other.__class__.__name__=='tuple':
             # This function takes a a list as intput
             l = other
             return GeneralHypermatrixProduct(self,*l)
         else:
             return GeneralHypermatrixScale(self,other)
 
     def __rmul__(self, a):
         return self*a
 
     def __getitem__(self,i):
         if i.__class__.__name__=='tuple':
             tmp = self.hm
             for j in i:
                 tmp = tmp[j]
             return tmp
 
     def __setitem__(self, i, v):
         if   i.__class__.__name__=='tuple':
             tmp = self.hm
             while len(i)>_sage_const_1 :
                 tmp = tmp[i[_sage_const_0 ]]
                 i = i[_sage_const_1 :]
             tmp[i[_sage_const_0 ]] = v
 
     def __call__(self, *inpts):
         # This function takes a a list as intput
         return GeneralHypermatrixProduct(self, *inpts)
 
     def hprod(self,*inpts):
         # This function takes a a list as intput
         return GeneralHypermatrixProduct(self,*inpts)
 
     def hprod3b(self, b, c, t):
         return HM(HypermatrixProductB(self.hm, b.hm, c.hm, t.hm))
 
     def elementwise_product(self,B):
         return GeneralHypermatrixHadamardProduct(self,B)
 
     def elementwise_exponent(self,s):
         return GeneralHypermatrixExponent(self,s)
 
     def elementwise_base_exponent(self,s):
         return GeneralHypermatrixBaseExponent(self,s)
 
     def transpose(self, i=_sage_const_1 ):
         t = Integer(mod(i, self.order()))
         A = self
         for i in range(t):
             A = GeneralHypermatrixCyclicPermute(A)
         return A
 
     def nrows(self):
         return len(self.hm)
 
     def ncols(self):
         return len(self.hm[_sage_const_0 ])
 
     def ndpts(self):
         return len(self.hm[_sage_const_0 ][_sage_const_0 ])
 
     def n(self,i):
         tmp = self.listHM()
         for j in range(i):
             tmp = tmp[_sage_const_0 ]
         return len(tmp)
 
     def list(self):
         lst = []
         l = [self.n(i) for i in range(self.order())]
         # Main loop canonicaly listing the elements
         for i in range(prod(l)):
             entry = [mod(i,l[_sage_const_0 ])]
             sm = Integer(mod(i,l[_sage_const_0 ]))
             for k in range(len(l)-_sage_const_1 ):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
                 sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
             lst.append(self[tuple(entry)])
         return lst
 
     def listHM(self):
         return self.hm
 
     def cayley_hamilton_list(self,n):
         tmp = HypermatrixCayleyHamiltonList(self.hm,n)
         return [HM(h) for h in tmp]
 
     def cayley_hamilton_mtrx(self,itr,bnd):
         tmp = []
         for i in range(itr):
             tmp = tmp + HypermatrixCayleyHamiltonList(self.hm, _sage_const_2 *i+_sage_const_1 )
         return Matrix([HM(h).list() for h in tmp[_sage_const_0 :bnd]])
 
     def order(self):
         cnt = _sage_const_0 
         H = self.listHM()
         while type(H) == type([]):
             H = H[_sage_const_0 ]
             cnt = cnt+_sage_const_1 
         return cnt
except:
 _st_.goboom(_sage_const_1573 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixProduct(*args):
     # Initialization of the list specifying the dimensions of the output
     l = [(args[i]).n(i) for i in range(len(args))]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['zero']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the assignement
     for i in range(\
 prod([(args[j]).n(Integer(mod(j+_sage_const_1 ,len(args)))) for j in range(len(args))])):
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         if len(args)<_sage_const_2 :
             raise ValueError, "The number of operands must be >= 2"
         elif len(args) >= _sage_const_2 :
             Rh[tuple(entry)]=sum(\
 [prod([args[s][tuple(entry[_sage_const_0 :Integer(mod(s+_sage_const_1 ,len(args)))]+\
 [t]+entry[Integer(mod(s+_sage_const_2 ,len(args))):])] for s in range(len(args)-_sage_const_2 )]+\
 [args[len(args)-_sage_const_2 ][tuple(entry[_sage_const_0 :len(args)-_sage_const_1 ]+[t])]]+\
 [args[len(args)-_sage_const_1 ][tuple([t]+entry[_sage_const_1 :])]]) for t in range((args[_sage_const_0 ]).n(_sage_const_1 ))])
     return Rh
except:
 _st_.goboom(_sage_const_1604 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixCyclicPermute(A):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     l = l[_sage_const_1 :]+[l[_sage_const_0 ]]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         # Performing the transpose
         Rh[tuple(entry)]=A[tuple([entry[len(entry)-_sage_const_1 ]]+entry[:len(entry)-_sage_const_1 ])]
     return Rh
except:
 _st_.goboom(_sage_const_1626 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixScale(A,s):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         # Performing the computation
         Rh[tuple(entry)]=s*A[tuple(entry)]
     return Rh
except:
 _st_.goboom(_sage_const_1646 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixExponent(A,s):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         # Performing computation
         Rh[tuple(entry)]=(A[tuple(entry)])**s
     return Rh
except:
 _st_.goboom(_sage_const_1667 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixBaseExponent(A,s):
 # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     # Initializing the input for generating a symbolic hypermatrix
     inpts = l+['r']
     # Initialization of the hypermatrix
     Rh = HM(*inpts)
     # Main loop performing the transposition of the entries
     for i in range(prod(l)):
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         # Performing computation
         Rh[tuple(entry)]=s**(A[tuple(entry)])
     return Rh
except:
 _st_.goboom(_sage_const_1688 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixAdd(A,B):
     # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     s = [B.n(i) for i in range(B.order())]
     # Testing the dimensions
     x = var('x')
     if(sum([l[i]*x**i for i in range(len(l))])==sum(\
 [s[i]*x**i for i in range(len(s))])):
         # Initializing the input for generating a symbolic hypermatrix
         inpts = l+['r']
         # Initialization of the hypermatrix
         Rh = HM(*inpts)
         # Main loop performing the transposition of the entries
         for i in range(prod(l)):
             entry = [mod(i,l[_sage_const_0 ])]
             sm = Integer(mod(i,l[_sage_const_0 ]))
             for k in range(len(l)-_sage_const_1 ):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
                 sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
             Rh[tuple(entry)]=A[tuple(entry)]+B[tuple(entry)]
         return Rh
     else:
         raise ValueError,\
 "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(_sage_const_1717 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralHypermatrixHadamardProduct(A,B):
 # Initialization of the list specifying the dimensions of the output
     l = [A.n(i) for i in range(A.order())]
     s = [B.n(i) for i in range(B.order())]
     # Testing the dimensions
     x = var('x')
     if(sum([l[i]*x**i for i in range(len(l))])==sum(\
 [s[i]*x**i for i in range(len(s))])):
         # Initializing the input for generating a symbolic hypermatrix
         inpts = l+['r']
         # Initialization of the hypermatrix
         Rh = HM(*inpts)
         # Main loop performing the transposition of the entries
         for i in range(prod(l)):
             entry = [mod(i,l[_sage_const_0 ])]
             sm = Integer(mod(i,l[_sage_const_0 ]))
             for k in range(len(l)-_sage_const_1 ):
                 entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
                 sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
             Rh[tuple(entry)]=A[tuple(entry)]+B[tuple(entry)]
         return Rh
     else:
         raise ValueError,\
 "The Dimensions of the input hypermatrices must match."
except:
 _st_.goboom(_sage_const_1744 )
_st_.blockend()
_st_.blockbegin()
try:
 def GeneralOrthogonalHypermatrix(od):
     # Initializing the hypermatrix
     Q = apply(HM,[_sage_const_2  for i in range(od)]+['q'])
 
     # Initilizing the list of variable
     VrbLst = Q.list()
 
     # Reinitializing of Q by exponentiation
     Q = Q.elementwise_base_exponent(e)
 
     # Computing the product
     Eq = apply(GeneralHypermatrixProduct,[Q.transpose(j) for j in range(od,_sage_const_0 ,-_sage_const_1 )])
 
     # Writting up the constraints
     LeQ = (Set(Eq.list())).list()
 
     # Removing the normalization constraints
     LeQ.remove(e**(od*var('q'+''.join(['0' for i in range(od)])))+\
 e**(od*var('q01'+''.join(['0' for i in range(od-_sage_const_2 )]))))
     LeQ.remove( e**(od*var('q10'+''.join(['1' for i in range(od-_sage_const_2 )])))+\
 e**(od*var('q'+''.join(['1' for i in range(od)]))))
 
     # Filling up the linear constraints
     CnstrLst= []
     for f in LeQ:
         CnstrLst.append(\
 ln((f.operands())[_sage_const_0 ]).simplify_exp()-I*pi-ln((f.operands())[_sage_const_1 ]).simplify_exp()==_sage_const_0 )
 
     # Directly solving the constraints
     Sl = solve(CnstrLst,VrbLst)
 
     # Main loop performing the substitution of the entries
     Lr = [var('r'+str(i)) for i in range(_sage_const_1 ,_sage_const_2 **od+_sage_const_1 )]
     l = [Q.n(i) for i in range(Q.order())]
     for i in range(prod(l)):
         # Turning the index i into an hypermatrix array location
         # using the decimal encoding trick
         entry = [mod(i,l[_sage_const_0 ])]
         sm = Integer(mod(i,l[_sage_const_0 ]))
         for k in range(len(l)-_sage_const_1 ):
             entry.append(Integer(mod(Integer((i-sm)/prod(l[_sage_const_0 :k+_sage_const_1 ])),l[k+_sage_const_1 ])))
             sm = sm+prod(l[_sage_const_0 :k+_sage_const_1 ])*entry[len(entry)-_sage_const_1 ]
         Q[tuple(entry)]=Q[tuple(entry)].subs(\
 dict(map(lambda eq: (eq.lhs(),eq.rhs()), Sl[_sage_const_0 ]))).simplify_exp()
     return Q
except:
 _st_.goboom(_sage_const_1796 )
_st_.blockend()
_st_.endofdoc()
